<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007267A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007267</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17894762</doc-number><date>20220824</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">METHOD AND APPARATUS FOR DECODING IMAGING RELATED TO SIGN DATA HIDING</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/KR2021/002409</doc-number><date>20210225</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17894762</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62982742</doc-number><date>20200227</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>LG ELECTRONICS INC.</orgname><address><city>Seoul</city><country>KR</country></address></addressbook><residence><country>KR</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>YOO</last-name><first-name>Sunmi</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>CHOI</last-name><first-name>Jungah</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>HEO</last-name><first-name>Jin</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>CHOI</last-name><first-name>Jangwon</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">An image decoding method performed by a decoding apparatus according to the present document comprises the steps of: obtaining a sign data hiding availability flag indicating whether or not sign data hiding is available for a current slice; obtaining a TSRC availability flag indicating whether or not TSRC is available for a transform skip block of the current slice; obtaining residual coding information about the transform skip block on the basis of the TSRC availability flag; deriving a residual sample for the transform skip block on the basis of the residual coding information; and generating a reconstruction picture on the basis of the residual sample, wherein the TSRC availability flag is obtained on the basis of the sign data hiding availability flag.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="75.10mm" wi="95.59mm" file="US20230007267A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="130.39mm" wi="97.62mm" file="US20230007267A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="195.33mm" wi="137.67mm" orientation="landscape" file="US20230007267A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="183.39mm" wi="135.47mm" orientation="landscape" file="US20230007267A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="181.86mm" wi="134.03mm" orientation="landscape" file="US20230007267A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="143.17mm" wi="69.77mm" file="US20230007267A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="131.32mm" wi="113.71mm" file="US20230007267A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="196.68mm" wi="107.44mm" orientation="landscape" file="US20230007267A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="143.76mm" wi="111.76mm" file="US20230007267A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="124.29mm" wi="139.19mm" file="US20230007267A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="173.91mm" wi="146.98mm" orientation="landscape" file="US20230007267A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND OF DISCLOSURE</heading><heading id="h-0002" level="1">Field of the Disclosure</heading><p id="p-0002" num="0001">This document relates to image coding technology, and more specifically, to a video decoding method and apparatus in which flag information about whether TSRC is enabled/disabled is coded based on flag information about whether SDH is enabled when coding residual data of a block in an image coding system.</p><heading id="h-0003" level="1">Related Art</heading><p id="p-0003" num="0002">Recently, demand for high-resolution, high-quality images, such as High Definition (HD) images and Ultra High Definition (UHD) images, has been increasing in various fields. As the image data has high resolution and high quality, the amount of information or bits to be transmitted increases relative to the legacy image data. Therefore, when image data is transmitted using a medium such as a conventional wired/wireless broadband line or image data is stored using an existing storage medium, the transmission cost and the storage cost thereof are increased.</p><p id="p-0004" num="0003">Accordingly, there is a need for a highly efficient image compression technique for effectively transmitting, storing, and reproducing information of high-resolution and high-quality images.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0005" num="0004">The present disclosure provides a method and apparatus for improving image coding efficiency.</p><p id="p-0006" num="0005">The present disclosure also provides a method and apparatus for improving residual coding efficiency.</p><p id="p-0007" num="0006">According to an embodiment of this document, an image decoding method performed by a decoding apparatus is provided. The method includes obtaining a sign data hiding enabled flag for whether sign data hiding is enabled for a current slice, obtaining a Transform Skip Residual Coding (TSRC) enabled flag for whether TSRC is enabled for a transform skip block in the current slice, obtaining residual coding information for the transform skip block based on the TSRC enabled flag, deriving a residual sample for the transform skip block based on the residual coding information, and generating a reconstructed picture based on the residual sample, wherein the TSRC enabled flag is obtained based on the sign data hiding enabled flag.</p><p id="p-0008" num="0007">According to another embodiment of this document, a decoding apparatus for performing image decoding is provided. The decoding apparatus includes an entropy decoder configured to obtain a sign data hiding enabled flag for whether sign data hiding is enabled for a current slice, to obtain a Transform Skip Residual Coding (TSRC) enabled flag for whether TSRC is enabled for a transform skip block in the current slice, and to obtain residual coding information for the transform skip block based on the TSRC enabled flag, a residual processor configured to derive a residual sample for the transform skip block based on the residual coding information, and an adder configured to generate a reconstructed picture based on the residual sample, wherein the TSRC enabled flag is obtained based on the sign data hiding enabled flag.</p><p id="p-0009" num="0008">According to still another embodiment of this document, a video encoding method which is performed by an encoding apparatus is provided. The method includes encoding a sign data hiding enabled flag for whether sign data hiding is enabled for a current slice, encoding a Transform Skip Residual Coding (TSRC) enabled flag for whether TSRC is enabled for a transform skip block in the current slice based on the sign data hiding enabled flag, encoding residual information for the transform skip block based on the TSRC enabled flag, and generating a bitstream including the sign data hiding enabled flag, the TSRC enabled flag and the residual information.</p><p id="p-0010" num="0009">According to still another embodiment of this document, a video encoding apparatus is provided. The encoding apparatus includes an entropy encoder configured to encode a sign data hiding enabled flag for whether sign data hiding is enabled for a current slice, to encode a Transform Skip Residual Coding (TSRC) enabled flag for whether TSRC is enabled for a transform skip block in the current slice based on the sign data hiding enabled flag, to encode residual information for the transform skip block based on the TSRC enabled flag, and to generate a bitstream including the sign data hiding enabled flag, the TSRC enabled flag and the residual information.</p><p id="p-0011" num="0010">According to still another embodiment of this document, there is provided a computer-readable digital storage medium that stores a bitstream including image information which causes a decoding apparatus to perform an image decoding method. In the computer-readable digital storage medium, the image decoding method includes obtaining a sign data hiding enabled flag for whether sign data hiding is enabled for a current slice, obtaining a Transform Skip Residual Coding (TSRC) enabled flag for whether TSRC is enabled for a transform skip block in the current slice, obtaining residual coding information for the transform skip block based on the TSRC enabled flag, deriving a residual sample for the transform skip block based on the residual coding information, and generating a reconstructed picture based on the residual sample, wherein the TSRC enabled flag is obtained based on the sign data hiding enabled flag.</p><p id="p-0012" num="0011">According to this document, it is possible to improve efficiency of residual coding.</p><p id="p-0013" num="0012">According to this document, the TSRC enabled flag can be signaled depending on the sign data hiding enabled flag, and through this, the coding efficiency can be improved by preventing sign data hiding from being used for the transform skip block for which TSRC is not enabled, and the overall residual coding efficiency can be improved by reducing the bit amount to be coded.</p><p id="p-0014" num="0013">According to this document, the TSRC enabled flag can be signaled depending on the transform skip enabled flag and the sign data hiding enabled flag, and through this, the coding efficiency can be improved by preventing sign data hiding from being used for the transform skip block for which TSRC is not enabled, and the overall residual coding efficiency can be improved by reducing the bit amount to be coded.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>1</b></figref> briefly illustrates an example of a video/image coding device to which embodiments of the present disclosure are applicable.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a schematic diagram illustrating a configuration of a video/image encoding apparatus to which the embodiment(s) of the present disclosure may be applied.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic diagram illustrating a configuration of a video/image decoding apparatus to which the embodiment(s) of the present disclosure may be applied.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>4</b></figref> exemplarily shows context-adaptive binary arithmetic coding (CABAC) for encoding a syntax element.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a diagram showing exemplary transform coefficients within a 4&#xd7;4 block.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>6</b></figref> briefly illustrates an image encoding method performed by an encoding apparatus according to the present disclosure.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>7</b></figref> briefly illustrates an encoding apparatus for performing an image encoding method according to the present disclosure.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>8</b></figref> briefly illustrates an image decoding method performed by a decoding apparatus according to the present disclosure.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>9</b></figref> briefly illustrates a decoding apparatus for performing an image decoding method according to the present disclosure.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a structural diagram of a contents streaming system to which the present disclosure is applied.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DESCRIPTION OF EMBODIMENTS</heading><p id="p-0025" num="0024">The present disclosure may be modified in various forms, and specific embodiments thereof will be described and illustrated in the drawings. However, the embodiments are not intended for limiting the disclosure. The terms used in the following description are used to merely describe specific embodiments but are not intended to limit the disclosure. An expression of a singular number includes an expression of the plural number, so long as it is clearly read differently. The terms such as &#x201c;include&#x201d; and &#x201c;have&#x201d; are intended to indicate that features, numbers, steps, operations, elements, components, or combinations thereof used in the following description exist and it should be thus understood that the possibility of existence or addition of one or more different features, numbers, steps, operations, elements, components, or combinations thereof is not excluded.</p><p id="p-0026" num="0025">Meanwhile, elements in the drawings described in the disclosure are independently drawn for the purpose of convenience for explanation of different specific functions, and do not mean that the elements are embodied by independent hardware or independent software. For example, two or more elements of the elements may be combined to form a single element, or one element may be partitioned into plural elements. The embodiments in which the elements are combined and/or partitioned belong to the disclosure without departing from the concept of the disclosure.</p><p id="p-0027" num="0026">Hereinafter, embodiments of the present disclosure will be described in detail with reference to the accompanying drawings. In addition, like reference numerals are used to indicate like elements throughout the drawings, and the same descriptions on the like elements will be omitted.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>1</b></figref> briefly illustrates an example of a video/image coding device to which embodiments of the present disclosure are applicable.</p><p id="p-0029" num="0028">Referring to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, a video/image coding system may include a first device (source device) and a second device (receiving device). The source device may deliver encoded video/image information or data in the form of a file or streaming to the receiving device via a digital storage medium or network.</p><p id="p-0030" num="0029">The source device may include a video source, an encoding apparatus, and a transmitter. The receiving device may include a receiver, a decoding apparatus, and a renderer. The encoding apparatus may be called a video/image encoding apparatus, and the decoding apparatus may be called a video/image decoding apparatus. The transmitter may be included in the encoding apparatus. The receiver may be included in the decoding apparatus. The renderer may include a display, and the display may be configured as a separate device or an external component.</p><p id="p-0031" num="0030">The video source may acquire video/image through a process of capturing, synthesizing, or generating the video/image. The video source may include a video/image capture device and/or a video/image generating device. The video/image capture device may include, for example, one or more cameras, video/image archives including previously captured video/images, and the like. The video/image generating device may include, for example, computers, tablets and smartphones, and may (electronically) generate video/images. For example, a virtual video/image may be generated through a computer or the like. In this case, the video/image capturing process may be replaced by a process of generating related data.</p><p id="p-0032" num="0031">The encoding apparatus may encode input image/image. The encoding apparatus may perform a series of procedures such as prediction, transform, and quantization for compression and coding efficiency. The encoded data (encoded video/image information) may be output in the form of a bit stream.</p><p id="p-0033" num="0032">The transmitter may transmit the encoded image/image information or data output in the form of a bit stream to the receiver of the receiving device through a digital storage medium or a network in the form of a file or streaming. The digital storage medium may include various storage mediums such as USB, SD, CD, DVD, Blu-ray, HDD, SSD, and the like. The transmitter may include an element for generating a media file through a predetermined file format and may include an element for transmission through a broadcast/communication network. The receiver may receive/extract the bit stream and transmit the received bit stream to the decoding apparatus.</p><p id="p-0034" num="0033">The decoding apparatus may decode the video/image by performing a series of procedures such as dequantization, inverse transform, and prediction corresponding to the operation of the encoding apparatus.</p><p id="p-0035" num="0034">The renderer may render the decoded video/image. The rendered video/image may be displayed through the display.</p><p id="p-0036" num="0035">Present disclosure relates to video/image coding. For example, the methods/embodiments disclosed in the present disclosure may be applied to a method disclosed in the versatile video coding (VVC), the EVC (essential video coding) standard, the AOMedia Video 1 (AV1) standard, the 2nd generation of audio video coding standard (AVS2), or the next generation video/image coding standard (e.g., H.267 or H.268, etc.).</p><p id="p-0037" num="0036">Present disclosure presents various embodiments of video/image coding, and the embodiments may be performed in combination with each other unless otherwise mentioned.</p><p id="p-0038" num="0037">In the present disclosure, video may refer to a series of images over time. Picture generally refers to a unit representing one image in a specific time zone, and a subpicture/slice/tile is a unit constituting part of a picture in coding. The subpicture/slice/tile may include one or more coding tree units (CTUs). One picture may consist of one or more subpictures/slices/tiles. One picture may consist of one or more tile groups. One tile group may include one or more tiles. A brick may represent a rectangular region of CTU rows within a tile in a picture. A tile may be partitioned into multiple bricks, each of which consisting of one or more CTU rows within the tile. A tile that is not partitioned into multiple bricks may be also referred to as a brick. A brick scan is a specific sequential ordering of CTUs partitioning a picture in which the CTUs are ordered consecutively in CTU raster scan in a brick, bricks within a tile are ordered consecutively in a raster scan of the bricks of the tile, and tiles in a picture are ordered consecutively in a raster scan of the tiles of the picture. In addition, a subpicture may represent a rectangular region of one or more slices within a picture. That is, a subpicture contains one or more slices that collectively cover a rectangular region of a picture. A tile is a rectangular region of CTUs within a particular tile column and a particular tile row in a picture. The tile column is a rectangular region of CTUs having a height equal to the height of the picture and a width specified by syntax elements in the picture parameter set. The tile row is a rectangular region of CTUs having a height specified by syntax elements in the picture parameter set and a width equal to the width of the picture. A tile scan is a specific sequential ordering of CTUs partitioning a picture in which the CTUs are ordered consecutively in CTU raster scan in a tile whereas tiles in a picture are ordered consecutively in a raster scan of the tiles of the picture. A slice includes an integer number of bricks of a picture that may be exclusively contained in a single NAL unit. A slice may consist of either a number of complete tiles or only a consecutive sequence of complete bricks of one tile. Tile groups and slices may be used interchangeably in the present disclosure. For example, in the present disclosure, a tile group/tile group header may be called a slice/slice header.</p><p id="p-0039" num="0038">A pixel or a pel may mean a smallest unit constituting one picture (or image). Also, &#x2018;sample&#x2019; may be used as a term corresponding to a pixel. A sample may generally represent a pixel or a value of a pixel, and may represent only a pixel/pixel value of a luma component or only a pixel/pixel value of a chroma component.</p><p id="p-0040" num="0039">A unit may represent a basic unit of image processing. The unit may include at least one of a specific region of the picture and information related to the region. One unit may include one luma block and two chroma (e.g., cb, cr) blocks. The unit may be used interchangeably with terms such as block or area in some cases. In a general case, an M&#xd7;N block may include samples (or sample arrays) or a set (or array) of transform coefficients of M columns and N rows.</p><p id="p-0041" num="0040">In the present description, &#x201c;A or B&#x201d; may mean &#x201c;only A&#x201d;, &#x201c;only B&#x201d; or &#x201c;both A and B&#x201d;. In other words, in the present specification, &#x201c;A or B&#x201d; may be interpreted as &#x201c;A and/or B&#x201d;. For example, &#x201c;A, B or C&#x201d; herein means &#x201c;only A&#x201d;, &#x201c;only B&#x201d;, &#x201c;only C&#x201d;, or &#x201c;any and any combination of A, B and C&#x201d;.</p><p id="p-0042" num="0041">A slash (/) or a comma (comma) used in the present description may mean &#x201c;and/or&#x201d;. For example, &#x201c;A/B&#x201d; may mean &#x201c;A and/or B&#x201d;. Accordingly, &#x201c;A/B&#x201d; may mean &#x201c;only A&#x201d;, &#x201c;only B&#x201d;, or &#x201c;both A and B&#x201d;. For example, &#x201c;A, B, C&#x201d; may mean &#x201c;A, B, or C&#x201d;.</p><p id="p-0043" num="0042">In the present description, &#x201c;at least one of A and B&#x201d; may mean &#x201c;only A&#x201d;, &#x201c;only B&#x201d;, or &#x201c;both A and B&#x201d;. In addition, in the present description, the expression &#x201c;at least one of A or B&#x201d; or &#x201c;at least one of A and/or B&#x201d; may be interpreted the same as &#x201c;at least one of A and B&#x201d;.</p><p id="p-0044" num="0043">In addition, in the present description, &#x201c;at least one of A, B and C&#x201d; means &#x201c;only A&#x201d;, &#x201c;only B&#x201d;, &#x201c;only C&#x201d;, or &#x201c;any combination of A, B and C&#x201d;. Also, &#x201c;at least one of A, B or C&#x201d; or &#x201c;at least one of A, B and/or C&#x201d; may mean &#x201c;at least one of A, B and C&#x201d;.</p><p id="p-0045" num="0044">In addition, parentheses used in the present description may mean &#x201c;for example&#x201d;. Specifically, when &#x201c;prediction (intra prediction)&#x201d; is indicated, &#x201c;intra prediction&#x201d; may be proposed as an example of &#x201c;prediction&#x201d;. In other words, &#x201c;prediction&#x201d; in the present description is not limited to &#x201c;intra prediction&#x201d;, and &#x201c;intra prediction&#x201d; may be proposed as an example of &#x201c;prediction&#x201d;. Also, even when &#x201c;prediction (i.e., intra prediction)&#x201d; is indicated, &#x201c;intra prediction&#x201d; may be proposed as an example of &#x201c;prediction&#x201d;.</p><p id="p-0046" num="0045">In the present description, technical features that are individually described within one drawing may be implemented individually or may be implemented at the same time.</p><p id="p-0047" num="0046">The following drawings were created to explain a specific example of the present description. Since the names of specific devices described in the drawings or the names of specific signals/messages/fields are presented by way of example, the technical features of the present description are not limited to the specific names used in the following drawings.</p><p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a schematic diagram illustrating a configuration of a video/image encoding apparatus to which the embodiment(s) of the present disclosure may be applied. Hereinafter, the video encoding apparatus may include an image encoding apparatus.</p><p id="p-0049" num="0048">Referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the encoding apparatus <b>200</b> includes an image partitioner <b>210</b>, a predictor <b>220</b>, a residual processor <b>230</b>, and an entropy encoder <b>240</b>, an adder <b>250</b>, a filter <b>260</b>, and a memory <b>270</b>. The predictor <b>220</b> may include an inter predictor <b>221</b> and an intra predictor <b>222</b>. The residual processor <b>230</b> may include a transformer <b>232</b>, a quantizer <b>233</b>, a dequantizer <b>234</b>, and an inverse transformer <b>235</b>. The residual processor <b>230</b> may further include a subtractor <b>231</b>. The adder <b>250</b> may be called a reconstructor or a reconstructed block generator. The image partitioner <b>210</b>, the predictor <b>220</b>, the residual processor <b>230</b>, the entropy encoder <b>240</b>, the adder <b>250</b>, and the filter <b>260</b> may be configured by at least one hardware component (e.g., an encoder chipset or processor) according to an embodiment. In addition, the memory <b>270</b> may include a decoded picture buffer (DPB) or may be configured by a digital storage medium. The hardware component may further include the memory <b>270</b> as an internal/external component.</p><p id="p-0050" num="0049">The image partitioner <b>210</b> may partition an input image (or a picture or a frame) input to the encoding apparatus <b>200</b> into one or more processors. For example, the processor may be called a coding unit (CU). In this case, the coding unit may be recursively partitioned according to a quad-tree binary-tree ternary-tree (QTBTTT) structure from a coding tree unit (CTU) or a largest coding unit (LCU). For example, one coding unit may be partitioned into a plurality of coding units of a deeper depth based on a quad tree structure, a binary tree structure, and/or a ternary structure. In this case, for example, the quad tree structure may be applied first and the binary tree structure and/or ternary structure may be applied later. Alternatively, the binary tree structure may be applied first. The coding procedure according to the present disclosure may be performed based on the final coding unit that is no longer partitioned. In this case, the largest coding unit may be used as the final coding unit based on coding efficiency according to image characteristics, or if necessary, the coding unit may be recursively partitioned into coding units of deeper depth and a coding unit having an optimal size may be used as the final coding unit. Here, the coding procedure may include a procedure of prediction, transform, and reconstruction, which will be described later. As another example, the processor may further include a prediction unit (PU) or a transform unit (TU). In this case, the prediction unit and the transform unit may be split or partitioned from the aforementioned final coding unit. The prediction unit may be a unit of sample prediction, and the transform unit may be a unit for deriving a transform coefficient and/or a unit for deriving a residual signal from the transform coefficient.</p><p id="p-0051" num="0050">The unit may be used interchangeably with terms such as block or area in some cases. In a general case, an M&#xd7;N block may represent a set of samples or transform coefficients composed of M columns and N rows. A sample may generally represent a pixel or a value of a pixel, may represent only a pixel/pixel value of a luma component or represent only a pixel/pixel value of a chroma component. A sample may be used as a term corresponding to one picture (or image) for a pixel or a pel.</p><p id="p-0052" num="0051">In the encoding apparatus <b>200</b>, a prediction signal (predicted block, prediction sample array) output from the inter predictor <b>221</b> or the intra predictor <b>222</b> is subtracted from an input image signal (original block, original sample array) to generate a residual signal residual block, residual sample array), and the generated residual signal is transmitted to the transformer <b>232</b>. In this case, as shown, a unit for subtracting a prediction signal (predicted block, prediction sample array) from the input image signal (original block, original sample array) in the encoder <b>200</b> may be called a subtractor <b>231</b>. The predictor may perform prediction on a block to be processed (hereinafter, referred to as a current block) and generate a predicted block including prediction samples for the current block. The predictor may determine whether intra prediction or inter prediction is applied on a current block or CU basis. As described later in the description of each prediction mode, the predictor may generate various information related to prediction, such as prediction mode information, and transmit the generated information to the entropy encoder <b>240</b>. The information on the prediction may be encoded in the entropy encoder <b>240</b> and output in the form of a bit stream.</p><p id="p-0053" num="0052">The intra predictor <b>222</b> may predict the current block by referring to the samples in the current picture. The referred samples may be located in the neighborhood of the current block or may be located apart according to the prediction mode. In the intra prediction, prediction modes may include a plurality of non-directional modes and a plurality of directional modes. The non-directional mode may include, for example, a DC mode and a planar mode. The directional mode may include, for example, 33 directional prediction modes or 65 directional prediction modes according to the degree of detail of the prediction direction. However, this is merely an example, more or less directional prediction modes may be used depending on a setting. The intra predictor <b>222</b> may determine the prediction mode applied to the current block by using a prediction mode applied to a neighboring block.</p><p id="p-0054" num="0053">The inter predictor <b>221</b> may derive a predicted block for the current block based on a reference block (reference sample array) specified by a motion vector on a reference picture. Here, in order to reduce the amount of motion information transmitted in the inter prediction mode, the motion information may be predicted in units of blocks, sub-blocks, or samples based on correlation of motion information between the neighboring block and the current block. The motion information may include a motion vector and a reference picture index. The motion information may further include inter prediction direction (L0 prediction, L1 prediction, Bi prediction, etc.) information. In the case of inter prediction, the neighboring block may include a spatial neighboring block present in the current picture and a temporal neighboring block present in the reference picture. The reference picture including the reference block and the reference picture including the temporal neighboring block may be the same or different. The temporal neighboring block may be called a collocated reference block, a co-located CU (colCU), and the like, and the reference picture including the temporal neighboring block may be called a collocated picture (colPic). For example, the inter predictor <b>221</b> may configure a motion information candidate list based on neighboring blocks and generate information indicating which candidate is used to derive a motion vector and/or a reference picture index of the current block. Inter prediction may be performed based on various prediction modes. For example, in the case of a skip mode and a merge mode, the inter predictor <b>221</b> may use motion information of the neighboring block as motion information of the current block. In the skip mode, unlike the merge mode, the residual signal may not be transmitted. In the case of the motion vector prediction (MVP) mode, the motion vector of the neighboring block may be used as a motion vector predictor and the motion vector of the current block may be indicated by signaling a motion vector difference.</p><p id="p-0055" num="0054">The predictor <b>220</b> may generate a prediction signal based on various prediction methods described below. For example, the predictor may not only apply intra prediction or inter prediction to predict one block but also simultaneously apply both intra prediction and inter prediction. This may be called combined inter and intra prediction (CIIP). In addition, the predictor may be based on an intra block copy (IBC) prediction mode or a palette mode for prediction of a block. The IBC prediction mode or palette mode may be used for content image/video coding of a game or the like, for example, screen content coding (SCC). The IBC basically performs prediction in the current picture but may be performed similarly to inter prediction in that a reference block is derived in the current picture. That is, the IBC may use at least one of the inter prediction techniques described in the present disclosure. The palette mode may be considered as an example of intra coding or intra prediction. When the palette mode is applied, a sample value within a picture may be signaled based on information on the palette table and the palette index.</p><p id="p-0056" num="0055">The prediction signal generated by the predictor (including the inter predictor <b>221</b> and/or the intra predictor <b>222</b>) may be used to generate a reconstructed signal or to generate a residual signal. The transformer <b>232</b> may generate transform coefficients by applying a transform technique to the residual signal. For example, the transform technique may include at least one of a discrete cosine transform (DCT), a discrete sine transform (DST), a Karhunen-lo&#xe8;ve transform (KLT), a graph-based transform (GBT), or a conditionally non-linear transform (CNT). Here, the GBT means transform obtained from a graph when relationship information between pixels is represented by the graph. The CNT refers to transform generated based on a prediction signal generated using all previously reconstructed pixels. In addition, the transform process may be applied to square pixel blocks having the same size or may be applied to blocks having a variable size rather than square.</p><p id="p-0057" num="0056">The quantizer <b>233</b> may quantize the transform coefficients and transmit them to the entropy encoder <b>240</b> and the entropy encoder <b>240</b> may encode the quantized signal (information on the quantized transform coefficients) and output a bit stream. The information on the quantized transform coefficients may be referred to as residual information. The quantizer <b>233</b> may rearrange block type quantized transform coefficients into a one-dimensional vector form based on a coefficient scanning order and generate information on the quantized transform coefficients based on the quantized transform coefficients in the one-dimensional vector form. Information on transform coefficients may be generated. The entropy encoder <b>240</b> may perform various encoding methods such as, for example, exponential Golomb, context-adaptive variable length coding (CAVLC), context-adaptive binary arithmetic coding (CABAC), and the like. The entropy encoder <b>240</b> may encode information necessary for video/image reconstruction other than quantized transform coefficients (e.g., values of syntax elements, etc.) together or separately. Encoded information (e.g., encoded video/image information) may be transmitted or stored in units of NALs (network abstraction layer) in the form of a bit stream. The video/image information may further include information on various parameter sets such as an adaptation parameter set (APS), a picture parameter set (PPS), a sequence parameter set (SPS), or a video parameter set (VPS). In addition, the video/image information may further include general constraint information. In the present disclosure, information and/or syntax elements transmitted/signaled from the encoding apparatus to the decoding apparatus may be included in video/picture information. The video/image information may be encoded through the above-described encoding procedure and included in the bit stream. The bit stream may be transmitted over a network or may be stored in a digital storage medium. The network may include a broadcasting network and/or a communication network, and the digital storage medium may include various storage media such as USB, SD, CD, DVD, Blu-ray, HDD, SSD, and the like. A transmitter (not shown) transmitting a signal output from the entropy encoder <b>240</b> and/or a storage unit (not shown) storing the signal may be included as internal/external element of the encoding apparatus <b>200</b>, and alternatively, the transmitter may be included in the entropy encoder <b>240</b>.</p><p id="p-0058" num="0057">The quantized transform coefficients output from the quantizer <b>233</b> may be used to generate a prediction signal. For example, the residual signal (residual block or residual samples) may be reconstructed by applying dequantization and inverse transform to the quantized transform coefficients through the dequantizer <b>234</b> and the inverse transformer <b>235</b>. The adder <b>250</b> adds the reconstructed residual signal to the prediction signal output from the inter predictor <b>221</b> or the intra predictor <b>222</b> to generate a reconstructed signal (reconstructed picture, reconstructed block, reconstructed sample array). If there is no residual for the block to be processed, such as a case where the skip mode is applied, the predicted block may be used as the reconstructed block. The adder <b>250</b> may be called a reconstructor or a reconstructed block generator. The generated reconstructed signal may be used for intra prediction of a next block to be processed in the current picture and may be used for inter prediction of a next picture through filtering as described below.</p><p id="p-0059" num="0058">Meanwhile, luma mapping with chroma scaling (LMCS) may be applied during picture encoding and/or reconstruction.</p><p id="p-0060" num="0059">The filter <b>260</b> may improve subjective/objective image quality by applying filtering to the reconstructed signal. For example, the filter <b>260</b> may generate a modified reconstructed picture by applying various filtering methods to the reconstructed picture and store the modified reconstructed picture in the memory <b>270</b>, specifically, a DPB of the memory <b>270</b>. The various filtering methods may include, for example, deblocking filtering, a sample adaptive offset, an adaptive loop filter, a bilateral filter, and the like. The filter <b>260</b> may generate various information related to the filtering and transmit the generated information to the entropy encoder <b>240</b> as described later in the description of each filtering method. The information related to the filtering may be encoded by the entropy encoder <b>240</b> and output in the form of a bit stream.</p><p id="p-0061" num="0060">The modified reconstructed picture transmitted to the memory <b>270</b> may be used as the reference picture in the inter predictor <b>221</b>. When the inter prediction is applied through the encoding apparatus, prediction mismatch between the encoding apparatus <b>200</b> and the decoding apparatus <b>300</b> may be avoided and encoding efficiency may be improved.</p><p id="p-0062" num="0061">The DPB of the memory <b>270</b> DPB may store the modified reconstructed picture for use as a reference picture in the inter predictor <b>221</b>. The memory <b>270</b> may store the motion information of the block from which the motion information in the current picture is derived (or encoded) and/or the motion information of the blocks in the picture that have already been reconstructed. The stored motion information may be transmitted to the inter predictor <b>221</b> and used as the motion information of the spatial neighboring block or the motion information of the temporal neighboring block. The memory <b>270</b> may store reconstructed samples of reconstructed blocks in the current picture and may transfer the reconstructed samples to the intra predictor <b>222</b>.</p><p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic diagram illustrating a configuration of a video/image decoding apparatus to which the embodiment(s) of the present disclosure may be applied.</p><p id="p-0064" num="0063">Referring to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the decoding apparatus <b>300</b> may include an entropy decoder <b>310</b>, a residual processor <b>320</b>, a predictor <b>330</b>, an adder <b>340</b>, a filter <b>350</b>, and a memory <b>360</b>. The predictor <b>330</b> may include an inter predictor <b>331</b> and an intra predictor <b>332</b>. The residual processor <b>320</b> may include a dequantizer <b>321</b> and an inverse transformer <b>322</b>. The entropy decoder <b>310</b>, the residual processor <b>320</b>, the predictor <b>330</b>, the adder <b>340</b>, and the filter <b>350</b> may be configured by a hardware component (e.g., a decoder chipset or a processor) according to an embodiment. In addition, the memory <b>360</b> may include a decoded picture buffer (DPB) or may be configured by a digital storage medium. The hardware component may further include the memory <b>360</b> as an internal/external component.</p><p id="p-0065" num="0064">When a bit stream including video/image information is input, the decoding apparatus <b>300</b> may reconstruct an image corresponding to a process in which the video/image information is processed in the encoding apparatus of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. For example, the decoding apparatus <b>300</b> may derive units/blocks based on block partition related information obtained from the bit stream. The decoding apparatus <b>300</b> may perform decoding using a processor applied in the encoding apparatus. Thus, the processor of decoding may be a coding unit, for example, and the coding unit may be partitioned according to a quad tree structure, binary tree structure and/or ternary tree structure from the coding tree unit or the largest coding unit. One or more transform units may be derived from the coding unit. The reconstructed image signal decoded and output through the decoding apparatus <b>300</b> may be reproduced through a reproducing apparatus.</p><p id="p-0066" num="0065">The decoding apparatus <b>300</b> may receive a signal output from the encoding apparatus of <figref idref="DRAWINGS">FIG. <b>2</b></figref> in the form of a bit stream, and the received signal may be decoded through the entropy decoder <b>310</b>. For example, the entropy decoder <b>310</b> may parse the bit stream to derive information (e.g., video/image information) necessary for image reconstruction (or picture reconstruction). The video/image information may further include information on various parameter sets such as an adaptation parameter set (APS), a picture parameter set (PPS), a sequence parameter set (SPS), or a video parameter set (VPS). In addition, the video/image information may further include general constraint information. The decoding apparatus may further decode picture based on the information on the parameter set and/or the general constraint information. Signaled/received information and/or syntax elements described later in the present disclosure may be decoded may decode the decoding procedure and obtained from the bit stream. For example, the entropy decoder <b>310</b> decodes the information in the bit stream based on a coding method such as exponential Golomb coding, CAVLC, or CABAC, and output syntax elements required for image reconstruction and quantized values of transform coefficients for residual. More specifically, the CABAC entropy decoding method may receive a bin corresponding to each syntax element in the bit stream, determine a context model using a decoding target syntax element information, decoding information of a decoding target block or information of a symbol/bin decoded in a previous stage, and perform an arithmetic decoding on the bin by predicting a probability of occurrence of a bin according to the determined context model, and generate a symbol corresponding to the value of each syntax element. In this case, the CABAC entropy decoding method may update the context model by using the information of the decoded symbol/bin for a context model of a next symbol/bin after determining the context model. The information related to the prediction among the information decoded by the entropy decoder <b>310</b> may be provided to the predictor (the inter predictor <b>332</b> and the intra predictor <b>331</b>), and the residual value on which the entropy decoding was performed in the entropy decoder <b>310</b>, that is, the quantized transform coefficients and related parameter information, may be input to the residual processor <b>320</b>. The residual processor <b>320</b> may derive the residual signal (the residual block, the residual samples, the residual sample array). In addition, information on filtering among information decoded by the entropy decoder <b>310</b> may be provided to the filter <b>350</b>. Meanwhile, a receiver (not shown) for receiving a signal output from the encoding apparatus may be further configured as an internal/external element of the decoding apparatus <b>300</b>, or the receiver may be a component of the entropy decoder <b>310</b>. Meanwhile, the decoding apparatus according to the present disclosure may be referred to as a video/image/picture decoding apparatus, and the decoding apparatus may be classified into an information decoder (video/image/picture information decoder) and a sample decoder (video/image/picture sample decoder). The information decoder may include the entropy decoder <b>310</b>, and the sample decoder may include at least one of the dequantizer <b>321</b>, the inverse transformer <b>322</b>, the adder <b>340</b>, the filter <b>350</b>, the memory <b>360</b>, the inter predictor <b>332</b>, and the intra predictor <b>331</b>.</p><p id="p-0067" num="0066">The dequantizer <b>321</b> may dequantize the quantized transform coefficients and output the transform coefficients. The dequantizer <b>321</b> may rearrange the quantized transform coefficients in the form of a two-dimensional block form. In this case, the rearrangement may be performed based on the coefficient scanning order performed in the encoding apparatus. The dequantizer <b>321</b> may perform dequantization on the quantized transform coefficients by using a quantization parameter (e.g., quantization step size information) and obtain transform coefficients.</p><p id="p-0068" num="0067">The inverse transformer <b>322</b> inversely transforms the transform coefficients to obtain a residual signal (residual block, residual sample array).</p><p id="p-0069" num="0068">The predictor may perform prediction on the current block and generate a predicted block including prediction samples for the current block. The predictor may determine whether intra prediction or inter prediction is applied to the current block based on the information on the prediction output from the entropy decoder <b>310</b> and may determine a specific intra/inter prediction mode.</p><p id="p-0070" num="0069">The predictor <b>320</b> may generate a prediction signal based on various prediction methods described below. For example, the predictor may not only apply intra prediction or inter prediction to predict one block but also simultaneously apply intra prediction and inter prediction. This may be called combined inter and intra prediction (CIIP). In addition, the predictor may be based on an intra block copy (IBC) prediction mode or a palette mode for prediction of a block. The IBC prediction mode or palette mode may be used for content image/video coding of a game or the like, for example, screen content coding (SCC). The IBC basically performs prediction in the current picture but may be performed similarly to inter prediction in that a reference block is derived in the current picture. That is, the IBC may use at least one of the inter prediction techniques described in the present disclosure. The palette mode may be considered as an example of intra coding or intra prediction. When the palette mode is applied, a sample value within a picture may be signaled based on information on the palette table and the palette index.</p><p id="p-0071" num="0070">The intra predictor <b>331</b> may predict the current block by referring to the samples in the current picture. The referred samples may be located in the neighborhood of the current block or may be located apart according to the prediction mode. In the intra prediction, prediction modes may include a plurality of non-directional modes and a plurality of directional modes. The intra predictor <b>331</b> may determine the prediction mode applied to the current block by using a prediction mode applied to a neighboring block.</p><p id="p-0072" num="0071">The inter predictor <b>332</b> may derive a predicted block for the current block based on a reference block (reference sample array) specified by a motion vector on a reference picture. In this case, in order to reduce the amount of motion information transmitted in the inter prediction mode, motion information may be predicted in units of blocks, sub-blocks, or samples based on correlation of motion information between the neighboring block and the current block. The motion information may include a motion vector and a reference picture index. The motion information may further include inter prediction direction (L0 prediction, L1 prediction, Bi prediction, etc.) information. In the case of inter prediction, the neighboring block may include a spatial neighboring block present in the current picture and a temporal neighboring block present in the reference picture. For example, the inter predictor <b>332</b> may configure a motion information candidate list based on neighboring blocks and derive a motion vector of the current block and/or a reference picture index based on the received candidate selection information. Inter prediction may be performed based on various prediction modes, and the information on the prediction may include information indicating a mode of inter prediction for the current block.</p><p id="p-0073" num="0072">The adder <b>340</b> may generate a reconstructed signal (reconstructed picture, reconstructed block, reconstructed sample array) by adding the obtained residual signal to the prediction signal (predicted block, predicted sample array) output from the predictor (including the inter predictor <b>332</b> and/or the intra predictor <b>331</b>). If there is no residual for the block to be processed, such as when the skip mode is applied, the predicted block may be used as the reconstructed block.</p><p id="p-0074" num="0073">The adder <b>340</b> may be called reconstructor or a reconstructed block generator. The generated reconstructed signal may be used for intra prediction of a next block to be processed in the current picture, may be output through filtering as described below, or may be used for inter prediction of a next picture.</p><p id="p-0075" num="0074">Meanwhile, luma mapping with chroma scaling (LMCS) may be applied in the picture decoding process.</p><p id="p-0076" num="0075">The filter <b>350</b> may improve subjective/objective image quality by applying filtering to the reconstructed signal. For example, the filter <b>350</b> may generate a modified reconstructed picture by applying various filtering methods to the reconstructed picture and store the modified reconstructed picture in the memory <b>360</b>, specifically, a DPB of the memory <b>360</b>. The various filtering methods may include, for example, deblocking filtering, a sample adaptive offset, an adaptive loop filter, a bilateral filter, and the like.</p><p id="p-0077" num="0076">The (modified) reconstructed picture stored in the DPB of the memory <b>360</b> may be used as a reference picture in the inter predictor <b>332</b>. The memory <b>360</b> may store the motion information of the block from which the motion information in the current picture is derived (or decoded) and/or the motion information of the blocks in the picture that have already been reconstructed. The stored motion information may be transmitted to the inter predictor <b>260</b> so as to be utilized as the motion information of the spatial neighboring block or the motion information of the temporal neighboring block. The memory <b>360</b> may store reconstructed samples of reconstructed blocks in the current picture and transfer the reconstructed samples to the intra predictor <b>331</b>.</p><p id="p-0078" num="0077">In the present disclosure, the embodiments described in the filter <b>260</b>, the inter predictor <b>221</b>, and the intra predictor <b>222</b> of the encoding apparatus <b>200</b> may be the same as or respectively applied to correspond to the filter <b>350</b>, the inter predictor <b>332</b>, and the intra predictor <b>331</b> of the decoding apparatus <b>300</b>. The same may also apply to the unit <b>332</b> and the intra predictor <b>331</b>.</p><p id="p-0079" num="0078">In the present disclosure, at least one of quantization/inverse quantization and/or transform/inverse transform may be omitted. When the quantization/inverse quantization is omitted, the quantized transform coefficients may be called transform coefficients. When the transform/inverse transform is omitted, the transform coefficients may be called coefficients or residual coefficients, or may still be called transform coefficients for uniformity of expression.</p><p id="p-0080" num="0079">In the present disclosure, a quantized transform coefficient and a transform coefficient may be referred to as a transform coefficient and a scaled transform coefficient, respectively. In this case, the residual information may include information on transform coefficient(s), and the information on the transform coefficient(s) may be signaled through residual coding syntax. Transform coefficients may be derived based on the residual information (or the information on the transform coefficient(s)), and scaled transform coefficients may be derived by inverse transforming (scaling) on the transform coefficients. Residual samples may be derived based on the inverse transforming (transforming) on the scaled transform coefficients. This may be applied/expressed in other parts of the present disclosure as well.</p><p id="p-0081" num="0080">As described above, the encoding apparatus may perform various encoding methods such as exponential Golomb, context-adaptive variable length coding (CAVLC), and context-adaptive binary arithmetic coding (CABAC). In addition, the decoding apparatus may decode information in a bitstream based on a coding method such as exponential Golomb coding, CAVLC or CABAC, and output a value of a syntax element required for image reconstruction and quantized values of transform coefficients related to residuals.</p><p id="p-0082" num="0081">For example, the coding methods described above may be performed as described below.</p><p id="p-0083" num="0082"><figref idref="DRAWINGS">FIG. <b>4</b></figref> exemplarily shows context-adaptive binary arithmetic coding (CABAC) for encoding a syntax element. For example, in the CABAC encoding process, when an input signal is a syntax element, rather than a binary value, the encoding apparatus may convert the input signal into a binary value by binarizing the value of the input signal. In addition, when the input signal is already a binary value (i.e., when the value of the input signal is a binary value), binarization may not be performed and may be bypassed. Here, each binary number 0 or 1 constituting a binary value may be referred to as a bin. For example, if a binary string after binarization is 110, each of 1, 1, and 0 is called one bin. The bin(s) for one syntax element may indicate a value of the syntax element.</p><p id="p-0084" num="0083">Thereafter, the binarized bins of the syntax element may be input to a regular coding engine or a bypass coding engine. The regular coding engine of the encoding apparatus may allocate a context model reflecting a probability value to the corresponding bin, and may encode the corresponding bin based on the allocated context model. The regular coding engine of the encoding apparatus may update a context model for each bin after performing encoding on each bin. A bin encoded as described above may be referred to as a context-coded bin.</p><p id="p-0085" num="0084">Meanwhile, when the binarized bins of the syntax element are input to the bypass coding engine, they may be coded as follows. For example, the bypass coding engine of the encoding apparatus omits a procedure of estimating a probability with respect to an input bin and a procedure of updating a probability model applied to the bin after encoding. When bypass encoding is applied, the encoding apparatus may encode the input bin by applying a uniform probability distribution instead of allocating a context model, thereby improving an encoding rate. The bin encoded as described above may be referred to as a bypass bin.</p><p id="p-0086" num="0085">Entropy decoding may represent a process of performing the same process as the entropy encoding described above in reverse order.</p><p id="p-0087" num="0086">For example, when a syntax element is decoded based on a context model, the decoding apparatus may receive a bin corresponding to the syntax element through a bitstream, determine a context model using the syntax element and decoding information of a decoding target block or a neighbor block or information of a symbol/bin decoded in a previous stage, predict an occurrence probability of the received bin according to the determined context model, and perform an arithmetic decoding on the bin to derive a value of the syntax element. Thereafter, a context model of a bin which is decoded next may be updated with the determined context model.</p><p id="p-0088" num="0087">Also, for example, when a syntax element is bypass-decoded, the decoding apparatus may receive a bin corresponding to the syntax element through a bitstream, and decode the input bin by applying a uniform probability distribution. In this case, the procedure of the decoding apparatus for deriving the context model of the syntax element and the procedure of updating the context model applied to the bin after decoding may be omitted.</p><p id="p-0089" num="0088">As described above, residual samples may be derived as quantized transform coefficients through transform and quantization processes. The quantized transform coefficients may also be referred to as transform coefficients. In this case, the transform coefficients in a block may be signaled in the form of residual information. The residual information may include a residual coding syntax. That is, the encoding apparatus may configure a residual coding syntax with residual information, encode the same, and output it in the form of a bitstream, and the decoding apparatus may decode the residual coding syntax from the bitstream and derive residual (quantized) transform coefficients. The residual coding syntax may include syntax elements representing whether transform was applied to the corresponding block, a location of a last effective transform coefficient in the block, whether an effective transform coefficient exists in the subblock, a size/sign of the effective transform coefficient, and the like, as will be described later.</p><p id="p-0090" num="0089">For example, syntax elements related to residual data encoding/decoding may be represented as shown in the following table.</p><p id="p-0091" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>transform unit( x0, y0, tbWidth, tbHeight, treeType, subTuIndex, chType ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( IntraSubPartitionsSplitTypc != ISP_NO_SPLIT &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;treeType = = SINGLE_TREE &#x26;&#x26; subTuIndex = = NumlntraSubPartiti</entry><entry/></row><row><entry>ons &#x2212; 1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;xC = CbPosX[ chType ][ x0 ][ y0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;yC = CbPosY[ chType ][ x0 ][ y0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;wC = CbWidth[ chType ][ x0 ][ y0 ] / SubWidthC</entry><entry/></row><row><entry>&#x2003;&#x2003;hC = CbHeight[ chType ] [ x0 ] [ y0 ] / SubHeightC</entry><entry/></row><row><entry>&#x2003;} else {</entry><entry/></row><row><entry>&#x2003;&#x2003;xC = x0</entry><entry/></row><row><entry>&#x2003;&#x2003;yC = y0</entry><entry/></row><row><entry>&#x2003;&#x2003;wC = tbWidth / SubWidthC</entry><entry/></row><row><entry>&#x2003;&#x2003;hC = tbHeight / SubHeightC</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;chromaAvailable = treeType != DUAL_TREE_LUMA &#x26;&#x26; sps_chroma_form</entry><entry/></row><row><entry>at_idc != 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;( IntraSubPartitionsSplitType = = ISP_NO_SPLIT | |</entry><entry/></row><row><entry>&#x2003;&#x2003;( IntraSubPartitions SplitType != ISP_NO_SPLIT &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;subTuIndex = = NumIntraSubPartitions &#x2212; 1 ) )</entry><entry/></row><row><entry>&#x2003;if( ( treeType = = SINGLE_TREE | | treeType = = DUAL_TREE_CHROM</entry><entry/></row><row><entry>A ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_chroma_format_idc != 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( ( IntraSubPartitionsSplitType == ISP_NO_SPLIT &#x26;&#x26; !( cu_sbt_flag</entry><entry/></row><row><entry>&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( ( subTuIndex = = 0 &#x26;&#x26; cu_sbt_pos_flag ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( subTuIndex = = 1 &#x26;&#x26; !cu_sbt_pos_flag ) ) ) ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( IntraSubPartitionsSplitType != ISP_NO_SPLIT &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( subTuIndex = = NumIntraSubPartitions &#x2212; 1 ) ) ) ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;tu cb coded flag[ xC ][ yC ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;tu cr coded flag[ xC ][ yC ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( treeType = = SINGLE_TREE | | treeType = = DUAL_TREE_LUMA ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( ( IntraSubPartitionsSplitType = = ISP_NO_SPLIT &#x26;&#x26; !( cu_sbt flag &#x26;</entry><entry/></row><row><entry>&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( (subTuIndex = = 0 &#x26;&#x26; cu_sbt_pos_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( subTuIndex = =1 &#x26;&#x26; !cu_sbt_pos_flag ) ) ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( ( CuPredMode[ chType ] [ x0 ] [ y0 ] = = MODE_INTRA &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;!cu_act_enabled_flag[ x0 ][ y0 ]) </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( chromaAvailable &#x26;&#x26; (tu_cb_coded_flag[ xC ][ yC ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tu_cr_coded_flag[ xC ] [ yC ] ) ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;CbWidth[ chType ][ x0 ][ y0 ] &#x3e; MaxTbSizeY | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;CbHeight[ chType ][ x0 II y0 1 &#x3e; MaxTbSizeY ) ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(IntraSubPartitionsSplitType != ISP_NO_SPLIT &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( subTuIndex &#x3c; NumIntraSubPartitions &#x2212; 1 | | !InferTuCbfLuma ) ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tu_y_coded_flag[ x0 ][ y0 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;if(IntraSubPartitionsSplitType != ISP_NO_SPLIT )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;InferTuCbfLuma = InferTuCbfLuma &#x26;&#x26; !tu y coded flag[ x0 ][ y0 ]</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( ( CbWidth[ chType ] [ x0 ] [ y0 ] &#x3e; 64 | | CbHeight[ chType ][ x0 ][ y</entry><entry/></row><row><entry>0 ] &#x3e; 64 | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tu_y_coded_flag[ x0 ][ y0 ] | | ( chromaAvailable &#x26;&#x26; (tu_cb_coded_flag</entry><entry/></row><row><entry>[ xC ][ yC ] | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tu_cr_coded_flag[ xC ][yC ] ) ) &#x26;&#x26; treeType != DUAL_TREE_CHRO</entry><entry/></row><row><entry>MA &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pps cu qp delta enabled flag &#x26;&#x26; !IsCuQpDeltaCoded ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;cu_qp_delta_abs</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;if( cu qp delta abs )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;cu_qp_delta_sign_flag</entry><entry>ae(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( ( CbWidth[ chType ] [ x0 ] [ y0 ] &#x3e; 64 CbHeight[ chType ][ x0 ][ y</entry><entry/></row><row><entry>0 ] &#x3e; 64 | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( chromaAvailable &#x26;&#x26; ( tu_cb_coded_flag[ xC ][ yC ] | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tu_cr_coded flag[ xC ] [ yC ] ) ) ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;treeType != DUAL_TREE_LUMA &#x26;&#x26; sh_cu_chroma_qp_offset_enable</entry><entry/></row><row><entry>d_flag &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;!IsCuChromaQpOffsetCoded ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;cu chroma qp offset flag</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;if( cu_chroma_qp_offset_flag &#x26;&#x26; pps_chroma_qp_offset_list_len_minus1 &#x3e;</entry><entry/></row><row><entry>0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;cu chroma qp offset idx</entry><entry>ae(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_joint_cbcr_enabled_flag &#x26;&#x26; ( ( CuPredMode[ chType ][ x0 ][ y0 ] = =</entry><entry/></row><row><entry>MODE_INTRA</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26; ( tu_cb_coded_flag[ xC ][ yC ] | | tu_cr_coded_flag[ xC ][ yC ] ) ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( tu_cb_coded _flag[ xC ][ yC ] &#x26;&#x26; tu_cr_coded _flag[ xC ][ yC ] ) ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;chromaAvailable )</entry><entry/></row><row><entry>&#x2003;&#x2003;tu_joint_cbcr_residual_flag[ xC ][ yC ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( tu y coded flag[ x0 ][ y0 ] &#x26;&#x26; treeType != DUAL_TREE_CHROMA) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( sps_transform_skip_enabled_flag &#x26;&#x26; !BdpcmFlag[ x0 ][ y0 ][ 0 ] &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tbWidth &#x3c;= MaxTsSize &#x26;&#x26; tbHeight &#x3c;= MaxTsSize &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( IntraSubPartitionsSplitType = = ISP_NO_SPLIT ) &#x26;&#x26; !cu sbt flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;transform_skip_flag[ x0 ][ y0 ][ 0 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;if( !transform_skip_flag[ x0 ][ y0 ][ 0 ] | | sh_ts_residual_coding_disabled_fla</entry><entry/></row><row><entry>g )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;residual coding[ x0, y0, Log2( tbWidth), Log2( tbHeight), 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;residual ts coding( x0, y0, Log2( tbWidth), Log2( tbHeight) 0 )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if(tu cb coded flag[ xC ][ yC ] &#x26;&#x26; treeType != DUAL_TREE_LUMA ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( sps_transform_skip_enabled_flag &#x26;&#x26; !BdpcmFlag[ x0 ][ y0 ][ 1 ] &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;wC &#x3c;= MaxTsSize &#x26;&#x26; hC &#x3c;= MaxTsSize &#x26;&#x26; !cu sbt flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;transform_skip_flag[ xC ][ yC ][ 1 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;if( !transform_skip_flag[ xC ][ yC ][ 1 ] | | sh_ts_residual_coding_disabled_fl</entry><entry/></row><row><entry>ag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;residual coding( xC, yC, Log2( wC ), Log2( hC ), 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;residual ts coding( xC, yC, Log2( wC ), Log2( hC ), 1 )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( tu_cr_coded_flag[ xC ][ yC ] &#x26;&#x26; treeType != DUAL_TREE_LUMA &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;!(tu_cb_coded_flag[ xC ][ yC ] &#x26;&#x26; tu_joint_cbcr_residual_flag[ xC ][ y</entry><entry/></row><row><entry>C ] ) ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( sps_transform_skip_enabled_flag &#x26;&#x26; !BdpcmFlag[ x0 ][ y0 ][ 2 ] &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;wC &#x3c;= MaxTsSize &#x26;&#x26; hC &#x3c;= MaxTsSize &#x26;&#x26; !cu sbt flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;transform_skip_flag[ xC ][ yC ][ 2 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;if( !transform_skip_flag[ xC ][ yC ][ 2 ] | | sh_ts_residual_coding_disabled_fl</entry><entry/></row><row><entry>ag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;residual coding( xC, yC, Log2( wC ), Log2( hC ), 2 )</entry><entry/></row><row><entry>&#x2003;&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;residual ts coding( xC, yC, Log2( wC ), Log2( hC ), 2 )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0092" num="0090">transform_skip_flag indicates whether transform is skipped in an associated block. The transform_skip_flag may be a syntax element of a transform skip flag. The associated block may be a coding block (CB) or a transform block (TB). Regarding transform (and quantization) and residual coding procedures, CB and TB may be used interchangeably. For example, as described above, residual samples may be derived for CB, and (quantized) transform coefficients may be derived through transform and quantization for the residual samples, and through the residual coding procedure, information (e.g., syntax elements) efficiently indicating a position, magnitude, sign, etc. of the (quantized) transform coefficients may be generated and signaled. The quantized transform coefficients may simply be called transform coefficients. In general, when the CB is not larger than a maximum TB, a size of the CB may be the same as a size of the TB, and in this case, a target block to be transformed (and quantized) and residual coded may be called a CB or a TB. Meanwhile, when the CB is greater than the maximum TB, a target block to be transformed (and quantized) and residual coded may be called a TB. Hereinafter, it will be described that syntax elements related to residual coding are signaled in units of transform blocks (TBs) but this is an example and the TB may be used interchangeably with coding blocks (CBs as described above.</p><p id="p-0093" num="0091">Meanwhile, syntax elements which are signaled after the transform skip flag is signaled may be the same as the syntax elements disclosed in Table 2 and/or Table 3 below, and detailed descriptions on the syntax elements are described below.</p><p id="p-0094" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="252pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 2</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>residual coding( x0, y0, log2TbWidth, log2TbHeight, cIdx ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( sps_mts_enabled _flag &#x26;&#x26; cu_sbt_flag &#x26;&#x26; cIdx = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2TbWidth = = 5 &#x26;&#x26; log2TbHeight &#x3c; 6 )</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbWidth = 4</entry><entry/></row><row><entry>&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbWidth = Min( log2TbWidth, 5 )</entry><entry/></row><row><entry>&#x2003;if( sps_mts_enabled_flag &#x26;&#x26; cu_sbt_flag &#x26;&#x26; cIdx = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2TbWidth &#x3c; 6 &#x26;&#x26; log2TbHeight = = 5 )</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbHeight = 4</entry><entry/></row><row><entry>&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbHeight = Min( log2TbHeight 5 )</entry><entry/></row><row><entry>&#x2003;if( log2TbWidth &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_x_prefix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( log2TbHeight &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_y_prefix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( last_sig_coeff_x_prefix &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_x_suffix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( last_sig_coeff_y_prefix &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_y_suffix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;log2TbWidth = log2ZoTbWidth</entry><entry/></row><row><entry>&#x2003;log2TbHeight = log2ZoTbHeight</entry><entry/></row><row><entry>&#x2003;remBinsPass1 = ( ( 1 &#x3c;&#x3c; ( log2TbWidth + log2TbHeight)) * 7 ) &#x3e;&#x3e; 2</entry><entry/></row><row><entry>&#x2003;log2SbW = ( Min( log2TbWidth, log2TbHeight ) &#x3c; 2 ? 1 : 2 )</entry><entry/></row><row><entry>&#x2003;log2SbH = log2SbW</entry><entry/></row><row><entry>&#x2003;if( log2TbWidth + log2TbHcight &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( log2TbWidth &#x3c; 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbW = log2TbWidth</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbH = 4 &#x2212; log2SbW</entry><entry/></row><row><entry>&#x2003;&#x2003;} else if( log2TbHeight &#x3c; 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbH = log2TbHeight</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbW = 4 &#x2212; log2SbH</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;numSbCoeff = 1 &#x3c;&#x3c; ( log2SbW + log2SbH )</entry><entry/></row><row><entry>&#x2003;lastScanPos = numSbCoeff</entry><entry/></row><row><entry>&#x2003;lastSubBlock = ( 1 &#x3c;&#x3c; ( log2TbWidth + log2TbHeight &#x2212; (log2SbW + log2Sb</entry><entry/></row><row><entry>H ) ) ) &#x2212; 1</entry><entry/></row><row><entry>&#x2003;do {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( lastScanPos = = 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;lastScanPos = numSbCoeff</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;lastSubBlock&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;lastScanPos&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;xS = DiagScanOrder&#x2514; log2TbWidth &#x2212; log2SbW &#x2518;&#x2514; log2TbHeight &#x2212; log2SbH &#x2518;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x250c; lastSubBlock &#x2510;&#x250c; 0 &#x2510;</entry><entry/></row><row><entry>&#x2003;&#x2003;yS = DiagScanOrder&#x250c; log2TbWidth &#x2212; log2SbW &#x2510;&#x250c; log2TbHeight &#x2212; log2SbH &#x2510;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x250c; lastSubBlock &#x2510; &#x250c; 1 &#x2510;</entry><entry/></row><row><entry>&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ] [ log2SbH ] [ lastScan</entry><entry/></row><row><entry>Pos ][ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ lastScan</entry><entry/></row><row><entry>Pos ][ 1 ]</entry><entry/></row><row><entry>&#x2003;} while( ( xC != LastSignificantCoefX ) | | ( yC != LastSignificantCoeffY )</entry><entry/></row><row><entry>)</entry><entry/></row><row><entry>&#x2003;if( lastSubBlock = = 0 &#x26;&#x26; log2TbWidth &#x3e;= 2 &#x26;&#x26; log2TbHeight &#x3e;= 2 &#x26;</entry><entry/></row><row><entry>&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;!transform skip flag[ x0 ][ y0 ][ cIdx ] &#x26;&#x26; lastScanPos &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;LfnstDcOnly = 0</entry><entry/></row><row><entry>&#x2003;if( ( lastSubBlock &#x3e; 0 &#x26;&#x26; log2TbWidth &#x3e;= 2 &#x26;&#x26; log2TbHeight &#x3e;= 2 ) | | </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( lastScanPos &#x3e; 7 &#x26;&#x26; (log2TbWidth = = 2 | | log2TbWidth = = 3 ) &#x26;</entry><entry/></row><row><entry>&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2TbWidth = = log2TbHeight ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;LfnstZeroOutSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;if( ( lastSubBlock &#x3e; 0 | | lastScanPos &#x3e; 0 ) &#x26;&#x26; cIdx = = 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;MtsDcOnly = 0</entry><entry/></row><row><entry>&#x2003;QState = 0</entry><entry/></row><row><entry>&#x2003;for( i = lastSubBlock; i &#x3e;= 0; i&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;startQStateSb = QState</entry><entry/></row><row><entry>&#x2003;&#x2003;xS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;[ i ][ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;yS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;[ i ][ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;inferSbDcSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;if( i &#x3c; lastSubBlock &#x26;&#x26; i &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sb coded flag[ xS ][ yS ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;inferSbDcSigCoeffFlag = 1</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( sb coded flag[ xS ][ yS ] &#x26;&#x26; ( xS &#x3e; 3 | | yS &#x3e; 3 ) &#x26;&#x26; cIdx = = 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;MtsZeroOutSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;firstSigScanPosSb = numSbCoeff</entry><entry/></row><row><entry>&#x2003;&#x2003;lastSigScanPosSb = &#x2212;1</entry><entry/></row><row><entry>&#x2003;&#x2003;firstPosMode0 = ( i = = lastSubBlock ? lastScanPos : numSbCoeff &#x2212; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;firstPosModc1 = FirstPosMode0</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = firstPosMode0; n &#x3e;= 0 &#x26;&#x26; remBinsPass1 &#x3e;= 4; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sb_coded_flag[ xS ][ yS ] &#x26;&#x26; (n &#x3e; 0 | | !inferSbDcSigCoeffFlag ) &#x26;</entry><entry/></row><row><entry>&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( xC != LastSignificantCoeffX | | yC != Last SignificantCocffY ) )</entry><entry/></row><row><entry>{</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sig coeff flag[ xC ][ yC ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( sig coeff flag[ xC ][ yC ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;inferSbDcSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sig coeff flag[ xC ][ yC ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_flag[ n ][ 0 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( abs level gtx flag[ n ][ 0 ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;par_level_flag| n |</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs level gtx flag[ n ][ 1 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( lastSigScanPosSb = = &#x2212;1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;lastSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;AbsLevelPass1[ xC ][ yC ] = sig_coeff_flag[ xC ][ yC ] + par_level_flag</entry><entry/></row><row><entry>[ n ] +</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_flag[ n ][ 0 ] + 2 * abs_level_gtx flag[ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sh dep quant used flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;QStatc = QStatcTransTablc| QStatc || AbsLcvclPass1| xC || yC | &#x26; 1 |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;firstPosMode1 = n &#x2212; 1</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = firstPosMode0; n &#x3e; firstPosMode1; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( abs level gtx flag[ n ][ 1 ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs_remainder[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;AbsLevel[ xC ][ yC ] = AbsLevelPass1[ xC ][ yC ] +2 * abs remainder[ n ]</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = firstPosMode1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sb coded flag[ xS ][ yS ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;dec_abs_level[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( AbsLcvcl| xC || yC | &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( lastSigScanPosSb = = &#x2212;1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;lastSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sh dep quant used flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState = QStatcTransTable[ QState ][ AbsLevel[ xC ][ yC ] &#x26; 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( sh dep quant used flag | | !sh sign data hiding used flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;signHidden = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;signHidden = (lastSigScanPosSb &#x2212; firstSigScanPosSb &#x3e; 3 ? 1 : 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = numSbCoeff &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS&#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS&#x3c;&#x3c; log2SbH ) + DiagScanOrder&#x2514; log2SbW &#x2518;&#x2514; log2SbH &#x2518;&#x2514; n &#x2518;</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( (AbsLevel[ xC ][ yC ] &#x3e; 0 ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( !signHidden | | (n != firstSigScanPosSb ) ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;coeff_sign_flag&#x250c; n &#x2510;</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( sh dep quant used flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;QState = startQStateSb</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( n = numSbCoeff &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;xC = ( xS&#x3c;&#x3c; log2SbW ) + DiagScanOrder&#x250c; log2SbW &#x2510;&#x250c; log2SbH &#x2510;&#x250c; n &#x2510;</entry><entry/></row><row><entry>| 0 |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( AbsLevel&#x250c; xC &#x2510;&#x250c; yC &#x2510; &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( 2 * AbsLevel[ xC ][ yC ] &#x2212; ( QState &#x3e; 1 ? 1 : 0 ) ) *</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( 1 &#x2212; 2 * coeff sign flag[ n ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState = QStateTransTable[ QState ][ AbsLevel[ xC ][ yC ] &#x26; 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;} else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sumAbsLevel = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( n = numSbCoeff &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder&#x250c; log2SbW &#x2510;&#x250c; log2SbH &#x2510;&#x250c; n ]</entry><entry/></row><row><entry>&#x250c; 0 &#x2510;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>&#x250c; 1 &#x2510;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( AbsLevel[ xC ][ yC ] &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AbsLevel[ xC ][ yC ] * ( 1 &#x2212; 2 * coeff sign flag[ n ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( signHidden ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sumAbsLevel += AbsLevel| xC || yC |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( ( n = = firstSigScanPosSb ) &#x26;&#x26; ( sumAbsLevel % 2 ) = = 1 )</entry><entry/></row><row><entry>)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ] [ y0 ][ cIdx ][ xC ] [ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2212;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0095" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 3</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>residual ts coding( x0, y0, log2TbWidth, log2TbHeight, cIdx ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><tbody valign="top"><row><entry>&#x2003;log2SbW = ( Min( log2TbWidth, log2TbHeight ) &#x3c; 2 ? 1 : 2 )</entry><entry/></row><row><entry>&#x2003;log2SbH = log2SbW</entry><entry/></row><row><entry>&#x2003;if( log2TbWidth + log2TbHeight &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( log2TbWidth &#x3c; 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbW = log2TbWidth</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbH = 4 &#x2212; log2SbW</entry><entry/></row><row><entry>&#x2003;&#x2003;} else if( log2TbHeight &#x3c; 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbH = log2TbHeight</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbW = 4 &#x2212; log2SbH</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;numSbCoeff = 1 &#x3c;&#x3c; ( log2SbW + log2SbH )</entry><entry/></row><row><entry>&#x2003;lastSubBlock = ( 1 &#x3c;&#x3c; ( log2TbWidth + log2TbHeight &#x2212; ( log2SbW + log2Sb</entry><entry/></row><row><entry>H ) ) ) &#x2212; 1</entry><entry/></row><row><entry>&#x2003;inferSbCbf = 1</entry><entry/></row><row><entry>&#x2003;RemCcbs = ( ( 1 &#x3c;&#x3c; ( log2TbWidth + log2TbHeight ) ) * 7 ) &#x3e;&#x3e; 2</entry><entry/></row><row><entry>&#x2003;for( i =0; i &#x3c;= lastSubBlock; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;xS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>[ i ][ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;yS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>[ i ][ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;if( i != lastSubBlock | | !inferSbCbf )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sb_coded_flag[ xS ][ yS ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;if( sb coded flag[ xS ][ yS ] &#x26;&#x26; i &#x3c; lastSubBlock )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;inferSbCbf = 0</entry><entry/></row><row><entry>&#x2003;/* First scan pass */</entry><entry/></row><row><entry>&#x2003;&#x2003;inferSbSigCoeffFlag = 1</entry><entry/></row><row><entry>&#x2003;&#x2003;lastScanPosPass 1 = &#x2212;1</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = 0; n &#x3c;= numSbCoeff &#x2212; 1 &#x26;&#x26; RemCcbs &#x3e;= 4; n++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ] [ log2SbH ] [ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;lastScanPosPass1 = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sb_coded_flag[ xS ] [ yS ] &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(n != numSbCoeff &#x2212; 1 | | !inferSbSigCoeffFlag ) ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sig_coeff_flag[ xC ][ yC ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;RemCcbs&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( sig coeff flag[ xC ][ yC ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;inferSbSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;CoeffSignLevel[ xC ][ yC ] = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sig coeff flag[ xC ] [ yC ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;coeff_sign_flag[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;RemCcbs&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;CoeffSignLevel[ xC ][ yC ] = ( coeff sign flag[ n ] &#x3e; 0 ? &#x2212;1 : 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_flag[ n ][ 0 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;RemCcbs&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( abs_level_gtx_flag[ n ][ 0 ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;par level flag[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RemCcbs&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;AbsLevelPass1[ xC ] [ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sig_coeff_flag[ xC ][ yC ] + par_level_flag[ n ] + abs_level_gtx_flag</entry><entry/></row><row><entry>[ n ][ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;/* Greater than X scan pass (numGtXFlags=5) */</entry><entry/></row><row><entry>&#x2003;&#x2003;lastScanPosPass2 = &#x2212;1</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = 0: n &#x3c;= numSbCoeff &#x2212; 1 &#x26;&#x26; RemCcbs &#x3e;= 4; n++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ] [ log2SbH ] [ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ] [ n ]</entry><entry/></row><row><entry>[ 1 ] </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;AbsLevelPass2[ xC ][ yC ] = AbsLevelPass1[ xC ][ yC ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for (j = 1;j &#x3c; 5;j++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( abs level gtx flag[n ][ j &#x2212; 1 ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs level gtx flag[ n ] [ j ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RemCcbs&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AbsLevelPass2[ xC ][ yC ] += 2 * abs level gtx flag[ n ][ j ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;lastScanPosPass2 = n</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;/* remainder scan pass */</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = 0; n &#x3c;= numSbCoeff &#x2212; 1; n++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ] [ log2SbH ] [ n ]</entry><entry/></row><row><entry>| 0 |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( ( n &#x3c;= lastScanPosPass2 &#x26;&#x26; AbsLevelPass2&#x2514; xC &#x2518;&#x2514; yC &#x2518; &#x3e;= 10 ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( n &#x3e; lastScanPosPass2 &#x26;&#x26; n &#x3c;= lastScanPosPass1 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AbsLevelPass1[ xC ] [ yC ] &#x3e;= 2 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( n &#x3e; lastScanPosPass1 &#x26;&#x26; sb coded flag[ xS ][ yS ] ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs remainder[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( n &#x3c;= lastScanPosPass2 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AbsLevel[ xC ][ yC ] = AbsLevelPass2[ xC ][ yC ] + 2 * abs_remainder</entry><entry/></row><row><entry>[ n ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;else if(n &#x3c;= lastScanPosPass1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AbsLevel&#x250c; xC &#x2510;&#x250c; yC &#x2510; = AbsLevelPass1&#x250c; xC &#x2510;[ yC &#x2510; + 2 * abs_remainder</entry><entry/></row><row><entry>| n |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;else { /* bypass */</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AbsLevel&#x250c; xC &#x2510;&#x250c; yC &#x2510; = abs remainder&#x250c; n ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( abs remainder[ n ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;coeff_sign_flag[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( BdpcmFlag[ x0 ][ y0 ][ cIdx ] = = 0 &#x26;&#x26; n &#x3c;= lastScanPosPass1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;absLeftCoeff = xC &#x3e; 0 ? AbsLevel[ xC &#x2212; 1 ][ yC ] ) : 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;absAboveCoeff = yC &#x3e; 0 ? AbsLevel[ xC ][ yC &#x2212; 1 ] ) : 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;predCoeff = Max( absLeftCoeff absAboveCoeff )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( AbsLcvcl| xC || yC | = = 1 &#x26;&#x26; predCoeff &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AbsLevel&#x250c; xC &#x2510;&#x250c; yC &#x2510; = predCoeff</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;else if( AbsLevel[ xC ] [ yC ] &#x3e; 0 &#x26;&#x26; AbsLevel[ xC ] [ yC ] &#x3c;= predCo</entry><entry/></row><row><entry>eff )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AbsLevel[ xC ][ yC ]&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ] = ( 1 &#x2212; 2 * coeff_sign_flag</entry><entry/></row><row><entry>[ n ] ) *</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AbsLevel[ xC ][ yC ]</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0096" num="0092">According to the present embodiment, as shown in Table 1, residual coding may be divided according to a value of the syntax element transform_skip_flag of the transform skip flag. That is, a different syntax element may be used for residual coding based on the value of the transform skip flag (based on whether the transform is skipped). Residual coding used when the transform skip is not applied (that is, when the transform is applied) may be called regular residual coding (RRC), and residual coding used when the transform skip is applied (that is, when the transform is not applied) may be called transform skip residual coding (TSRC). Also, the regular residual coding may be referred to as general residual coding. Also, the regular residual coding may be referred to as a regular residual coding syntax structure, and the transform skip residual coding may be referred to as a transform skip residual coding syntax structure. Table 2 above may show a syntax element of residual coding when a value of transform_skip_flag is 0, that is, when the transform is applied, and Table 3 above may show a syntax element of residual coding when the value of transform_skip_flag is 1, that is, when the transform is not applied.</p><p id="p-0097" num="0093">Specifically, for example, the transform skip flag indicating whether to skip the transform of the transform block may be parsed, and whether the transform skip flag is 1 may be determined. If the value of the transform skip flag is 0, as shown in Table 2, syntax elements last_sig_coeff_x_prefix, last_sig_coeff_y_prefix, last_sig_coeff_x_suffix, last_sig_coeff_y_suffix, sb_coded_flag, sig_coeff_flag, abs_level_gtx_flag, par_level_flag, abs_remainder, coeff_sign_flag and/or dec_abs_level for a residual coefficient of the transform block may be parsed, and the residual coefficient may be derived based on the syntax elements. In this case, the syntax elements may be sequentially parsed, and a parsing order may be changed. In addition, the abs_level_gtx_flag may represent abs_level_gt1_flag, and/or abs_level_gt3_flag. For example, abs_level_gtx_flag[n][0] may be an example of a first transform coefficient level flag (abs_level_gt1_flag), and the abs_level_gtx_flag[n][1] may be an example of a second transform coefficient level flag (abs_level_gt3_flag).</p><p id="p-0098" num="0094">Referring to the Table 2 above, last_sig_coeff_x_prefix, last_sig_coeff_y_prefix, last_sig_coeff_x_suffix, last_sig_coeff_y_suffix, sb_coded_flag, sig_coeff_flag, abs_level_gt1_flag, par_level_flag, abs_level_gt3_flag, abs_remainder, coeff_sign_flag, and/or dec_abs_level may be encoded/decoded. Meanwhile, sb_coded_flag may be represented as coded_sub_block_flag.</p><p id="p-0099" num="0095">In an embodiment, the encoding apparatus may encode (x,y) position information of the last non-zero transform coefficient in a transform block based on the syntax elements last_sig_coeff_x_prefix, last_sig_coeff_y_prefix, last_sig_coeff_x_suffix, and last_sig_coeff_y_suffix. More specifically, the last_sig_coeff_x_prefix represents a prefix of a column position of a last significant coefficient in a scanning order within the transform block, the last_sig_coeff_y_prefix represents a prefix of a row position of the last significant coefficient in the scanning order within the transform block, the last_sig_coeff_x_suffix represents a suffix of a column position of the last significant coefficient in the scanning order within the transform block, and the last_sig_coeff_y_suffix represents a suffix of a row position of the last significant coefficient in the scanning order within the transform block. Here, the significant coefficient may represent a non-zero coefficient. In addition, the scanning order may be a right diagonal scanning order. Alternatively, the scanning order may be a horizontal scanning order or a vertical scanning order. The scanning order may be determined based on whether intra/inter prediction is applied to a target block (a CB or a CB including a TB) and/or a specific intra/inter prediction mode.</p><p id="p-0100" num="0096">Thereafter, the encoding apparatus may divide the transform block into 4&#xd7;4 sub-blocks, and then indicate whether there is a non-zero coefficient in the current sub-block using a 1-bit syntax element coded_sub_block_flag for each 4&#xd7;4 sub-block.</p><p id="p-0101" num="0097">If a value of coded_sub_block_flag is 0, there is no more information to be transmitted, and thus, the encoding apparatus may terminate the encoding process on the current sub-block. Conversely, if the value of coded_sub_block_flag is 1, the encoding apparatus may continuously perform the encoding process on sig_coeff_flag. Since the sub-block including the last non-zero coefficient does not require encoding for the coded_sub_block_flag and the sub-block including the DC information of the transform block has a high probability of including the non-zero coefficient, coded_sub_block_flag may not be coded and a value thereof may be assumed as 1.</p><p id="p-0102" num="0098">If the value of coded_sub_block_flag is 1 and thus it is determined that a non-zero coefficient exists in the current sub-block, the encoding apparatus may encode sig_coeff_flag having a binary value according to a reverse scanning order. The encoding apparatus may encode the 1-bit syntax element sig_coeff_flag for each transform coefficient according to the scanning order. If the value of the transform coefficient at the current scan position is not 0, the value of sig_coeff_flag may be 1. Here, in the case of a subblock including the last non-zero coefficient, sig_coeff_flag does not need to be encoded for the last non-zero coefficient, so the coding process for the sub-block may be omitted. Level information coding may be performed only when sig_coeff_flag is 1, and four syntax elements may be used in the level information encoding process. More specifically, each sig_coeff_flag[xC][yC] may indicate whether a level (value) of a corresponding transform coefficient at each transform coefficient position (xC, yC) in the current TB is non-zero. In an embodiment, the sig_coeff_flag may correspond to an example of a syntax element of a significant coefficient flag indicating whether a quantized transform coefficient is a non-zero significant coefficient.</p><p id="p-0103" num="0099">A level value remaining after encoding for sig_coeff_flag may be derived as shown in the following equation. That is, the syntax element remAbsLevel indicating a level value to be encoded may be derived from the following equation.</p><p id="p-0104" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>remAbsLevel=|coeff|&#x2212;1&#x2003;&#x2003;[Equation 1]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0105" num="0100">Herein, coeff means an actual transform coefficient value.</p><p id="p-0106" num="0101">Additionally, abs_level_gt1_flag may indicate whether or not remAbsLevel&#x2032; of the corresponding scanning position (n) is greater than 1. For example, when the value of abs_level_gt1_flag is 0, the absolute value of the transform coefficient of the corresponding position may be 1. In addition, when the value of the abs_level_gt1_flag is 1, the remAbsLevel indicating the level value to be encoded later may be updated as shown in the following equation.</p><p id="p-0107" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>remAbsLevel=remAbsLevel&#x2212;1&#x2003;&#x2003;[Equation 2]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0108" num="0102">In addition, the least significant coefficient (LSB) value of remAbsLevel described in Equation 2 described above may be encoded as in Equation 3 below through par_level_flag.</p><p id="p-0109" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>par_level_flag=|coeff|&#x26;1&#x2003;&#x2003;[Equation 3]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0110" num="0103">Herein, par_level_flag[n] may indicate a parity of a transform coefficient level (value) at a scanning position n.</p><p id="p-0111" num="0104">A transform coefficient level value remAbsLevel that is to be encoded after performing par_level_flag encoding may be updated as shown below in the following equation.</p><p id="p-0112" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>remAbsLevel=remAbsLevel&#x3e;&#x3e;1&#x2003;&#x2003;[Equation 4]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0113" num="0105">abs_level_gt3_flag may indicate whether or not remAbsLevel&#x2032; of the corresponding scanning position (n) is greater than 3. Encoding for abs_remainder may be performed only in a case where rem_abs_gt3_flag is equal to 1. A relationship between the actual transform coefficient value coeff and each syntax element may be as shown below in the following equation.</p><p id="p-0114" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>|coeff|=sig_coeff_flag+abs_level_<i>gt</i>1_flag+par_level_flag+2*(abs_level_<i>gt</i>3_flag+abs_remainder)&#x2003;&#x2003;[Equation 5]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0115" num="0106">Additionally, the following table indicates examples related to the above-described Equation 5.</p><p id="p-0116" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="49pt" align="center"/><colspec colname="3" colwidth="63pt" align="center"/><colspec colname="4" colwidth="49pt" align="center"/><colspec colname="5" colwidth="63pt" align="center"/><colspec colname="6" colwidth="49pt" align="center"/><thead><row><entry namest="1" nameend="6" rowsep="1">TABLE 4</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row><row><entry/><entry>sig_coeff_flag</entry><entry>abs_level_gtX_flag </entry><entry>par_level_flag</entry><entry>abs_level_gtX_flag </entry><entry>abs_remainder</entry></row><row><entry>|coeff[n]|</entry><entry>[n]</entry><entry>[n] [0]</entry><entry>[n]</entry><entry>[n] [1]</entry><entry>[n]</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="49pt" align="center"/><colspec colname="3" colwidth="63pt" align="center"/><colspec colname="4" colwidth="49pt" align="center"/><colspec colname="5" colwidth="63pt" align="center"/><colspec colname="6" colwidth="49pt" align="center"/><tbody valign="top"><row><entry>&#x2002;0</entry><entry>0</entry><entry/><entry/><entry/><entry/></row><row><entry>&#x2002;1</entry><entry>1</entry><entry>0</entry><entry/><entry/><entry/></row><row><entry>&#x2002;2</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>0</entry><entry/></row><row><entry>&#x2002;3</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry/></row><row><entry>&#x2002;4</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>0</entry></row><row><entry>&#x2002;5</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>0</entry></row><row><entry>&#x2002;6</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>1</entry></row><row><entry>&#x2002;7</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry></row><row><entry>&#x2002;8</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>2</entry></row><row><entry>&#x2002;9</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>2</entry></row><row><entry>10</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>3</entry></row><row><entry>11</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>3</entry></row><row><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0117" num="0107">Herein, |coeff| indicates a transform coefficient level (value) and may also be indicates as an AbsLevel for a transform coefficient. Additionally, a sign of each coefficient may be encoded by using coeff_sign_flag, which is a 1-bit symbol.</p><p id="p-0118" num="0108">Also, if the value of the transform skip flag is 1, as shown in Table 3, syntax elements sb_coded_flag, sig_coeff_flag, coeff_sign_flag, abs_level_gtx_flag, par_level_flag and/or abs_remainder for a residual coefficient of the transform block may be parsed, and the residual coefficient may be derived based on the syntax elements. In this case, the syntax elements may be sequentially parsed, and a parsing order may be changed. In addition, the abs_level_gtx_flag may represent abs_level_gt1_flag, abs_level_gt3_flag, abs_level_gt5_flag, abs_level_gt7_flag, and/or abs_level_gt9_flag. For example, abs_level_gtx_flag[n][j] may be a flag indicating whether an absolute value or a level (a value) of a transform coefficient at a scanning position n is greater than (j&#x3c;&#x3c;1)+1. The condition (j&#x3c;&#x3c;1)+1 may be optionally replaced with a specific threshold such as a first threshold, a second threshold, or the like.</p><p id="p-0119" num="0109">Meanwhile, CABAC provides high performance, but disadvantageously has poor throughput performance. This is caused by a regular coding engine of the CABAC. Regular encoding (i.e., coding through the regular coding engine of the CABAC) shows high data dependence since it uses a probability state and range updated through coding of a previous bin, and it may take a lot of time to read a probability interval and determine a current state. The throughput problem of the CABAC may be solved by limiting the number of context-coded bins. For example, as shown in Table 2 described above, a sum of bins used to express sig_coeff_flag, abs_level_gt1_flag, par_level_flag, and abs_level_gt3_flag may be limited to the number of bins depending on a size of a corresponding block. Also, for example, as shown in Table 3 described above, a sum of bins used to express sig_coeff_flag, coeff_sign_flag, abs_level_gt1_flag, par_level_flag, abs_level_gt3_flag abs_level_gt5_flag, abs_level_gt7_flag, abs_level_gt9_flag may be limited to the number of bins depending on a size of a corresponding block. For example, if the corresponding block is a block of a 4&#xd7;4 size, the sum of bins for the sig_coeff_flag, abs_level_gt1_flag, par_level_flag, abs_level_gt3_flag or sig_coeff_flag, coeff_sign_flag, abs_level_gt1_flag, par_level_flag, abs_level_gt3_flag abs_level_gt5_flag, abs_level_gt7_flag, abs_level_gt9_flag may be limited to 32 (or ex. 28), and if the corresponding block is a block of a 2&#xd7;2 size, the sum of bins for the sig_coeff_flag, abs_level_gt1_flag, par_level_flag, abs_level_gt3_flag may be limited to 8 (or ex. 7). The limited number of bins may be represented by remBinsPass1 or RemCcbs. Or, for example, for higher CABAC throughput, the number of context coded bins may be limited for a block (CB or TB) including a coding target CG. In other words, the number of context coded bins may be limited in units of blocks (CB or TB). For example, when the size of the current block is 16&#xd7;16, the number of context coded bins for the current block may be limited to 1.75 times the number of pixels of the current block, i.e., 448, regardless of the current CG.</p><p id="p-0120" num="0110">In this case, if all context-coded bins of which the number is limited are used when a context element is coded, the encoding apparatus may binarize the remaining coefficients through a method of binarizing the coefficient as described below, instead of using the context coding, and may perform bypass encoding. In other words, for example, if the number of context-coded bins which are coded for 4&#xd7;4 CG is 32 (or ex. 28), or if the number of context-coded bins which are coded for 2&#xd7;2 CG is 8 (or ex. 7), sig_coeff_flag, abs_level_gt1_flag, par_level_flag, abs_level_gt3_flag which are coded with the context-coded bin may no longer be coded, and may be coded directly to dec_abs_level. Or, for example, when the number of context coded bins coded for a 4&#xd7;4 block is 1.75 times the number of pixels of the entire block, that is, when limited to 28, the sig_coeff_flag, abs_level_gt1_flag, par_level_flag, and abs_level_gt3_flag coded as context coded bins may not be coded any more, and may be directly coded as dec_abs_level as shown in Table 5 below.</p><p id="p-0121" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="133pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 5</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry/><entry>dec_abs_level </entry></row><row><entry/><entry>|coeff[n]|</entry><entry>[n]</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="35pt" align="char" char="."/><colspec colname="2" colwidth="133pt" align="char" char="."/><tbody valign="top"><row><entry/><entry>0</entry><entry>0</entry></row><row><entry/><entry>1</entry><entry>1</entry></row><row><entry/><entry>2</entry><entry>2</entry></row><row><entry/><entry>3</entry><entry>3</entry></row><row><entry/><entry>4</entry><entry>4</entry></row><row><entry/><entry>5</entry><entry>5</entry></row><row><entry/><entry>6</entry><entry>6</entry></row><row><entry/><entry>7</entry><entry>7</entry></row><row><entry/><entry>8</entry><entry>8</entry></row><row><entry/><entry>9</entry><entry>9</entry></row><row><entry/><entry>10</entry><entry>10</entry></row><row><entry/><entry>11</entry><entry>11</entry></row><row><entry/><entry>. . .</entry><entry>. . .</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0122" num="0111">A value |coeff| may be derived based on dec_abs_level. In this case, a transform coefficient value, i.e., |coeff|, may be derived as shown in the following equation.</p><p id="p-0123" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>|coeff|=<i>dec</i>_abs_level&#x2003;&#x2003;[Equation 6]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0124" num="0112">In addition, the coeff_sign_flag may indicate a sign of a transform coefficient level at a corresponding scanning position n. That is, the coeff_sign_flag may indicate the sign of the transform coefficient at the corresponding scanning position n.</p><p id="p-0125" num="0113"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows an example of transform coefficients in a 4&#xd7;4 block.</p><p id="p-0126" num="0114">The 4&#xd7;4 block of <figref idref="DRAWINGS">FIG. <b>5</b></figref> represents an example of quantized coefficients. The block of <figref idref="DRAWINGS">FIG. <b>5</b></figref> may be a 4&#xd7;4 transform block, or a 4&#xd7;4 sub-block of an 8&#xd7;8, 16&#xd7;16, 32&#xd7;32, or 64&#xd7;64 transform block. The 4&#xd7;4 block of <figref idref="DRAWINGS">FIG. <b>5</b></figref> may represent a luma block or a chroma block.</p><p id="p-0127" num="0115">Meanwhile, as described above, when an input signal is not a binary value but a syntax element, the encoding apparatus may transform the input signal into a binary value by binarizing a value of the input signal. In addition, the decoding apparatus may decode the syntax element to derive a binarized value (e.g., a binarized bin) of the syntax element, and may de-binarize the binarized value to derive a value of the syntax element. The binarization process may be performed as a truncated rice (TR) binarization process, a k-th order Exp-Golomb (EGk) binarization process, a limited k-th order Exp-Golomb (limited EGk), a fixed-length (FL) binarization process, or the like. In addition, the de-binarization process may represent a process performed based on the TR binarization process, the EGk binarization process, or the FL binarization process to derive the value of the syntax element.</p><p id="p-0128" num="0116">For example, the TR binarization process may be performed as follows.</p><p id="p-0129" num="0117">An input of the TR binarization process may be cMax and cRiceParam for a syntax element and a request for TR binarization. In addition, an output of the TR binarization process may be TR binarization for symbolVal which is a value corresponding to a bin string.</p><p id="p-0130" num="0118">Specifically, for example, in the presence of a suffix bin string for a syntax element, a TR bin string for the syntax element may be concatenation of a prefix bin string and the suffix bin string, and in the absence of the suffix bin string, the TR bin string for the syntax element may be the prefix bin string. For example, the prefix bin string may be derived as described below.</p><p id="p-0131" num="0119">A prefix value of the symbolVal for the syntax element may be derived as shown in the following equation.</p><p id="p-0132" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>prefixVal=symbolVal&#x3e;&#x3e;cRiceParam&#x2003;&#x2003;[Equation 7]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0133" num="0120">Herein, prefixVal may denote a prefix value of the symbolVal. A prefix (i.e., a prefix bin string) of the TR bin string of the syntax element may be derived as described below.</p><p id="p-0134" num="0121">For example, if the prefixVal is less than cMax&#x3e;&#x3e;cRiceParam, the prefix bin string may be a bit string of length prefixVal+1, indexed by binIdx. That is, if the prefixVal is less than cMax&#x3e;&#x3e;cRiceParam, the prefix bin string may be a bit string of which the number of bits is prefixVal+1, indicated by binIdx. A bin for binIdx less than prefixVal may be equal to 1. In addition, a bin for the same binIdx as the prefixVal may be equal to 0.</p><p id="p-0135" num="0122">For example, a bin string derived through unary binarization for the prefixVal may be as shown in the following table.</p><p id="p-0136" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="56pt" align="center"/><colspec colname="2" colwidth="154pt" align="center"/><colspec colname="3" colwidth="7pt" align="center"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 6</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>prefixVal</entry><entry>Bin string</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="1" colwidth="56pt" align="center"/><colspec colname="2" colwidth="21pt" align="center"/><colspec colname="3" colwidth="35pt" align="center"/><colspec colname="4" colwidth="21pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><colspec colname="6" colwidth="14pt" align="center"/><colspec colname="7" colwidth="35pt" align="center"/><tbody valign="top"><row><entry>0</entry><entry>0</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>1</entry><entry>1</entry><entry>0</entry></row><row><entry>2</entry><entry>1</entry><entry>1</entry><entry>0</entry></row><row><entry>3</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>0</entry></row><row><entry>4</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>0</entry></row><row><entry>5</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>0</entry></row><row><entry>. . .</entry></row><row><entry>binIdx</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry><entry>5</entry></row><row><entry namest="1" nameend="7" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0137" num="0123">Meanwhile, if the prefixVal is not less than cMax&#x3e;&#x3e;cRiceParam, the prefix bin string may be a bit string in which a length is cMax&#x3e;&#x3e;cRiceParam and all bits are 1.</p><p id="p-0138" num="0124">In addition, if cMax is greater than symbolVal and if cRiceParam is greater than 0, a bin suffix bin string of a TR bin string may be present. For example, the suffix bin string may be derived as described below.</p><p id="p-0139" num="0125">A suffix value of the symbolVal for the syntax element may be derived as shown in the following equation.</p><p id="p-0140" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>suffixVal=symbolVal&#x2212;((prefixVal)&#x3c;&#x3c;cRiceParam)&#x2003;&#x2003;[Equation 8]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0141" num="0126">Herein, suffixVal may denote a suffix value of the symbolVal.</p><p id="p-0142" num="0127">A suffix of a TR bin string (i.e., a suffix bin string) may be derived based on an FL binarization process for suffixVal of which a value cMax is (1&#x3c;&#x3c;cRiceParam)&#x2212;1.</p><p id="p-0143" num="0128">Meanwhile, if a value of an input parameter, i.e., cRiceParam, is 0, the TR binarization may be precisely truncated unary binarization, and may always use the same value cMax as a possible maximum value of a syntax element to be decoded.</p><p id="p-0144" num="0129">In addition, for example, the EGk binarization process may be performed as follows. A syntax element coded with ue(v) may be a syntax element subjected to Exp-Golomb coding.</p><p id="p-0145" num="0130">For example, a 0-th order Exp-Golomb (EGO) binarization process may be performed as follows.</p><p id="p-0146" num="0131">A parsing process for the syntax element may begin with reading a bit including a first non-zero bit starting at a current position of a bitstream and counting the number of leading bits equal to 0. The process may be represented as shown in the following table.</p><p id="p-0147" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="161pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 7</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>leadingZeroBits = &#x2212;1</entry></row><row><entry/><entry>for( b = 0; !b; leadingZeroBits++ )</entry></row><row><entry/><entry>&#x2003;b = read_bits( 1 )</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0148" num="0132">In addition, a variable &#x2018;codeNum&#x2019; may be derived as shown in the following equation.</p><p id="p-0149" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>codeNum=2<sup>leadingZeroBits</sup>&#x2212;1+read_bits(leadingZeroBits)&#x2003;&#x2003;[Equation 9]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0150" num="0133">Herein, a value returned from read_bits(leadingZeroBits), that is, a value indicated by read_bits(leadingZeroBits), may be interpreted as binary representation of an unsigned integer for a most significant bit recorded first.</p><p id="p-0151" num="0134">A structure of an Exp-Golomb code in which a bit string is divided into a &#x201c;prefix&#x201d; bit and a &#x201c;suffix&#x201d; bit may be represented as shown in the following table.</p><p id="p-0152" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="77pt" align="left"/><colspec colname="2" colwidth="105pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 8</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry/><entry>Range of </entry></row><row><entry/><entry>Bit string form</entry><entry>codeNum</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>1</entry><entry>0</entry></row><row><entry/><entry>0 1 x<sub>0</sub></entry><entry>1 . . . 2</entry></row><row><entry/><entry>0 0 1 x<sub>1 </sub>x<sub>0</sub></entry><entry>3 . . . 6</entry></row><row><entry/><entry>0 0 0 1 x<sub>2 </sub>x<sub>1 </sub>x<sub>0</sub></entry><entry>7 . . . 14</entry></row><row><entry/><entry>0 0 0 0 1 x<sub>3 </sub>x<sub>2 </sub>x<sub>1 </sub>x<sub>0</sub></entry><entry>15 . . . 30</entry></row><row><entry/><entry>0 0 0 0 0 1 x<sub>4 </sub>x<sub>3 </sub>x<sub>2 </sub>x<sub>1 </sub>x<sub>0</sub></entry><entry>31 . . . 62</entry></row><row><entry/><entry>. . .</entry><entry>. . .</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0153" num="0135">The &#x201c;prefix&#x201d; bit may be a bit parsed as described above to calculate leadingZeroBits, and may be represented by 0 or 1 of a bit string in Table 8. That is, the bit string disclosed by 0 or 1 in Table 8 above may represent a prefix bit string. The &#x201c;suffix&#x201d; bit may be a bit parsed in the computation of codeNum, and may be represented by xi in Table 8 above. That is, a bit string disclosed as xi in Table 8 above may represent a suffix bit string. Herein, i may be a value in the range of LeadingZeroBits&#x2212;1. In addition, each xi may be equal to 0 or 1.</p><p id="p-0154" num="0136">A bit string assigned to the codeNum may be as shown in the following table.</p><p id="p-0155" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="42pt" align="center"/><colspec colname="2" colwidth="133pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 9</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Bit string</entry><entry>codeNum</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>1</entry><entry>0</entry></row><row><entry/><entry>0 1 0</entry><entry>1</entry></row><row><entry/><entry>0 1 1</entry><entry>2</entry></row><row><entry/><entry>0 0 1 0 0</entry><entry>3</entry></row><row><entry/><entry>0 0 1 0 1</entry><entry>4</entry></row><row><entry/><entry>0 0 1 1 0</entry><entry>5</entry></row><row><entry/><entry>0 0 1 1 1</entry><entry>6</entry></row><row><entry/><entry>0 0 0 1 0 0 0</entry><entry>7</entry></row><row><entry/><entry>0 0 0 1 0 0 1</entry><entry>8</entry></row><row><entry/><entry>0 0 0 1 0 1 0</entry><entry>9</entry></row><row><entry/><entry>. . .</entry><entry>. . .</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0156" num="0137">If a descriptor of the syntax element is ue(v), that is, if the syntax element is coded with ue(v), a value of the syntax element may be equal to codeNum.</p><p id="p-0157" num="0138">In addition, for example, the EGk binarization process may be performed as follows.</p><p id="p-0158" num="0139">An input of the EGk binarization process may be a request for EGk binarization. In addition, the output of the EGk binarization process may be EGk binarization for symbolVal, i.e., a value corresponding to a bin string.</p><p id="p-0159" num="0140">A bit string of the EGk binarization process for symbolVal may be derived as follows.</p><p id="p-0160" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="161pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 10</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>absV = Abs( symbolVal )</entry></row><row><entry/><entry>stopLoop = 0</entry></row><row><entry/><entry>do</entry></row><row><entry/><entry>&#x2003;if( absV &#x3e;= ( 1 &#x3c;&#x3c; k ) ) {</entry></row><row><entry/><entry>&#x2003;&#x2003;put( 1 )</entry></row><row><entry/><entry>&#x2003;&#x2003;absV = absV &#x2212; ( 1 &#x3c;&#x3c; k )</entry></row><row><entry/><entry>&#x2003;&#x2003;k++</entry></row><row><entry/><entry>&#x2003;} else {</entry></row><row><entry/><entry>&#x2003;&#x2003;put( 0 )</entry></row><row><entry/><entry>&#x2003;&#x2003;while( k&#x2212; &#x2212; )</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;put( ( absV &#x3e;&#x3e; k ) &#x26; 1 )</entry></row><row><entry/><entry>&#x2003;&#x2003;stopLoop = 1</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>while( !stopLoop )</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0161" num="0141">Referring to Table 10 above, a binary value X may be added to an end of a bin string through each call of put(X). Herein, X may be 0 or 1.</p><p id="p-0162" num="0142">In addition, for example, the limited EGk binarization process may be performed as follows.</p><p id="p-0163" num="0143">An input of the limited EGk binarization process may be a request for limited EGk binarization, a rice parameter riceParam, log 2TransformRange as a variable representing a binary logarithm of a maximum value, and maxPreExtLen as a variable representing a maximum prefix extension length. In addition, an output of the limited EGk binarization process may be limited EGk binarization for symbolVal as a value corresponding to an empty string.</p><p id="p-0164" num="0144">A bit string of the limited EGk binarization process for the symbolVal may be derived as follows.</p><p id="p-0165" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 11</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>codeValue = symbolVal &#x3e;&#x3e; riceParam</entry></row><row><entry>PrefixExtensionLength = 0</entry></row><row><entry>while( ( PrefixExtensionLength &#x3c; maxPrefixExtensionLength ) &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;( codeValue &#x3e; ( ( 2 &#x3c;&#x3c; PrefixExtensionLength ) &#x2212; 2 ) ) ) {</entry></row><row><entry>&#x2003;&#x2009;PrefixExtensionLength++</entry></row><row><entry>&#x2003;&#x2009;put( 1 )</entry></row><row><entry>&#x2009;}</entry></row><row><entry>&#x2009;if( PrefixExtensionLength = = maxPrefixExtensionLength )</entry></row><row><entry>&#x2003;escapeLength = log2TransformRange</entry></row><row><entry>&#x2009;else {</entry></row><row><entry>&#x2003;escapeLength = PrefixExtensionLength + riceParam</entry></row><row><entry>&#x2003;put( 0 )</entry></row><row><entry>&#x2009;}</entry></row><row><entry>&#x2009;symbolVal = symbolVal &#x2212; ( ( ( 1 &#x3c;&#x3c; PrefixExtensionLength ) &#x2212; 1 ) &#x3c;&#x3c; riceParam )</entry></row><row><entry>&#x2009;while( ( escapeLength&#x2212; &#x2212; ) &#x3e; 0 )</entry></row><row><entry>&#x2003;&#x2009;put( ( symbolVal &#x3e;&#x3e; escapeLength ) &#x26; 1 )</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0166" num="0145">In addition, for example, the FL binarization process may be performed as follows.</p><p id="p-0167" num="0146">An input of the FL binarization process may be a request for FL binarization and cMax for the syntax element. In addition, an output of the FL binarization process may be FL binarization for symbolVal as a value corresponding to a bin string.</p><p id="p-0168" num="0147">FL binarization may be configured by using a bit string of which the number of bits has a fixed length of symbolVal. Herein, the fixed-length bit may be an unsigned integer bit string. That is, a bit string for symbolVal as a symbol value may be derived through FL binarization, and a bit length (i.e., the number of bits) of the bit string may be a fixed length.</p><p id="p-0169" num="0148">For example, the fixed length may be derived as shown in the following equation.</p><p id="p-0170" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>fixedLength=Ceil(Log 2(<i>c</i>Max+1))[Equation 10]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0171" num="0149">Indexing of bins for FL binarization may be a method using a value which increases orderly from a most significant bit to a least significant bit. For example, a bin index related to the most significant bit may be binIdx=0.</p><p id="p-0172" num="0150">Meanwhile, for example, a binarization process for a syntax element abs_remainder in the residual information may be performed as follows.</p><p id="p-0173" num="0151">An input of the binarization process for the abs_remainder may be a request for binarization of a syntax element abs_remainder[n], a colour component cIdx, and a luma position (x0, y0). The luma position (x0, y0) may indicate a top-left sample of a current luma transform block based on the top-left luma sample of a picture.</p><p id="p-0174" num="0152">An output of the binarization process for the abs_remainder may be binarization of the abs_remainder (i.e., a binarized bin string of the abs_remainder). Available bin strings for the abs_remainder may be derived through the binarization process.</p><p id="p-0175" num="0153">A rice parameter cRiceParam for the abs_remainder[n] may be derived through a rice parameter derivation process performed by inputting the color component cIdx and luma position (x0, y0), the current coefficient scan position (xC, yC), log 2TbWidth, which is the binary logarithm of the width of the transform block, and log 2TbHeight, which is the binary logarithm of the height of the transform block. A detailed description of the rice parameter derivation process will be described later.</p><p id="p-0176" num="0154">In addition, for example, cMax for abs_remainder[n] to be currently coded may be derived based on the rice parameter cRiceParam. The cMax may be derived as shown in the following equation.</p><p id="p-0177" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>c</i>Max=6<i>&#x3c;&#x3c;c</i>RiceParam&#x2003;&#x2003;[Equation 11]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0178" num="0155">Meanwhile, binarization for the abs_remainder, that is, a bin string for the abs_remainder, may be concatenation of a prefix bin string and a suffix bin string in the presence of the suffix bin string. In addition, in the absence of the suffix bin string, the bin string for the abs_remainder may be the prefix bin string.</p><p id="p-0179" num="0156">For example, the prefix bin string may be derived as described below.</p><p id="p-0180" num="0157">A prefix value prefixVal of the abs_remainder[n] may be derived as shown in the following equation.</p><p id="p-0181" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>prefixVal=Min(<i>c</i>Max,abs_remainder[<i>n</i>])&#x2003;&#x2003;[Equation 12]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0182" num="0158">A prefix of the bin string (i.e., a prefix bin string) of the abs_remainder[n] may be derived through a TR binarization process for the prefixVal, in which the cMax and the cRiceParam are used as an input.</p><p id="p-0183" num="0159">If the prefix bin string is identical to a bit string in which all bits are 1 and a bit length is 6, a suffix bin string of the bin string of the abs_remainder[n] may exist, and may be derived as described below.</p><p id="p-0184" num="0160">The rice parameter deriving process for the dec_abs_level[n] may be as follows.</p><p id="p-0185" num="0161">An input of the rice parameter deriving process may be a colour component index cIdx, a luma position (x0, y0), a current coefficient scan position (xC, yC), log 2TbWidth as a binary logarithm of a width of a transform block, and log 2TbHeight as a binary logarithm of a height of the transform block. The luma position (x0, y0) may indicate a top-left sample of a current luma transform block based on a top-left luma sample of a picture. In addition, an output of the rice parameter deriving process may be the rice parameter cRiceParam.</p><p id="p-0186" num="0162">For example, a variable locSumAbs may be derived similarly to a pseudo code disclosed in the following table, based on an array AbsLevel[x][y] for a transform block having the given component index cIdx and the top-left luma position (x0, y0).</p><p id="p-0187" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 12</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>locSumAbs = 0</entry></row><row><entry/><entry>if( xC &#x3c; (1 &#x3c;&#x3c; log2TbWidth) &#x2212; 1 ) {</entry></row><row><entry/><entry>&#x2003;locSumAbs += AbsLevel[ xC + 1 ][ yC ]</entry></row><row><entry/><entry>&#x2003;if( xC &#x3c; (1 &#x3c;&#x3c; log2TbWidth) &#x2212; 2 )</entry></row><row><entry/><entry>&#x2003;&#x2003;locSumAbs += AbsLevel[ xC + 2 ][ yC ]</entry></row><row><entry/><entry>&#x2003;if( yC &#x3c; (1 &#x3c;&#x3c; log2TbHeight) &#x2212; 1 )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="161pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;&#x2003;locSumAbs += AbsLevel[ xC + 1 ][ yC + 1 ]</entry><entry>(1532)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><tbody valign="top"><row><entry/><entry>}</entry></row><row><entry/><entry>if( yC &#x3c; (1 &#x3c;&#x3c; log2TbHeight) &#x2212; 1 ) {</entry></row><row><entry/><entry>&#x2003;locSumAbs += AbsLevel[ xC ][ yC + 1 ]</entry></row><row><entry/><entry>&#x2003;if( yC &#x3c; (1 &#x3c;&#x3c; log2TbHeight) &#x2212; 2 )</entry></row><row><entry/><entry>&#x2003;&#x2003;locSumAbs += AbsLevel[ xC ][ yC + 2 ]</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>locSumAbs = Clip3( 0, 31, locSumAbs &#x2212; baseLevel * 5 )</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0188" num="0163">Then, based on the given variable locSumAbs, the rice parameter cRiceParam may be derived as shown in the following table.</p><p id="p-0189" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="17"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="14pt" align="center"/><colspec colname="3" colwidth="14pt" align="center"/><colspec colname="4" colwidth="14pt" align="center"/><colspec colname="5" colwidth="14pt" align="center"/><colspec colname="6" colwidth="14pt" align="center"/><colspec colname="7" colwidth="14pt" align="center"/><colspec colname="8" colwidth="14pt" align="center"/><colspec colname="9" colwidth="14pt" align="center"/><colspec colname="10" colwidth="14pt" align="center"/><colspec colname="11" colwidth="14pt" align="center"/><colspec colname="12" colwidth="14pt" align="center"/><colspec colname="13" colwidth="14pt" align="center"/><colspec colname="14" colwidth="14pt" align="center"/><colspec colname="15" colwidth="14pt" align="center"/><colspec colname="16" colwidth="14pt" align="center"/><colspec colname="17" colwidth="14pt" align="center"/><thead><row><entry namest="1" nameend="17" rowsep="1">TABLE 13</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>locSumAbs</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry><entry>5</entry><entry>6</entry><entry>7</entry><entry>8</entry><entry>9</entry><entry>10</entry><entry>11</entry><entry>12</entry><entry>13</entry><entry>14</entry><entry>15</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row><row><entry>cRiceParam</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>2</entry><entry>2</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row><row><entry>locSumAbs</entry><entry>16</entry><entry>17</entry><entry>18</entry><entry>19</entry><entry>20</entry><entry>21</entry><entry>22</entry><entry>23</entry><entry>24</entry><entry>25</entry><entry>26</entry><entry>27</entry><entry>28</entry><entry>29</entry><entry>30</entry><entry>31</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row><row><entry>cRiceParam</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>3</entry><entry>3</entry><entry>3</entry><entry>3</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0190" num="0164">Also, for example, in the rice parameter derivation process for abs_remainder[n], the baseLevel may be set to 4.</p><p id="p-0191" num="0165">Alternatively, for example, the rice parameter cRiceParam may be determined based on whether a transform skip is applied to a current block. That is, if a transform is not applied to a current TB including a current CG, in other words, if the transform skip is applied to the current TB including the current CG, the rice parameter cRiceParam may be derived to be 1.</p><p id="p-0192" num="0166">Also, a suffix value suffixVal of the abs_remainder may be derived as shown in the following equation.</p><p id="p-0193" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>suffixVal=abs_remainder[<i>n</i>]<i>c</i>Max&#x2003;&#x2003;[Equation 13]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0194" num="0167">A suffix bin string of the bin string of the abs_remainder may be derived through a limited EGk binarization process for the suffixVal in which k is set to cRiceParam+1, riceParam is set to cRiceParam, and log 2TransformRange is set to 15, and maxPreExtLen is set to 11.</p><p id="p-0195" num="0168">Meanwhile, for example, a binarization process for a syntax element dec_abs_level in the residual information may be performed as follows.</p><p id="p-0196" num="0169">An input of the binarization process for the dec_abs_level may be a request for binarization of a syntax element dec_abs_level[n], a colour component cIdx, a luma position (x0, y0), a current coefficient scan position (xC, yC), log 2TbWidth as a binary logarithm of a width of a transform block, and log 2TbHeight as a binary logarithm of a height of the transform block. The luma position (x0, y0) may indicate a top-left sample of a current luma transform block based on a top-left luma sample of a picture.</p><p id="p-0197" num="0170">An output of the binarization process for the dec_abs_level may be binarization of the dec_abs_level (i.e., a binarized bin string of the dec_abs_level). Available bin strings for the dec_abs_level may be derived through the binarization process.</p><p id="p-0198" num="0171">A rice parameter cRiceParam for dec_abs_level[n] may be derived through a rice parameter deriving process performed with an input of the colour component cIdx, the luma position (x0, y0), the current coefficient scan position (xC, yC), the log 2TbWidth as the binary logarithm of the width of the transform block, and the log 2TbHeight as the binary logarithm of the height of the transform block. The rice parameter deriving process will be described below in detail.</p><p id="p-0199" num="0172">In addition, for example, cMax for the dec_abs_level[n] may be derived based on the rice parameter cRiceParam. The cMax may be derived as shown in the following table.</p><p id="p-0200" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>c</i>Max=6<i>&#x3c;&#x3c;c</i>RiceParam&#x2003;&#x2003;[Equation 14]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0201" num="0173">Meanwhile, binarization for the dec_abs_level[n], that is, a bin string for the dec_abs_level[n], may be concatenation of a prefix bin string and a suffix bin string in the presence of the suffix bin string. In addition, in the absence of the suffix bin string, the bin string for the dec_abs_level[n] may be the prefix bin string.</p><p id="p-0202" num="0174">For example, the prefix bin string may be derived as described below.</p><p id="p-0203" num="0175">A prefix value prefixVal of the dec_abs_level[n] may be derived as shown in the following equation.</p><p id="p-0204" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>prefixVal=Min(<i>c</i>Max,<i>dec</i>_abs_level[<i>n</i>])&#x2003;&#x2003;[Equation 15]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0205" num="0176">A prefix of the bin string (i.e., a prefix bin string) of the dec_abs_level[n] may be derived through a TR binarization process for the prefixVal, in which the cMax and the cRiceParam are used as an input.</p><p id="p-0206" num="0177">If the prefix bin string is identical to a bit string in which all bits are 1 and a bit length is 6, a suffix bin string of the bin string of the dec_abs_level[n] may exist, and may be derived as described below.</p><p id="p-0207" num="0178">The rice parameter deriving process for the dec_abs_level[n] may be as follows.</p><p id="p-0208" num="0179">An input of the rice parameter deriving process may be a colour component index cIdx, a luma position (x0, y0), a current coefficient scan position (xC, yC), log 2TbWidth as a binary logarithm of a width of a transform block, and log 2TbHeight as a binary logarithm of a height of the transform block. The luma position (x0, y0) may indicate a top-left sample of a current luma transform block based on a top-left luma sample of a picture. In addition, an output of the rice parameter deriving process may be the rice parameter cRiceParam.</p><p id="p-0209" num="0180">For example, a variable locSumAbs may be derived similarly to a pseudo code disclosed in the following table, based on an array AbsLevel[x][y] for a transform block having the given component index cIdx and the top-left luma position (x0, y0).</p><p id="p-0210" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 14</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>locSumAbs = 0</entry></row><row><entry/><entry>if( xC &#x3c; (1 &#x3c;&#x3c; log2TbWidth) &#x2212; 1 ) {</entry></row><row><entry/><entry>&#x2003;locSumAbs += AbsLevel[ xC + 1 ][ yC ]</entry></row><row><entry/><entry>&#x2003;if( xC &#x3c; (1 &#x3c;&#x3c; log2TbWidth) &#x2212; 2 )</entry></row><row><entry/><entry>&#x2003;&#x2003;locSumAbs += AbsLevel[ xC + 2 ][ yC ]</entry></row><row><entry/><entry>&#x2003;if( yC &#x3c; (1 &#x3c;&#x3c; log2TbHeight) &#x2212; 1 )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="161pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;&#x2003;locSumAbs += AbsLevel[ xC + 1 ][ yC + 1 ]</entry><entry>(1532)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><tbody valign="top"><row><entry/><entry>}</entry></row><row><entry/><entry>if( yC &#x3c; (1 &#x3c;&#x3c; log2TbHeight) &#x2212; 1 ) {</entry></row><row><entry/><entry>&#x2003;locSumAbs += AbsLevel[ xC ][ yC + 1 ]</entry></row><row><entry/><entry>&#x2003;if( yC &#x3c; (1 &#x3c;&#x3c; log2TbHeight) &#x2212; 2 )</entry></row><row><entry/><entry>&#x2003;&#x2003;locSumAbs += AbsLevel[ xC ][ yC + 2 ]</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>locSumAbs = Clip3( 0, 31, locSumAbs &#x2212; baseLevel * 5)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0211" num="0181">Then, based on the given variable locSumAbs, the rice parameter cRiceParam may be derived as shown in the following table.</p><p id="p-0212" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="17"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="14pt" align="center"/><colspec colname="3" colwidth="14pt" align="center"/><colspec colname="4" colwidth="14pt" align="center"/><colspec colname="5" colwidth="14pt" align="center"/><colspec colname="6" colwidth="14pt" align="center"/><colspec colname="7" colwidth="14pt" align="center"/><colspec colname="8" colwidth="14pt" align="center"/><colspec colname="9" colwidth="14pt" align="center"/><colspec colname="10" colwidth="14pt" align="center"/><colspec colname="11" colwidth="14pt" align="center"/><colspec colname="12" colwidth="14pt" align="center"/><colspec colname="13" colwidth="14pt" align="center"/><colspec colname="14" colwidth="14pt" align="center"/><colspec colname="15" colwidth="14pt" align="center"/><colspec colname="16" colwidth="14pt" align="center"/><colspec colname="17" colwidth="14pt" align="center"/><thead><row><entry namest="1" nameend="17" rowsep="1">TABLE 15</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>locSumAbs</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry><entry>5</entry><entry>6</entry><entry>7</entry><entry>8</entry><entry>9</entry><entry>10</entry><entry>11</entry><entry>12</entry><entry>13</entry><entry>14</entry><entry>15</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row><row><entry>cRiceParam</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>1</entry><entry>2</entry><entry>2</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row><row><entry>locSumAbs</entry><entry>16</entry><entry>17</entry><entry>18</entry><entry>19</entry><entry>20</entry><entry>21</entry><entry>22</entry><entry>23</entry><entry>24</entry><entry>25</entry><entry>26</entry><entry>27</entry><entry>28</entry><entry>29</entry><entry>30</entry><entry>31</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row><row><entry>cRiceParam</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>3</entry><entry>3</entry><entry>3</entry><entry>3</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0213" num="0182">Also, for example, in the rice parameter derivation process for dec_abs_level[n], the baseLevel may be set to 0, and the ZeroPos[n] may be derived as follows.</p><p id="p-0214" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>ZeroPos[<i>n</i>]=(<i>Q</i>State&#x3c;2?1:2)&#x3c;&#x3c;<i>c</i>RiceParam&#x2003;&#x2003;[Equation 16]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0215" num="0183">In addition, a suffix value suffixVal of the dec_abs_level[n] may be derived as shown in the following equation.</p><p id="p-0216" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>suffixVal=<i>dec</i>_abs_level[<i>n</i>]&#x2212;<i>c</i>Max&#x2003;&#x2003;[Equation 17]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0217" num="0184">A suffix bin string of the bin string of the dec_abs_level[n] may be derived through a limited EGk binarization process for the suffixVal in which k is set to cRiceParam+1, truncSuffixLen is set to 15, and maxPreExtLen is set to 11.</p><p id="p-0218" num="0185">Meanwhile, the RRC and the TSRC may have the following differences.<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0186">For example, the Rice parameter for the syntax element abs_remainder[ ] in TSRC may be derived as 1. The Rice parameter cRiceParam of the syntax element abs_remainder[ ] in RRC may be derived based on the lastAbsRemainder and the lastRiceParam as described above, but the Rice parameter cRiceParam of the syntax element abs_remainder [ ] in TSRC may be derived as 1. That is, for example, when transform skip is applied to the current block (e.g., the current TB), the Rice parameter cRiceParam for abs_remainder[ ] of the TSRC for the current block may be derived as 1.</li>        <li id="ul0002-0002" num="0187">Also, for example, referring to Table 3 and Table 4, in the RRC, abs_level_gtx_flag [n][0] and/or abs_level_gtx_flag[n][1] may be signaled, but in the TSRC, abs_level_gtx_flag[n][0], abs_level_gtx_flag[n] [1], abs_level_gtx_flag[n] [2], abs_level_gtx_flag [n] [3], and abs_level_gtx_flag[n][4] may be signaled. Here, the abs_level_gtx_flag[n][0] may be expressed as abs_level_gt1_flag or a first coefficient level flag, the abs_level_gtx_flag [n][1] may be expressed as abs_level_gt3_flag or a second coefficient level flag, the abs_level_gtx_flag[n][2] may be expressed as abs_level_gt5_flag or a third coefficient level flag, the abs_level_gtx_flag[n][3] may be expressed as abs_level_gt7_flag or a fourth coefficient level flag, and the abs_level_gtx_flag[n] [4] may be expressed as abs_level_gt9_flag or a fifth coefficient level flag. Specifically, the first coefficient level flag may be a flag for whether a coefficient level is greater than a first threshold (for example, 1), the second coefficient level flag may be a flag for whether a coefficient level is greater than a second threshold (for example, 3), the third coefficient level flag may be a flag for whether a coefficient level is greater than a third threshold (for example, 5), the fourth coefficient level flag may be a flag for whether a coefficient level is greater than a fourth threshold (for example, 7), the fifth coefficient level flag may be a flag for whether a coefficient level is greater than a fifth threshold (for example, 9). As described above, in the TSRC, compared to the RRC, abs_level_gtx_flag[n][0], abs_level_gtx_flag[n] [1], and abs_level_gtx_flag[n][2], abs_level_gtx_flag[n][3], abs_level_gtx_flag[n][4] may be further included.</li>        <li id="ul0002-0003" num="0188">Also, for example, in the RRC, the syntax element coeff_sign_flag may be bypass coded, but in the TSRC, the syntax element coeff_sign_flag may be bypass coded or context coded.</li>        <li id="ul0002-0004" num="0189">Also, for example, when the context-coded bin for the current block is exhausted, in the RRC, it may be coded as the syntax element dec_abs_level, but in the TSRC, it may be coded as a syntax element abs remainder.</li>        <li id="ul0002-0005" num="0190">Also, for example, the order of parsing transform coefficients of the RRC may be parsed in a promised order in the bottom right-top left direction based on the last non-zero coefficient, but in the case of the TSRC, it may be parsed in a promised order in the upper left-bottom right direction, and the position of the last non-zero coefficient may be omitted.</li>        <li id="ul0002-0006" num="0191">Also, for example, in the RRC, a dependent quantization (DQ) or a sign data hiding method (SDH) method may be applied, but in the TSRC, dependent quantization and sign data hiding methods may not be used.</li>    </ul>    </li></ul></p><p id="p-0219" num="0192">Also, a sign data hiding (SDH) method may be proposed in relation to residual coding. The sign data hiding method may be as follows.</p><p id="p-0220" num="0193">In deriving the transform coefficient, the sign of the transform coefficient may be derived based on a 1-bit sign flag (the above-described syntax element coeff_sign_flag). In this regard, SDH may indicate a technique for omitting explicit signaling of coeff_sign_flag for the first significant transform coefficient in a sub-block/coefficient group (CG) in order to improve coding efficiency. Here, the value of coeff_sign_flag for the first significant transform coefficient may be derived based on the sum of absolute levels (i.e., absolute values) of the significant transform coefficients in the corresponding sub-block/coefficient group. That is, the sign of the first significant transform coefficient may be derived based on the sum of absolute levels of the significant transform coefficients in the corresponding sub-block/coefficient group. Meanwhile, the significant transform coefficient may refer to a non-zero transform coefficient whose (absolute) value is not 0. For example, when the sum of absolute levels for the significant transform coefficients is even, the value of coeff_sign_flag for the first significant transform coefficient may be derived as 1, while, when the sum of absolute levels for the significant transform coefficients is odd, the value of coeff_sign_flag for the first significant transform coefficient may be derived as 0. In other words, for example, when the sum of absolute levels for the significant transform coefficients is even, the sign for the first significant transform coefficient may be derived as a negative value, while, when the sum of absolute levels for the significant transform coefficients is odd, the sign for the first significant transform coefficient may be derived as a positive value. Alternatively, for example, when the sum of absolute levels for the significant transform coefficients is even, the value of coeff_sign_flag for the first significant transform coefficient may be derived as 0, while, when the sum of absolute levels for the significant transform coefficients is odd, the value of coeff_sign_flag for the first significant transform coefficient may be derived as 1. In other words, for example, when the sum of absolute levels for the significant transform coefficients is even, the sign for the first significant transform coefficient may be derived as a positive value, while, when the sum of absolute levels for the significant transform coefficients is odd, the sign for the first significant transform coefficient may be derived as a negative value.</p><p id="p-0221" num="0194">For example, the SDH in the residual syntax may be expressed as shown in the following table.</p><p id="p-0222" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 16</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>}</entry></row><row><entry>signHiddenFlag = sh_sign_data_hiding_used_flag &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;( lastSigScanPosSb &#x2212; firstSigScanPosSb &#x3e; 3 ? 1 : 0 )</entry></row><row><entry>for( n = numSbCoeff &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry></row><row><entry>&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ][ 0 ]</entry></row><row><entry>&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ][ 1 ]</entry></row><row><entry>&#x2003;if( ( AbsLevel[ xC ][ yC ] &#x3e; 0 ) &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;( !signHiddenFlag || ( n != firstSigScanPosSb ) ) )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="168pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;coeff_sign_flag[ n ]</entry><entry>ae(v)</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0223" num="0195">Referring to Table 16, the variable signHiddenFlag may indicate whether the SDH is applied. The variable signHiddenFlag may be also called signHidden. For example, when the value of the variable signHiddenFlag is 0, the variable signHiddenFlag may indicate that the SDH is not applied, while, when the value of the variable signHiddenFlag is 1, the variable signHiddenFlag may indicate that the SDH is applied. For example, the value of the variable signHiddenFlag may be set based on signaled flag information (e.g., sh_sign_data_hiding_used_flag or pic_sign_data_hiding_enabled_flag or sps_sign_data_hiding_enabled_flag). Also, for example, the value of the variable signHiddenFlag may be set based on lastSigScanPosSb and firstSigScanPosSb. Here, lastSigScanPosSb may indicate the position of the last significant transform coefficient searched in the corresponding sub-block/coefficient group according to the scan order, and firstSigScanPosSb may indicate a position of a first significant transform coefficient searched in a corresponding sub-block/coefficient group according to a scan order. In general, lastSigScanPosSb may be located in a relatively high frequency component region than firstSigScanPosSb. Accordingly, when lastSigScanPosSb&#x2212;firstSigScanPosSb is greater than a predetermined threshold, the signHidden value may be derived as 1 (that is, SDH is applied), while otherwise the signHidden value may be derived as 0 (that is, SDH is not applied). Here, for example, referring to Table 35, the threshold value may be set to 3.</p><p id="p-0224" num="0196">In addition, referring to Table 16, even if the value of signHiddenFlag is 0 (i.e., !signHiddenFlag), if the current coefficient is not the first significant coefficient in the (sub)block according to the scan order (i.e., n!=firstSigScanPosSb), then the coeff_sign_flag[n] for the current coefficient may be explicitly signaled.</p><p id="p-0225" num="0197">Also, referring to Table 16, if the value of signHiddenFlag is 1, and the current coefficient is the first significant coefficient in the (sub)block according to the scan order (i.e., n=first SigScanPosSb), then explicit signaling of coeff_sign_flag[n] for the current coefficient may be omitted. In this case, the value of coeff_sign_flag[n] for the current coefficient (i.e., the first significant coefficient) may be derived as follows. For example, the value of coeff_sign_flag[n] for the first significant coefficient may be derived based on coeff_sign_flag[n] values for the significant coefficients in the corresponding (sub) block. For example, when the sum of coeff_sign_flag[n] values for the significant coefficients is even, coeff_sign_flag[n] for the first significant coefficient may be derived as 1, while, when the sum of coeff_sign_flag[n] values for the remaining significant coefficients except for the first significant coefficient is odd, coeff_sign_flag[n] for the first significant coefficient may be derived as 0. Alternatively, when the sum of coeff_sign_flag[n] values for the significant coefficients is even, coeff_sign_flag[n] for the first significant coefficient may be derived as 0, while, when the sum of coeff_sign_flag[n] values for the significant coefficients is odd, coeff_sign_flag[n] for the first significant coefficient may be derived as 1.</p><p id="p-0226" num="0198">Meanwhile, if in high-level syntax (VPS, SPS, PPS, slice header syntax, etc.) or low-level syntax (slice data syntax, coding unit syntax, transformation unit syntax, etc.), the above-described sign data hiding is activated, and if the sh_ts_residual_coding_disabled_flag is 1, then the sign data hiding process of RRC may be used in lossless coding. Accordingly, the lossless coding may become impossible due to incorrect settings in the encoding apparatus. Alternatively, if loss coding (that is, an irreversible coding method) other than lossless coding is applied, and the residual signal to which the transform skip has been applied is coded with RRC while at the same time BDPCM is applied, then the BDPCM may be subjected to coding loss because SDH is performed in accordance with the SDH application condition, despite the fact that the interval in which the residual value becomes 0 occurs more frequently than in the general case due to the difference between the residuals. Specifically, for example, if significant transform coefficients (non-zero residual data) exist at positions 0 and 15 in the CG, respectively, and the values of the transform coefficients at the remaining positions in the CG are 0, then SDH may be applied to the CG according to the above-described SDH application conditions, and thus sign data (i.e., coding of a sign flag) for the first significant transform coefficient of the CG may be omitted. Accordingly, in this case, the parity of only two residual data of the CG may be adjusted in the quantization step in order to omit the sign data, and thus more coding loss may occur than in the case where SDH is not applied. Such cases may also occur in blocks to which the BDPCM is not applied, but due to the characteristics of BDPCM, the level is lowered through the difference with the neighboring residual, so disadvantageous cases may occur more frequently in applying the SDH.</p><p id="p-0227" num="0199">Accordingly, in this document, in order to prevent an unintended coding loss or malfunction caused by using together SDH and residual coding when sh_ts_residual_coding_disabled_flag=1 (that is, coding the residual samples of transform skip blocks in the current slice with the RRC), there are provided embodiments for setting a dependency/constraint between the two techniques described above.</p><p id="p-0228" num="0200">Meanwhile, as described above, the residual data coding method may include regular residual coding (RRC) and transform skip residual coding (TSRC).</p><p id="p-0229" num="0201">As shown in Table 1, the residual data coding method for the current block among the above two methods may be determined based on values of transform_skip_flag and sh_ts_residual_coding_disabled_flag. Here, the syntax element sh_ts_residual_coding_disabled_flag may indicate whether the TSRC is enabled. Accordingly, even when the transform_skip_flag indicates that transform is skipped, if sh_ts_residual_coding_disabled_flag indicates that the TSRC is not enabled, then syntax elements according to RRC with respect to the transform skip block may be signaled. That is, when the value of transform_skip_flag is 0 or the value of sh_ts_residual_coding_disabled_flag is 1, the RRC may be used, while otherwise the TSRC may be used.</p><p id="p-0230" num="0202">This document proposes as an embodiment a method in which sh_ts_residual_coding_disabled_flag is dependent on pic_sign_data_hiding_enabled_flag. For example, the syntax elements proposed in this embodiment may be as shown in the following table.</p><p id="p-0231" num="0000"><tables id="TABLE-US-00017" num="00017"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="175pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 17</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>slice header( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;picture header in slice header flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( picture header in slice header flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;picture header structure( )</entry><entry/></row><row><entry>&#x2003;(...)</entry><entry/></row><row><entry>&#x2003;if(!pic sign data hiding enabled flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;sh ts residual coding disabled flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ph lmcs enabled flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice lmcs enabled flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pic scaling list enabled flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice scaling list present flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( NumEntryPoints &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;offset len minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; NumEntryPoints; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;entry_point_offset_minus1[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( slice header extension present flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_header_extension_length</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; slice header extension length; i++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice header extension data byte[ i ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;byte alignment( )</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0232" num="0203">Here, for example, the pic_sign_data_hiding_enabled_flag may be a flag for whether the sign data hiding is enabled. For example, pic_sign_data_hiding_enabled_flag may indicate whether sign data hiding is enabled. That is, for example, pic_sign_data_hiding_enabled_flag may indicate whether sign data hiding is enabled for blocks of pictures for a sequence or picture header structure (i.e., picture_header_structure( )). For example, pic_sign_data_hiding_enabled_flag may indicate whether a sign data hiding used flag indicating whether sign data hiding is used for the current slice may be present. For example, the pic_sign_data_hiding_enabled_flag whose value is 1 may indicate that the sign data hiding is enabled, while the pic_sign_data_hiding_enabled_flag whose value is 0 may indicate that the sign data hiding is not enabled. For example, the pic_sign_data_hiding_enabled_flag whose value is 1 may indicate that a sign flag to which the sign data hiding has been applied may be present, while the pic_sign_data_hiding_enabled_flag whose value is 0 may indicate that the sign flag to which the sign data hiding has been applied is not present.</p><p id="p-0233" num="0204">According to Table 17 described above, sh_ts_residual_coding_disabled_flag may be signaled only when sign data hiding is not enabled. Additionally, when sign data hiding is enabled, sh_ts_residual_coding_disabled_flag may not be signaled, and the value of sh_ts_residual_coding_disabled_flag may be inferred to be 0 (coding the residual samples of the transform skip block in the current slice with TSRC syntax) or 1 (coding the residual samples of the transform skip block in the current slice with RRC syntax).</p><p id="p-0234" num="0205">Here, for example, the pic_sign_data_hiding_enabled_flag may be signaled as a picture header syntax or a slice header syntax. For example, when the pic_sign_data_hiding_enabled_flag is signaled as a syntax other than the picture header syntax, it may be called another name. For example, the pic_sign_data_hiding_enabled_flag may be represented as slice_sign_data_hiding_enabled_flag. Additionally, sh_ts_residual_coding_disabled_flag may be signaled as a slice header syntax, or may be signaled in a high level syntax (HLS)(e.g., SPS syntax/VPS syntax/PPS syntax/PH syntax/DPS syntax, etc.) or low level (CU/TU) other than the slice header syntax. When the residual coding method is determined by whether SDH is enabled regardless of an upper/lower relationship of signaled syntaxes or a position on the syntax, it may be interpreted as conforming to the present embodiment.</p><p id="p-0235" num="0206">Meanwhile, according to the conventional image/video coding, in high-level syntax (SPS syntax/VPS syntax/PPS syntax/DPS syntax/picture header syntax/slice header syntax, etc.) or low level (CU/TU), the SDH is enabled, and when sh_ts_residual_coding_disabled_flag is 1, the SDH in the above-described RRC may be used for lossless coding, so the lossless coding may become impossible due to an incorrect setting in the encoding apparatus. Accordingly, in this document, in order to prevent an unintended coding loss or malfunction caused by using together SDH and residual coding when sh_ts_residual_coding_disabled_flag=1 (that is, coding the residual samples of transform skip blocks in the current slice with the RRC), there is provided an embodiment in which the SDH is not used in coding the level of the transform coefficient when the value of transform_skip_flag is 1. The residual coding syntax according to the proposed embodiment may be as in the following table.</p><p id="p-0236" num="0000"><tables id="TABLE-US-00018" num="00018"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 18</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>residual_coding( x0, y0, log2TbWidth, log2TbHeight, cIdx ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( sps_mts_enabled_flag &#x26;&#x26; cu_sbt_flag &#x26;&#x26; cIdx = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2TbWidth = = 5 &#x26;&#x26; log2TbHeight &#x3c; 6 )</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTb Width = 4</entry><entry/></row><row><entry>&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbWidth = Min( log2TbWidth, 5 )</entry><entry/></row><row><entry>&#x2003;if( sps_mts_enabled_flag &#x26;&#x26; cu_sbt_flag &#x26;&#x26; cIdx = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2TbWidth &#x3c; 6 &#x26;&#x26; log2TbHeight = = 5 )</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbHeight = 4</entry><entry/></row><row><entry>&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbHeight = Min( log2TbHeight, 5 )</entry><entry/></row><row><entry>&#x2003;if( log2TbWidth &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_x_prefix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( log2TbHeight &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_y_prefix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( last sig coeff x prefix &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_x_suffix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( last sig coeff y prefix &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_y_suffix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;log2TbWidth = log2ZoTbWidth</entry><entry/></row><row><entry>&#x2003;log2TbHeight = log2ZoTbHeight</entry><entry/></row><row><entry>&#x2003;remBinsPass1 = ( ( 1 &#x3c;&#x3c; ( log2TbWidth + log2TbHeight)) * 7 ) &#x3e;&#x3e; 2</entry><entry/></row><row><entry>&#x2003;log2SbW = (Min( log2TbWidth, log2TbHeight) &#x3c; 2 ? 1 : 2 )</entry><entry/></row><row><entry>&#x2003;log2SbH = log2SbW</entry><entry/></row><row><entry>&#x2003;if( log2TbWidth + log2TbHeight &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( log2TbWidth &#x3c; 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbW = log2TbWidth</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbH = 4 &#x2212; log2SbW</entry><entry/></row><row><entry>&#x2003;&#x2003;} else if( log2TbHeight &#x3c; 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbH = log2TbHeight</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbW = 4 &#x2212; log2SbH</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;numSbCoeff = 1 &#x3c;&#x3c; (log2SbW + log2SbH)</entry><entry/></row><row><entry>&#x2003;lastScanPos = numSbCoeff</entry><entry/></row><row><entry>&#x2003;lastSubBlock = ( 1 &#x3c;&#x3c; (log2TbWidth + log2TbHeight &#x2212; (log2SbW + log2Sb</entry><entry/></row><row><entry>H ) ) ) &#x2212; 1</entry><entry/></row><row><entry>&#x2003;do {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( lastScanPos = = 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;lastScanPos = numSbCoeff</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;lastSubBlock&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;lastScanPos&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;xS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[ lastSubBlock ][ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;yS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[ lastSubBlock ][ 1 ]</entry><entry/></row><row><entry>&#x2003;xC = (xS &#x3c;&#x3c; log2SbW) + DiagScanOrder[ log2SbW ][ log2SbH ] [ lastScanPos ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;yC = (yS &#x3c;&#x3c; log2SbH) + DiagScanOrder[ log2SbW ][ log2SbH ][ lastScanPos ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;} while( (xC != LastSignificantCoeffX) | | (yC != LastSignificantCoeffY)</entry><entry/></row><row><entry>)</entry><entry/></row><row><entry>&#x2003;if( lastSubBlock = = 0 &#x26;&#x26; log2TbWidth &#x3e;= 2 &#x26;&#x26; log2TbHeight &#x3e;= 2 &#x26;</entry><entry/></row><row><entry>&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;!transform skip flag[ x0 ][ y0 ][ cIdx ] &#x26;&#x26; lastScanPos &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;LfnstDcOnly = 0</entry><entry/></row><row><entry>&#x2003;if( (lastSubBlock &#x3e; 0 &#x26;&#x26; log2TbWidth &#x3e;= 2 &#x26;&#x26; log2TbHeight &#x3e;= 2 ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;(lastScanPos &#x3e; 7 &#x26;&#x26; (log2TbWidth = = 2 | | log2TbWidth = = 3 ) &#x26;</entry><entry/></row><row><entry>&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2TbWidth = = log2TbHeight ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;LfstZeroOutSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;if( (lastSubBlock &#x3e; 0 | | lastScanPos &#x3e; 0 ) &#x26;&#x26; cIdx = = 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;MtsDcOnly = 0</entry><entry/></row><row><entry>&#x2003;QState = 0</entry><entry/></row><row><entry>&#x2003;for( i = lastSubBlock; i &#x3e;= 0; i&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;startQStateSb = Q State</entry><entry/></row><row><entry>&#x2003;&#x2003;xS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[ i ][ 0]</entry><entry/></row><row><entry>&#x2003;yS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[ i ][ 1 ]</entry><entry/></row><row><entry>&#x2003;inferSbDcSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;if( i &#x3c; lastSubBlock &#x26;&#x26; i &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;coded_sub_block_flag[ xS ][ yS ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;inferSbDcSigCocfFlag = 1</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( coded_sub_block_flag[ xS ][ yS ] &#x26;&#x26; ( xS &#x3e; 3 | | yS &#x3e; 3 ) &#x26;&#x26; cIdx</entry><entry/></row><row><entry>= = 0)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;MtsZeroOutSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;firstSigScanPosSb = numSbCoeff</entry><entry/></row><row><entry>&#x2003;&#x2003;lastSigScanPosSb = &#x2212;1</entry><entry/></row><row><entry>&#x2003;&#x2003;firstPosMode0 = (i = = lastSubBlock ? lastScanPos : numSbCoeff &#x2212; 1)</entry><entry/></row><row><entry>&#x2003;&#x2003;firstPosMode1 = firstPosMode0</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = firstPosMode0; n &#x3e;= 0 &#x26;&#x26; remBinsPass1 &#x3e;= 4; n&#x2212; &#x2212; ){</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if(coded_sub_block_flag[ xS ][ yS ] &#x26;&#x26; (n &#x3e; 0 | | !inferSbDcSigCoeffFlag)</entry><entry/></row><row><entry>&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(xC != LastSignificantCoeffX | | yC != Last SignificantCoeffY ) ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sig_coeff_flag[ xC ][ yC ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( sig_coeff_flag[ xC ][ yC ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;inferSbDcSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sig_coeff_flag[ xC ][ yC ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_flag[ n ][ 0 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( abs_level_gtx_flag[ n ][ 0 ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;par_level_flag[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_flag[ n ][ 1 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( lastSigScanPosSb = = &#x2212;1)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;lastSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;AbsLevelPassl[ xC ][ yC ] = sig_coeff_flag[ xC ][ yC ] + par_level_flag</entry><entry/></row><row><entry>[ n ] +</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx flag[ n ][ 0 ] + 2 * abs_level_gtx flag [ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_dep_quant_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState = QStateTransTable[ QState ][ AbsLevelPass1[ xC ][ yC ] &#x26; 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;firstPosModel = n &#x2212; 1</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = firstPosMode0; n &#x3e; firstPosMode1; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( abs_level_gtx_flag[ n ][ 1 ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs remainder[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;AbsLevel[ xC ][ yC ] = AbsLevelPass1[ xC ][ yC ] +2 * abs remainder[ n ]</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = firstPosMode 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( coded_sub_block_flag[ xS ][ yS ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;dec_abs_level[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( AbsLevel )[ xC ][ yC ] &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( lastSigScanPosSb = = &#x2212;1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;lastSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_dep quant enabled flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState = QStateTransTable[ QState ][ AbsLevel[ xC ][ yC ] &#x26; 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( ph_dep_quant_enabled_flag | | !pic_sign_data_hiding_enabled_flag | | </entry><entry/></row><row><entry>transform_skip_flag[x0][y0][cIdx] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;signHidden = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;signHidden = (lastSigScanPosSb &#x2212; FirstSigScanPosSb &#x3e; 3 ? 1 : 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = numSbCoeff &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( (AbsLevel[ xC ][ yC ] &#x3e; 0 ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( !signHidden | | (n != firstSigScanPosSb ) ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;coeff_sign_flag[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( ph_dep_quant_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;QState = startQStateSb</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( n = numSbCoeff &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;xC = (xS &#x3c;&#x3c; log2SbW) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;yC = (yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( AbsLevel[ xC ][ yC ] &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ] [ y0 ] [ cIdx ] [ xC ] [ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(2 * AbsLevel[ xC ][ yC ] &#x2212; ( QState &#x3e; l ? 1 : 0 ) ) *</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( 1 &#x2212; 2 * coeff sign flag[ n ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState = QStateTransTable[ QState ][ AbsLevel[ xC ][yC ] &#x26; 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;} else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sumAbsLevel = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( n = numSbCoeff &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;xC = (xS &#x3c;&#x3c; log2SbW) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;yC = (yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( AbsLevel[ xC ][ yC ] &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AbsLevel[ xC ][ yC ] * ( 1 &#x2212; 2 * coeff sign flag[ n ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( signHidden ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sumAbsLevel += AbsLevel[ xC ][ yC ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( (n = = firstSigScanPosSb ) &#x26;&#x26; ( sumAbsLevel % 2 ) = = 1)</entry><entry/></row><row><entry>)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2212;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0237" num="0207">Referring to Table 18 described above, a variable signHidden indicating whether the SDH is applied may be derived based on a value of transform_skip_flag. For example, when the value of transform_skip_flag is 1, the value of signHidden may be derived as 0. That is, for example, when the value of transform_skip_flag is 1, the SDH may not be applied in deriving the sign of the transform coefficient of the current block.</p><p id="p-0238" num="0208">Additionally, in this document, in order to prevent an unintended coding loss or malfunction caused by using together SDH and residual coding when sh_ts_residual_coding_disabled_flag=1 (that is, coding the residual samples of transform skip blocks in the current slice with the RRC), there is provided an embodiment in which the SDH is not used in coding the level of the transform coefficient when the value of BdpcmFlag is 1. The residual coding syntax according to the proposed embodiment may be as in the following table.</p><p id="p-0239" num="0000"><tables id="TABLE-US-00019" num="00019"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 19</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>residual coding( x0, y0, log2TbWidth, log2TbHeight, cIdx ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( sps_mts_enabled_flag &#x26;&#x26; cu_sbt_flag &#x26;&#x26; cIdx = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2TbWidth = = 5 &#x26;&#x26; log2TbHeight &#x3c; 6 )</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbWidth = 4</entry><entry/></row><row><entry>&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbWidth = Min( log2TbWidth, 5 )</entry><entry/></row><row><entry>&#x2003;if( sps_mts_enabled_flag &#x26;&#x26; cu_sbt_flag &#x26;&#x26; cIdx = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2TbWidth &#x3c; 6 &#x26;&#x26; log2TbHeight = = 5 )</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbHeight = 4</entry><entry/></row><row><entry>&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;log2ZoTbHeight = Min( log2TbHeight, 5 )</entry><entry/></row><row><entry>&#x2003;if( log2TbWidth &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_x_prefix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( log2TbHeight &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_y_prefix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( last_sig_coeff_x_prefix &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_x_suffix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;if( last_sig_coeff_y_prefix &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;last_sig_coeff_y_suffix</entry><entry>ae(v)</entry></row><row><entry>&#x2003;log2TbWidth = log2ZoTbWidth</entry><entry/></row><row><entry>&#x2003;log2TbHeight = log2ZoTbHeight</entry><entry/></row><row><entry>&#x2003;remBinsPass1 = ( ( 1 &#x3c;&#x3c; (log2TbWidth + log2TbHeight )) * 7 ) &#x3e;&#x3e; 2</entry><entry/></row><row><entry>&#x2003;log2SbW = ( Min( log2TbWidth, log2TbHeight) &#x3c; 2 ? 1 : 2 )</entry><entry/></row><row><entry>&#x2003;log2SbH = log2SbW</entry><entry/></row><row><entry>&#x2003;if( log2TbWidth + log2TbHeight &#x3e; 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( log2TbWidth &#x3c; 2) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbW = log2TbWidth</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbH = 4 &#x2212; log2SbW</entry><entry/></row><row><entry>&#x2003;&#x2003;} else if( log2TbHeight &#x3c; 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbH = log2TbHeight</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2SbW = 4 &#x2212; log2SbH</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;numSbCoeff = 1 &#x3c;&#x3c; ( log2SbW + log2SbH )</entry><entry/></row><row><entry>&#x2003;lastScanPos = numSbCoeff</entry><entry/></row><row><entry>&#x2003;lastSubBlock = ( 1 &#x3c;&#x3c; (log2TbWidth + log2TbHeight &#x2212; ( log2SbW + log2Sb</entry><entry/></row><row><entry>H ) ) ) &#x2212; 1</entry><entry/></row><row><entry>&#x2003;do {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( lastScanPos = = 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;lastScanPos = numSbCoeff</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;lastSubBlock&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;lastScanPos&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;xS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[ lastSubBlock ][ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;yS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[ lastSubBlock ][ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ lastScan</entry><entry/></row><row><entry>Pos ][ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ lastScan</entry><entry/></row><row><entry>Pos ][ 1 ]</entry><entry/></row><row><entry>&#x2003;} while( ( xC != LastSignificantCoeffX) | | ( yC != LastSignificantCoeffY )</entry><entry/></row><row><entry>)</entry><entry/></row><row><entry>&#x2003;if( lastSubBlock = = 0 &#x26;&#x26; log2TbWidth &#x3e;= 2 &#x26;&#x26; log2TbHeight &#x3e;= 2 &#x26;</entry><entry/></row><row><entry>&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;!transform_skip_flag| x0 | | y0 | | cIdx | &#x26;&#x26; lastScanPos &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;LfnstDcOnly = 0</entry><entry/></row><row><entry>&#x2003;if( ( lastSubBlock &#x3e; 0 &#x26;&#x26; log2TbWidth &#x3e;= 2 &#x26;&#x26; log2TbHeight &#x3e;= 2 ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( lastScanPos &#x3e; 7 &#x26;&#x26; (log2TbWidth = = 2 | | log2TbWidth = = 3 ) &#x26;</entry><entry/></row><row><entry>&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;log2TbWidth = = log2TbHeight ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;LfhstZeroOutSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;if( (lastSubBlock &#x3e; 0 | | lastScanPos &#x3e; 0 ) &#x26;&#x26; cIdx = = 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;MtsDcOnly = 0</entry><entry/></row><row><entry>QState = 0</entry><entry/></row><row><entry>for( i = lastSubBlock; i &#x3e;= 0; i&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;startQStateSb = QState</entry><entry/></row><row><entry>&#x2003;&#x2003;xS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[ i ][ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;yS = DiagScanOrder[ log2TbWidth &#x2212; log2SbW ][ log2TbHeight &#x2212; log2SbH ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[ i ][ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;inferSbDcSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;if( i &#x3c; lastSubBlock &#x26;&#x26; i &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;coded_sub_block_flag[ xS ][ yS ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;inferSbDcSigCocfFlag = 1</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( coded_sub_block_flag[xS][yS] &#x26;&#x26; (xS &#x3e;3 | | yS &#x3e; 3 ) &#x26;&#x26; cIdx</entry><entry/></row><row><entry>= = 0)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;MtsZeroOutSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;firstSigScanPosSb = numSbCoeff</entry><entry/></row><row><entry>&#x2003;&#x2003;lastSigScanPosSb = &#x2212;1</entry><entry/></row><row><entry>&#x2003;&#x2003;firstPosMode0 = (i = = lastSubBlock ? lastScanPos : numSbCoeff &#x2212; 1)</entry><entry/></row><row><entry>&#x2003;&#x2003;firstPosMode1 = firstPosMode0</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = firstPosMode0; n &#x3e;= 0 &#x26;&#x26; remBinsPassl &#x3e;= 4; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if(coded_sub_block_flag[ xS ][ yS ] &#x26;&#x26; (n &#x3e; 0 | | !inferSbDcSigCoeffFlag)</entry><entry/></row><row><entry>&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(xC != LastSignificantCoefX | | yC != Last SignificantCoeffY ) ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sig_coeff_flag[ xC ][ yC ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( sig_coeff_flag[ xC ][ yC ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;inferSbDcSigCoeffFlag = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if sig coeff flag[ xC ][ yC ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_flag[ n ][ 0 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212; </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( abs_level_gtx_flag[ n ][ 0 ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;par_level_flag[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs level gtx flag n II 1 ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212; &#x2212;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( lastSigScanPosSb = = &#x2212;1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;lastSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;AbsLevelPass1[ xC ][ yC ] = sig_coeff_flag[ xC ][ yC ] + par_level_flag</entry><entry/></row><row><entry>[ n ] +</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx flag[ n ][ 0 ] + 2 * abs level_gtx flag[ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph dep quant enabled flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState = QStateTransTable[ QState ][ AbsLevelPass1] xC ][ yC ] &#x26; 1]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;firstPosModel = n &#x2212; 1</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = firstPosMode0; n &#x3e; firstPosMode1; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( abs level gtx flag] n ][ 1] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs_remainder[ n ]</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;AbsLevel[ xC ][ yC ] = AbsLevelPass1[ xC ][ yC ] +2 * abs remainder[ n ]</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = firstPosMode1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( coded sub block flag[ xS ][ yS ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;dec_abs_level| n |</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( AbsLevel[ xC ][ yC ] &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( lastSigScanPosSb = = &#x2212;1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;lastSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstSigScanPosSb = n</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_dep_quant_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState = QStateTransTable[ QState ][ AbsLevel[ xC ][ yC ] &#x26; 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( ph_dep_quant_enabled_flag | | !pic_sign_data_hiding_enabled_flag | | </entry><entry/></row><row><entry>BdpcmFlag[ x0 ][ y0 ][ cIdx ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;signHidden = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;signHidden = ( lastSigScanPosSb &#x2212; FirstSigScanPosSb &#x3e; 3 ? 1 : 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;for( n = numSbCoef &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;yC = ( yS &#x3c;&#x3c; log2SbH) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( (AbsLevel[ xC ] [ yC ] &#x3e; 0 ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( !signHidden | | (n != firstSigScanPosSb ) ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;coeff_sign_flag| n |</entry><entry>ae(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( ph dep quant enabled flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;Q State = startQ StateSb</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( n = numSbCoeff &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;xC = (xS &#xab; log2SbW) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;yC = (yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( AbsLevel[ xC ][ yC ] &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ][ y0 ] [ cIdx ] [ xC ] [ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( 2 * AbsLevel[ xC ][ yC ] &#x2212; ( QState &#x3e; 1 ? 1 : 0 ) ) *</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( 1 &#x2212; 2 * coeff sign flag[ n ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState = QStateTransTable[ QState ][ AbsLevel[ xC ][ yC ] &#x26; 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;} else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sumAbsLevel = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( n = numSbCoeff &#x2212; 1; n &#x3e;= 0; n&#x2212; &#x2212; ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;xC = ( xS &#x3c;&#x3c; log2SbW ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 0 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;yC = (yS &#x3c;&#x3c; log2SbH ) + DiagScanOrder[ log2SbW ][ log2SbH ][ n ]</entry><entry/></row><row><entry>[ 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( AbsLevel[ xC ][ yC ] &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AbsLevel[ xC ][ yC ] * ( 1 &#x2212; 2 * coeff sign flag[ n ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( signHidden) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sumAbsLevel += AbsLevel[ xC ][ yC ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( ( n = = firstSigScanPosSb ) &#x26;&#x26; ( sumAbsLevel % 2 ) = = 1)</entry><entry/></row><row><entry>)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ] =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2212;TransCoeffLevel[ x0 ][ y0 ][ cIdx ][ xC ][ yC ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0240" num="0209">Referring to Table 19 above, the variable signHidden indicating whether the SDH is applied may be derived based on the value of the variable BdpcmFlag indicating whether the BDPCM is applied. For example, when the value of BdpcmFlag is 1, the value of signHidden may be derived as 0. That is, for example, when the value of BdpcmFlag is 1 (when the BDPCM is applied to the current block), the SDH may not be applied in deriving the sign of the transform coefficient of the current block.</p><p id="p-0241" num="0210">Referring to Table 19, when the BdpcmFlag is 1, the SDH for the TSRC is allowed if loss coding is applied, but the SDH may not be used if the BDPCM is applied.</p><p id="p-0242" num="0211">In addition, this document proposes various embodiments related to signaling of the above-described syntax element sh_ts_residual_coding_disabled_flag.</p><p id="p-0243" num="0212">For example, as described above, since sh_ts_residual_coding_disabled_flag is a syntax element defining whether TSRC is disabled, it may not need to be signaled when the transform skip block is not used. That is, it may be meaningful to signal the sh_ts_residual_coding_disabled_flag only when the syntax element for whether the transform skip block is used indicates that the transform skip block is used.</p><p id="p-0244" num="0213">Therefore, this document proposes an embodiment in which sh_ts_residual_coding_disabled_flag is signaled only when sps_transform_skip_enabled_flag is 1. The syntax according to the present embodiment is shown in the following table.</p><p id="p-0245" num="0000"><tables id="TABLE-US-00020" num="00020"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="140pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 20</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>slice header( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>&#x2003;if(sps transform skip enabled flag)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;sh ts residual coding disabled flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0246" num="0214">Referring to Table 20, when sps_transform_skip_enabled_flag is 1, sh_ts_residual_coding_disabled_flag may be signaled, while, when sps_transform_skip_enabled_flag is 0, sh_ts_residual_coding_disabled_flag may not be signaled. Here, for example, the sps_transform_skip_enabled_flag may indicate whether a transform skip block is used. That is, for example, the sps_transform_skip_enabled_flag may indicate whether transform skip is enabled. For example, when the value of the sps_transform_skip_enabled_flag is 1, the sps_transform_skip_enabled_flag may indicate that a transform skip flag (transform_skip_flag) may be present in a transform unit syntax, while, when the value of the sps_transform_skip_enabled_flag is 0, the sps_transform_skip_enabled_flag may indicate that the transform skip flag is not present in the transform unit syntax. Meanwhile, when sh_ts_residual_coding_disabled_flag is not signaled, sh_ts_residual_coding_disabled_flag may be inferred to be 0. In addition, the above-described sps_transform_skip_enabled_flag may be signaled in the SPS, or may be signaled in a high-level syntax (VPS, PPS, picture header syntax, slice header syntax, or the like) or low-level syntax (slice data syntax, coding unit syntax, transform unit syntax, or the like) other than SPS. Also, it may be signaled before sh_ts_residual_coding_disabled_flag.</p><p id="p-0247" num="0215">Additionally, this document proposes an embodiment combining the embodiments described above in connection with signaling of sh_ts_residual_coding_disabled_flag. For example, an embodiment of signaling sh_ts_residual_coding_disabled_flag may be proposed as shown in the following table.</p><p id="p-0248" num="0000"><tables id="TABLE-US-00021" num="00021"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="161pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 21</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>slice header( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;(...)</entry><entry/></row><row><entry>&#x2003;if( !pic_sign_data_hiding_enabled_flag &#x26;&#x26;</entry><entry/></row><row><entry>sps_transform_skip_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sh ts residual coding disabled flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;(...)</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0249" num="0216">Referring to Table 21, when sps_transform_skip_enabled_flag is 1 and pic_sign_data_hiding_enabled_flag is 0, sh_ts_residual_coding_disabled_flag may be signaled, while otherwise sh_ts_residual_coding_disabled_flag may not be signaled. Meanwhile, when sh_ts_residual_coding_disabled_flag is not signaled, sh_ts_residual_coding_disabled_flag may be inferred to be 0.</p><p id="p-0250" num="0217">Alternatively, for example, an embodiment of signaling sh_ts_residual_coding_disabled_flag may be proposed as shown in the following table.</p><p id="p-0251" num="0000"><tables id="TABLE-US-00022" num="00022"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="140pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 22</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>picture header structure( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>&#x2003;ph dep quant enabled flag</entry><entry/></row><row><entry/><entry>&#x2003;if( !pic sign data hiding enabled flag ||</entry><entry/></row><row><entry/><entry>&#x2003;sps transform skip enabled flag)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;ph ts residual coding disabled flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0252" num="0218">Referring to Table 22, when pic_sign_data_hiding_enabled_flag is 0 or sps_transform_skip_enabled_flag is 1, sh_ts_residual_coding_disabled_flag may be signaled, while otherwise sh_ts_residual_coding_disabled_flag may not be signaled. Meanwhile, when sh_ts_residual_coding_disabled_flag is not signaled, sh_ts_residual_coding_disabled_flag may be inferred to be 0.</p><p id="p-0253" num="0219">Also, for example, according to this embodiment, a method of signaling the syntax elements ph_dep_quant_enabled_flag and sh_ts_residual_coding_disabled_flag in the same high-level syntax or low-level syntax may be proposed. For example, referring to Table 22 above, both ph_dep_quant_enabled_flag and sh_ts_residual_coding_disabled_flag may be signaled in the picture header syntax. In this case, the sh_ts_residual_coding_disabled_flag may be referred to as ph_ts_residual_coding_disabled_flag. Meanwhile, the ph_dep_quant_enabled_flag may be a flag indicating whether dependent quantization is enabled. For example, ph_dep_quant_enabled_flag may indicate whether dependent quantization is enabled. That is, for example, ph_dep_quant_enabled_flag may indicate whether dependent quantization is enabled for blocks of pictures in a sequence. For example, ph_dep_quant_enabled_flag may indicate whether a dependent quantization used flag indicating whether dependent quantization is used for the current slice may be present. For example, the ph_dep_quant_enabled_flag whose value is 1 may indicate that the dependent quantization is enabled, while the ph_dep_quant_enabled_flag whose value is 0 may indicate that the dependent quantization is not enabled. Also, for example, the ph_dep_quant_enabled_flag may be called sh_dep_quant_enabled_flag according to a signaled syntax.</p><p id="p-0254" num="0220">Alternatively, for example, an embodiment of signaling sh_ts_residual_coding_disabled_flag may be proposed as shown in the following table.</p><p id="p-0255" num="0000"><tables id="TABLE-US-00023" num="00023"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="161pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 23</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>picture header structure( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;(...)</entry><entry/></row><row><entry>&#x2003;ph dep quant enabled flag</entry><entry/></row><row><entry>&#x2003;if( !pic_sign_data_hiding_enabled_flag &#x26;&#x26;</entry><entry/></row><row><entry>sps_transform_skip_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_ts_residual_coding_disabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;(...)</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0256" num="0221">Referring to Table 23, when pic_sign_data_hiding_enabled_flag is 0 and sps_transform_skip_enabled_flag is 1, sh_ts_residual_coding_disabled_flag may be signaled, while otherwise sh_ts_residual_coding_disabled_flag may not be signaled. Meanwhile, when sh_ts_residual_coding_disabled_flag is not signaled, sh_ts_residual_coding_disabled_flag may be inferred to be 0. Also, for example, referring to Table 23 above, both ph_dep_quant_enabled_flag and sh_ts_residual_coding_disabled_flag may be signaled in the picture header syntax. In this case, the sh_ts_residual_coding_disabled_flag may be referred to as ph_ts_residual_coding_disabled_flag.</p><p id="p-0257" num="0222">In addition, this document proposes an embodiment in which the above-described syntax elements ph_dep_quant_enabled_flag, pic_sign_data_hiding_enabled_flag and/or sh_ts_residual_coding_disabled_flag are signaled in the same high level syntax (VPS, SPS, PPS, picture header, slice header, or the like) or low level syntax (slice data, coding unit, transform unit, or the like).</p><p id="p-0258" num="0223">For example, as shown in the following table, an embodiment in which both pic_sign_data_hiding_enabled_flag and sh_ts_residual_coding_disabled_flag are signaled in picture header syntax may be proposed.</p><p id="p-0259" num="0000"><tables id="TABLE-US-00024" num="00024"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="140pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 24</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>picture header structure( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if( sps sign data hiding enabled flag)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;pic sign data hiding enabled flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;&#x2003;if( !pic sign data hiding enabled flag)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;ph ts residual coding disabled flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0260" num="0224">In this case, the sh_ts_residual_coding_disabled_flag may be referred to as ph_ts_residual_coding_disabled_flag.</p><p id="p-0261" num="0225">According to this embodiment, a syntax element (i.e., sh_ts_residual_coding_disabled_flag) indicating whether residual coding (i.e., TSRC) for the transform skip block is enabled may be signaled only when the value of the syntax element (ie, pic_sign_data_hiding_enabled_flag) indicating whether SDH is enabled in HLS is 0. For example, referring to Table 24, pic_sign_data_hiding_enabled_flag may be signaled in picture header syntax, and when the value of pic_sign_data_hiding_enabled_flag is 0, ph_ts_residual_coding_disabled_flag may be signaled in picture header syntax. Meanwhile, for example, when the value of pic_sign_data_hiding_enabled_flag is 1, ph_ts_residual_coding_disabled_flag may not be signaled. When sh_ts_residual_coding_disabled_flag is not signaled, sh_ts_residual_coding_disabled_flag may be inferred to be 0. Also, when the value of sps_sign_data_hiding_enabled_flag is 1, pic_sign_data_hiding_enabled_flag may be signaled in picture header syntax.</p><p id="p-0262" num="0226">The embodiment according to Table 24 described above is only an example, and the two syntax elements may be signaled in high-level syntax (VPS, SPS, PPS, slice header, or the like) or low-level syntax (slice data, coding unit, transform unit, or the like) other than the picture header.</p><p id="p-0263" num="0227">Alternatively, for example, as shown in the following table, there may be provided an embodiment in which a syntax element indicating whether SDH is enabled is signaled only when the value of the syntax element indicating whether residual coding (i.e., TSRC) for the transform skip block is enabled is 0 (i.e., when TSRC is enabled).</p><p id="p-0264" num="0000"><tables id="TABLE-US-00025" num="00025"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="140pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 25</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>picture header structure( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>&#x2003;ph_ts_residual_coding_disabled_flag</entry><entry/></row><row><entry/><entry>&#x2003;if( !ph ts residual coding disabled flag )</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;pic_sign_data_hiding_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0265" num="0228">Referring to Table 25, when the value of ph_ts_residual_coding_disabled_flag is 0, pic_sign_data_hiding_enabled_flag may be signaled in the picture header syntax. Meanwhile, for example, when the value of ph_ts_residual_coding_disabled_flag is 1, pic_sign_data_hiding_enabled_flag may not be signaled. Also, for example, when pic_sign_data_hiding_enabled_flag is not signaled, pic_sign_data_hiding_enabled_flag may be inferred to be 0 in the decoding apparatus.</p><p id="p-0266" num="0229">The embodiment according to Table 25 described above is only an example, and the two syntax elements may be signaled in high-level syntax (VPS, SPS, PPS, slice header, or the like) or low-level syntax (slice data, coding unit, transform unit, or the like) other than the picture header.</p><p id="p-0267" num="0230">Alternatively, for example, methods for restricting pic_sign_data_hiding_enabled_flag and/or ph_dep_quant_enabled_flag based on ph_ts_residual_coding_disabled_flag may be proposed.</p><p id="p-0268" num="0231">For example, as shown in the following table, there may be provided an embodiment in which pic_sign_data_hiding_enabled_flag and ph_dep_quant_enabled_flag are signaled only when the value of ph_ts_residual_coding_disabled_flag is 0.</p><p id="p-0269" num="0000"><tables id="TABLE-US-00026" num="00026"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="147pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 26</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>picture header structured( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>&#x2003;ph_ts_residual_coding_disabled_flag</entry><entry/></row><row><entry/><entry>&#x2003;if( !ph ts residual coding disabled flag ) {</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;pic_sign_data_hiding_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;ph_dep_quant_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0270" num="0232">Referring to Table 26, when the value of ph_ts_residual_coding_disabled_flag is 0, pic_sign_data_hiding_enabled_flag and ph_dep_quant_enabled_flag may be signaled in picture header syntax. Meanwhile, for example, when the value of ph_ts_residual_coding_disabled_flag is 1, pic_sign_data_hiding_enabled_flag and ph_dep_quant_enabled_flag may not be signaled. Also, for example, when pic_sign_data_hiding_enabled_flag and ph_dep_quant_enabled_flag are not signaled, pic_sign_data_hiding_enabled_flag and ph_dep_quant_enabled_flag may be inferred to be 0 in the decoding apparatus.</p><p id="p-0271" num="0233">Also, for example, referring to Table 26 above, ph_ts_residual_coding_disabled_flag, pic_sign_data_hiding_enabled_flag, and ph_dep_quant_enabled_flag may all be signaled in the picture header syntax.</p><p id="p-0272" num="0234">Additionally, this document proposes an embodiment combining the embodiments described above in connection with signaling of sh_ts_residual_coding_disabled_flag. For example, an embodiment of signaling sh_ts_residual_coding_disabled_flag may be proposed as shown in the following table.</p><p id="p-0273" num="0000"><tables id="TABLE-US-00027" num="00027"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="147pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 27</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>picture header structure( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if( sps sign data hiding enabled flag )</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;pic_sign_data_hiding_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;&#x2003;if( !pic sign data hiding enabled flag | |</entry><entry/></row><row><entry/><entry>sps transform skip enabled flag )</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;ph_ts_residual_coding_disabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0274" num="0235">Referring to Table 27, when pic_sign_data_hiding_enabled_flag is 0 or sps_transform_skip_enabled_flag is 1, ph_ts_residual_coding_disabled_flag may be signaled, while otherwise ph_ts_residual_coding_disabled_flag may not be signaled. Meanwhile, when ph_ts_residual_coding_disabled_flag is not signaled, ph_ts_residual_coding_disabled_flag may be inferred to be 0 in the decoding apparatus. Also, when the value of sps_sign_data_hiding_enabled_flag is 1, pic_sign_data_hiding_enabled_flag may be signaled in picture header syntax.</p><p id="p-0275" num="0236">Alternatively, for example, an embodiment of signaling sh_ts_residual_coding_disabled_flag may be proposed as shown in the following table.</p><p id="p-0276" num="0000"><tables id="TABLE-US-00028" num="00028"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="154pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 28</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>picture header structured( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if( sps sign data hiding enabled flag)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;pic_sign_data_hiding_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;&#x2003;if( !pic_sign_data_hiding_enabled_flag &#x26;&#x26;</entry><entry/></row><row><entry/><entry>sps_transform_skip_enabled_flag )</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_ts_residual_coding_disabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0277" num="0237">Referring to Table 28, when pic_sign_data_hiding_enabled_flag is 0 and sps_transform_skip_enabled_flag is 1, ph_ts_residual_coding_disabled_flag may be signaled, while otherwise ph_ts_residual_coding_disabled_flag may not be signaled. Meanwhile, when ph_ts_residual_coding_disabled_flag is not signaled, ph_ts_residual_coding_disabled_flag may be inferred to be 0 in the decoding apparatus. Also, when the value of sps_sign_data_hiding_enabled_flag is 1, pic_sign_data_hiding_enabled_flag may be signaled in picture header syntax.</p><p id="p-0278" num="0238">Alternatively, for example, an embodiment of signaling sh_ts_residual_coding_disabled_flag may be proposed as shown in the following table.</p><p id="p-0279" num="0000"><tables id="TABLE-US-00029" num="00029"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="140pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 29</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>picture header structure( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if(sps transform skip enabled flag)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;ph ts residual coding disabled flag</entry><entry/></row><row><entry/><entry>&#x2003;if( !ph ts residual coding disabled flag)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;pic sign data hiding enabled flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0280" num="0239">Referring to Table 29, when sps_transform_skip_enabled_flag is 1, ph_ts_residual_coding_disabled_flag may be signaled, while otherwise ph_ts_residual_coding_disabled_flag may not be signaled. Also, referring to Table 29, when ph_ts_residual_coding_disabled_flag is 0, pic_sign_data_hiding_enabled_flag may be signaled, while otherwise pic_sign_data_hiding_enabled_flag may not be signaled. Meanwhile, when ph_ts_residual_coding_disabled_flag is not signaled, ph_ts_residual_coding_disabled_flag may be inferred to be 0 in the decoding apparatus. Also, when pic_sign_data_hiding_enabled_flag is not signaled, pic_sign_data_hiding_enabled_flag may be inferred to be 0 in the decoding apparatus.</p><p id="p-0281" num="0240">Alternatively, for example, an embodiment of signaling sh_ts_residual_coding_disabled_flag may be proposed as shown in the following table.</p><p id="p-0282" num="0000"><tables id="TABLE-US-00030" num="00030"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="147pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 30</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>picture header structure( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if(sps transform skip enabled flag)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;ph_ts_residual_coding_disabled_flag</entry><entry/></row><row><entry/><entry>&#x2003;if( !ph ts residual coding disabled flag ){</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;pic sign data hiding enabled flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;ph dep quant enabled flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;(...)</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0283" num="0241">Referring to Table 30, when sps_transform_skip_enabled_flag is 1, ph_ts_residual_coding_disabled_flag may be signaled, while otherwise ph_ts_residual_coding_disabled_flag may not be signaled. In addition, referring to Table 30, when ph_ts_residual_coding_disabled_flag is 0, pic_sign_data_hiding_enabled_flag and ph_dep_quant_enabled_flag may be signaled, while otherwise pic_sign_data_hiding_enabled_flag and ph_dep_quant_enabled_flag may not be signaled. Meanwhile, when ph_ts_residual_coding_disabled_flag is not signaled, ph_ts_residual_coding_disabled_flag may be inferred to be 0 in the decoding apparatus. Also, when pic_sign_data_hiding_enabled_flag and ph_dep_quant_enabled_flag are not signaled, pic_sign_data_hiding_enabled_flag and ph_dep_quant_enabled_flag may be inferred to be 0 in the decoding apparatus.</p><p id="p-0284" num="0242">Meanwhile, as described above, the information (syntax element) in the syntax table disclosed in this document may be included in the image/video information, and may be configured/encoded in the encoding apparatus and transmitted to the decoding apparatus in the form of a bitstream. The decoding apparatus may parse/decode information (syntax element) in the corresponding syntax table. The decoding apparatus may perform a block/image/video reconstruction process based on the decoded information.</p><p id="p-0285" num="0243"><figref idref="DRAWINGS">FIG. <b>6</b></figref> briefly illustrates an image encoding method performed by an encoding apparatus according to the present disclosure. The method disclosed in <figref idref="DRAWINGS">FIG. <b>6</b></figref> may be performed by the encoding apparatus disclosed in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Specifically, for example, S<b>600</b> to S<b>630</b> of <figref idref="DRAWINGS">FIG. <b>6</b></figref> may be performed by the entropy encoder of the encoding apparatus. Additionally, although not shown, the process of deriving a prediction sample for the transform skip block may be performed by a predictor of the encoding apparatus, the process of deriving a residual sample for the transform skip block based on an original sample and a prediction sample for the transform skip block may be performed by a subtractor of the encoding apparatus, and the process of generating the reconstructed sample and the reconstructed picture for the transform skip block based on the residual sample and the prediction sample for the transform skip block may be performed by the adder of the encoding apparatus.</p><p id="p-0286" num="0244">The encoding apparatus encodes a sign data hiding enabled flag for whether sign data hiding is enabled for a current slice (S<b>600</b>). The encoding apparatus may encode a sign data hiding enabled flag for whether sign data hiding is enabled for a current slice. The image information may include a sign data hiding enabled flag. For example, the encoding apparatus may determine whether sign data hiding is enabled for blocks of pictures in a sequence, an may encode a sign data hiding enabled flag for whether sign data hiding is enabled. For example, the sign data hiding enabled flag may be a flag for whether sign data hiding is enabled. For example, the sign data hiding enabled flag may indicate whether sign data hiding is enabled. That is, for example, the sign data hiding enabled flag may indicate whether sign data hiding is enabled for blocks of pictures in a sequence. For example, sign data hiding enabled flag may indicate whether a sign data hiding used flag indicating whether sign data hiding is used for the current slice may be present. For example, the sign data hiding enabled flag whose value is 1 may indicate that the sign data hiding is enabled, while the sign data hiding enabled flag whose value is 0 may indicate that the sign data hiding is not enabled. For example, the sign data hiding enabled flag whose value is 1 may indicate that a sign flag to which the sign data hiding has been applied may be present, while the sign data hiding enabled flag whose value is 0 may indicate that a sign flag to which the sign data hiding has been applied is not present. Also, for example, the sign data hiding enabled flag may be signaled in a sequence parameter set (SPS) syntax. Alternatively, for example, the sign data hiding enabled flag may be signaled in a picture header syntax or a slice header syntax. The syntax element of the sign data hiding enabled flag may be the above-described sps_sign_data_hiding_enabled_flag.</p><p id="p-0287" num="0245">The encoding apparatus encodes a Transform Skip Residual Coding (TSRC) enabled flag for whether TSRC is enabled for a transform skip block in the current slice based on the sign data hiding enabled flag (S<b>610</b>). The image information may include a TSRC enabled flag.</p><p id="p-0288" num="0246">For example, the encoding apparatus may encode the TSRC enabled flag based on the sign data hiding enabled flag. For example, the TSRC enabled flag may be encoded based on the sign data hiding enabled flag whose value is 0. That is, for example, when the value of the sign data hiding enabled flag is 0 (i.e., when the sign data hiding enabled flag indicates that sign data hiding is not enabled), the TSRC enabled flag may be encoded. In other words, for example, when the value of the sign data hiding enabled flag is 0 (i.e., when the sign data hiding enabled flag indicates that sign data hiding is not enabled), the TSRC enabled flag may be signaled. Also, for example, when the value of the sign data hiding enabled flag is 1, the TSRC enabled flag may not be encoded, and the value of the TSRC enabled flag may be derived as 0 in the decoding apparatus. That is, for example, when the value of the sign data hiding enabled flag is 1, the TSRC enabled flag may not be signaled, and the value of the TSRC enabled flag may be derived as 0 in the decoding apparatus.</p><p id="p-0289" num="0247">Here, for example, the TSRC enabled flag may be a flag for whether TSRC is enabled. That is, for example, the TSRC enabled flag may be a flag indicating whether TSRC is enabled for blocks in a slice. In other words, for example, the TSRC enabled flag may be a flag indicating whether TSRC is enabled for a transform skip block in a slice. Here, the block may be a coding block (CB) or a transform block (TB). For example, the TSRC enabled flag whose value is 1 may indicate that the TSRC is not enabled, and the TSRC enabled flag whose value is 0 may indicate that the TSRC is enabled. Also, for example, the TSRC enabled flag may be signaled in a slice header syntax. The syntax element of the TSRC enabled flag may be the above-described sh_ts_residual_coding_disabled_flag. The TSRC enabled flag may be referred to as a TSRC disabled flag.</p><p id="p-0290" num="0248">Meanwhile, for example, the encoding apparatus may determine whether dependent quantization is enabled for blocks of pictures in a sequence, and may encode a dependent quantization enabled flag for whether dependent quantization is enabled. The image information may include the dependent quantization enabled flag. For example, the dependent quantization enabled flag may be a flag for whether dependent quantization is enabled. For example, the dependent quantization enabled flag may indicate whether dependent quantization is enabled. That is, for example, the dependent quantization enabled flag may indicate whether dependent quantization is enabled for blocks of pictures in a sequence. For example, dependent quantization enabled flag may indicate whether a dependent quantization used flag indicating whether dependent quantization is used for the current slice may be present. For example, the dependent quantization enabled flag whose value is 1 may indicate that the dependent quantization is enabled, and the dependent quantization enabled flag whose value is 0 may indicate that the dependent quantization is not enabled. Also, for example, the dependent quantization enabled flag may be signaled in an SPS syntax, a slice header syntax or the like. The syntax element of the dependent quantization enabled flag may be the above-described sps_dep_quant_enabled_flag.</p><p id="p-0291" num="0249">Also, for example, the encoding apparatus may encode a transform skip enabled flag for whether transform skip is enabled for the current slice. The image information may include a transform skip enabled flag. For example, the encoding apparatus may determine whether transform skip is enabled for blocks of pictures in a sequence, and may encode a transform skip enabled flag for whether transform skip is enabled. For example, the transform skip enabled flag may be a flag for whether transform skip is enabled. For example, the transform skip enabled flag may indicate whether transform skip is enabled. That is, for example, the transform skip enabled flag may indicate whether transform skip is enabled for blocks of pictures in a sequence. For example, the transform skip enabled flag may indicate whether a transform skip flag may be present. For example, the transform skip enabled flag whose value is 1 may indicate that the transform skip is enabled, and the transform skip enabled flag whose value is 0 may indicate that the transform skip is not enabled. That is, for example, the transform skip enabled flag whose value is 1 may indicate that the transform skip flag may be present, and the transform skip enabled flag whose value is 0 may indicate that the transform skip flag is not present. Also, for example, the transform skip enabled flag may be signaled in a sequence parameter set (SPS) syntax. The syntax element of the transform skip enabled flag may be the above-described sps_transform_skip_enabled_flag.</p><p id="p-0292" num="0250">Also, for example, the TSRC enabled flag may be encoded based on the sign data hiding enabled flag and/or the transform skip enabled flag. For example, the TSRC enabled flag may be encoded based on the sign data hiding enabled flag whose value is 0, and the transform skip enabled flag whose value is 1. That is, for example, when the value of the sign data hiding enabled flag is 0 (that is, the sign data hiding enabled flag indicates that sign data hiding is not enabled), and the value of the transform skip enabled flag is 1 (that is, when the transform skip enabled flag indicates that the transform skip is enabled), the TSRC enabled flag may be encoded (or signaled). Also, for example, when the value of the transform skip enabled flag is 0, the TSRC enabled flag may not be encoded, and the value of the TSRC enabled flag may be derived as 0. That is, for example, when the value of the transform skip enabled flag is 0, the TSRC enabled flag may not be signaled, and the value of the TSRC enabled flag may be derived as 0.</p><p id="p-0293" num="0251">The encoding apparatus encodes residual information for the transform skip block based on the TSRC enabled flag (S<b>620</b>). The encoding apparatus may encode residual information for the transform skip block based on the TSRC enabled flag.</p><p id="p-0294" num="0252">For example, the encoding apparatus may determine a residual coding syntax for the transform skip block based on the TSRC enabled flag. For example, the encoding apparatus may determine a residual coding syntax for the transform skip block as one of the Regular Residual Coding (RRC) syntax and Transform Skip Residual Coding (TSRC) syntax based on the TSRC enabled flag. The RRC syntax may indicate a syntax according to RRC, and the TSRC syntax may indicate a syntax according to TSRC.</p><p id="p-0295" num="0253">For example, the residual coding syntax for the transform skip block may be determined as the regular residual coding (RRC) syntax based on the TSRC enabled flag whose value is 1. In this case, for example, a transform skip flag for whether the transform skip block is transform-skipped may be encoded, and the value of the transform skip flag may be 1. For example, the image information may include a transform skip flag for the transform skip block. The transform skip flag may indicate whether the transform skip block is transform-skipped. That is, the transform skip flag may indicate whether a transform is applied to transform coefficients of the transform skip block. The syntax element representing the transform skip flag may be the above-described transform_skip_flag. For example, when the value of the transform skip flag is 1, the transform skip flag may indicate that transform is not applied to the transform skip block (i.e., transform-skipped), while, when the value of the transform skip flag is 0, the transform skip flag may indicate that transform is applied to the transform skip block. For example, when the block in the current slice is a transform skip block, the value of the transform skip flag for the block may be 1.</p><p id="p-0296" num="0254">Also, for example, the residual coding syntax for the transform skip block may be determined as the transform skip residual coding (TSRC) syntax based on the TSRC enabled flag whose value is 0. Also, for example, the transform skip flag for whether the transform skip block is transform-skipped may be encoded, and the residual coding syntax for the transform skip block may be determined as the transform skip residual coding (TSRC) syntax based on the transform skip flag whose value is 1 and the TSRC enabled flag whose value is 0. Also, for example, the transform skip flag for whether the block is transform-skipped may be encoded, and the residual coding syntax for the block may be determined as the Regular Residual Coding (RRC) syntax based on the transform skip flag whose value is 0 and the TSRC enabled flag whose value is 0.</p><p id="p-0297" num="0255">Then, for example, the encoding apparatus may encode residual information of the determined residual coding syntax for the transform skip block. The encoding apparatus may derive a residual sample for the transform skip block, and may encode residual information of the determined residual coding syntax for the residual sample of the transform skip block. For example, residual information of the regular residual coding (RRC) syntax for the transform skip block may be encoded based on the TSRC enabled flag whose value is 1, and residual information of the TSRC syntax for the transform skip block may be encoded based on the TSRC enabled flag whose value is 0. The image information may include residual information.</p><p id="p-0298" num="0256">For example, the encoding apparatus may determine whether to perform inter prediction or intra prediction on the transform skip block, and may determine a specific inter prediction mode or a specific intra prediction mode based on RD cost. According to the determined mode, the encoding apparatus may derive the prediction samples for the transform skip block, and may derive the residual samples for the transform skip block through the subtraction of the prediction samples with the original samples for the transform skip block.</p><p id="p-0299" num="0257">Then, for example, the encoding apparatus may derive transform coefficients of the transform skip block based on the residual samples. For example, the encoding apparatus may determine whether a transform is applied to the transform skip block. That is, the encoding apparatus may determine whether a transform is applied to the residual samples of the transform skip block. The encoding apparatus may determine whether to apply the transform to the transform skip block in consideration of coding efficiency. For example, the encoding apparatus may determine that no transform is applied to the transform skip block. Meanwhile, a block to which the transform is not applied may be referred to as a transform skip block.</p><p id="p-0300" num="0258">When transform is not applied to the transform skip block, that is, when transform is not applied to the residual samples, the encoding apparatus may derive the derived residual samples as transform coefficients of the transform skip block. In addition, when transform is applied to the transform skip block, that is, when transform is applied to the residual samples, the encoding apparatus may perform transform on the residual samples to derive transform coefficients of the transform skip block. The transform skip block may include a plurality of sub-blocks or Coefficient Groups (CGs). In addition, the size of the subblock of the transform skip block may be 4&#xd7;4 size or 2&#xd7;2 size. That is, the subblock of the transform skip block may include up to 16 non-zero transform coefficients or up to 4 non-zero transform coefficients. Here, the transform skip block may be a coding block (CB) or a transform block (TB). Also, the transform coefficient may be referred to as a residual coefficient.</p><p id="p-0301" num="0259">For example, when the residual coding syntax for the transform skip block is determined as the RRC syntax, the encoding apparatus may encode residual information of the RRC syntax for the transform skip block. For example, the residual information of the RRC syntax may include the syntax elements shown in Table 2 above.</p><p id="p-0302" num="0260">For example, the residual information of the RRC syntax may include syntax elements for transform coefficients of a transform skip block. Here, the transform coefficient may be referred to as a residual coefficient.</p><p id="p-0303" num="0261">For example, the syntax elements may include syntax elements such as last_sig_coeff_x_prefix, last_sig_coeff_y_prefix, last_sig_coeff_x_suffix, last_sig_coeff_y_suffix, sb_coded_flag, sig_coeff_flag, abs_level_gt1_flag, par_level_flag, abs_level_gtX_flag, abs_remainder, dec_abs_level, and/or coeff_sign_flag.</p><p id="p-0304" num="0262">Specifically, for example, the syntax elements may include position information indicating the position of the last non-zero transform coefficient in the residual coefficient array of the transform skip block. That is, the syntax elements may include position information indicating the position of the last non-zero transform coefficient in a scanning order of the transform skip block. The position information may include information indicating a prefix of a column position of the last non-zero transform coefficient, information indicating a prefix of a row position of the last non-zero transform coefficient, information indicating a suffix of a column position of the last non-zero transform coefficient, and information indicating a suffix of a row position of the last non-zero transform coefficient. The syntax elements for the location information may be last_sig_coeff_x_prefix, last_sig_coeff_y_prefix, last_sig_coeff_x_suffix, and last_sig_coeff_y_suffix. Meanwhile, the non-zero transform coefficient may be referred to as a significant coefficient.</p><p id="p-0305" num="0263">Also, for example, the syntax elements may include a coded subblock flag indicating whether a subblock of the transform skip block includes a non-zero transform coefficient; a significant coefficient flag indicating whether the transform coefficient of the transform skip block is non-zero transform coefficient; a first coefficient level flag for whether the coefficient level for the transform coefficient is greater than a first threshold; a parity level flag for parity of the coefficient level; and/or a second coefficient level flag for whether the coefficient level of the transform coefficient is greater than a second threshold. Here, the coded sub-block flag may be sb_coded_flag or coded_sub_block_flag; the significant coefficient flag may be sig_coeff_flag; the first coefficient level flag may be abs_level_gt1_flag or abs_level_gtx_flag; the parity level flag may be par_level_flag; and the second coefficient level flag may be abs_level_gt3_flag or abs_level_gtx_flag.</p><p id="p-0306" num="0264">Also, for example, the syntax elements may include information related to the coefficient value for value of transform coefficient of the transform skip block. The coefficient value related information may be abs_remainder and/or dec_abs_level.</p><p id="p-0307" num="0265">Also, for example, the syntax elements may include a sign flag indicating a sign of the transform coefficient. The sign flag may be coeff_sign_flag.</p><p id="p-0308" num="0266">Meanwhile, for example, when the sign data hiding is applied to the transform skip block, the sign flag of the first significant transform coefficient of the current coefficient group (CG) in the transform skip block may not be encoded and signaled. That is, for example, when the sign data hiding is applied to the transform skip block, the syntax elements may not include a sign flag indicating a sign of the first significant transform coefficient. Meanwhile, for example, whether the sign data hiding is applied to the transform skip block may be derived based on the sign data hiding enabled flag, and/or the position of the first significant transform coefficient and the position of the last significant transform coefficient of the current CG of the transform skip block. For example, when the value of the sign data hiding enabled flag is 1, and the value obtained by subtracting the first significant transform coefficient position from the last significant transform coefficient position is greater than 3 (that is, when the value of the sign data hiding enabled flag is 1, and the number of significant transform coefficients in the current CG is greater than 3), the sign data hiding may be applied to the current CG of the transform skip block.</p><p id="p-0309" num="0267">Additionally, for example, when the residual coding syntax for the transform skip block is determined as the TSRC syntax, the encoding apparatus may encode residual information of the TSRC syntax for the transform skip block. For example, the residual information of the TSRC syntax may include the syntax elements shown in Table 3 above.</p><p id="p-0310" num="0268">For example, the residual information of the TSRC syntax may include syntax elements for transform coefficients of a transform skip block. Here, the transform coefficient may be referred to as a residual coefficient.</p><p id="p-0311" num="0269">For example, the syntax elements may include context coded syntax elements and/or bypass coded syntax elements for a transform coefficient. The syntax elements may include syntax elements such as sig_coeff_flag, coeff_sign_flag, abs_level_gt1_flag, par_level_flag, abs_level_gtX_flag and/or abs remainder.</p><p id="p-0312" num="0270">For example, the context-coded syntax elements for the transform coefficient may include a significant coefficient flag indicating whether the transform coefficient is a non-zero transform coefficient; a sign flag indicating a sign for the transform coefficient; a first coefficient level flag for whether the coefficient level for the transform coefficient is greater than a first threshold; and/or parity level flag for parity of the coefficient level for the transform coefficient. In addition, for example, the context-coded syntax elements may include a second coefficient level flag for whether the coefficient level of the transform coefficient is greater than a second threshold; a third coefficient level flag for whether the coefficient level of the transform coefficient is greater than a third threshold; a fourth coefficient level flag for whether the coefficient level of the transform coefficient is greater than a fourth threshold; and/or a fifth coefficient level flag for whether the coefficient level of the transform coefficient is greater than a fifth threshold. Here, the significant coefficient flag may be sig_coeff_flag; the sign flag may be coeff_sign_flag; the first coefficient level flag may be abs_level_gt1_flag; and the parity level flag may be par_level_flag. In addition, the second coefficient level flag may be abs_level_gt3_flag or abs_level_gtx_flag; the third coefficient level flag may be abs_level_gt5_flag or abs_level_gtx_flag; the fourth coefficient level flag may be abs_level_gt7_flag or abs_level_gtx_flag; and the fifth coefficient level flag may be abs_level_gt9_flag or abs_level_gtx_flag.</p><p id="p-0313" num="0271">Also, for example, the syntax elements bypass-coded for the transform coefficient may include coefficient level information for the value (or coefficient level) of the transform coefficient, and/or a sign flag indicating a sign for the transform coefficient. The coefficient level information may be abs_remainder and/or dec_abs_level, and the sign flag may be coeff_sign_flag.</p><p id="p-0314" num="0272">The encoding apparatus generates a bitstream including the sign data hiding enabled flag, the TSRC enabled flag and the residual information (S<b>630</b>). For example, the encoding apparatus may output, as a bitstream, image information including the sign data hiding enabled flag, the TSRC enabled flag, and the residual information. The bitstream may include the sign data hiding enabled flag, the TSRC enabled flag, and the residual information. In addition, the bitstream may further include the dependent quantization enabled flag and/or the transform skip enabled flag.</p><p id="p-0315" num="0273">Meanwhile, the image information may include prediction related information for the transform skip block. The prediction-related information may include prediction mode information about an inter prediction mode or an intra prediction mode performed on the transform skip block.</p><p id="p-0316" num="0274">Meanwhile, the bitstream may be transmitted to the decoding apparatus through a network or a (digital) storage medium. Here, the network may include a broadcast network, a communication network and/or the like, and the digital storage medium may include various storage media, such as a universal serial bus (USB), secure digital (SD), a compact disk (CD), a digital video disk (DVD), Blu-ray, a hard disk drive (HDD), a solid state drive (SSD), and the like.</p><p id="p-0317" num="0275"><figref idref="DRAWINGS">FIG. <b>7</b></figref> briefly illustrates an encoding apparatus for performing an image encoding method according to the present disclosure. The method disclosed in <figref idref="DRAWINGS">FIG. <b>6</b></figref> may be performed by the encoding apparatus disclosed in <figref idref="DRAWINGS">FIG. <b>7</b></figref>. Specifically, for example, the entropy encoder of the encoding apparatus of <figref idref="DRAWINGS">FIG. <b>7</b></figref> may perform S<b>600</b> to S<b>630</b> in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. Additionally, although not shown, the process of deriving a prediction sample for the transform skip block may be performed by a predictor of the encoding apparatus, the process of deriving a residual sample for the transform skip block based on an original sample and a prediction sample for the transform skip block may be performed by a subtractor of the encoding apparatus, and the process of generating the reconstructed sample and the reconstructed picture for the transform skip block based on the residual sample and the prediction sample for the transform skip block may be performed by the adder of the encoding apparatus.</p><p id="p-0318" num="0276"><figref idref="DRAWINGS">FIG. <b>8</b></figref> briefly illustrates an image decoding method performed by a decoding apparatus according to the present disclosure. The method disclosed in <figref idref="DRAWINGS">FIG. <b>8</b></figref> may be performed by the decoding apparatus disclosed in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. Specifically, for example, S<b>800</b> to S<b>820</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref> may be performed by the entropy decoder of the decoding apparatus, S<b>830</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref> may be performed by the residual processor of the decoding apparatus, and S<b>840</b> may be performed by the adder of the decoding apparatus. In addition, although not shown, the process of receiving prediction information for the transform skip block may be performed by an entropy decoder of the decoding apparatus, and the process of deriving the prediction sample of the transform skip block may be performed by the predictor of the decoding apparatus.</p><p id="p-0319" num="0277">The decoding apparatus obtains a sign data hiding enabled flag for whether sign data hiding is enabled for a current slice (S<b>800</b>). The decoding apparatus may obtain image information including the sign data hiding enabled flag through the bitstream. The image information may include the sign data hiding enabled flag. For example, the sign data hiding enabled flag may be a flag for whether sign data hiding is enabled. For example, the sign data hiding enabled flag may indicate whether sign data hiding is enabled. That is, for example, the sign data hiding enabled flag may indicate whether sign data hiding is enabled for blocks of pictures in a sequence. For example, sign data hiding enabled flag may indicate whether a sign data hiding used flag indicating whether sign data hiding is used for the current slice may be present. For example, the sign data hiding enabled flag whose value is 1 may indicate that the sign data hiding is enabled, while the sign data hiding enabled flag whose value is 0 may indicate that the sign data hiding is not enabled. For example, the sign data hiding enabled flag whose value is 1 may indicate that a sign flag to which the sign data hiding has been applied may be present, while the sign data hiding enabled flag whose value is 0 may indicate that a sign flag to which the sign data hiding has been applied is not present. Also, for example, the sign data hiding enabled flag may be signaled in a sequence parameter set (SPS) syntax. Alternatively, for example, the sign data hiding enabled flag may be signaled in a picture header syntax or a slice header syntax. The syntax element of the sign data hiding enabled flag may be the above-described sps_sign_data_hiding_enabled_flag.</p><p id="p-0320" num="0278">The decoding apparatus obtains a Transform Skip Residual Coding (TSRC) enabled flag for whether TSRC is enabled for a transform skip block in the current slice (S<b>810</b>). The image information may include a TSRC enabled flag.</p><p id="p-0321" num="0279">For example, the decoding apparatus may obtain the TSRC enabled flag based on the sign data hiding enabled flag. For example, the TSRC enabled flag may be obtained based on the sign data hiding enabled flag whose value is 0. That is, for example, when the value of the sign data hiding enabled flag is 0 (i.e., when the sign data hiding enabled flag indicates that sign data hiding is not enabled), the TSRC enabled flag may be obtained. In other words, for example, when the value of the sign data hiding enabled flag is 0 (i.e., when the sign data hiding enabled flag indicates that sign data hiding is not enabled), the TSRC enabled flag may be signaled. Also, for example, when the value of the sign data hiding enabled flag is 1, the TSRC enabled flag may not be obtained, and the value of the TSRC enabled flag may be derived as 0. That is, for example, when the value of the sign data hiding enabled flag is 1, the TSRC enabled flag may not be signaled, and the value of the TSRC enabled flag may be derived as 0.</p><p id="p-0322" num="0280">Here, for example, the TSRC enabled flag may be a flag for whether TSRC is enabled. That is, for example, the TSRC enabled flag may be a flag indicating whether TSRC is enabled for blocks in a slice. In other words, for example, the TSRC enabled flag may be a flag indicating whether TSRC is enabled for a transform skip block in a slice. Here, the block may be a coding block (CB) or a transform block (TB). For example, the TSRC enabled flag whose value is 1 may indicate that the TSRC is not enabled, and the TSRC enabled flag whose value is 0 may indicate that the TSRC is enabled. Also, for example, the TSRC enabled flag may be signaled in a slice header syntax. The syntax element of the TSRC enabled flag may be the above-described sh_ts_residual_coding_disabled_flag. The TSRC enabled flag may be referred to as a TSRC disabled flag.</p><p id="p-0323" num="0281">Meanwhile, for example, the decoding apparatus may obtain a dependent quantization enabled flag. The decoding apparatus may obtain image information including the dependent quantization enabled flag through the bitstream. The image information may include the dependent quantization enabled flag. For example, the dependent quantization enabled flag may be a flag for whether dependent quantization is enabled. For example, the dependent quantization enabled flag may indicate whether dependent quantization is enabled. That is, for example, the dependent quantization enabled flag may indicate whether dependent quantization is enabled for blocks of pictures in a sequence. For example, dependent quantization enabled flag may indicate whether a dependent quantization used flag indicating whether dependent quantization is used for the current slice may be present. For example, the dependent quantization enabled flag whose value is 1 may indicate that the dependent quantization is enabled, and the dependent quantization enabled flag whose value is 0 may indicate that the dependent quantization is not enabled. Also, for example, the dependent quantization enabled flag may be signaled in an SPS syntax, a slice header syntax or the like. The syntax element of the dependent quantization enabled flag may be the above-described sps_dep_quant_enabled_flag.</p><p id="p-0324" num="0282">Also, for example, the decoding apparatus may obtain a transform skip enabled flag. The decoding apparatus may obtain image information including the transform skip enabled flag through the bitstream. The image information may include the transform skip enabled flag. For example, the transform skip enabled flag may be a flag for whether transform skip is enabled. For example, the transform skip enabled flag may indicate whether transform skip is enabled. That is, for example, the transform skip enabled flag may indicate whether transform skip is enabled for blocks of pictures in a sequence. For example, the transform skip enabled flag may indicate whether a transform skip flag may be present. For example, the transform skip enabled flag whose value is 1 may indicate that the transform skip is enabled, and the transform skip enabled flag whose value is 0 may indicate that the transform skip is not enabled. That is, for example, the transform skip enabled flag whose value is 1 may indicate that the transform skip flag may be present, and the transform skip enabled flag whose value is 0 may indicate that the transform skip flag is not present. Also, for example, the transform skip enabled flag may be signaled in a sequence parameter set (SPS) syntax. The syntax element of the transform skip enabled flag may be the above-described sps_transform_skip_enabled_flag.</p><p id="p-0325" num="0283">Also, for example, the TSRC enabled flag may be obtained based on the sign data hiding enabled flag and/or the transform skip enabled flag. For example, the TSRC enabled flag may be obtained based on the sign data hiding enabled flag whose value is 0, and the transform skip enabled flag whose value is 1. That is, for example, when the value of the sign data hiding enabled flag is 0 (that is, the sign data hiding enabled flag indicates that sign data hiding is not enabled), and the value of the transform skip enabled flag is 1 (that is, when the transform skip enabled flag indicates that the transform skip is enabled), the TSRC enabled flag may be obtained (or signaled). Also, for example, when the value of the transform skip enabled flag is 0, the TSRC enabled flag may not be obtained, and the value of the TSRC enabled flag may be derived as 0. That is, for example, when the value of the transform skip enabled flag is 0, the TSRC enabled flag may not be signaled, and the value of the TSRC enabled flag may be derived as 0.</p><p id="p-0326" num="0284">The decoding apparatus obtains residual information for the transform skip block based on the TSRC enabled flag (S<b>820</b>). The decoding apparatus may obtain residual information for the transform skip block based on the TSRC enabled flag.</p><p id="p-0327" num="0285">For example, the decoding apparatus may determine a residual coding syntax for the transform skip block in the current slice based on the TSRC enabled flag. For example, the decoding apparatus may determine a residual coding syntax for the transform skip block as one of the Regular Residual Coding (RRC) syntax and Transform Skip Residual Coding (TSRC) syntax based on the TSRC enabled flag. The RRC syntax may indicate a syntax according to RRC, and the TSRC syntax may indicate a syntax according to TSRC.</p><p id="p-0328" num="0286">For example, the residual coding syntax for the transform skip block in the current slice may be determined as the regular residual coding (RRC) syntax based on the TSRC enabled flag whose value is 1. In this case, for example, a transform skip flag for whether the transform skip block is transform-skipped may be obtained based on the transform skip enabled flag whose value is 1, and the value of the transform skip flag may be 1. For example, the image information may include a transform skip flag for the transform skip block. The transform skip flag may indicate whether the transform skip block is transform-skipped. That is, the transform skip flag may indicate whether a transform is applied to transform coefficients of the transform skip block. The syntax element representing the transform skip flag may be the above-described transform_skip_flag. For example, when the value of the transform skip flag is 1, the transform skip flag may indicate that transform is not applied to the transform skip block (i.e., transform-skipped), while, when the value of the transform skip flag is 0, the transform skip flag may indicate that transform is applied to the transform skip block. For example, the value of the transform skip flag for the transform skip block may be 1.</p><p id="p-0329" num="0287">Also, for example, the residual coding syntax for the transform skip block may be determined as the transform skip residual coding (TSRC) syntax based on the TSRC enabled flag whose value is 0. Also, for example, the transform skip flag for whether the transform skip block is transform-skipped may be obtained, and the residual coding syntax for the transform skip block may be determined as the transform skip residual coding (TSRC) syntax based on the transform skip flag whose value is 1 and the TSRC enabled flag whose value is 0. Also, for example, the transform skip flag for whether the current block is transform-skipped may be obtained, and the residual coding syntax for the current block may be determined as the Regular Residual Coding (RRC) syntax based on the transform skip flag whose value is 0 and the TSRC enabled flag whose value is 0.</p><p id="p-0330" num="0288">Then, for example, the decoding apparatus may obtain residual information of the determined residual coding syntax for the transform skip block. For example, residual information of the regular residual coding (RRC) syntax may be obtained based on the TSRC enabled flag whose value is 1, and residual information of the TSRC syntax may be obtained based on the TSRC enabled flag whose value is 0. The image information may include residual information.</p><p id="p-0331" num="0289">For example, when the residual coding syntax for the transform skip block is determined as the RRC syntax, the decoding apparatus may obtain residual information of the RRC syntax for the transform skip block. For example, the residual information of the RRC syntax may include the syntax elements shown in Table 2 above.</p><p id="p-0332" num="0290">For example, the residual information of the RRC syntax may include syntax elements for transform coefficients of the transform skip block. Here, the transform coefficient may be referred to as a residual coefficient.</p><p id="p-0333" num="0291">For example, the syntax elements may include syntax elements such as last_sig_coeff_x_prefix, last_sig_coeff_y_prefix, last_sig_coeff_x_suffix, last_sig_coeff_y_suffix, sb_coded_flag, sig_coeff_flag, abs_level_gt1_flag, par_level_flag, abs_level_gtX_flag, abs_remainder, dec_abs_level, and/or coeff_sign_flag.</p><p id="p-0334" num="0292">Specifically, for example, the syntax elements may include position information indicating the position of the last non-zero transform coefficient in the residual coefficient array of the transform skip block. That is, the syntax elements may include position information indicating the position of the last non-zero transform coefficient in a scanning order of the transform skip block. The position information may include information indicating a prefix of a column position of the last non-zero transform coefficient, information indicating a prefix of a row position of the last non-zero transform coefficient, information indicating a suffix of a column position of the last non-zero transform coefficient, and information indicating a suffix of a row position of the last non-zero transform coefficient. The syntax elements for the location information may be last_sig_coeff_x_prefix, last_sig_coeff_y_prefix, last_sig_coeff_x_suffix, and last_sig_coeff_y_suffix. Meanwhile, the non-zero transform coefficient may be referred to as a significant coefficient.</p><p id="p-0335" num="0293">Also, for example, the syntax elements may include a coded subblock flag indicating whether a subblock of the transform skip block includes a non-zero transform coefficient; a significant coefficient flag indicating whether the transform coefficient of the transform skip block is non-zero transform coefficient; a first coefficient level flag for whether the coefficient level for the transform coefficient is greater than a first threshold; a parity level flag for parity of the coefficient level; and/or a second coefficient level flag for whether the coefficient level of the transform coefficient is greater than a second threshold. Here, the coded sub-block flag may be sb_coded_flag or coded_sub_block_flag; the significant coefficient flag may be sig_coeff_flag; the first coefficient level flag may be abs_level_gt1_flag or abs_level_gtx_flag; the parity level flag may be par_level_flag; and the second coefficient level flag may be abs_level_gt3_flag or abs_level_gtx_flag.</p><p id="p-0336" num="0294">Also, for example, the syntax elements may include information related to the coefficient value for value of transform coefficient of the transform skip block. The coefficient value related information may be abs_remainder and/or dec_abs_level.</p><p id="p-0337" num="0295">Also, for example, the syntax elements may include a sign flag indicating a sign of the transform coefficient. The sign flag may be coeff_sign_flag.</p><p id="p-0338" num="0296">Meanwhile, for example, when the sign data hiding is applied to the transform skip block, the sign flag of the first significant transform coefficient of the current coefficient group (CG) in the transform skip block may not be signaled. That is, for example, when the sign data hiding is applied to the transform skip block, the syntax elements may not include a sign flag indicating a sign of the first significant transform coefficient. Meanwhile, for example, whether the sign data hiding is applied to the transform skip block may be derived based on the sign data hiding enabled flag, and/or the position of the first significant transform coefficient and the position of the last significant transform coefficient of the current CG. For example, when the value of the sign data hiding enabled flag is 1, and the value obtained by subtracting the first significant transform coefficient position from the last significant transform coefficient position is greater than 3 (that is, when the value of the sign data hiding enabled flag is 1, and the number of significant transform coefficients in the current CG is greater than 3), the sign data hiding may be applied to the current CG of the transform skip block.</p><p id="p-0339" num="0297">Additionally, for example, when the residual coding syntax for the transform skip block is determined as the TSRC syntax, the decoding apparatus may obtain residual information of the TSRC syntax for the transform skip block. For example, the residual information of the TSRC syntax may include the syntax elements shown in Table 3 above.</p><p id="p-0340" num="0298">For example, the residual information of the TSRC syntax may include syntax elements for transform coefficients of the transform skip block. Here, the transform coefficient may be referred to as a residual coefficient.</p><p id="p-0341" num="0299">For example, the syntax elements may include context coded syntax elements and/or bypass coded syntax elements for a transform coefficient. The syntax elements may include syntax elements such as sig_coeff_flag, coeff_sign_flag, abs_level_gt1_flag, par_level_flag, abs_level_gtX_flag and/or abs_remainder.</p><p id="p-0342" num="0300">For example, the context-coded syntax elements for the transform coefficient may include a significant coefficient flag indicating whether the transform coefficient is a non-zero transform coefficient; a sign flag indicating a sign for the transform coefficient; a first coefficient level flag for whether the coefficient level for the transform coefficient is greater than a first threshold; and/or parity level flag for parity of the coefficient level for the transform coefficient. In addition, for example, the context-coded syntax elements may include a second coefficient level flag for whether the coefficient level of the transform coefficient is greater than a second threshold; a third coefficient level flag for whether the coefficient level of the transform coefficient is greater than a third threshold; a fourth coefficient level flag for whether the coefficient level of the transform coefficient is greater than a fourth threshold; and/or a fifth coefficient level flag for whether the coefficient level of the transform coefficient is greater than a fifth threshold. Here, the significant coefficient flag may be sig_coeff_flag; the sign flag may be coeff_sign_flag; the first coefficient level flag may be abs_level_gt1_flag; and the parity level flag may be par_level_flag. In addition, the second coefficient level flag may be abs_level_gt3_flag or abs_level_gtx_flag; the third coefficient level flag may be abs_level_gt5_flag or abs_level_gtx_flag; the fourth coefficient level flag may be abs_level_gt7_flag or abs_level_gtx_flag; and the fifth coefficient level flag may be abs_level_gt9_flag or abs_level_gtx_flag.</p><p id="p-0343" num="0301">Also, for example, the syntax elements bypass-coded for the transform coefficient may include coefficient level information for the value (or coefficient level) of the transform coefficient, and/or a sign flag indicating a sign for the transform coefficient. The coefficient level information may be abs_remainder and/or dec_abs_level, and the sign flag may be coeff_sign_flag.</p><p id="p-0344" num="0302">The decoding apparatus derives a residual sample for the transform skip block based on the residual coding information (S<b>830</b>). For example, the decoding apparatus may derive transform coefficients of the transform skip block based on the residual information, and may derive residual samples of the transform skip block based on the transform coefficients.</p><p id="p-0345" num="0303">For example, the decoding apparatus may derive transform coefficients of the transform skip block based on syntax elements of the residual information. Thereafter, the decoding apparatus may derive residual samples of the transform skip block based on the transform coefficients. For example, when it is derived that transform is not applied to the transform skip block based on the transform skip flag, that is, when the value of the transform skip flag is 1, the decoding apparatus may derive the transform coefficients as the residual samples of the transform skip block. Alternatively, for example, when being derived without applying transform to the transform skip block based on the transform skip flag, that is, when the value of the transform skip flag is 1, the decoding apparatus may dequantize the transform coefficients to derive the residual samples of the transform skip block. Alternatively, for example, when being derived while applying transform to the block in the current slice based on the transform skip flag, that is, when the value of the transform skip flag for the block is 0, the decoding apparatus may inverse transform the transform coefficients to derive the residual samples of the block. Alternatively, for example, when being derived while applying transform to the block based on the transform skip flag, that is, when the value of the transform skip flag is 0, the decoding apparatus may dequantize the transform coefficients, and inverse transform the dequantized transform coefficients to derive the residual samples of the current block.</p><p id="p-0346" num="0304">Meanwhile, for example, when the sign data hiding is applied to the transform skip block, the sign of the first significant transform coefficient of the current CG in the transform skip block may be derived based on the sum of absolute values of the significant transform coefficients in the current CG. For example, when the sum of the absolute values of the significant transform coefficients is even, the sign of the first significant transform coefficient may be derived as a positive value, while, when the sum of absolute values of the significant transform coefficients is odd, the sign of the first significant transform coefficient may be derived as a negative value.</p><p id="p-0347" num="0305">The decoding apparatus generates a reconstructed picture based on the residual sample (S<b>840</b>). For example, the decoding apparatus may generate a reconstructed sample and/or a reconstructed picture of a transform skip block in the current slice based on the residual sample. For example, the decoding apparatus may derive a prediction sample by performing an inter prediction mode or an intra prediction mode for the transform skip block based on prediction information received through a bitstream, and may generate the reconstructed sample through addition of the prediction sample and the residual sample.</p><p id="p-0348" num="0306">After this, as described above, an in-loop filtering procedure such as an ALF procedure, SAO and/or deblocking filtering may be applied as needed to the reconstructed picture in order to improve subjective/objective video quality.</p><p id="p-0349" num="0307"><figref idref="DRAWINGS">FIG. <b>9</b></figref> briefly illustrates a decoding apparatus for performing an image decoding method according to the present disclosure. The method disclosed in <figref idref="DRAWINGS">FIG. <b>8</b></figref> may be performed by the decoding apparatus disclosed in <figref idref="DRAWINGS">FIG. <b>9</b></figref>. Specifically, for example, the entropy decoder of the decoding apparatus of <figref idref="DRAWINGS">FIG. <b>9</b></figref> may perform S<b>800</b> to S<b>820</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref>; the residual processor of the decoding apparatus of <figref idref="DRAWINGS">FIG. <b>9</b></figref> may perform S<b>830</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref>; and the adder of the decoding apparatus of <figref idref="DRAWINGS">FIG. <b>9</b></figref> may perform S<b>840</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref>. Additionally, although not shown, the process of receiving prediction information for the transform skip block may be performed by an entropy decoder of the decoding apparatus of <figref idref="DRAWINGS">FIG. <b>9</b></figref>, and the process of deriving the prediction sample of the current block may be performed by the predictor of the decoding apparatus of <figref idref="DRAWINGS">FIG. <b>9</b></figref>.</p><p id="p-0350" num="0308">According to this document, as described above, it is possible to improve efficiency of residual coding.</p><p id="p-0351" num="0309">Additionally, according to this document, the TSRC enabled flag can be signaled depending on the sign data hiding enabled flag, and through this, the coding efficiency can be improved by preventing sign data hiding from being used for the transform skip block for which TSRC is not enabled, and the overall residual coding efficiency can be improved by reducing the bit amount to be coded.</p><p id="p-0352" num="0310">Additionally, according to this document, the TSRC enabled flag can be signaled depending on the transform skip enabled flag and the sign data hiding enabled flag, and through this, the coding efficiency can be improved by preventing sign data hiding from being used for the transform skip block for which TSRC is not enabled, and the overall residual coding efficiency can be improved by reducing the bit amount to be coded.</p><p id="p-0353" num="0311">In the above-described embodiment, the methods are described based on the flowchart having a series of steps or blocks. The present disclosure is not limited to the order of the above steps or blocks. Some steps or blocks may occur simultaneously or in a different order from other steps or blocks as described above. Further, those skilled in the art will understand that the steps shown in the above flowchart are not exclusive, that further steps may be included, or that one or more steps in the flowchart may be deleted without affecting the scope of the present disclosure.</p><p id="p-0354" num="0312">The embodiments described in this specification may be performed by being implemented on a processor, a microprocessor, a controller or a chip. For example, the functional units shown in each drawing may be performed by being implemented on a computer, a processor, a microprocessor, a controller or a chip. In this case, information for implementation (e.g., information on instructions) or algorithm may be stored in a digital storage medium.</p><p id="p-0355" num="0313">In addition, the decoding apparatus and the encoding apparatus to which the present disclosure is applied may be included in a multimedia broadcasting transmission/reception apparatus, a mobile communication terminal, a home cinema video apparatus, a digital cinema video apparatus, a surveillance camera, a video chatting apparatus, a real-time communication apparatus such as video communication, a mobile streaming apparatus, a storage medium, a camcorder, a VoD service providing apparatus, an Over the top (OTT) video apparatus, an Internet streaming service providing apparatus, a three-dimensional (3D) video apparatus, a teleconference video apparatus, a transportation user equipment (e.g., vehicle user equipment, an airplane user equipment, a ship user equipment, etc.) and a medical video apparatus and may be used to process video signals and data signals. For example, the Over the top (OTT) video apparatus may include a game console, a blue-ray player, an internet access TV, a home theater system, a smart phone, a tablet PC, a Digital Video Recorder (DVR), and the like.</p><p id="p-0356" num="0314">Furthermore, the processing method to which the present disclosure is applied may be produced in the form of a program that is to be executed by a computer and may be stored in a computer-readable recording medium. Multimedia data having a data structure according to the present disclosure may also be stored in computer-readable recording media. The computer-readable recording media include all types of storage devices in which data readable by a computer system is stored. The computer-readable recording media may include a BD, a Universal Serial Bus (USB), ROM, PROM, EPROM, EEPROM, RAM, CD-ROM, a magnetic tape, a floppy disk, and an optical data storage device, for example. Furthermore, the computer-readable recording media includes media implemented in the form of carrier waves (e.g., transmission through the Internet). In addition, a bit stream generated by the encoding method may be stored in a computer-readable recording medium or may be transmitted over wired/wireless communication networks.</p><p id="p-0357" num="0315">In addition, the embodiments of the present disclosure may be implemented with a computer program product according to program codes, and the program codes may be performed in a computer by the embodiments of the present disclosure. The program codes may be stored on a carrier which is readable by a computer.</p><p id="p-0358" num="0316"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a structural diagram of a contents streaming system to which the present disclosure is applied.</p><p id="p-0359" num="0317">The content streaming system to which the embodiment(s) of the present disclosure is applied may largely include an encoding server, a streaming server, a web server, a media storage, a user device, and a multimedia input device.</p><p id="p-0360" num="0318">The encoding server compresses content input from multimedia input devices such as a smartphone, a camera, a camcorder, etc. Into digital data to generate a bitstream and transmit the bitstream to the streaming server. As another example, when the multimedia input devices such as smartphones, cameras, camcorders, etc. directly generate a bitstream, the encoding server may be omitted.</p><p id="p-0361" num="0319">The bitstream may be generated by an encoding method or a bitstream generating method to which the embodiment(s) of the present disclosure is applied, and the streaming server may temporarily store the bitstream in the process of transmitting or receiving the bitstream.</p><p id="p-0362" num="0320">The streaming server transmits the multimedia data to the user device based on a user's request through the web server, and the web server serves as a medium for informing the user of a service. When the user requests a desired service from the web server, the web server delivers it to a streaming server, and the streaming server transmits multimedia data to the user. In this case, the content streaming system may include a separate control server. In this case, the control server serves to control a command/response between devices in the content streaming system.</p><p id="p-0363" num="0321">The streaming server may receive content from a media storage and/or an encoding server. For example, when the content is received from the encoding server, the content may be received in real time. In this case, in order to provide a smooth streaming service, the streaming server may store the bitstream for a predetermined time.</p><p id="p-0364" num="0322">Examples of the user device may include a mobile phone, a smartphone, a laptop computer, a digital broadcasting terminal, a personal digital assistant (PDA), a portable multimedia player (PMP), navigation, a slate PC, tablet PCs, ultrabooks, wearable devices (ex. Smartwatches, smart glasses, head mounted displays), digital TVs, desktops computer, digital signage, and the like. Each server in the content streaming system may be operated as a distributed server, in which case data received from each server may be distributed.</p><p id="p-0365" num="0323">The claims described in the present disclosure may be combined in various ways. For example, the technical features of the method claims of the present disclosure may be combined to be implemented as an apparatus, and the technical features of the apparatus claims of the present disclosure may be combined to be implemented as a method. In addition, the technical features of the method claim of the present disclosure and the technical features of the apparatus claim may be combined to be implemented as an apparatus, and the technical features of the method claim of the present disclosure and the technical features of the apparatus claim may be combined to be implemented as a method.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-01-15" num="01-15"><claim-text><b>1</b>-<b>15</b>. (canceled)</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. An image decoding method performed by a decoding apparatus, the method comprising:<claim-text>obtaining a sign data hiding enabled flag for whether sign data hiding is enabled;</claim-text><claim-text>obtaining a Transform Skip Residual Coding (TSRC) disabled flag for whether TSRC is used for a transform skip block in a current slice;</claim-text><claim-text>obtaining residual coding information for the transform skip block based on the TSRC disabled flag;</claim-text><claim-text>deriving a residual sample for the transform skip block based on the residual coding information; and</claim-text><claim-text>generating a reconstructed picture based on the residual sample,</claim-text><claim-text>wherein the TSRC disabled flag is obtained based on the sign data hiding enabled flag.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the sign data hiding enabled flag equal to 1 represents that the sign data hiding is enabled, and<claim-text>wherein the sign data hiding enabled flag equal to 0 represents that the sign data hiding is not enabled.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein, in response to a value of the sign data hiding enabled flag being equal to 1, a sign of a first significant transform coefficient of a current coefficient group (CG) in the transform skip block is derived based on a sum of absolute values of significant transform coefficients in the current CG.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein, in response to the value of the sign data hiding enabled flag being equal to 1, a sign flag for the first significant transform coefficient is not signaled.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the TSRC disabled flag is obtained from a bitstream in response to a value of the sign data hiding enabled flag being equal to 0.</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. The method of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein, in response to the value of the sign data hiding enabled flag being equal to 1, the TSRC disabled flag is not obtained from the bitstream, and a value of the TSRC disabled flag is derived as 0.</claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising obtaining a transform skip enabled flag for whether transform skip is enabled,<claim-text>wherein the TSRC disabled flag is obtained based on the sign data hiding enabled flag and the transform skip enabled flag.</claim-text></claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein the TSRC disabled flag is obtained from a bitstream in response to a value of the sign data hiding enabled flag being equal to 0 and a value of the transform skip enabled flag being equal to 1.</claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. The method of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein, in response to the value of the sign data hiding enabled flag being equal to 1 or the value of the transform skip enabled flag being equal to 0, the TSRC disabled flag is not obtained from the bitstream, and a value of the TSRC disabled flag is derived as 0.</claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. An image encoding method performed by an encoding apparatus, the method comprising:<claim-text>encoding a sign data hiding enabled flag for whether sign data hiding is enabled;</claim-text><claim-text>encoding, based on the sign data hiding enabled flag, a Transform Skip Residual Coding (TSRC) disabled flag for whether TSRC is used for a transform skip block in a current slice;</claim-text><claim-text>encoding residual information for the transform skip block based on the TSRC disabled flag; and</claim-text><claim-text>generating a bitstream including the sign data hiding enabled flag, the TSRC disabled flag, and the residual information.</claim-text></claim-text></claim><claim id="CLM-00026" num="00026"><claim-text><b>26</b>. The method of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the sign data hiding enabled flag equal to is 1 represents that the sign data hiding is enabled, and<claim-text>wherein the sign data hiding enabled flag equal to 0 represents that the sign data hiding is not enabled.</claim-text></claim-text></claim><claim id="CLM-00027" num="00027"><claim-text><b>27</b>. The method of <claim-ref idref="CLM-00026">claim 26</claim-ref>, wherein the TSRC disabled flag is encoded into the bitstream in response to a value of the sign data hiding enabled flag being equal to 0.</claim-text></claim><claim id="CLM-00028" num="00028"><claim-text><b>28</b>. The method of <claim-ref idref="CLM-00027">claim 27</claim-ref>, wherein the TSRC disabled flag is not encoded into the bitstream in response to the value of the sign data hiding enabled flag being equal to 1.</claim-text></claim><claim id="CLM-00029" num="00029"><claim-text><b>29</b>. The method of <claim-ref idref="CLM-00025">claim 25</claim-ref>, further comprising encoding a transform skip enabled flag for whether transform skip is enabled,<claim-text>wherein the TSRC disabled flag is encoded into the bitstream based on the sign data hiding enabled flag and the transform skip enabled flag.</claim-text></claim-text></claim><claim id="CLM-00030" num="00030"><claim-text><b>30</b>. A non-transitory computer-readable storage medium for storing a bitstream generated by an image encoding method, the image encoding method comprising:<claim-text>encoding a sign data hiding enabled flag for whether sign data hiding is enabled;</claim-text><claim-text>encoding, based on the sign data hiding enabled flag, a Transform Skip Residual Coding (TSRC) disabled flag for whether TSRC is used for a transform skip block in a current slice; and</claim-text><claim-text>encoding residual information for the transform skip block based on the TSRC disabled flag,</claim-text><claim-text>wherein the bitstream includes the sign data hiding enabled flag, the TSRC disabled flag, and the residual information.</claim-text></claim-text></claim><claim id="CLM-00031" num="00031"><claim-text><b>31</b>. A method for transmitting data for image information comprising:<claim-text>encoding a sign data hiding enabled flag for whether sign data hiding is enabled;</claim-text><claim-text>encoding, based on the sign data hiding enabled flag, a Transform Skip Residual Coding (TSRC) disabled flag for whether TSRC is used for a transform skip block in a current slice;</claim-text><claim-text>encoding residual information for the transform skip block based on the TSRC disabled flag;</claim-text><claim-text>generating a bitstream including the sign data hiding enabled flag, the TSRC disabled flag, and the residual information; and</claim-text><claim-text>transmitting the data including the bitstream.</claim-text></claim-text></claim></claims></us-patent-application>