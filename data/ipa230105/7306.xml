<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007307A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221220" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007307</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17892866</doc-number><date>20220822</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>CN</country><doc-number>PCT/CN2020/076158</doc-number><date>20200221</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>96</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>96</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">Indication of Tiles in a Video Picture</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/CN2021/077217</doc-number><date>20210222</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17892866</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Beijing Bytedance Network Technology Co., Ltd.</orgname><address><city>Beijing</city><country>CN</country></address></addressbook><residence><country>CN</country></residence></us-applicant><us-applicant sequence="01" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Bytedance Inc.</orgname><address><city>Los Angeles</city><country>CA</country></address></addressbook><residence><country>CA</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Zhang</last-name><first-name>Kai</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Zhang</last-name><first-name>Li</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Wang</last-name><first-name>Ye-kui</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Deng</last-name><first-name>Zhipin</first-name><address><city>Beijing</city><country>CN</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Fan</last-name><first-name>Kui</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Xu</last-name><first-name>Jizheng</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>Liu</last-name><first-name>Hongbin</first-name><address><city>Beijing</city><country>CN</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A method includes performing a conversion between a video including a video picture including one or more tiles and a bitstream of the video. The video picture refers to a picture parameter set, and the picture parameter set conforms to a format rule specifying that the picture parameter set includes a list of column widths for N tile columns, where N is an integer. An (N&#x2212;1)-th tile column exists in the video picture and the (N&#x2212;1)-th tile column has a width that is equal to an (N&#x2212;1)-th entry in a list of explicitly included tile column widths plus one number of coding tree blocks.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="110.15mm" wi="131.49mm" file="US20230007307A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="199.90mm" wi="108.03mm" orientation="landscape" file="US20230007307A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="212.43mm" wi="104.39mm" orientation="landscape" file="US20230007307A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="82.47mm" wi="117.77mm" orientation="landscape" file="US20230007307A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="167.89mm" wi="98.21mm" orientation="landscape" file="US20230007307A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="169.84mm" wi="128.78mm" orientation="landscape" file="US20230007307A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="122.34mm" wi="125.56mm" orientation="landscape" file="US20230007307A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="131.91mm" wi="121.50mm" orientation="landscape" file="US20230007307A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="185.34mm" wi="141.56mm" orientation="landscape" file="US20230007307A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="230.21mm" wi="159.60mm" orientation="landscape" file="US20230007307A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="236.22mm" wi="144.61mm" orientation="landscape" file="US20230007307A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="133.60mm" wi="136.91mm" orientation="landscape" file="US20230007307A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="133.35mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="133.35mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="133.35mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="133.35mm" wi="154.86mm" orientation="landscape" file="US20230007307A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00022" num="00022"><img id="EMI-D00022" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00023" num="00023"><img id="EMI-D00023" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00024" num="00024"><img id="EMI-D00024" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00025" num="00025"><img id="EMI-D00025" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00026" num="00026"><img id="EMI-D00026" he="133.52mm" wi="140.12mm" orientation="landscape" file="US20230007307A1-20230105-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00027" num="00027"><img id="EMI-D00027" he="133.52mm" wi="147.83mm" orientation="landscape" file="US20230007307A1-20230105-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00028" num="00028"><img id="EMI-D00028" he="133.52mm" wi="145.20mm" orientation="landscape" file="US20230007307A1-20230105-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00029" num="00029"><img id="EMI-D00029" he="133.35mm" wi="145.20mm" orientation="landscape" file="US20230007307A1-20230105-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of International Patent Application No. PCT/CN2021/077217 filed on Feb. 22, 2021, which claims the priority to and benefits of International Patent Application No. PCT/CN2020/076158, filed on Feb. 21, 2020, all of which are hereby incorporated by reference in their entireties.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">This patent document relates to image and video coding and decoding.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Digital video accounts for the largest bandwidth use on the internet and other digital communication networks. As the number of connected user devices capable of receiving and displaying video increases, it is expected that the bandwidth demand for digital video usage will continue to grow.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0005" num="0004">The present document discloses techniques that can be used by video encoders and decoders for processing coded representation of video using control information useful for decoding of the coded representation.</p><p id="p-0006" num="0005">In one example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more slices and the rule specifies that a syntax element indicating a difference between tile indices of two rectangular slices is present in the bitstream responsive to at least one condition being satisfied. A first rectangular slice of the two rectangular slices is represented as i-th rectangular slice, where i is an integer.</p><p id="p-0007" num="0006">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more sub-pictures and each sub-picture comprises one or more rectangular slices. The rule specifies that a slice index at a sub-picture level for each rectangular slice in each sub-picture is derived to determine a number of coding tree units in each slice.</p><p id="p-0008" num="0007">In another example aspect, a video processing method is disclosed. The method includes determining, for a conversion between a video picture of a video that comprises one or more sub-pictures and a bitstream of the video, a mapping relationship between a sub-picture-level slice index of a slice in a sub-picture and a picture level slice index of the slice. The method also includes performing the conversion based on the determining.</p><p id="p-0009" num="0008">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more sub-pictures and the rule specifies that a tile of the video is positioned entirely within a single sub-picture of the video picture.</p><p id="p-0010" num="0009">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video, wherein the video picture comprises one or more sub-pictures. The bitstream conforms to a format rule specifying that information of partitioning a picture is included in a syntax structure associated with the picture.</p><p id="p-0011" num="0010">In another example aspect, a video processing method is disclosed. The method includes determining, for a conversion between a video picture of a video that comprises one or more slices having a non-rectangular shape and a bitstream of the video, slice partitioning information of the video picture. The method also includes performing the conversion based on the determining.</p><p id="p-0012" num="0011">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video that comprises one or more slices and a bitstream of the video according to a rule. The rule specifies that a number of slices in the video picture is equal to or greater than a minimum number of slices determined based on whether rectangular partitioning or non-rectangular partitioning is applied to the video picture.</p><p id="p-0013" num="0012">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more slices. In case slice partitioning information of the video picture is included in a syntax structure of a video unit, a slice is represented by a top-left location and a dimension of the slice.</p><p id="p-0014" num="0013">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more sub-pictures and each sub-picture comprises one or more slices. The rule specifies a manner by which partitioning information of the one or more slices in each sub-picture is present in the bitstream.</p><p id="p-0015" num="0014">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more rectangular slices and each slice comprises one or more tiles. The rule specifies that signalling between a difference between a first tile index of a first tile in ith rectangular slice and a second tile index of a first tile in (i+1)th rectangular slice is omitted in the bitstream.</p><p id="p-0016" num="0015">In another example aspect, a video processing method is disclosed. The method includes determining, for a conversion between a video picture of a video and a bitstream of the video, that information for deriving a number of columns of tiles and a number of rows of tiles in the video picture is conditionally included in the bitstream responsive to a relationship between a dimension of the video picture and a dimension of a coding tree block. The method also includes performing the conversion based on the determining.</p><p id="p-0017" num="0016">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video. The video picture comprises one or more sub-pictures. The bitstream conforms to a format rule specifying that, in case a variable that specifies a subpicture identifier of a subpicture that includes a slice is present in the bitstream, there is one and only one syntax element that satisfies a condition that a second variable corresponding to the syntax element is equal to the variable.</p><p id="p-0018" num="0017">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video. The video picture comprises one or more sub-pictures. In case a non-rectangular partitioning is applied or sub-picture information is omitted in the bitstream, two tiles in a slice have different addresses.</p><p id="p-0019" num="0018">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more tiles. The rule specifies that a syntax element is used to indicate a type of tile layout in case the one or more tiles are organized in both uniform spacing and non-uniform spacing.</p><p id="p-0020" num="0019">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The rule specifies that whether or how a Merge Estimation Region (MER) size is processed in the conversion is conditioned on a minimum allowed coding block size.</p><p id="p-0021" num="0020">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video that comprises at least a video tile and a bitstream of the video according to a rule. The rule specifies that a height of a slice in the video tile in units of coding tree units is derived based on a value of a first syntax element in the bitstream indicating a number of explicitly provided slice heights for slices in the video tile that includes the slice.</p><p id="p-0022" num="0021">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising a video picture comprising a video tile including one or more slices and a bitstream of the video according to a rule. The rule specifies that a second slice in a tile that includes a first slice in a picture has a height that is represented in a unit of coding tree units. The first slice has a first slice index, and the second slice has a second slice index that is determined based on the first slice index and a number of explicitly provided slice heights in the video tile. The height of the second slice is determined based on the first slice index and the second slice index.</p><p id="p-0023" num="0022">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising a video picture including one or more tiles and a bitstream of the video. The video picture refers to a picture parameter set and the picture parameter set conforms to a format rule specifying that the picture parameter set includes a list of column widths for N tile columns, where N is an integer. An (N&#x2212;1)-th tile column exists in the video picture and the (N&#x2212;1)-th tile column has a width that is equal to an (N&#x2212;1)-th entry in a list of explicitly included tile column widths plus one number of coding tree blocks.</p><p id="p-0024" num="0023">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising a video picture including one or more tiles and a bitstream of the video. The video picture refers to a picture parameter set and the picture parameter set conforms to a format rule specifying that the picture parameter set includes a list of row heights for N tile rows, where N is an integer. An (N&#x2212;1)-th tile row exists in the video picture and the (N&#x2212;1)-th tile row has a height that is equal to an (N&#x2212;1)-th entry in a list of explicitly included tile row heights plus one number of coding tree blocks.</p><p id="p-0025" num="0024">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more subpictures that comprise one or more slices and a coded representation of a video, wherein the coded representation conforms to a format rule; wherein the format rule specifies that, in case that a rectangular slices mode is enabled for a video picture, then a picture-level slice index for each slice in each subpicture in the video picture is derived without explicit signalling in the coded representation; and wherein the format rule specifies that a number of coding tree units in each slice is derivable from the picture-level slice index.</p><p id="p-0026" num="0025">In another example aspect, another video processing method is disclosed. The method includes performing a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more subpictures that comprise one or more slices and a coded representation of a video, wherein the coded representation conforms to a format rule; wherein the format rule specifies that a subpicture level slice index is derivable based on information in the coded representation without signalling the sub-picture level slice index in the coded representation.</p><p id="p-0027" num="0026">In another example aspect, another video processing method is disclosed. The method includes performing a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more subpictures and/or one or more tiles and a coded representation of a video, wherein the coded representation conforms to a format rule; and wherein the conversion conforms to a constraint rule.</p><p id="p-0028" num="0027">In another example aspect, another video processing method is disclosed. The method includes performing a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more tiles and/or one or more slices; wherein the coded representation conforms to a format rule; wherein the format rule specifies that a field at a video picture level carries information about portioning of slices and/or tiles in the video picture.</p><p id="p-0029" num="0028">In another example aspect, another video processing method is disclosed. The method includes performing a conversion between a video comprising one or more pictures and a coded representation of the video, wherein the conversion conforms to a partitioning rule that a minimum number of slices in which a video picture is partitioned is a function of whether rectangular partitioning is used for partitioning the video picture.</p><p id="p-0030" num="0029">In another example aspect, another video processing method is disclosed. The method includes performing a conversion between a video slice of a video region of a video and a coded representation of the video; wherein the coded representation conforms to a format rule; wherein the format rule specifies that the coded representation signals the video slice based on a top-left location of the video slice and wherein the format rule specifies that the coded representation signals a height and/or a width of the video slice in partitioning information that is signalled at a video unit level.</p><p id="p-0031" num="0030">In another example aspect, another video processing method is disclosed. The method includes performing a conversion between a video comprising video pictures and a coded representation of the video; wherein the coded representation conforms to a format rule; wherein the format rule specifies to omit signalling a difference between a tile index of a first tile in a rectangular slice and a tile index of a first tile in a next rectangular slice.</p><p id="p-0032" num="0031">In another example aspect, another video processing method is disclosed. The method includes performing a conversion between a video and a coded representation of the video, wherein the coded representation conforms to a format rule, wherein the format rule specifies that a relationship between a width of a video picture and a size of a coding tree unit controls signalling of information used for deriving a number of tile columns or rows in the video picture.</p><p id="p-0033" num="0032">In another example aspect, another video processing method is disclosed. The method includes performing a conversion between a video comprising one or more video pictures and a coded representation of the video, wherein the coded representation conforms to a format rule, wherein the format rule specifies that a tile layout information is included in the coded representation for a video picture that comprises uniform spacing tiles and non-uniform spacing tiles.</p><p id="p-0034" num="0033">In yet another example aspect, a video encoder apparatus is disclosed. The video encoder comprises a processor configured to implement the above-described methods.</p><p id="p-0035" num="0034">In yet another example aspect, a video decoder apparatus is disclosed. The video decoder comprises a processor configured to implement the above-described methods.</p><p id="p-0036" num="0035">In yet another example aspect, a computer readable medium having code stored thereon is disclosed. The code embodies one of the methods described herein in the form of processor-executable code.</p><p id="p-0037" num="0036">These, and other, features are described throughout the present document.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example of raster scan slice partitioning of a picture, where the picture is divided into 12 tiles and 3 raster scan slices.</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example of rectangular slice partitioning of a picture, where the picture is divided into 24 tiles (6 tile columns and 4 tile rows) and 9 rectangular slices.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example of a picture partitioned into tiles and rectangular slices, where the picture is divided into 4 tiles (2 tile columns and 2 tile rows) and 4 rectangular slices.</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a picture that is partitioned into 15 tiles, 24 slices and 24 subpictures.</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a nominal vertical and horizontal locations of 4:2:2 luma and chroma samples in a picture.</p><p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an example of picture partitioning, in which blue lines represent boundaries of tiles, green lines represent boundaries of slices and red dashed lines represent boundaries of subpictures, and in which the picture-level indices, decoding order indices, subpicture-level indices of the four slices and the indices of subpictures and tiles are indicated in the figure.</p><p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram of an example video processing system.</p><p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a block diagram of a video processing apparatus.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a flowchart for an example method of video processing.</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram that illustrates a video coding system according to various embodiments of the present disclosure.</p><p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a block diagram that illustrates an encoder according to various embodiments of the present disclosure.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a block diagram that illustrates a decoder according to various embodiments of the present disclosure.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is flowchart representation of a method for video processing according to various embodiments of the present disclosure.</p><p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. <b>19</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. <b>20</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>21</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. <b>22</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. <b>23</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. <b>24</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. <b>25</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. <b>26</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>27</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>28</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. <b>29</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. <b>30</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p><p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. <b>31</b></figref> is flowchart representation of another method for video processing according to various embodiments of the present disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0069" num="0068">Section headings are used in the present document for ease of understanding and do not limit the applicability of techniques and embodiments disclosed in each section only to that section. Furthermore, H.266 terminology is used in some description only for ease of understanding and not for limiting scope of the disclosed techniques. As such, the techniques described herein are applicable to other video codec protocols and designs also.</p><heading id="h-0007" level="1">1. OVERVIEW</heading><p id="p-0070" num="0069">This document is related to video coding technologies. Specifically, it is about signalling of subpictures, tiles, and slices. The ideas may be applied individually or in various combination, to any video coding standard or non-standard video codec that supports multi-layer video coding, e.g., the being-developed Versatile Video Coding (VVC).</p><heading id="h-0008" level="1">2. ABBREVIATIONS</heading><p id="p-0071" num="0000"><ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0070">APS Adaptation Parameter Set</li>        <li id="ul0002-0002" num="0071">AU Access Unit</li>        <li id="ul0002-0003" num="0072">AUD Access Unit Delimiter</li>        <li id="ul0002-0004" num="0073">AVC Advanced Video Coding</li>        <li id="ul0002-0005" num="0074">CLVS Coded Layer Video Sequence</li>        <li id="ul0002-0006" num="0075">CPB Coded Picture Buffer</li>        <li id="ul0002-0007" num="0076">CRA Clean Random Access</li>        <li id="ul0002-0008" num="0077">CTU Coding Tree Unit</li>        <li id="ul0002-0009" num="0078">CVS Coded Video Sequence</li>        <li id="ul0002-0010" num="0079">DPB Decoded Picture Buffer</li>        <li id="ul0002-0011" num="0080">DPS Decoding Parameter Set</li>        <li id="ul0002-0012" num="0081">EOB End Of Bitstream</li>        <li id="ul0002-0013" num="0082">EOS End Of Sequence</li>        <li id="ul0002-0014" num="0083">GDR Gradual Decoding Refresh</li>        <li id="ul0002-0015" num="0084">HEVC High Efficiency Video Coding</li>        <li id="ul0002-0016" num="0085">HRD Hypothetical Reference Decoder</li>        <li id="ul0002-0017" num="0086">IDR Instantaneous Decoding Refresh</li>        <li id="ul0002-0018" num="0087">JEM Joint Exploration Model</li>        <li id="ul0002-0019" num="0088">MCTS Motion-Constrained Tile Sets</li>        <li id="ul0002-0020" num="0089">NAL Network Abstraction Layer</li>        <li id="ul0002-0021" num="0090">OLS Output Layer Set</li>        <li id="ul0002-0022" num="0091">PH Picture Header</li>        <li id="ul0002-0023" num="0092">PPS Picture Parameter Set</li>        <li id="ul0002-0024" num="0093">PTL Profile, Tier and Level</li>        <li id="ul0002-0025" num="0094">PU Picture Unit</li>        <li id="ul0002-0026" num="0095">RB SP Raw Byte Sequence Payload</li>        <li id="ul0002-0027" num="0096">SEI Supplemental Enhancement Information</li>        <li id="ul0002-0028" num="0097">SPS Sequence Parameter Set</li>        <li id="ul0002-0029" num="0098">SVC Scalable Video Coding</li>        <li id="ul0002-0030" num="0099">VCL Video Coding Layer</li>        <li id="ul0002-0031" num="0100">VPS Video Parameter Set</li>        <li id="ul0002-0032" num="0101">VTM VVC Test Model</li>        <li id="ul0002-0033" num="0102">VUI Video Usability Information</li>        <li id="ul0002-0034" num="0103">VVC Versatile Video Coding</li>    </ul>    </li></ul></p><heading id="h-0009" level="1">3. INITIAL DISCUSSION</heading><p id="p-0072" num="0104">Video coding standards have evolved primarily through the development of the well-known International Telecommunication Union (ITU) Telecommunication Standardization Sector (ITU-T) and International Organization for Standardization (ISO)/International Electrotechnical Commission (IEC) standards. The ITU-T produced H.261 and H.263, ISO/IEC produced Moving Picture Experts Group (MPEG)-1 and MPEG-4 Visual, and the two organizations jointly produced the H.262/MPEG-2 Video and H.264/MPEG-4 Advanced Video Coding (AVC) and H.265/High Efficiency Video Coding (HEVC) standards. Since H.262, the video coding standards are based on the hybrid video coding structure wherein temporal prediction plus transform coding are utilized. To explore the future video coding technologies beyond HEVC, the Joint Video Exploration Team (JVET) was founded by Video Coding Experts Group (VCEG) and MPEG jointly in 2015. Since then, many new methods have been adopted by JVET and put into the reference software named Joint Exploration Model (JEM). The JVET meeting is concurrently held once every quarter, and the new coding standard is targeting at 50% bitrate reduction as compared to HEVC. The new video coding standard was officially named as Versatile Video Coding (VVC) in the April 2018 JVET meeting, and the first version of VVC test model (VTM) was released at that time. As there are continuous effort contributing to VVC standardization, new coding techniques are being adopted to the VVC standard in every JVET meeting. The VVC working draft and test model VTM are then updated after every meeting. The VVC project is now aiming for technical completion (FDIS) at the July 2020 meeting.</p><heading id="h-0010" level="1">3.1. Picture Partitioning Schemes in HEVC</heading><p id="p-0073" num="0105">HEVC includes four different picture partitioning schemes, namely regular slices, dependent slices, tiles, and Wavefront Parallel Processing (WPP), which may be applied for Maximum Transfer Unit (MTU) size matching, parallel processing, and reduced end-to-end delay.</p><p id="p-0074" num="0106">Regular slices are similar as in H.264/AVC. Each regular slice is encapsulated in its own NAL unit, and in-picture prediction (intra sample prediction, motion information prediction, coding mode prediction) and entropy coding dependency across slice boundaries are disabled. Thus, a regular slice can be reconstructed independently from other regular slices within the same picture (though there may still have interdependencies due to loop filtering operations).</p><p id="p-0075" num="0107">The regular slice is the only tool that can be used for parallelization that is also available, in virtually identical form, in H.264/AVC. Regular slice-based parallelization does not require much inter-processor or inter-core communication (except for inter-processor or inter-core data sharing for motion compensation when decoding a predictively coded picture, which is typically much heavier than inter-processor or inter-core data sharing due to in-picture prediction). However, for the same reason, the use of regular slices can incur substantial coding overhead due to the bit cost of the slice header and due to the lack of prediction across the slice boundaries. Further, regular slices (in contrast to the other tools mentioned below) also serve as the key mechanism for bitstream partitioning to match MTU size requirements, due to the in-picture independence of regular slices and that each regular slice is encapsulated in its own NAL unit. In many cases, the goal of parallelization and the goal of MTU size matching place contradicting demands to the slice layout in a picture. The realization of this situation led to the development of the parallelization tools mentioned below.</p><p id="p-0076" num="0108">Dependent slices have short slice headers and allow partitioning of the bitstream at treeblock boundaries without breaking any in-picture prediction. Basically, dependent slices provide fragmentation of regular slices into multiple NAL units, to provide reduced end-to-end delay by allowing a part of a regular slice to be sent out before the encoding of the entire regular slice is finished.</p><p id="p-0077" num="0109">In WPP, the picture is partitioned into single rows of coding tree blocks (CTBs). Entropy decoding and prediction are allowed to use data from CTBs in other partitions. Parallel processing is possible through parallel decoding of CTB rows, where the start of the decoding of a CTB row is delayed by two CTBs, so to ensure that data related to a CTB above and to the right of the subject CTB is available before the subject CTB is being decoded. Using this staggered start (which appears like a wavefront when represented graphically), parallelization is possible with up to as many processors/cores as the picture contains CTB rows. Because in-picture prediction between neighboring treeblock rows within a picture is permitted, the required inter-processor/inter-core communication to enable in-picture prediction can be substantial. The WPP partitioning does not result in the production of additional NAL units compared to when it is not applied, thus WPP is not a tool for MTU size matching. However, if MTU size matching is required, regular slices can be used with WPP, with certain coding overhead.</p><p id="p-0078" num="0110">Tiles define horizontal and vertical boundaries that partition a picture into tile columns and rows. Tile column runs from the top of a picture to the bottom of the picture. Likewise, tile row runs from the left of the picture to the right of the picture. The number of tiles in a picture can be derived simply as number of tile columns multiply by number of tile rows.</p><p id="p-0079" num="0111">The scan order of CTBs is changed to be local within a tile (in the order of a CTB raster scan of a tile), before decoding the top-left CTB of the next tile in the order of tile raster scan of a picture. Similar to regular slices, tiles break in-picture prediction dependencies as well as entropy decoding dependencies. However, they do not need to be included into individual NAL units (same as WPP in this regard); hence tiles may not be used for MTU size matching. Each tile can be processed by one processor/core, and the inter-processor/inter-core communication required for in-picture prediction between processing units decoding neighboring tiles is limited to conveying the shared slice header in cases a slice is spanning more than one tile, and loop filtering related sharing of reconstructed samples and metadata. When more than one tile or WPP segment is included in a slice, the entry point byte offset for each tile or WPP segment other than the first one in the slice is signalled in the slice header.</p><p id="p-0080" num="0112">For simplicity, restrictions on the application of the four different picture partitioning schemes have been specified in HEVC. A given coded video sequence may not include both tiles and wavefronts for most of the profiles specified in HEVC. For each slice and tile, either or both of the following conditions may be fulfilled: 1) all coded treeblocks in a slice belong to the same tile; 2) all coded treeblocks in a tile belong to the same slice. Finally, a wavefront segment contains exactly one CTB row, and when WPP is in use, if a slice starts within a CTB row, it may end in the same CTB row.</p><p id="p-0081" num="0113">A recent amendment to HEVC is specified in the JCT-VC output document JCTVC-AC1005, J. Boyce, A. Ramasubramonian, R. Skupin, G. J. Sullivan, A. Tourapis, Y.-K. Wang (editors), &#x201c;HEVC Additional Supplemental Enhancement Information (Draft 4),&#x201d; Oct. 24, 2017, publicly available herein: http://phenix.int-evry.fr/jct/doc_end_user/documents/29_Macau/wg11/JCTVC-AC1005-v2.zip. With this amendment included, HEVC specifies three MCTS-related SEI (supplemental enhancement information) messages, namely temporal MCTSs SEI message, MCTSs extraction information set SEI message, and MCTSs extraction information nesting SEI message.</p><p id="p-0082" num="0114">The temporal MCTSs SEI message indicates existence of MCTSs in the bitstream and signals the MCTSs. For each MCTS, motion vectors are restricted to point to full-sample locations inside the MCTS and to fractional-sample locations that require only full-sample locations inside the MCTS for interpolation, and the usage of motion vector candidates for temporal motion vector prediction derived from blocks outside the MCTS is disallowed. This way, each MCTS may be independently decoded without the existence of tiles not included in the MCTS.</p><p id="p-0083" num="0115">The MCTSs extraction information sets SEI message provides supplemental information that can be used in the MCTS sub-bitstream extraction (specified as part of the semantics of the SEI message) to generate a conforming bitstream for an MCTS set. The information consists of a number of extraction information sets, each defining a number of MCTS sets and containing RBSP bytes of the replacement VPSs, SPSs, and PPSs to be used during the MCTS sub-bitstream extraction process. When extracting a sub-bitstream according to the MCTS sub-bitstream extraction process, parameter sets (VPSs, SPSs, and PPSs) need to be rewritten or replaced, slice headers need to be slightly updated because one or all of the slice address related syntax elements (including first_slice_segment_in_pic_flag and slice_segment_address) typically would need to have different values.</p><heading id="h-0011" level="1">3.2. Partitioning of Pictures in VVC</heading><p id="p-0084" num="0116">In VVC, a picture is divided into one or more tile rows and one or more tile columns. A tile is a sequence of CTUs that covers a rectangular region of a picture. The CTUs in a tile are scanned in raster scan order within that tile.</p><p id="p-0085" num="0117">A slice consists of an integer number of complete tiles or an integer number of consecutive complete CTU rows within a tile of a picture.</p><p id="p-0086" num="0118">Two modes of slices are supported, namely the raster scan slice mode and the rectangular slice mode. In the raster scan slice mode, a slice contains a sequence of complete tiles in a tile raster scan of a picture. In the rectangular slice mode, a slice contains either a number of complete tiles that collectively form a rectangular region of the picture or a number of consecutive complete CTU rows of one tile that collectively form a rectangular region of the picture. Tiles within a rectangular slice are scanned in tile raster scan order within the rectangular region corresponding to that slice.</p><p id="p-0087" num="0119">A subpicture contains one or more slices that collectively cover a rectangular region of a picture.</p><p id="p-0088" num="0120"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example of raster scan slice partitioning of a picture, where the picture is divided into 12 tiles and 3 raster scan slices.</p><p id="p-0089" num="0121"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example of rectangular slice partitioning of a picture, where the picture is divided into 24 tiles (6 tile columns and 4 tile rows) and 9 rectangular slices.</p><p id="p-0090" num="0122"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example of a picture partitioned into tiles and rectangular slices, where the picture is divided into 4 tiles (2 tile columns and 2 tile rows) and 4 rectangular slices.</p><p id="p-0091" num="0123"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example of subpicture partitioning of a picture, where a picture is partitioned into 18 tiles, 12 on the left-hand side each covering one slice of 4 by 4 CTUs and 6 tiles on the right-hand side each covering 2 vertically-stacked slices of 2 by 2 CTUs, altogether resulting in 24 slices and 24 subpictures of varying dimensions (each slice is a subpicture).</p><heading id="h-0012" level="1">3.3. Signalling of SPS/PPS/Picture Header/Slice Header in VVC</heading><heading id="h-0013" level="2">7.3.2.3 Sequence Parameter Set RBSP Syntax</heading><p id="p-0092" num="0124"></p><p id="p-0093" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="273pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>seq_parameter_set_rbsp( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>sps_seq_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_video_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_max_sublayers_minus1</entry><entry>u(3)</entry></row><row><entry>&#x2003;sps_reserved_zero_4bits</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_ptl_dpb_hrd_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_ptl_dpb_hrd_params_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;profile_tier_level( 1, sps_max_sublayers_minus1 )</entry><entry/></row><row><entry>&#x2003;gdr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;chroma_format_idc</entry><entry>u(2)</entry></row><row><entry>&#x2003;if( chroma_format_idc = = 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;separate_colour_plane_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;res_change_in_clvs_allowed_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pic_width_max_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;pic_height_max_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_conformance_window_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_conformance_window_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_conf_win_left_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_right_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_top_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_bottom_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;subpic_info_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( subpic_info_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_num_subpics_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_independent_subpics_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;for(&#x2003;&#x2003;i&#x2003;&#x2003;=&#x2003;&#x2003;0; sps_num_subpics_minus1&#x2003;&#x2003;&#x3e;&#x2003;&#x2003;0&#x2003;&#x2003;&#x26;&#x26;&#x2003;&#x2003;i&#x2003;&#x2003; &#x3c;=</entry><entry/></row><row><entry>sps_num_subpics_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3e; 0 &#x26;&#x26; pic_width_max_in_luma_samples &#x3e; CtbSizeY )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_x[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3e; 0 &#x26;&#x26; pic_height_max_in_luma_samples &#x3e; CtbSizeY ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_y[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;&#x2003;i&#x2003;&#x2003;&#x3c;&#x2003;&#x2003;sps_num_subpics_minus1&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003; &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;pic_width_max_in_luma_samples &#x3e; CtbSizeY )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_width_minusl[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;&#x2003;i&#x2003;&#x2003;&#x3c;&#x2003;&#x2003;sps_num_subpics_minus1&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;pic_height_max_in_luma_samples &#x3e; CtbSizeY )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_height_minusl[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if(! sps_independent_subpics_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_treated_as_pic_flag[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;loop_filter_across_subpic_enabled_flag[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_subpic_id_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;subpic_id_mapping_explicitly_signalled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( subpic_id_mapping_explicitly_signalled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;subpic_id_mapping_in_sps_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( subpic_id_mapping_in_sps_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minusl; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_subpic_id[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;bit_depth_minus8</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_entropy_coding_sync_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_entropy_coding_sync_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_wpp_entry_point_offsets_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_weighted_pred_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_weighted_bipred_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;log2_max_pic_order_cnt_lsb_minus4</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_poc_msb_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_poc_msb_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;poc_msb_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;num_extra_ph_bits_bytes</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;extra_ph_bits_struct( num_extra_ph_bits_bytes )</entry><entry/></row><row><entry>&#x2003;num_extra_sh_bits_bytes</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;extra_sh_bits_struct( num_extra_sh_bits_bytes )</entry><entry/></row><row><entry>&#x2003;if( sps_max_sublayers_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_sublayer_dpb_params_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_ptl_dpb_hrd_params_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;dpb_parameters( sps_max_sublayers minus1,</entry><entry/></row><row><entry>sps_sublayer_dpb_params_flag )</entry><entry/></row><row><entry>&#x2003;long_term_ref_pics_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;inter_layer_ref_pics_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_idr_rpl_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;rpl1_same_as_rpl0_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; !rpl1_same_as_rpl0_flag ? 2 : 1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;num_ref_pic_lists_in_sps[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( j = 0; j &#x3c; num_ref_pic_lists_in_sps[ i ]; j++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ref_pic_list_struct( i, j )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;qtbtt_dual_tree_intra_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;log2_min luma coding block size minus2</entry><entry>ue(v)</entry></row><row><entry>&#x2003;partition_constraints_override_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_log2_diff_min_qt_min_cb_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_max_mtt_hierarchy_depth_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( sps_max_mtt_hierarchy_depth_intra_slice_luma != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_log2_diff_max_bt_min_qt_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_log2_diff_max_tt_min_qt_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_log2_diff_min_qt_min_cb_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_max_mtt_hierarchy_depth_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( sps_max_mtt_hierarchy_depth_inter_slice != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_log2_diff_max_bt_min_qt_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_log2_diff_max_tt_min_qt_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( qtbtt_dual tree intra flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_log2_diff_min_qt_min_cb_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_max_mtt_hierarchy_depth_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_log2_diff_max_bt_min_qt_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;sps_log2_diff_max_tt_min_qt_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_max_luma_transform_size_64 flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ChromaArrayType != 0){</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_joint_cber_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;sameqptableforchroma</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;numQpTables&#x2003;&#x2003;=&#x2003;&#x2003;sameqptableforchroma&#x2003;&#x2003;?&#x2003;&#x2003;1&#x2003;&#x2003;:&#x2003;&#x2003;(</entry><entry/></row><row><entry>sps_joint_cbcr_enabled_flag ? 3 : 2 )</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c; numQpTables; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;qp_table_start_minus26[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;num_points_in_qp_table_minusl[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( j = 0; j &#x3c;= numj&#x3e;oints_in_qp_table_minusl[ i ]; j++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;delta_qp_in_val_minusl[ i ][ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;delta_qp_diff_val[ i ][ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>&#x2003;sps_sao_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_alf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_alf_enabled_flag &#x26;&#x26; ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_ccalf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_transform_skip_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_transform_skip_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;log2_transform_skip_max_size_minus2</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_bdpcm_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_ref_wraparound_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_temporal_mvp_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_temporal_mvp_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_sbtmvp_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_amvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_bdof_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_bdof_enabled flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_bdof_pic_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_smvd_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_dmvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_dmvr_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_dmvr_pic_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_mmvd_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_isp_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_mrl_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_mip_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_cclm_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( chroma_format_idc = = 1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_chroma_horizontal_collocated_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;sps_chroma_vertical_collocated_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_mts_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_mts_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_explicit_mts_intra_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;sps_explicit_mts_inter_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;six_minus_max_num_merge_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_sbt_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_affine_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_affine_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;five_minus_max_num_subblock_merge_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_affine_type_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps amvr enabled flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_affine_amvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;sps_affine_prof_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps affine prof enabled flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_prof_pic_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_palette_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ChromaArrayType = = 3 &#x26;&#x26; !sps_max_luma_transform_size_64_flag</entry><entry/></row><row><entry>)</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_act_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_transform_skip_enabled_flag | | sps_palette_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;min_qp_prime_ts_minus4</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_bcw_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_ibc_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_ibc_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;six_minus_max_num_ibc_merge_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_ciip_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_mmvd_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_fpel_mmvd_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( MaxNumMergeCand &#x3e;= 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_gpm_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_gpm_enabled_flag &#x26;&#x26; MaxNumMergeCand &#x3e;= 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;max_num_merge_cand_minus_max_num_gpm_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_lfnst_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_ladf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps ladf enabled flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_num_ladf_intervals_minus2</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;sps_ladf_lowest_interval_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; sps_num_ladf_intervals_minus2 + 1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_ladf_qp_offset[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;sps_ladf_delta_threshold_minusl[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;log2_parallel_merge_level_minus2</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_scaling_list_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_dep_quant_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if(! sps_dep_quant_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_sign_data_hiding_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_virtual_boundaries_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps virtual boundaries enabled flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_virtual_boundaries_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps virtual boundaries present flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_num_ver_virtual_boundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; sps_num_ver_virtual_boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sps_virtual_boundaries_pos_x[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;sps_num_hor_virtual_boundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; sps_num_hor_virtual_boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sps_virtual_boundaries_pos_y[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_ptl_dpb_hrd_params_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_general_hrd_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_general_hrd_params_present_Aag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;general_hrd_parameters()</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sps_max_sublayers_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sps_sublayer_cpb_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;firstSubLayer&#x2003;&#x2003;=&#x2003;&#x2003;sps_sublayer_cpbj&#x3e;aramsj&#x3e;resent flag&#x2003;&#x2003;?&#x2003;&#x2003;0&#x2003;&#x2003;:</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sps_max_sublayers_minus1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ols_hrd_parameters( firstSubLayer, sps_max_sublayers_minus1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;field_seq_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;vui_parameters_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( vui_parameters_present_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;vui_parameters( ) /* Specified in ITU-T H.SEI ISO/IEC 23002-7 */</entry><entry/></row><row><entry>&#x2003;sps_extension_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_extension_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;while( more_rbsp_data())</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_extension_data_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;rbsp_trailing_bits( )</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0094" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>pic_parameter_set_rbsp( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;pps_pic_parameter_set_id</entry><entry>ue(v)</entry></row><row><entry>&#x2003;pps_seq_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;mixed_nalu_types_in_pic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pic_width_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;pic_height_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;pps_conformance_window_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pps_conformance_window_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_conf_win_left_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;pps_conf_win_right_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;pps_conf_win_top_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;pps_conf_win_bottom_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;scaling_window_explicit_signalling_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( scaling_window_explicit_signalling_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;scaling_win_left_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;scaling_win_right_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;scaling_win_top_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;scaling_win_bottom_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;output_flag_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;subpic_id_mapping_in_pps_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( subpic_id_mapping_in_pps_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_num_subpics_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;pps_subpic_id_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= pps_num_subpic_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pps_subpic_id[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;no_pic_partition_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( !no_pic_partition_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_columns_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_rows_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_columns_minus1; i++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_column_width_minusl[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_rows_minusl; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_row_height_minusl[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;rect_slice_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag &#x26;&#x26; ! single_slice_per_subpic flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minusl[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;&#x2003;NumTileRows&#x2003;&#x2003;&#x3e;&#x2003;&#x2003;1&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003; &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( tile_idx_delta_present_flag | | tileIdx % NumTileColumns = =</entry><entry/></row><row><entry>0 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minusl[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;&#x2003;slice_width_in_tiles_minusl[ i ]&#x2003;&#x2003;= =&#x2003;&#x2003;0&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minusl[ i ]&#x2003;&#x2003;= =&#x2003;&#x2003;0&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight SliceTopLeftTileIdx[ i ] / NumTileColumns ] &#x3e; 1 )</entry><entry/></row><row><entry>{</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1 [ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c; num_slices_in_pic_minusl )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;loop_filter_across_tiles_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_slices_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;cabac_init_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; 2; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;num_ref_idx_default_active_minusl[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;rpl1_idx_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;init_qp_minus26</entry><entry>se(v)</entry></row><row><entry>&#x2003;cu_qp_delta_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pps_chroma_tool_offsets_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pps_chroma_tool_offsets_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_cb_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;pps_cr_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;pps_joint_cbcr_qp_offset_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( pps_joint_cbcr_qp_offset_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pps_joint_cbcr_qp_offset_value</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;pps_slice_chroma_qp_offsets_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;pps_cu_chroma_qp_offset_list_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( pps_cu_chroma_qp_offset_list_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;chroma_qp_offset_list_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= chroma_qp_offset_list_len_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;cb_qp_offset_list[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;cr_qp_offset_list[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( pps_joint_cbcr_qp_offset_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;joint_cbcr_qp_offset_list[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;pps_weighted_pred_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pps_weighted_bipred_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;deblocking_filter_control_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( deblocking_filter_control_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;deblocking_filter_override_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;pps_deblocking_filter_disabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( !pps_deblocking_filter_disabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pps_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_cb_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_cb_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_cr_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_cr_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;rpl_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( deblocking_filter_override_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;dbf_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sao_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;alf_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if(&#x2003;(&#x2003;pps_weighted_pred_flag&#x2003;&#x2003;| |&#x2003;&#x2003;pps_weighted_bipred_flag&#x2003;)&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>rpl_present_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;wp_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;qp_delta_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pps_ref_wraparound_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pps_ref_wraparound_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_ref_wraparound_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;picture_header_extension_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;slice_header_extension_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pps_extension_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pps_extension_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;while( more_rbsp_data( ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pps_extension_data_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;rbsp_trailing_bits( )</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0095" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>picture_header_structure( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;gdr_or_irap_pic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( gdr_or_irap_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;gdr_pic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;ph_inter_slice_allowed_flag</entry><entry>u(I)</entry></row><row><entry>&#x2003;if( ph_inter_slice_allowed_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_intra_slice_allowed_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;non_reference_picture_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;ph_pic_parameter_set_id</entry><entry>ue(v)</entry></row><row><entry>&#x2003;ph_pic_order_cnt_lsb</entry><entry>u(v)</entry></row><row><entry>&#x2003;if( gdr_or_irap_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;no_output_of_prior_pics_flag</entry><entry>u(I)</entry></row><row><entry>&#x2003;if( gdr_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;recovery_poc_cnt</entry><entry>ue(v)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; NumExtraPhBits; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_extra_bit[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_poc_msb_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_poc_msb_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_poc_msb_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;poc_msb_val</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_alf_enabled_flag &#x26;&#x26; alf_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_alf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_alf_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_num_alf_aps_ids_luma</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ph_num_alf_aps_ids_luma; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_alf_aps_id_luma[ i ]</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ChromaArrayType != 0)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_alf_chroma_idc</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_alf_chroma_idc )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_alf_aps_id_chroma</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( sps_ccalf_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cc_alf_cb_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( ph_cc_alf_cb_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ph_cc_alf_cb_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cc_alf_cr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( ph_cc_alf_cr_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ph_cc_alf_cr_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_lmcs_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_lmcs_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_lmcs_aps_id</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ChromaArrayType != 0)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_chroma_residual_scale_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_scaling_list_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_scaling_list_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_scaling_list_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_scaling_list_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if(&#x2003;&#x2003;&#x2003;&#x2003;sps_virtual_boundaries_enabled_flag&#x2003;&#x2003;&#x2003;&#x2003;&#x2003; &#x26;&#x26;</entry><entry/></row><row><entry>!sps_virtual_boundaries_present_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_virtual_boundaries_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_virtual_boundaries_present_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_num_ver_virtua_lboundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ph_num_ver_virtual_boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_virtual_boundaries_pos_x[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ph_num_hor_virtual_boundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ph num hor virtual boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_virtual_boundaries_pos_y[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( output_flag_present_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;pic_output_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( rpl_info_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;ref_pic_lists( )</entry><entry/></row><row><entry>&#x2003;if( partition_constraints_override_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;partition_constraints_override_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ph_intra_slice_allowed_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( partition_constraints_override_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_log2_diff_min_qt_min_cb_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ph_max_mtt_hierarchy_depth_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_max_mtt_hierarchy_depth_intra_slice_luma != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_bt_min_qt_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_tt_min_qt_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( qtbtt_dual_tree_intra_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_min_qt_min_cb_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_max_mtt_hierarchy_depth_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( ph_max_mtt_hierarchy_depth_intra_slice_chroma != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_bt_min_qt_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_tt_min_qt_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( cu_qp_delta_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_cu_qp_delta_subdiv_intra_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( pps_cu_chroma_qp_offset_list_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_cu_chroma_qp_offset_subdiv_intra_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( ph_inter_slice_allowed_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( partition_constraints_override_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_log2_diff_min_qt_min_cb_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ph_max_mtt_hierarchy_depth_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_max_mtt_hierarchy_depth_inter_slice != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_bt_min_qt_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_tt_min_qt_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( cu_ qp_delta_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_cu_qp_delta_subdiv_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( pps_cu_chroma_qp_offset_list_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_cu_chroma_qp_offset_subdiv_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( sps_temporal_mvp_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_temporal_mvp_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_temporal_mvp_enabled_flag &#x26;&#x26; rpl_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_collocated_from_l0_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;&#x2003;(&#x2003;&#x2003;ph_collocated_from_l0_flag&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_ref_entries[ 0 ][ PicRpIsIdx[ 0 ] ]&#x2003;&#x2003;&#x3e;&#x2003;&#x2003;1)&#x2003;&#x2003; | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(&#x2003;&#x2003;&#x2003;&#x2003;!ph_collocated_from_l0_flag&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_ref_entries[ 1 ][ PicRplsIdx[ l ] ] &#x3e; 1 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ph_collocated_ref_idx</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;mvd_l1_zero_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_fpel_mmvd_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_fpel_mmvd_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_bdof_pic_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_disable_bdof_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_dmvr_pic_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_disable_dmvr_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_prof_pic_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_disable_prof_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ( pps_weighted_pred_flag&#x2003;| |&#x2003;pps_weighted_bipred_flag )&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>wp_info_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;pred_weight_table( )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( qp_delta_info_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_qp_delta</entry><entry>se(v)</entry></row><row><entry>&#x2003;if( sps_joint_cbcr_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_joint_cbcr_sign_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_sao_enabled_flag &#x26;&#x26; sao_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_sao_luma_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_sao_chroma_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_dep_quant_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_dep_quant_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_sign_data_hiding_enabled_flag &#x26;&#x26; !ph_dep_quant_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;pic_sign_data_hiding_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( deblocking_filter_override_enabled_flag &#x26;&#x26; dbf_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_deblocking_filter_override_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_deblocking_filter_override_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_deblocking_filter_disabled_flag</entry><entry>u(I)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( !ph_deblocking_filter_disabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cb_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cb_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cr_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cr_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( picture_header_extension_present_ flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_extension_length</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; ph_extension_length; i++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_extension_data_byte[ i ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0096" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>slice_header( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;picture_header_in_slice_header_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( picture_header_in_slice_header_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;picture_header_structure( )</entry><entry/></row><row><entry>&#x2003;if( subpic_info_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_subpic_id</entry><entry>u(v)</entry></row><row><entry>&#x2003;if( ( rect_slice_flag &#x26;&#x26; NumSlicesInSubpic[ CurrSubpicIdx ] &#x3e; 1 ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( !rect_slice flag &#x26;&#x26; NumTilesInPic &#x3e; 1 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_address</entry><entry>u(v)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; NumExtraPhBits; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;sh_extra_bit[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( !rect_slice_flag &#x26;&#x26; NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;num_tiles_in_slice_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( ph_inter_slice_allowed_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_type</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( sps_alf_enabled_flag &#x26;&#x26; !alf_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_alf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( slice_alf_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_num_alf_aps_ids_luma</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; slice_num_alf_aps_ids_luma; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_alf_aps_id_luma[ i ]</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ChromaArrayType != 0)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_alf_chromaidc</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_alf_chroma_idc)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_alf_aps_id_chroma</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( sps_cc_alf_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_cc_alf_cb_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_cc_alf_cb_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_cc_alf_cb_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_cc_alf_cr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_cc_alf_cr_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_cc_alf_cr_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( separate_colour_plane_flag = = 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;colour_plane_id</entry><entry>u(2)</entry></row><row><entry>&#x2003;if( !rpl_info_in_ph_flag&#x2003;&#x26;&#x26;&#x2003;((nal_unit_type&#x2003;!=&#x2003;IDR_W_RADL &#x26;&#x26;</entry><entry/></row><row><entry>nal_unit_type&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;!=</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;IDR_N_LP ) | | sps_idr_rpl_present_flag ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;ref_pic_lists( )</entry><entry/></row><row><entry>&#x2003;if( ( rpl_info_in_ph_flag&#x2003;| |&#x2003;((nal_unit_type&#x2003;!=&#x2003;IDR_W_RADL&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>nal_unit_type !=</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;IDR_N_LP)&#x2003;&#x2003;| | &#x2003;&#x2003;sps_idr_rpl_present_flag ))&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( slice_type != I&#x2003;&#x26;&#x26;&#x2003;num_ref_entries[ 0 ][ RplsIdx[ 0 ] ] &#x3e; 1 ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( slice_type = = B&#x2003;&#x26;&#x26;&#x2003;num_ref_entries[ 1 ][ RplsIdx[ l ] ] &#x3e; l ) ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;num_ref_idx_active_override_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( num_ref_idx_active_override_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ( slice_type = = B ? 2: 1 ); i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( num_ref_entries[ i ][ RplsIdx[ i ] ] &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_ref_idx_active_minusl[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( slice_type != 1) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( cabac_init_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;cabac_init_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if(ph_temporal_mvp_enabled_flag &#x26;&#x26; !rpl_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice type = = B )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_collocated_from_l0_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ( slice_collocated_from_l0_flag &#x26;&#x26; NumRefIdxActive[ 0 ] &#x3e; 1)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( ! slice_collocated_from_l0_flag &#x26;&#x26; NumRefIdxActive[ l ] &#x3e; 1</entry><entry/></row><row><entry>) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_collocated_ref_idx</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( !wp_info_in_ph_flag &#x26;&#x26; ((pps_weighted _pred_flag &#x26;&#x26; slice_type</entry><entry/></row><row><entry>= =&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;P&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;)&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003; | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(pps_weighted_bipred_flag &#x26;&#x26; slice_type = = B ) ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pred_weight_table( )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( !qp_delta_info_in_ph _flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_qp_delta</entry><entry>se(v)</entry></row><row><entry>&#x2003;if( pps_slice_chroma_qp_offsets_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_cb_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;slice_cr_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;if( spsjoint_cbcr_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_joint_cbcr_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( pps_cubchroma_ qp_offset_list_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;cu_chroma_qp_offset_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_sao_enabled_flag &#x26;&#x26; ! sao_info_in_ph_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_sao_luma_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_sao_chroma_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( deblocking_filter_override_enabled_flag &#x26;&#x26; !dbf_info_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_deblocking_filter_override_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( slice_deblocking_filter_override_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_deblocking_filter_disabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( !slice_deblocking_filter_disabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_cb_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_cb_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_cr_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_cr_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;slice_ts_residual_coding_disabled _flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ph_lmcs_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pic_scaling_list_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_scaling_list_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( NumEntryPoints &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;offset_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; NumEntryPoints; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;entry_point_offset_minusl[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( slice_header_extension_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_header_extension_length</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; slice_header_extension_length; i++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_header_extension_data_byte[ i ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;byte_alignment( )</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0014" level="1">3.4. Example Specifications for Tiles, Slices and Subpictures</heading><heading id="h-0015" level="1">3 Definitions</heading><p id="p-0097" num="0000"><ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0125">picture-level slice index: An index of a slice to the list of slices in a picture in the order as they are signalled in the PPS when the rect_slice_flag is equal to 1.</li>        <li id="ul0004-0002" num="0126">subpicture-level slice index: An index of a slice to the list of slices in a subpicture in the order as they are signalled in the PPS when the rect_slice_flag is equal to 1.</li>    </ul>    </li></ul></p><heading id="h-0016" level="2">6.5.1 CTB Raster Scanning, Tile Scanning, and Subpicture Scanning Processes</heading><p id="p-0098" num="0127">The variable NumTileColumns, specifying the number of tile columns, and the list colWidth[i] for i ranging from 0 to NumTileColumn&#x2212;1, inclusive, specifying the width of the i-th tile column in units of CTBs, are derived as follows:</p><p id="p-0099" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="182pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;</entry><entry>remainingWidthInCtbsY = PicWidthInCtbsY</entry></row><row><entry/><entry/><entry>for( i = 0; i &#x3c; num_exp_tile_columns_minus1; i++ ) {</entry></row><row><entry/><entry/><entry>&#x2003;colWidth[ i ] = tile_column_width_minus1[ i ] + 1</entry></row><row><entry/><entry/><entry>&#x2003;remainingWidthInCtbsY &#x2212;= colWidth[ i ]</entry></row><row><entry/><entry/><entry>}</entry></row><row><entry/><entry/><entry>uniformTileColWidth = tile_column_width_mi-</entry></row><row><entry/><entry/><entry>nus1[ num_exp_tile_columns_minus1 ] + 1&#x2003;(23)</entry></row><row><entry/><entry/><entry>while( remainingWidthInCtbsY &#x3e;= uniformTileColWidth ) {</entry></row><row><entry/><entry/><entry>&#x2003;colWidth[ i++ ] = uniformTileColWidth</entry></row><row><entry/><entry/><entry>&#x2003;remainingWidthInCtbsY &#x2212;= uniformTileColWidth</entry></row><row><entry/><entry/><entry>}</entry></row><row><entry/><entry/><entry>if( remainingWidthInCtbsY &#x3e; 0 )</entry></row><row><entry/><entry/><entry>&#x2003;colWidth[ i++ ] = remainingWidthInCtbsY</entry></row><row><entry/><entry/><entry>NumTileColumns = i</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variable NumTileRows, specifying the number of tile rows, and the list RowHeight[j] for j ranging from 0 to NumTileRows&#x2212;1, inclusive, specifying the height of the j-th tile row in units of CTBs, are derived as follows:</p><p id="p-0100" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="189pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>remainingHeightInCtbsY = PicHeightInCtbsY</entry></row><row><entry/><entry>for( j = 0; j &#x3c; num_exp_tile_rows_minus1; j++ ) {</entry></row><row><entry/><entry>&#x2003;RowHeight[ j ] = tile_row_height_minus1[ j ] + 1</entry></row><row><entry/><entry>&#x2003;remainingHeightInCtbsY &#x2212;= RowHeight[ j ]</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>uniformTileRowHeight = tile_row_height_mi-</entry></row><row><entry/><entry>nus1[ num_exp_tile_rows_minus1 ] + 1&#x2003;(24)</entry></row><row><entry/><entry>while( remainingHeightInCtbsY &#x3e;= uniformTileRowHeight ) {</entry></row><row><entry/><entry>&#x2003;RowHeight[ j++ ] = uniformTileRowHeight</entry></row><row><entry/><entry>&#x2003;remainingHeightInCtbsY &#x2212;= uniformTileRowHeight</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>if( remainingHeightInCtbsY &#x3e; 0 )</entry></row><row><entry/><entry>&#x2003;RowHeight[ j++ ] = remainingHeightInCtbsY</entry></row><row><entry/><entry>NumTileRows = j</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variable NumTilesInPic is set equal to NumTileColumns*NumTileRows.<br/>The list tileColBd[i] for i ranging from 0 to NumTileColumns, inclusive, specifying the location of the i-th tile column boundary in units of CTBs, is derived as follows:</p><p id="p-0101" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>for(tileColBd[0]=0,<i>i=</i>0;<i>i</i>&#x3c;NumTileColumns;<i>i</i>++)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0102" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>tileColBd[<i>i+</i>1]=tileColBd[<i>i</i>]+colWidth[<i>i</i>]&#x2003;&#x2003;(25)<?in-line-formulae description="In-line Formulae" end="tail"?><ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0128">NOTE 1&#x2014;The size of the array tileColBd[ ] is one greater than the actual number of tile columns in the derivation of CtbToTileColBd[ ].<br/>The list tileRowBd[j] for j ranging from 0 to NumTileRows, inclusive, specifying the location of the j-th tile row boundary in units of CTBs, is derived as follows:</li>    </ul>    </li></ul></p><p id="p-0103" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>for(tileRowBd[0]=0,<i>j=</i>0;<i>j</i>&#x3c;NumTileRows;<i>j</i>++)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0104" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>tileRowBd[<i>j+</i>1]=tileRowBd[<i>j</i>]+RowHeight[<i>j</i>]&#x2003;&#x2003;(26)<?in-line-formulae description="In-line Formulae" end="tail"?><ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0129">NOTE 2&#x2014;The size of the array tileRowBd[ ] in the above derivation is one greater than the actual number of tile rows in the derivation of CtbToTileRowBd[ ].<br/>The list CtbToTileColBd[ctbAddrX] for ctbAddrX ranging from 0 to PicWidthInCtbsY, inclusive, specifying the conversion from a horizontal CTB address to a left tile column boundary in units of CTBs, is derived as follows:</li>    </ul>    </li></ul></p><p id="p-0105" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="203pt" align="left"/><colspec colname="2" colwidth="14pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>tileX = 0</entry><entry/></row><row><entry>for( ctbAddrX = 0; ctbAddrX &#x3c;= PicWidthInCtbsY; ctbAddrX++ ) {</entry><entry/></row><row><entry>&#x2003;if( ctbAddrX = = tileColBd[ tileX + 1 ] )</entry><entry>(27)</entry></row><row><entry>&#x2003;&#x2003;tileX++</entry><entry/></row><row><entry>&#x2003;CtbToTileColBd[ ctbAddrX ] = tileColBd[ tileX ]</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0130">NOTE 3&#x2014;The size of the array CtbToTileColBd[ ] in the above derivation is one greater than the actual number of picture width in CTBs in the derivaqiton slice_data( ) signalling.<br/>The list CtbToTileRowBd[ctbAddrY] for ctbAddrY ranging from 0 to PicHeightInCtbsY, inclusive, specifying the conversion from a vertical CTB address to a top tile column boundary in units of CTBs, is derived as follows:</li>    </ul>    </li></ul></p><p id="p-0106" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="203pt" align="left"/><colspec colname="2" colwidth="14pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>tileY = 0</entry><entry/></row><row><entry>for( ctbAddrY = 0; ctbAddrY &#x3c;= PicHeightInCtbsY; ctbAddrY++ ) {</entry><entry/></row><row><entry>&#x2003;if( ctbAddrY = = tileRowBd[ tileY + 1 ] )</entry><entry>(28)</entry></row><row><entry>&#x2003;&#x2003;tileY++</entry><entry/></row><row><entry>&#x2003;CtbToTileRowBd[ ctbAddrY ] = tileRowBd[ tileY ]</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0131">NOTE 4&#x2014;the size of the array CtbToTileRowBd[ ] in the above derivation is one greater than the actual number of picture height in CTBs in the slice_data( ) signalling.<br/>For rectangular slices, the list NumCtusInSlice[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the number of CTU in the i-th slice, the list SliceTopLeftTileldx[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the index of the top-left tile of the slice, and the matrix CtbAddrInSlice[i] [j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, specifying the picture raster scan address of the j-th CTB within the i-th slice, are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0107" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry></row><row><entry>&#x2003;&#x2003;sliceIdx = subpic_info_present_flag ? CtbToSubpicIdx[ i ] : 0</entry></row><row><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] = i</entry></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry></row><row><entry>&#x2003;}</entry></row><row><entry>} else {</entry></row><row><entry>&#x2003;tileIdx = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] = tileIdx</entry></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;if( i = = num_slices_in_pic_minus1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ] = NumTileColumns &#x2212; 1 &#x2212; tileX</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = NumTileRows &#x2212; 1 &#x2212; tileY</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = 1</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] == 0 &#x26;&#x26; slice_height_in_tiles_minus1[ i ]</entry></row><row><entry>= = 0 ) {&#x2003;( 29 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; NumSlicesInTile[ i ] &#x2212; 1; j++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + SliceHeightInCtusMinus1[ i ] + 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbY += SliceHeightInCtusMinus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i++</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ], ctbY,</entry></row><row><entry>tileRow[ tileY + 1 ] )</entry></row><row><entry>&#x2003;&#x2003;} else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= slice_height_in_tiles_minus1[ i ]; j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c;= slice_width_in_tiles_minus1[ i ]; k++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j + 1 ] )</entry></row><row><entry>&#x2003;&#x2003;if( tile_idx_delta_present_flag )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry></row><row><entry>&#x2003;&#x2003;else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += slice_width_in_tiles_minus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += slice_height_in_tiles_minus1[ i ] * NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0013" list-style="none">    <li id="ul0013-0001" num="0000">    <ul id="ul0014" list-style="none">        <li id="ul0014-0001" num="0132">AddCtbsToSlice(tileColBd[tileX], tileColBd[tileX+1], ctbY, tileRowBd[tileY+1])</li>    </ul>    </li></ul></p><p id="p-0108" num="0133">Where the function AddCtbsToSlice(sliceIdx, startX, stopX, startY, stopY) is specified as follows:</p><p id="p-0109" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="189pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>for( ctbY = startY; ctbY &#x3c; stopY; ctbY++ )</entry></row><row><entry/><entry>&#x2003;for( ctbX = startX; ctbX &#x3c; stopX; ctbX++ ) {</entry></row><row><entry/><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] =</entry></row><row><entry/><entry>ctbY * PicWidthInCtbsY + ctbX (30)</entry></row><row><entry/><entry>&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>For bitstream conformance, the values of NumCtusInSlice[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, may be greater than 0. Additionally, for bitstream conformance, the matrix CtbAddrInSlice[i] [j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, may include all CTB may address in the range 0 to PicSizeInCtbsY&#x2212;1 once and only once. The list CtbToSubpicIdx[ctbAddrRs] for ctbAddrRs ranging from 0 to PicSizeInCtbsY&#x2212;1, inclusive, specifying the conversion from a CTB address in picture raster scan to a subpicture index, is derived as follows:</p><p id="p-0110" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="196pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>for( ctbAddrRs = 0; ctbAddrRs &#x3c; PicSizeInCtbsY; ctbAddrRs++ ) {</entry></row><row><entry/><entry>&#x2003;posX = ctbAddrRs % PicWidthInCtbsY</entry></row><row><entry/><entry>&#x2003;posY = ctbAddrRs / PicWidthInCtbsY</entry></row><row><entry/><entry>&#x2003;CtbToSubpicIdx[ ctbAddrRs ] = &#x2212;1</entry></row><row><entry/><entry>&#x2003;for( i = 0; CtbToSubpicIdx[ ctbAddrRs ] &#x3c; 0 &#x26;&#x26; i &#x3c;=</entry></row><row><entry/><entry>sps_num_subpics_minus1; i++ ) {&#x2003;&#x2003;(31)</entry></row><row><entry/><entry>&#x2003;&#x2003;if( ( posX &#x3e;= subpic_ctu_top_left_x[ i ] ) &#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posX &#x3c; subpic_ctu_top_left_x[ i ] + subpic_width_mi-</entry></row><row><entry/><entry>nus1[ i ] + 1 ) &#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3e;= subpic_ctu_top_left_y[ i ] ) &#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3c; subpic_ctu_top_left_y[ i ] + sub-</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;pic_height_minus1[ i ] + 1 ) )</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;CtbToSubpicIdx[ ctbAddrRs ] = i</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The list NumSlicesInSubpic[i], specifying the number of rectangular slices in the i-th subpicture, is derived as follows:</p><p id="p-0111" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="168pt" align="left"/><colspec colname="3" colwidth="28pt" align="left"/><thead><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>for( j = 0; j &#x3c;= sps_num_subpics_minus1; j++ )</entry><entry/></row><row><entry/><entry>&#x2003;NumSlicesInSubpic[ j ] = 0</entry><entry/></row><row><entry/><entry>for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry/><entry>&#x2003;posX = CtbAddrInSlice[ i ][ 0 ] % PicWidthInCtbsY</entry><entry/></row><row><entry/><entry>&#x2003;posY = CtbAddrInSlice[ i ][ 0 ] / PicWidthInCtbsY</entry><entry/></row><row><entry/><entry>&#x2003;for( j = 0; j &#x3c;= sps_num_subpics_minus1; j++ ) {</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if( ( posX &#x3e;= subpic_ctu_top_left_x[ j ] ) &#x26;&#x26;</entry><entry>(32)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="196pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posX &#x3c; subpic_ctu_top_left_x[ j ] +</entry></row><row><entry/><entry>subpic_width_minus1[ j ] + 1 ) &#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3e;= subpic_ctu_top_left_y[ j ] ) &#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3c; subpic_ctu_top_left_y[ j ] +</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_height_minus1[ j ] + 1 ) ) {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;NumSlicesInSubpic[ j ]++</entry></row><row><entry/><entry>&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0017" level="2">7.3.4.3 Picture Parameter Set RBSP Semantics</heading><p id="p-0112" num="0134">subpic_id_mapping_in_pps_flag equal to 1 specifies that the subpicture ID mapping is signalled in the PPS. subpic_id_mapping_in_pps_flag equal to 0 specifies that the subpicture ID mapping is not signalled in the PPS. If subpic_id_mapping_explicitly_signalled_flag is 0 or subpic_id_mapping_in_sps_flag is equal to 1, the value of subpic_id_mapping_in_pps_flag may be equal to 0. Otherwise (subpic_id_mapping_explicitly_signalled_flag is equal to 1 and subpic_id_mapping_in_sps_flag is equal to 0), the value of subpic_id_mapping_in_pps_flag may be equal to 1.<br/>pps_num_subpics_minus1 may be equal to sps_num_subpics_minus1.<br/>pps_subpic_id_len_minus1 may be equal to sps_subpic_id_len_minus1.<br/>pps_subpic_id[i] specifies the subpicture ID of the i-th subpicture. The length of the pps_subpic_id[i] syntax element is pps_subpic_id_len_minus1+1 bits.<br/>The variable SubpicIdVal[i], for each value of i in the range of 0 to sps_num_subpics_minus1, inclusive, is derived as follows:</p><p id="p-0113" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="182pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry></row><row><entry/><entry>&#x2003;if( subpic_id_mapping_explicitly_signalled_flag )</entry></row><row><entry/><entry>&#x2003;&#x2003;SubpicIdVal[ i ] = subpic_id_mapping_in_pps_flag ?</entry></row><row><entry/><entry>&#x2003;&#x2003;pps_subpic_id[ i ] :</entry></row><row><entry/><entry>sps_subpic_id[ i ]&#x2003;&#x2003;&#x2003;&#x2003;(80)</entry></row><row><entry/><entry>&#x2003;else</entry></row><row><entry/><entry>&#x2003;&#x2003;SubpicIdVal[ i ] = i</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>For bitstream conformance, both of the following constraints may apply:<ul id="ul0015" list-style="none">    <li id="ul0015-0001" num="0000">    <ul id="ul0016" list-style="none">        <li id="ul0016-0001" num="0135">For any two different values of i and j in the range of 0 to sps_num_subpics_minus1, inclusive, SubpicIdVal[i] may not be equal to SubpicIdVal[j].</li>        <li id="ul0016-0002" num="0136">When the current picture is not the first picture of the CLVS, for each value of i in the range of 0 to sps_num_subpics_minus1, inclusive, if the value of SubpicIdVal[i] is not equal to the value of SubpicIdVal[i] of the previous picture in decoding order in the same layer, the nal_unit_type for all coded slice NAL units of the subpicture in the current picture with subpicture index i may be equal to a particular value in the range of IDR_W_RADL to CRA_NUT, inclusive.<br/>no_pic_partition_flag equal to 1 specifies that no picture partitioning is applied to each picture referring to the PPS. no_pic_partition_flag equal to 0 specifies each picture referring to the PPS may be partitioned into more than one tile or slice.<br/>For bitstream conformance, the value of no_pic_partition_flag may be the same for all PPSs that are referred to by coded pictures within a CLVS.<br/>For bitstream conformance, the value of no_pic_partition_flag may not be equal to 1 when the value of sps_num_subpics_minus1+1 is greater than 1.<br/>pps_log2_ctu_size_minus5 plus 5 specifies the luma coding tree block size of each CTU. pps_log2_ctu_size_minus5 may be equal to sps_log2_ctu_size_minus5.<br/>num_exp_tile_columns_minus1 plus 1 specifies the number of explicitly provided tile column widths. The value of num_exp_tile_columns_minus1 may be in the range of 0 to PicWidthInCtbsY&#x2212;1, inclusive. When no_pic_partition_flag is equal to 1, the value of num_exp_tile_columns_minus1 is inferred to be equal to 0.<br/>num_exp_tile_rows_minus1 plus 1 specifies the number of explicitly provided tile row heights. The value of num_exp_tile_rows_minus1 may be in the range of 0 to PicHeightInCtbsY&#x2212;1, inclusive. When no_pic_partition_flag is equal to 1, the value of num_tile_rows_minus1 is inferred to be equal to 0.<br/>tile_column_width_minus1[i] plus 1 specifies the width of the i-th tile column in units of CTBs for i in the range of 0 to num_exp_tile_columns_minus1&#x2212;1, inclusive. tile_column_width_minus1[num_exp_tile_columns_minus1] is used to derive the width of the tile columns with index greater than or equal to num_exp_tile_columns_minus1 as specified in clause 6.5.1. The value of tile_column_width_minus1 [i] may be in the range of 0 to PicWidthInCtbsY&#x2212;1, inclusive. When not present, the value of tile_column_width_minus1[0] is inferred to be equal to PicWidthInCtbsY&#x2212;1.<br/>tile_row_height_minus1[i] plus 1 specifies the height of the i-th tile row in units of CTBs for i in the range of 0 to num_exp_tile_rows_minus1&#x2212;1, inclusive. tile row height minus1 [num_exp_tile_rows_minus1] is used to derive the height of the tile rows with index greater than or equal to num_exp_tile_rows_minus1 as specified in clause 6.5.1. The value of tile row height minus1 [i] may be in the range of 0 to PicHeightInCtbsY&#x2212;1, inclusive. When not present, the value of tile_row_height_minus1[0] is inferred to be equal to PicHeightInCtbsY&#x2212;1.<br/>rect_slice_flag equal to 0 specifies that tiles within each slice are in raster scan order and the slice information is not signalled in PPS. rect_slice_flag equal to 1 specifies that tiles within each slice cover a rectangular region of the picture and the slice information is signalled in the PPS. When not present, rect_slice_flag is inferred to be equal to 1. When subpic_info_present_flag is equal to 1, the value of rect_slice_flag may be equal to 1.<br/>single_slice_per_subpic_flag equal to 1 specifies that each subpicture consists of one and only one rectangular slice. single_slice_per_subpic_flag equal to 0 specifies that each subpicture may consist of one or more rectangular slices. When single_slice_per_subpic_flag is equal to 1, num_slices_in_pic_minus1 is inferred to be equal to sps_num_subpics_minus1. When not present, the value of single_slice_per_subpic_flag is inferred to be equal to 0.<br/>num_slices_in_pic_minus1 plus 1 specifies the number of rectangular slices in each picture referring to the PPS. The value of num_slices_in_pic_minus1 may be in the range of 0 to MaxSlicesPerPicture&#x2212;1, inclusive, where MaxSlicesPerPicture is specified in Annex A. When no_pic_partition_flag is equal to 1, the value of num_slices_in_pic_minus1 is inferred to be equal to 0.<br/>tile_idx_delta_present_flag equal to 0 specifies that tile_idx_delta values are not present in the PPS and all rectangular slices in pictures referring to the PPS are specified in raster order according to the process defined in clause 6.5.1. tile_idx_delta_present_flag equal to 1 specifies that tile_idx_delta values may be present in the PPS and all rectangular slices in pictures referring to the PPS are specified in the order indicated by the values of tile_idx_delta. When not present, the value of tile_idx_delta_present_flag is inferred to be equal to 0.<br/>slice_width_in_tiles_minus1[i] plus 1 specifies the width of the i-th rectangular slice in units of tile columns. The value of slice_width_in_tiles_minus1 [i] may be in the range of 0 to NumTileColumns&#x2212;1, inclusive.<br/>When slice_width_in_tiles_minus1[i] is not present, the following applies:&#x2014;</li>        <li id="ul0016-0003" num="0137">If NumTileColumns is equal to 1, the value of slice_width_in_tiles_minus1 [i] is inferred to be equal to 0.</li>        <li id="ul0016-0004" num="0138">Otherwise, the value of slice_width_in_tiles_minus1 [i] is inferred as specified in clause 6.5.1.<br/>slice_height_in_tiles_minus1 [i] plus 1 specifies the height of the i-th rectangular slice in units of tile rows. The value of slice_height_in_tiles_minus1 [i] may be in the range of 0 to NumTileRows&#x2212;1, inclusive.<br/>When slice_height_in_tiles_minus1[i] is not present, the following applies:</li>        <li id="ul0016-0005" num="0139">If NumTileRows is equal to 1, or tile_idx_delta_present_flag is equal to 0 and tileIdx % NumTileColumns is greater than 0), the value of slice_height_in_tiles_minus1[i] is inferred to be equal to 0.</li>        <li id="ul0016-0006" num="0140">Otherwise (NumTileRows is not equal to 1, and tile_idx_delta_present_flag is equal to 1 or tileIdx % NumTileColumns is equal to 0), when tile_idx_delta_present_flag is equal to 1 or tileIdx % NumTileColumns is equal to 0, the value of slice_height_in_tiles_minus1 [i] is inferred to be equal to slice_height_in_tiles_minus1[i&#x2212;1].<br/>num_exp_slices_in_tile[i] specifies the number of explicitly provided slice heights in the current tile that contains more than one rectangular slices. The value of num_exp_slices_in_tile[i] may be in the range of 0 to RowHeight[tileY]&#x2212;1, inclusive, where tileY is the tile row index containing the i-th slice. When not present, the value of num_exp_slices_in_tile[i] is inferred to be equal to 0. When num_exp_slices_in_tile[i] is equal to 0, the value of the variable NumSlicesInTile[i] is derived to be equal to 1.<br/>exp_slice_height_in_ctus_minus1[j] plus 1 specifies the height of the j-th rectangular slice in the current tile in units of CTU rows. The value of exp_slice_height_in_ctus_minus1 [j] may be in the range of 0 to RowHeight[tileY]&#x2212;1, inclusive, where tileY is the tile row index of the current tile.<br/>When num_exp_slices_in_tile[i] is greater than 0, the variable NumSlicesInTile[i] and SliceHeightInCtusMinus1[i+k] for k in the range of 0 to NumSlicesInTile[i]&#x2212;1 are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0114" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>remainingHeightInCtbsY = RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry></row><row><entry>numExpSliceInTile = num_exp_slices_in_tile[ i ]</entry></row><row><entry>for( j = 0; j &#x3c; numExpSliceInTile &#x2212; 1; j++ ) {</entry></row><row><entry>&#x2003;SliceHeightInCtusMinus1[ i++ ] = exp_slice_height_in_ctu_minus1[ j ]</entry></row><row><entry>&#x2003;remainingHeightInCtbsY &#x2212;= SliceHeightInCtusMinus1[ j ]</entry></row><row><entry>}</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="238pt" align="left"/><colspec colname="2" colwidth="21pt" align="left"/><tbody valign="top"><row><entry>uniformSliceHeightMinus1 = SliceHeightInCtusMinus1[ i &#x2212; 1 ]</entry><entry>(81)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry>while( remainingHeightInCtbsY &#x3e;= (uniformSliceHeightMinus1 + 1) ) {</entry></row><row><entry>&#x2003;SliceHeightInCtusMinus1[ i++ ] = uniformSliceHeightMinus1</entry></row><row><entry>&#x2003;remainingHeightInCtbsY &#x2212;= (uniformSliceHeightMinus1 + 1)</entry></row><row><entry>&#x2003;j++</entry></row><row><entry>}</entry></row><row><entry>if( remainingHeightInCtbsY &#x3e; 0 ) {</entry></row><row><entry>&#x2003;SliceHeightInCtusMinus1[ i++ ] = remainingHeightInCtbsY</entry></row><row><entry>&#x2003;j++</entry></row><row><entry>}</entry></row><row><entry>NumSlicesInTile[ i ] = j</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>tile_idx_delta[i] specifies the difference between the tile index of the first tile in the i-th rectangular slice and the tile index of the first tile in the (i+1)-th rectangular slice. The value of tile_idx_delta[i] may be in the range of &#x2212;NumTilesInPic+1 to NumTilesInPic&#x2212;1, inclusive. When not present, the value of tile_idx_delta[i] is inferred to be equal to 0. When present, the value of tile_idx_delta[i] may not be equal to 0.<br/>7.4.2.4.5 Order of VCL NAL Units and their Association to Coded Pictures<br/>The order of the VCL NAL units within a coded picture is constrained as follows:<ul id="ul0017" list-style="none">    <li id="ul0017-0001" num="0000">    <ul id="ul0018" list-style="none">        <li id="ul0018-0001" num="0141">For any two coded slice NAL units A and B of a coded picture, let subpicldxA and subpicldxB be their subpicture level index values, and sliceAddrA and sliceddrB be their slice address values.</li>        <li id="ul0018-0002" num="0142">When either of the following conditions is true, coded slice NAL unit A may precede coded slice NAL unit B:        <ul id="ul0019" list-style="none">            <li id="ul0019-0001" num="0143">subpicIdxA is less than subpicIdxB.</li>            <li id="ul0019-0002" num="0144">subpicIdxA is equal to subpicIdxB and sliceAddrA is less than sliceAddrB.</li>        </ul>        </li>    </ul>    </li></ul></p><heading id="h-0018" level="2">7.4.8.1 General Slice Header Semantics</heading><p id="p-0115" num="0145">The variable CuQpDeltaVal, specifying the difference between a luma quantization parameter for the coding unit containing cu_qp_delta_abs and its prediction, is set equal to 0. The variables CuQpOffset<sub>Cb</sub>, CuQpOffset<sub>Cr</sub>, and CuQpOffset<sub>CbCr</sub>, specifying values to be used when determining the respective values of the Qp&#x2032;<sub>Cb</sub>, Qp&#x2032;<sub>Cr</sub>, and Qp&#x2032;<sub>CbCr </sub>quantization parameters for the coding unit containing cu_chroma_qp_offset_flag, are all set equal to 0.<br/>picture_header_in_slice_header_flag equal to 1 specifies that the PH syntax structure is present in the slice header. picture_header_in_slice_header_flag equal to 0 specifies that the PH syntax structure is not present in the slice header.<br/>For bitstream conformance, the value of picture_header_in_slice_header_flag may be the same in all coded slices in a CLVS.<br/>When picture_header_in_slice_header_flag is equal to 1 for a coded slice, for bitstream conformance, no VCL NAL unit with nal_unit_type equal to PH NUT may be present in the CLVS.<br/>When picture_header_in_slice_header_flag is equal to 0, all coded slices in the current picture may have picture_header_in_slice_header_flag is equal to 0, and the current PU may have a PH NAL unit.<br/>slice_subpic_id specifies the subpicture ID of the subpicture that contains the slice. If slice_subpic_id is present, the value of the variable CurrSubpicIdx is derived to be such that SubpicIdVal[CurrSubpicIdx] is equal to slice_subpic_id. Otherwise (slice_subpic_id is not present), CurrSubpicIdx is derived to be equal to 0. The length of slice_subpic_id is sps_subpic_id_len_minus1+1 bits.<br/>slice_address specifies the slice address of the slice. When not present, the value of slice_address is inferred to be equal to 0. When rect_slice_flag is equal to 1 and NumSlicesInSubpic[CurrSubpicIdx] is equal to 1, the value of slice_address is inferred to be equal to 0.<br/>If rect_slice_flag is equal to 0, the following applies:<ul id="ul0020" list-style="none">    <li id="ul0020-0001" num="0000">    <ul id="ul0021" list-style="none">        <li id="ul0021-0001" num="0146">The slice address is the raster scan tile index.</li>        <li id="ul0021-0002" num="0147">The length of slice_address is Ceil(Log2(NumTilesInPic)) bits.</li>        <li id="ul0021-0003" num="0148">The value of slice_address may be in the range of 0 to NumTilesInPic&#x2212;1, inclusive.<br/>Otherwise (rect_slice_flag is equal to 1), the following applies:</li>        <li id="ul0021-0004" num="0149">The slice address is the subpicture-level slice index of the slice.</li>        <li id="ul0021-0005" num="0150">The length of slice_address is Ceil(Log2(NumSlicesInSubpic[CurrSubpicIdx])) bits.</li>        <li id="ul0021-0006" num="0151">The value of slice_address may be in the range of 0 to NumSlicesInSubpic[CurrSubpicIdx]&#x2212;1, inclusive.<br/>For bitstream conformance, the following constraints may apply:</li>        <li id="ul0021-0007" num="0152">If rect_slice_flag is equal to 0 or subpic_info_present_flag is equal to 0, the value of slice_address may not be equal to the value of slice_address of any other coded slice NAL unit of the same coded picture.</li>        <li id="ul0021-0008" num="0153">Otherwise, the pair of slice_subpic_id and slice_address values may not be equal to the pair of slice_subpic_id and slice_address values of any other coded slice NAL unit of the same coded picture.</li>        <li id="ul0021-0009" num="0154">The shapes of the slices of a picture may be such that each CTU, when decoded, may have its entire left boundary and entire top boundary consisting of a picture boundary or consisting of boundaries of previously decoded CTU(s).<br/>sh_extra_bit[i] may be equal to 1 or 0. Decoders conforming to this version of this Specification may ignore the value of sh_extra_bit[i]. Its value does not affect decoder conformance to profiles specified in this version of specification.<br/>num_tiles_in_slice_minus1 plus 1, when present, specifies the number of tiles in the slice. The value of num_tiles_in_slice_minus1 may be in the range of 0 to NumTilesInPic&#x2212;1, inclusive. The variable NumCtusInCurrSlice, which specifies the number of CTUs in the current slice, and the list CtbAddrInCurrSlice[i], for i ranging from 0 to NumCtusInCurrSlice&#x2212;1, inclusive, specifying the picture raster scan address of the i-th CTB within the slice, are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0116" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( rect_slice_flag ) {</entry></row><row><entry>&#x2003;picLevelSliceIdx = slice_address</entry></row><row><entry>&#x2003;for( j = 0; j &#x3c; CurrSubpicIdx; j++ )</entry></row><row><entry>&#x2003;&#x2003;picLevelSliceIdx += NumSlicesInSubpic[ j ]</entry></row><row><entry>&#x2003;NumCtusInCurrSlice = NumCtusInSlice[ picLevelSliceIdx ]</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; NumCtusInCurrSlice; i++ )</entry></row><row><entry>&#x2003;&#x2003;CtbAddrInCurrSlice[ i ] = CtbAddrInSlice[ picLevelSliceIdx ][ i ]&#x2003;(117)</entry></row><row><entry>} else {</entry></row><row><entry>&#x2003;NumCtusInCurrSlice = 0</entry></row><row><entry>&#x2003;for( tileIdx = slice_address; tileIdx &#x3c;= slice_address + num_tiles_in_slice_minus1;</entry></row><row><entry>tileIdx++ ) {</entry></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;for( ctbY = tileRowBd[ tileY ]; ctbY &#x3c; tileRowBd[ tileY + 1 ]; ctbY++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( ctbX = tileColBd[ tileX ]; ctbX &#x3c; tileColBd[ tileX + 1 ]; ctbX++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;CtbAddrInCurrSlice[ NumCtusInCurrSlice ] =</entry></row><row><entry>ctbY * PicWidthInCtb + ctbX</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;NumCtusInCurrSlice++</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variables SubpicLeftBoundaryPos, SubpicTopBoundaryPos, SubpicRightBoundaryPos, and SubpicBotBoundaryPos are derived as follows:</p><p id="p-0117" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( subpic_treated_as_pic_flag[ CurrSubpicIdx ] ) {</entry></row><row><entry>&#x2003;SubpicLeftBoundaryPos = subpic_ctu_top_left_x[ CurrSubpicIdx ] * CtbSizeY</entry></row><row><entry>&#x2003;SubpicRightBoundaryPos = Min( pic_width_max_in_luma_samples &#x2212; 1,</entry></row><row><entry>&#x2003;&#x2003;( subpic_ctu_top_left_x[ CurrSubpicIdx ] +</entry></row><row><entry>&#x2003;&#x2003;subpic_width_minus1[ CurrSubpicIdx ] + 1 ) * CtbSizeY &#x2212; 1 )</entry></row><row><entry>&#x2003;SubpicTopBoundaryPos = subpic_ctu_top_left_y[ CurrSubpicIdx ] *CtbSizeY</entry></row><row><entry>&#x2003;(118)</entry></row><row><entry>&#x2003;SubpicBotBoundaryPos = Min( pic_height_max_in_luma_samples &#x2212; 1,</entry></row><row><entry>&#x2003;&#x2003;( subpic_ctu_top_left_y[ CurrSubpicIdx ] +</entry></row><row><entry>&#x2003;&#x2003;subpic_height_minus1[ CurrSubpicIdx ] + 1 ) * CtbSizeY &#x2212; 1 )</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0019" level="1">3.5. Color Space and Chroma Subsampling</heading><p id="p-0118" num="0155">Color space, also known as the color model (or color system), is an abstract mathematical model which simply describes the range of colors as tuples of numbers, typically as 3 or 4 values or color components (e.g. RGB). Basically speaking, color space is an elaboration of the coordinate system and sub-space.</p><p id="p-0119" num="0156">For video compression, the most frequently used color spaces are YCbCr and RGB.</p><p id="p-0120" num="0157">YCbCr, Y&#x2032;CbCr, or Y Pb/Cb Pr/Cr, also written as YCBCR or Y&#x2032;CBCR, is a family of color spaces used as a part of the color image pipeline in video and digital photography systems. Y&#x2032; is the luma component and CB and CR are the blue-difference and red-difference chroma components. Y&#x2032; (with prime) is distinguished from Y, which is luminance, meaning that light intensity is nonlinearly encoded based on gamma corrected RGB primaries.</p><p id="p-0121" num="0158">Chroma subsampling is the practice of encoding images by implementing less resolution for chroma information than for luma information, taking advantage of the human visual system's lower acuity for color differences than for luminance.</p><p id="p-0122" num="0000">3.5.1. 4:4:4</p><p id="p-0123" num="0159">Each of the three Y&#x2032;CbCr components have the same sample rate, thus there is no chroma subsampling. This scheme is sometimes used in high-end film scanners and cinematic post production.</p><p id="p-0124" num="0000">3.5.2. 4:2:2</p><p id="p-0125" num="0160">The two chroma components are sampled at half the sample rate of luma: the horizontal chroma resolution is halved while the vertical chroma resolution is unchanged. This reduces the bandwidth of an uncompressed video signal by one-third with little to no visual difference. An example of nominal vertical and horizontal locations of 4:2:2 color format is depicted in <figref idref="DRAWINGS">FIG. <b>5</b></figref> in VVC working draft.</p><p id="p-0126" num="0000">3.5.3. 4:2:0</p><p id="p-0127" num="0161">In 4:2:0, the horizontal sampling is doubled compared to 4:1:1, but as the Cb and Cr channels are only sampled on each alternate line in this scheme, the vertical resolution is halved. The data rate is thus the same. Cb and Cr are each subsampled at a factor of 2 both horizontally and vertically. There are three variants of 4:2:0 schemes, having different horizontal and vertical siting.<ul id="ul0022" list-style="none">    <li id="ul0022-0001" num="0000">    <ul id="ul0023" list-style="none">        <li id="ul0023-0001" num="0162">In MPEG-2, Cb and Cr are co-sited horizontally. Cb and Cr are sited between pixels in the vertical direction (sited interstitially).</li>        <li id="ul0023-0002" num="0163">In JPEG/JFIF, H.261, and MPEG-1 Cb and Cr are sited interstitially, halfway between alternate luma samples.</li>        <li id="ul0023-0003" num="0164">In 4:2:0 DV, Cb and Cr are co-sited in the horizontal direction. In the vertical direction, they are co-sited on alternating lines.</li>    </ul>    </li></ul></p><p id="p-0128" num="0000"><tables id="TABLE-US-00017" num="00017"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 3-1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>SubWidthC and SubHeightC values derived from chroma_format_idc and</entry></row><row><entry>separate_colour_plane_flag</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="center"/><colspec colname="2" colwidth="77pt" align="center"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="42pt" align="center"/><colspec colname="5" colwidth="42pt" align="center"/><tbody valign="top"><row><entry>chroma_format_</entry><entry>separate_colour_plane_</entry><entry/><entry/><entry/></row><row><entry>idc</entry><entry>flag</entry><entry>Chroma format</entry><entry>SubWidthC</entry><entry>SubHeightC</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>0</entry><entry>0</entry><entry>Monochrome</entry><entry>1</entry><entry>1</entry></row><row><entry>1</entry><entry>0</entry><entry>4:2:0</entry><entry>2</entry><entry>2</entry></row><row><entry>2</entry><entry>0</entry><entry>4:2:2</entry><entry>2</entry><entry>1</entry></row><row><entry>3</entry><entry>0</entry><entry>4:4:4</entry><entry>1</entry><entry>1</entry></row><row><entry>3</entry><entry>1</entry><entry>4:4:4</entry><entry>1</entry><entry>1</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0020" level="1">4. EXAMPLES OF TECHNICAL PROBLEMS SOLVED BY DISCLOSED EMBODIMENTS</heading><p id="p-0129" num="0165">The existing designs for signalling of SPS/PPS/Picture header/Slice header in VVC have the following problems:<ul id="ul0024" list-style="none">    <li id="ul0024-0001" num="0000">    <ul id="ul0025" list-style="none">        <li id="ul0025-0001" num="0166">1) When rect_slice_flag is equal to 1, according to the current VVC text, the following applies:        <ul id="ul0026" list-style="none">            <li id="ul0026-0001" num="0167">a. slice address represents the subpicture-level slice index of the slice.</li>            <li id="ul0026-0002" num="0168">b. The subpicture-level slice index is defined as the index of a slice to the list of slices in a subpicture in the order as they are signalled in the PPS.</li>            <li id="ul0026-0003" num="0169">c. The picture-level slice index is defined as the index of a slice to the list of slices in a picture in the order as they are signalled in the PPS.</li>            <li id="ul0026-0004" num="0170">d. For any two slices belonging to two different subpictures, the one associated with the less subpicture index goes earlier in decoding order, and for any two slices belonging to the same subpicture, the one with the less subpicture-level slice index goes earlier in decoding order.</li>            <li id="ul0026-0005" num="0171">e. And the derivation of the variable NumCtusInCurrSlice, which specifies the number of CTUs in the current slice, by Equation 117 in the current VVC text, assumes that the order of increasing picture-level slice index values is the same as the decoding order of slices.</li>        </ul>        </li>        <li id="ul0025-0002" num="0172">However, when some slices are resulted from splitting one tile, some of the above aspects may be violated. As an example shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, when a picture is partitioned into two tiles by a vertical tile boundary, and each of the two tiles is partitioned into two slices by the same horizontal boundary across the entire picture, and the upper two slices are included into the first subpicture and the lower two slices are included into the second subpicture. In this case, according to the current VVC text, the picture-level slice index values of the four slices in slice raster scan order would be 0, 2, 1, 3, while the decoding order index values of the four slices in slice raster scan order would be 0, 1, 2, 3. Consequently, the derivation of NumCtusInCurrSlice would be incorrect, and in turn the parsing of slice data would be problematic, the decoded sample values won't be correct, and the decoder would likely to crash.</li>        <li id="ul0025-0003" num="0173">2) There are two types of slice signalling methods. With the rectangular mode, all the slice partitioning information is signalled in PPS. With the non-rectangular mode, partial of the slice partitioning information is signalled in the slice header, thus in this mode the full slice partitioning of a picture may not be known before parsing all slices of the picture.</li>        <li id="ul0025-0004" num="0174">3) With the rectangular mode, the slices may be signalled arbitrarily by setting tile_idx_delta. An evil bitstream may make the decoder crash with this mechanism.</li>        <li id="ul0025-0005" num="0175">4) In some embodiments, an uninitialized tile_idx_delta[i] when i is equal to num_slices_in_pic_minus1.</li>    </ul>    </li></ul></p><p id="p-0130" num="0176"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an example of picture partitioning. Solid lines <b>602</b> represent boundaries of tiles; dashed lines <b>604</b> represent boundaries of slices and dashed lines <b>606</b> represent boundaries of subpictures. The picture-level indices, decoding order indices, subpicture-level indices of the four slices and the indices of subpictures and tiles are indicated in the figure.</p><heading id="h-0021" level="1">5. EXAMPLE EMBODIMENTS AND TECHNIQUES</heading><p id="p-0131" num="0177">To solve the above problems, and others, methods as summarized below are disclosed. The embodiments should be considered as examples to explain the general concepts and should not be interpreted in a narrow way. Furthermore, these embodiments can be applied individually or combined in any manner.<ul id="ul0027" list-style="none">    <li id="ul0027-0001" num="0000">    <ul id="ul0028" list-style="none">        <li id="ul0028-0001" num="0178">1. For slices of the rectangular slices mode (i.e., when rect_slice_flag is equal to 1), the picture-level slice index for each slice in each subpicture is derived, and the derived value is used for the derivation of the number of CTUs in each slice.</li>        <li id="ul0028-0002" num="0179">2. The subpicture-level slice index may be defined/derived in the following ways:        <ul id="ul0029" list-style="none">            <li id="ul0029-0001" num="0180">a. In one example, the subpicture-level slice index is defined as &#x201c;The index of a slice to the list of slices in a subpicture in their decoding order when the rect_slice_flag is equal to 1.&#x201d;</li>            <li id="ul0029-0002" num="0181">b. Alternatively, the subpicture-level slice index is defined as &#x201c;The index of a slice to the list of slices in a subpicture when the rect_slice_flag is equal to 1, as specified by the variable SubpicLevelSliceIdx[i] as derived in Equation 32 (as in Embodiment 1), where i is the picture-level slice index of the slice.&#x201d;</li>            <li id="ul0029-0003" num="0182">c. In one example, the subpicture index of each slice with a particular value of picture-level slice index is derived.</li>            <li id="ul0029-0004" num="0183">d. In one example, the subpicture-level slice index of each slice with a particular value of picture-level slice index is derived.</li>            <li id="ul0029-0005" num="0184">e. In one example, when rect_slice_flag is equal to 1, the semantics of the slice address is specified as &#x201c;The slice address is the subpicture-level slice index of the slice as specified by the variable SubpicLevelSliceIdx[i] as derived in Equation 32 (e.g., as in Embodiment 1), where i is the picture-level slice index of the slice.&#x201d;</li>        </ul>        </li>        <li id="ul0028-0003" num="0185">3. A subpicture-level slice index of the slice is assigned to a slice in a first subpicture which contains the slice. The subpicture-level slice index for each slice may be stored in an array (e.g. SubpicLevelSliceIdx[i] in Embodiment 1) indexed by the picture-level slice index.        <ul id="ul0030" list-style="none">            <li id="ul0030-0001" num="0186">a. In one example, the subpicture-level slice index is a non-negative integer.</li>            <li id="ul0030-0002" num="0187">b. In one example, the value of a subpicture-level slice index of the slice is greater than or equal to 0.</li>            <li id="ul0030-0003" num="0188">c. In one example, the value of a subpicture-level slice index of the slice is smaller than N, wherein N is the number of slices in the subpicture.</li>            <li id="ul0030-0004" num="0189">d. In one example, a first subpicture-level slice index (denoted as subIdxA) of a first slice (slice A) may be different to a second subpicture-level slice index (denoted as subIdxB) of a second slice (slice B) if the first slice and the second slice are in the same subpicture but they are different.</li>            <li id="ul0030-0005" num="0190">e. In one example, if a first subpicture-level slice index (denoted as subIdxA) of a first slice (slice A) in a first subpicture is smaller than a second subpicture-level slice index (denoted as subIdxB) of a second slice (slice B) in the same first subpicture, IdxA is smaller than IdxB, wherein idxA and idxB represent the slice index in the whole picture (a.k.a. picture-level slice index, e.g. sliceIdx) for slice A and slice B, respectively.</li>            <li id="ul0030-0006" num="0191">f. In one example, if a first subpicture-level slice index (denoted as subIdxA) of a first slice (slice A) in a first subpicture is smaller than a second subpicture-level slice index (denoted as subIdxB) of a second slice (slice B) in the same first subpicture, slice A is ahead of slice B in the decoding order.</li>            <li id="ul0030-0007" num="0192">g. In one example, the subpicture-level slice index in a subpicture is derived based on the picture-level slice index (e.g. sliceIdx).</li>        </ul>        </li>        <li id="ul0028-0004" num="0193">4. It is proposed to derive a mapping function/table between the subpicture-level slice index in a sub-picture and the picture-level slice index.        <ul id="ul0031" list-style="none">            <li id="ul0031-0001" num="0194">a. In one example, a two-dimensional array PicLevelSliceIdx[subPicIdx] [SubPicLevelSliceIdx] is derived to map the subpicture-level slice index in a sub-picture to the picture-level slice index, wherein PicLevelSliceIdxdenotes the picture-level slice index of a slice, subPicIdx denotes the index of the subpicture, and SubPicLevelSliceIdxdenotes the subpicture-level slice index of the slice in the subpicture.            <ul id="ul0032" list-style="none">                <li id="ul0032-0001" num="0195">i. In one example, an array NumSlicesInSubpic[subPicIdx] is used to derive PicLevelSliceIdx, wherein NumSlicesInSubpic[subPicIdx] denotes the number of slices in the subpicture with index equal to subPicIdx.                <ul id="ul0033" list-style="none">                    <li id="ul0033-0001" num="0196">1) In one example, NumSlicesInSubpic[subPicIdx] and PicLevelSliceIdx [subPicIdx] [SubPicLevelSliceIdx] are derived in a single process by scanning all the slices in the order of picture-level slice index.</li>                    <li id="ul0033-0002" num="0000">&#x2003;a. NumSlicesInSubpic[subPicIdx] is set equal to 0 for all valid subPicIdx before the process.</li>                    <li id="ul0033-0003" num="0000">&#x2003;b. When checking a slice with picture level index equal to S, if it is in the subpicture with subpicture index equal to P, PicLevelSliceIdx[P] [NumSlicesInSubpic[P]] is set equal to S, and then NumSlicesInSubpic[P] is set equal to NumSlicesInSubpic[P]+1.</li>                </ul>                </li>                <li id="ul0032-0002" num="0197">ii. In one example, SliceldxInPic[subPicIdx] [SubPicLevelSliceIdx] is used to derive the picture level slice index (e.g. picLevelSliceIdx), which is then used to derive the number and/or addresses of CTBs in the slice when parsing the slice header.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0028-0005" num="0198">5. For a conformance bitstream, one tile may not be permitted to be in more than one subpictures.</li>        <li id="ul0028-0006" num="0199">6. For a conformance bitstream, one subpicture may not be permitted to include two slices, denoted as slice A and slice B, wherein slice A is in but is smaller than a tile A, and slice B is in but is smaller than a tile B, and tile A and tile B are different.</li>        <li id="ul0028-0007" num="0200">7. It is proposed that the tile and/or slice portioning information of a picture may be signalled in the associated picture header.        <ul id="ul0034" list-style="none">            <li id="ul0034-0001" num="0201">a. In one example, it is signalled in an associated PPS whether the tile and/or slice portioning information of a picture is signalled in the PPS or in the associated picture header.</li>            <li id="ul0034-0002" num="0202">b. In one example, it is signalled in the picture header whether the tile and/or slice portioning information of a picture is in the associated picture header.            <ul id="ul0035" list-style="none">                <li id="ul0035-0001" num="0203">i. In one example, if the tile and/or slice portioning information of a picture is signalled both in an associated PPS and in an associated picture header, the tile and/or slice portioning information of a picture signalled in the picture header will be used.</li>                <li id="ul0035-0002" num="0204">ii. In one example, if the tile and/or slice portioning information of a picture is signalled both in an associated PPS and in an associated picture header, the tile and/or slice portioning information of a picture signalled in the PPS will be used.</li>            </ul>            </li>            <li id="ul0034-0003" num="0205">c. In one example, it is signalled in a video unit at a level higher than picture (such as in SPS) to indicate whether the tile and/or slice portioning information of a picture is signalled in the associated PPS or in the associated picture header.</li>        </ul>        </li>        <li id="ul0028-0008" num="0206">8. It is proposed that the slice partitioning information is signalled in a higher-level video unit (such as in PPS and/or picture header) higher than the slice level when the associated picture is partitioned in slices with the non-rectangular mode.        <ul id="ul0036" list-style="none">            <li id="ul0036-0001" num="0207">a. In one example, the information to indicate the number of slices (e.g. num_slices_in_pic_minus1) may be signalled in the higher-level video unit when the associated picture is partitioned in slices with the non-rectangular mode.</li>            <li id="ul0036-0002" num="0208">b. In one example, the information to indicate the index (or address, or location, or coordinate) of the first block-unit of a slice in the higher-level video unit when the associated picture is partitioned in slices with the non-rectangular mode. For example, the block-unit may be a CTU or a tile.</li>            <li id="ul0036-0003" num="0209">c. In one example, the information to indicate the number of the block-units of a slice in the higher-level video unit when the associated picture is partitioned in slices with the non-rectangular mode. For example, the block-unit may be a CTU or a tile.</li>            <li id="ul0036-0004" num="0210">d. In one example, the slice partitioning information (e.g. num_tiles_in_slice_minus1) is not signalled in the slice header when the associated picture is partitioned in slices with the non-rectangular mode.</li>            <li id="ul0036-0005" num="0211">e. In one example, the slice index is signalled in the slice header when the associated picture is partitioned in slices with the non-rectangular mode.            <ul id="ul0037" list-style="none">                <li id="ul0037-0001" num="0212">i. In one example, slice_address is interpreted as the picture-level slice index when the associated picture is partitioned in slices with the non-rectangular mode.</li>            </ul>            </li>            <li id="ul0036-0006" num="0213">f. In one example, the partitioning information (such as the index of the first block-unit and/or the number of the block-units) of each slice in a picture may be signalled in an order in the higher-level video unit when the associated picture is partitioned in slices with the non-rectangular mode.            <ul id="ul0038" list-style="none">                <li id="ul0038-0001" num="0214">i. In one example, the index of a slice may be signalled for each slice in the higher-level video unit when the associated picture is partitioned in slices with the non-rectangular mode.</li>                <li id="ul0038-0002" num="0215">ii. In one example, the partitioning information of each slice is signalled in an ascending order of slice indices.                <ul id="ul0039" list-style="none">                    <li id="ul0039-0001" num="0000">&#x2003;1) In one example, the partitioning information of each slice is signalled in the order of slice 0, slice 1, . . . , slice K&#x2212;1, slice K, slice K+1, . . . slice S&#x2212;2, slice S&#x2212;1, wherein K represents a slice index and S represents the number of slices in the picture.</li>                </ul>                </li>                <li id="ul0038-0003" num="0216">iii. In one example, the partitioning information of each slice is signalled in a descending order of slice indices.                <ul id="ul0040" list-style="none">                    <li id="ul0040-0001" num="0000">&#x2003;1) In one example, the partitioning information of each slice is signalled in the order of slice S&#x2212;2, slice S&#x2212;1, . . . , slice K+1, slice K, slice K&#x2212;1, . . . , slice 1, slice 0, wherein K represents a slice index and S represents the number of slices in the picture.</li>                </ul>                </li>                <li id="ul0038-0004" num="0217">iv. In one example, the index of the first block-unit for a slice may not be signalled in the higher-level video unit when the associated picture is partitioned in slices with the non-rectangular mode.                <ul id="ul0041" list-style="none">                    <li id="ul0041-0001" num="0218">1) For example, the index of the first block-unit for slice 0 (the slice with the slice index equal to 0) is inferred to be 0.</li>                    <li id="ul0041-0002" num="0219">2) For example, the index of the first block-unit for slice K (the slice with the slice index equal to K, K&#x3e;0) is inferred to be &#x3a3;<sub>i=0</sub><sup>K&#x2212;1</sup>N<sub>i</sub>, wherein N<sub>i </sub>represents the number of block-units in slice i.</li>                </ul>                </li>                <li id="ul0038-0005" num="0220">v. In one example, the index of the first block-unit for a slice may not be signalled in the higher-level video unit when the associated picture is partitioned in slices with the non-rectangular mode.                <ul id="ul0042" list-style="none">                    <li id="ul0042-0001" num="0221">1) For example, the index of the first block-unit for slice 0 (the slice with the slice index equal to 0) is inferred to be 0.</li>                    <li id="ul0042-0002" num="0222">2) For example, the index of the first block-unit for slice K (the slice with the slice index equal to K, K&#x3e;0) is inferred to be &#x3a3;<sub>i=0</sub><sup>K&#x2212;1</sup>N<sub>i</sub>, wherein N<sub>i </sub>represents the number of block-units in slice i.</li>                </ul>                </li>                <li id="ul0038-0006" num="0223">vi. In one example, the number of block-units for a slice may not be signalled in the higher-level video unit when the associated picture is partitioned in slices with the non-rectangular mode.                <ul id="ul0043" list-style="none">                    <li id="ul0043-0001" num="0224">1) The number of block-units for slice 0 is M when there is only one slice in the picture and there are M blocks units in the picture.</li>                    <li id="ul0043-0002" num="0225">2) For example, the number of block-units for slice K (the slice with the slice index equal to 0) is inferred to be T<sub>K+1</sub>&#x2212;T<sub>K</sub>, wherein T<sub>K </sub>represents the index of the first block-unit for slice K when K&#x3c;S&#x2212;1, wherein S is the number of slices in the picture and S&#x3e;1.</li>                    <li id="ul0043-0003" num="0226">3) For example, the number of block-units for slice S&#x2212;1 is inferred to be M&#x2212;&#x3a3;<sub>i=0</sub><sup>S&#x2212;2</sup>N<sub>i</sub>, wherein S is the number of slices in the picture and S&#x3e;1, M is the number of blocks units in the picture.</li>                </ul>                </li>                <li id="ul0038-0007" num="0227">vii. In one example, the partitioning information of one or more slices may NOT be signalled in the higher-level video unit when the associated picture is partitioned in slices with the non-rectangular mode.                <ul id="ul0044" list-style="none">                    <li id="ul0044-0001" num="0228">1) In one example, the partitioning information of one or more slices may NOT be signalled in the higher-level video unit may be inferred by the partitioning information of other slices to be signalled.</li>                    <li id="ul0044-0002" num="0229">2) In one example, the partitioning information of the last C slices may NOT be signalled. E.g. C is equal to 1.</li>                    <li id="ul0044-0003" num="0230">3) For example, the number of block-units for slice S&#x2212;1 is not signalled, wherein S is the number of slices in the picture and S&#x3e;1.</li>                    <li id="ul0044-0004" num="0000">&#x2003;a. For example, the number of block-units for slice S&#x2212;1 is inferred to be M&#x2212;&#x3a3;<sub>i=0</sub><sup>S&#x2212;2</sup>N<sub>i</sub>, wherein there are M blocks units in the picture.</li>                </ul>                </li>            </ul>            </li>        </ul>        </li>        <li id="ul0028-0009" num="0231">9. It is proposed that the minimum number of slices in a picture may be different depending on whether rectangular partitioning is applied, or non-rectangular partitioning is applied.        <ul id="ul0045" list-style="none">            <li id="ul0045-0001" num="0232">a. In one example, the picture is partitioned into at least two slices if non-rectangular partitioning mode is applied, and the picture is partitioned into at least one slice if rectangular partitioning mode is applied.            <ul id="ul0046" list-style="none">                <li id="ul0046-0001" num="0233">i. For example, num_slices_in_pic_minus2 plus 2 specifying the number of slices in a picture may be signalled if non-rectangular partitioning mode is applied.</li>            </ul>            </li>            <li id="ul0045-0002" num="0234">b. In one example, the picture is partitioned into at least one slices if non-rectangular partitioning mode is applied, and the picture is partitioned into at least one slice if rectangular partitioning mode is applied.            <ul id="ul0047" list-style="none">                <li id="ul0047-0001" num="0235">i. For example, num_slices_in_pic_minus2 plus 2 specifying the number of slices in a picture may be signalled if rectangular partitioning mode is applied.</li>                <li id="ul0047-0002" num="0236">c. In one example, the minimum number of slices in a picture may be different depending on whether rectangular partitioning is applied, or non-rectangular partitioning is applied when the picture is not partitioned into subpictures or partitioned into only one subpicture.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0028-0010" num="0237">10. It is proposed that a slice is represented by the top-left location and the width/height of the slice when the partitioning information is signalled in a video unit such as PPS or picture header.        <ul id="ul0048" list-style="none">            <li id="ul0048-0001" num="0238">a. In one example, the index/location/coordinate of the top-left block-unit (such as CTU or tile) and/or the width measured with video unit (such as CTU or tile), and/or height measured with video unit (such as CTU or tile) of a slice is signalled.</li>            <li id="ul0048-0002" num="0239">b. In one example, the information of top-left location and the width/height of each slice is signalled in an order.            <ul id="ul0049" list-style="none">                <li id="ul0049-0001" num="0240">i. For example, the information of top-left location and the width/height of each slice is signalled in an ascending order of slice indices, such as 0, 1, 2, . . . , S&#x2212;1, wherein S is the number of slices in a picture.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0028-0011" num="0241">11. It is proposed that the partitioning information (such as location/width/height) for slices in a subpicture is signalled in a video unit such as SPS/PPS/picture header.        <ul id="ul0050" list-style="none">            <li id="ul0050-0001" num="0242">a. In one example, the slice partitioning information for each subpicture is signalled in an order.            <ul id="ul0051" list-style="none">                <li id="ul0051-0001" num="0243">i. For example, the slice partitioning information for each subpicture is signalled in an ascending order of subpicture index.</li>            </ul>            </li>            <li id="ul0050-0002" num="0244">b. In one example, the partitioning information (such as location/width/height) for each slice in a subpicture is signalled in an order.            <ul id="ul0052" list-style="none">                <li id="ul0052-0001" num="0245">i. In one example, the partitioning information (such as location/width/height) for each slice in a subpicture is signalled in an ascending order of subpicture-level slice index.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0028-0012" num="0246">12. It is proposed that the difference between the tile index of the first tile in the i-th rectangular slice and the tile index of the first tile in the (i+1)-th rectangular slice (denoted as tile_idx_delta[i]) is not signalled but derived.        <ul id="ul0053" list-style="none">            <li id="ul0053-0001" num="0247">a. In one example, the tile index of the first tile in the (i+1)-th rectangular slice is derived based on the rectangular slices from the 0<sup>th </sup>rectangular slice to the i-th rectangular slice.</li>            <li id="ul0053-0002" num="0248">b. In one example, the tile index of the first tile in the (i+1)-th rectangular slice is derived to be the minimum index of the tiles, which are not inside the rectangular slices from the 0<sup>th </sup>rectangular slice to the i-th rectangular slice.</li>        </ul>        </li>        <li id="ul0028-0013" num="0249">13. It is proposed that the signalling of information to derive the number of tile columns/rows (e.g. NumTileColumns or NumTileRows) may be conditioned on the relationship between the width of a picture and the size of a CTU.</li>        <li id="ul0028-0014" num="0250">a. For example, num_exp_tile_columns_minus1 and/or tile_column_width_minus1 may not be signalled if the width of a picture is smaller than or equal to the size or width of a CTU.</li>        <li id="ul0028-0015" num="0251">b. For example, num_exp_tile_rows_minus1 and/or tile_row_height_minus1 may not be signalled if the height of a picture is smaller than or equal to the size or height of a CTU.</li>        <li id="ul0028-0016" num="0252">14. There may be one and only one CurrSubpicIdx that satisfies SubpicIdVal[CurrSubpicIdx] is equal to slice_subpic_id when slice_subpic_id is present.</li>        <li id="ul0028-0017" num="0253">15. If rect_slice_flag is equal to 0 or subpic_info_present_flag is equal to 0, the value of slice_address+i, wherein i is in the range of 0 to num_tiles_in_slice_minus1, inclusively, may not be equal to the value of slice_address+j, wherein j is in the range of 0 to num_tiles_in_slice_minus1, inclusively, of any other coded slice NAL unit of the same coded picture, wherein i is in the range.</li>        <li id="ul0028-0018" num="0254">16. In case that there are both uniform spacing tiles and non-uniform spacing tiles in pictures, a syntax element may be signalled in PPS (or SPS) to specify the type of tile layout.        <ul id="ul0054" list-style="none">            <li id="ul0054-0001" num="0255">a. In one example, there may be a syntax flag signalled in PPS to specify whether the tile layout is non-uniform spacing followed by uniform spacing, or, uniform spacing followed by non-uniform spacing.</li>            <li id="ul0054-0002" num="0256">b. For example, whenever there are non-uniform spacing tiles, the number of explicitly provided tile columns/rows (e.g., num_exp_tile_columns_minus1, num_exp_tile_rows_minus1) may be NO less than the total number of non-uniform tiles.</li>            <li id="ul0054-0003" num="0257">c. For example, whenever there are uniform spacing tiles, the number of explicitly provided tile columns/rows (e.g., num_exp_tile_columns_minus1, num_exp_tile_rows_minus1) may be less or equal to the total number of uniform tiles.</li>            <li id="ul0054-0004" num="0258">d. If the tile layout is like uniform spacing followed by non-uniform spacing (i.e., a picture is starting with uniform spacing tiles and ended with multiple non-uniform spacing tiles).            <ul id="ul0055" list-style="none">                <li id="ul0055-0001" num="0259">i. In one example, the widths of tile columns for non-uniform spacing tiles located in the latter of picture may be firstly assigned in inverse order (i.e., with the order of the tile index equal to NumTileColumns, NumTileColumns&#x2212;1, NumTileColumns&#x2212;2, . . . ), and then the widths of tile columns for uniform spacing tiles located in the former of picture may be implicitly derived in inverse order (i.e., with the order of the tile index equal to NumTileColumns&#x2212;T, NumTileColumns&#x2212;T&#x2212;1, . . . , 2, 1, 0, where T indicate the number of non-uniform tile columns).</li>                <li id="ul0055-0002" num="0260">ii. The heights of tile rows may be derived in a same way of the width of tile columns as mentioned above.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0028-0019" num="0261">17. The syntax element to specify the difference between the representative tile indices of two rectangular slices, wherein one of them is the i-th slice (e.g. tile_idx_delta[i]) can only be used when a condition is true.        <ul id="ul0056" list-style="none">            <li id="ul0056-0001" num="0262">a. In one example, the condition is (i&#x3c;num_slices_in_pic_minus1), wherein num_slices_in_pic_minus1 plus 1 represents the number of slices in the picture.</li>            <li id="ul0056-0002" num="0263">b. In one example, the condition is (i!=num_slices_in_pic_minus1), wherein num_slices_in_pic_minus1 plus 1 represents the number of slices in the picture.</li>        </ul>        </li>        <li id="ul0028-0020" num="0264">18. Whether to and/or how to signal or interpret or restrict the Merge Estimation Region (MER) size (e.g. signalled by log2_parallel_merge_level_minus2) may depend on the minimum allowed coding block size (e.g. signalled/denoted as log2_min_luma_coding_block_size_minus2 and/or MinCbSizeY).        <ul id="ul0057" list-style="none">            <li id="ul0057-0001" num="0265">a. In one example, the size of MER may not be smaller than the minimum allowed coding block size.            <ul id="ul0058" list-style="none">                <li id="ul0058-0001" num="0266">i. For example, log2_parallel_merge_level_minus2 may be equal to or larger than log2_min_luma_coding_block_size_minus2.</li>                <li id="ul0058-0002" num="0267">ii. For example, log2_parallel_merge_level_minus2 may be in the range of log2_min_luma_coding_block_size_minus2 to CtbLog2SizeY&#x2212;2.</li>            </ul>            </li>            <li id="ul0057-0002" num="0268">b. In one example, the difference between Log2(MER size) and Log2(MinCbSizeY) is signalled, which is denoted as log2_parallel_merge_level_minus_log2_mincb.            <ul id="ul0059" list-style="none">                <li id="ul0059-0001" num="0269">i. For example, log2_parallel_merge_level_minus_log2_mincb is coded by a unary code (ue).</li>                <li id="ul0059-0002" num="0270">ii. For example, log2_parallel_merge_level_minus_log2_mincb may be in the range of 0 to CtbLog2SizeY&#x2212;log2_min_luma_coding_block_size_minus2&#x2212;2.</li>                <li id="ul0059-0003" num="0271">iii. For example, Log2ParMrgLevel=log2_parallel_merge_level_minus_log2_mincb+log2_min_luma_coding_block_size_minus2+2, wherein Log2ParMrgLevel is used to control the MER size.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0028-0021" num="0272">19. It is proposed that, when num_exp_slices_in_tile[i] is equal to 0, the slice height in units of CTU rows for the i-th slice, e.g., denoted as sliceHeightInCtus[i], is derived.        <ul id="ul0060" list-style="none">            <li id="ul0060-0001" num="0273">a. In one example, sliceHeightInCtus[i] is derived to be equal to RowHeight[SliceTopLeftTileIdx[i]/NumTileColumns] when num_exp_slices_in_tile[i] is equal to 0.</li>        </ul>        </li>        <li id="ul0028-0022" num="0274">20. It is proposed that the (num_exp_slices_in_tile[i]&#x2212;1)-th slice in the tile containing the i-th slice in a picture always exists and the height is always exp_slice_height_in_ctus_minus1[i] [num_exp_slices_in_tile[i]&#x2212;1]+1 CTU rows.        <ul id="ul0061" list-style="none">            <li id="ul0061-0001" num="0275">a. Alternatively, the (num_exp_slices_in_tile[i]&#x2212;1)-th slice in the tile containing the i-th slice in a picture may or may not exist and the height is less than or equal to exp_slice_height_in_ctus_minus1[i] [num_exp_slices_in_tile[i]&#x2212;1]+1 CTU rows.</li>        </ul>        </li>        <li id="ul0028-0023" num="0276">21. It is proposed that, during the derivation of information for rectangular slices, the variable tileIdx is only updated for slices with picture-level slice index less than num_slices_in_pic_minus1, i.e., not updated for the last slice in each picture referring to the PPS.</li>        <li id="ul0028-0024" num="0277">22. It is proposed that the num_exp_tile_columns_minus1-th tile column always exists in pictures referring to the PPS and the width is always tile_column_width_minus1[num_exp_tile_columns_minus1]+1 CTBs.</li>        <li id="ul0028-0025" num="0278">23. It is proposed that the num_exp_tile_rows_minus1-th tile row always exists in pictures referring to the PPS and the height is always tile_column_height_minus1[num_exp_tile_rows_minus1]+1 CTBs.</li>        <li id="ul0028-0026" num="0279">24. It is proposed that, when the max picture width and the max picture height are both not greater than CtbSizeY, the signalling of the syntax element sps_num_subpics_minus1 may be skipped.        <ul id="ul0062" list-style="none">            <li id="ul0062-0001" num="0280">a. Alternatively, additionally, the value of sps_num_subpics_minus1 is inferred to be equal to 0 when the above condition is true.</li>        </ul>        </li>        <li id="ul0028-0027" num="0281">25. It is proposed that, when the picture width is not greater than CtbSizeY, the signalling of the syntax element num_exp_tile_columns_minus1 may be skipped.        <ul id="ul0063" list-style="none">            <li id="ul0063-0001" num="0282">b. Alternatively, additionally, the value of num_exp_tile_columns_minus1 is inferred to be equal to 0 when the above condition is true.</li>        </ul>        </li>        <li id="ul0028-0028" num="0283">26. It is proposed that, when the picture height is not greater than CtbSizeY, the signalling of the syntax element num_exp_tile_rows_minus1 may be skipped.        <ul id="ul0064" list-style="none">            <li id="ul0064-0001" num="0284">c. Alternatively, additionally, the value of num_exp_tile_row_minus1 is inferred to be equal to 0 when the above condition is true.</li>        </ul>        </li>        <li id="ul0028-0029" num="0285">27. It is proposed that, when num_exp_tile_columns_minus1 is equal to PicWidthInCtbsY&#x2212;1, the signalling of the syntax elements tile_column_width_minus1 [i] for i ranging from 0 to num_exp_tile_columns_minus1, inclusive, may be skipped.        <ul id="ul0065" list-style="none">            <li id="ul0065-0001" num="0286">d. Alternatively, additionally, the value of tile_column_width_minus1[i] is inferred to be equal to 0.</li>        </ul>        </li>        <li id="ul0028-0030" num="0287">28. It is proposed that, when num_exp_tile_rows_minus1 is equal to PicHeightInCtbsY&#x2212;1, the signalling of the syntax elements tile_row_height_minus1[i] for i ranging from 0 to num_exp_tile_rows_minus1, inclusive, may be skipped.        <ul id="ul0066" list-style="none">            <li id="ul0066-0001" num="0288">e. Alternatively, additionally, the value of tile_row_height_minus1 [i] is inferred to be equal to 0.</li>        </ul>        </li>        <li id="ul0028-0031" num="0289">29. It is proposed that the height of uniform slices that partition a tile is indicated by the last entry of exp_slice_height_in_ctus_minus1[ ]s that indicate height of slices in that tile. Uniform slices are slices below slices explicitly signalled. For example: uniformSliceHeight=exp_slice_height_in_ctus_minus1[i] [num_exp_slices_in_tile[i]&#x2212;1]+1</li>        <li id="ul0028-0032" num="0290">30. It is proposed that the width of &#x2018;num_exp_tile_columns_minus1&#x2019;-th tile column is disallowed to be reset, that is, the parsed value from the bitstream (e.g., denoted by tile_column_width_minus1[num_exp_tile_columns_minus1]) may be directly used to derive the width without referring other information.        <ul id="ul0067" list-style="none">            <li id="ul0067-0001" num="0291">a. In one example, the width of &#x2018;num_exp_tile_columns_minus1&#x2019;-th tile column is directly set to tile_column_width_minus1[num_exp_tile_columns_minus1] plus 1. Alternatively, furthermore, tile_column_width_minus1[num_exp_tile_columns_minus1] is used to derive the width of the tile columns with index greater than num_exp_tile_columns_minus1, e.g., as specified in clause 6.5.1.</li>            <li id="ul0067-0002" num="0292">b. Similarly, for the height of &#x2018;num_exp_tile_columns_minus1&#x2019;-th tile row is disallowed to be reset, that is, the parsed value from the bitstream (e.g., denoted by tile_row_height_minus1[num_exp_tile_columns_minus1]) may be directly used to derive the height without referring other information.            <ul id="ul0068" list-style="none">                <li id="ul0068-0001" num="0293">i. In one example, the height of &#x2018;num_exp_tile_columns_minus1&#x2019;-th tile row is directly set to tile_row_height_minus1 [num_exp_tile_columns_minus1] plus 1. Alternatively, furthermore, tile_row_height_minus1[num_exp_tile_columns_minus1] is used to derive the height of the tile rows with index greater than num_exp_tile_columns_minus1, e.g., as specified in clause 6.5.1.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0028-0033" num="0294">31. It is proposed that the height of the (num_exp_slices_in_tile[i]&#x2212;1)-th slice in a tile is disallowed to be reset, that is, the parsed value from the bitstream (e.g., denoted by exp_slice_height_in_ctus_minus1[i] [num_exp_slices_in_tile[i]&#x2212;1]) may be directly used to derive the height without referring other information.        <ul id="ul0069" list-style="none">            <li id="ul0069-0001" num="0295">a. In one example, the height of the (num_exp_slices_in_tile[i]&#x2212;1)-th slice in a tile is directly set to exp_slice_height_in_ctus_minus1 [i] [num_exp_slices_in_tile[i]&#x2212;1] plus 1. Alternatively, furthermore, exp_slice_height_in_ctus_minus1[i] [num_exp_slices_in_tile[i]&#x2212;1] is used to derive the height of the slices with index greater than num_exp_slices_in_tile[i]&#x2212;1.</li>        </ul>        </li>    </ul>    </li></ul></p><heading id="h-0022" level="1">6. EMBODIMENTS</heading><p id="p-0132" num="0296">In the embodiments below, the added portions are marked as bold, underlined, and italicized texts. The deleted portions are marked within.</p><heading id="h-0023" level="1">6.1. Embodiment 1: Example Subpicture Level Slice Index Changes</heading><heading id="h-0024" level="1">3 Definitions</heading><p id="p-0133" num="0000"><ul id="ul0070" list-style="none">    <li id="ul0070-0001" num="0000">    <ul id="ul0071" list-style="none">        <li id="ul0071-0001" num="0297">picture-level slice index: <img id="CUSTOM-CHARACTER-00001" he="2.79mm" wi="5.67mm" file="US20230007307A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/> index of a slice to the list of slices in a picture in the order as they are signalled in the PPS when the rect_slice_flag is equal to 1.</li>        <li id="ul0071-0002" num="0298">[[subpicture-level slice index: An index of a slice to the list of slices in a subpicture in the order as they are signalled in the PPS when the rect_slice_flag is equal to 1.]] <img id="CUSTOM-CHARACTER-00002" he="3.22mm" wi="15.16mm" file="US20230007307A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00003" he="2.79mm" wi="21.17mm" file="US20230007307A1-20230105-P00003.TIF" alt="custom-character" img-content="character" img-format="tif"/>: <img id="CUSTOM-CHARACTER-00004" he="3.22mm" wi="17.61mm" file="US20230007307A1-20230105-P00004.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00005" he="2.79mm" wi="16.93mm" file="US20230007307A1-20230105-P00005.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00006" he="3.22mm" wi="15.49mm" file="US20230007307A1-20230105-P00006.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00007" he="3.22mm" wi="20.15mm" file="US20230007307A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00008" he="2.79mm" wi="10.24mm" file="US20230007307A1-20230105-P00008.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00009" he="3.22mm" wi="12.36mm" file="US20230007307A1-20230105-P00009.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00010" he="2.79mm" wi="15.49mm" file="US20230007307A1-20230105-P00010.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00011" he="3.22mm" wi="17.61mm" file="US20230007307A1-20230105-P00011.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00012" he="3.22mm" wi="23.28mm" file="US20230007307A1-20230105-P00012.TIF" alt="custom-character" img-content="character" img-format="tif"/>.</li>    </ul>    </li></ul></p><heading id="h-0025" level="2">6.5.1 CTB Raster Scanning, Tile Scanning, and Subpicture Scanning Processes</heading><p id="p-0134" num="0299">. . .</p><p id="p-0135" num="0300">[[The list NumSlicesInSubpic[i], specifying the number of rectangular slices in the i-th subpicture,]] <img id="CUSTOM-CHARACTER-00013" he="2.79mm" wi="16.93mm" file="US20230007307A1-20230105-P00013.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00014" he="2.79mm" wi="14.48mm" file="US20230007307A1-20230105-P00014.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00015" he="3.22mm" wi="18.03mm" file="US20230007307A1-20230105-P00015.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00016" he="3.22mm" wi="18.71mm" file="US20230007307A1-20230105-P00016.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00017" he="3.22mm" wi="14.82mm" file="US20230007307A1-20230105-P00017.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00018" he="3.22mm" wi="23.62mm" file="US20230007307A1-20230105-P00018.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00019" he="3.22mm" wi="28.62mm" file="US20230007307A1-20230105-P00019.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00020" he="3.22mm" wi="25.74mm" file="US20230007307A1-20230105-P00020.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00021" he="3.22mm" wi="20.15mm" file="US20230007307A1-20230105-P00021.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00022" he="3.22mm" wi="18.71mm" file="US20230007307A1-20230105-P00022.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00023" he="3.22mm" wi="30.73mm" file="US20230007307A1-20230105-P00023.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00024" he="3.22mm" wi="31.41mm" file="US20230007307A1-20230105-P00024.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00025" he="2.79mm" wi="34.54mm" file="US20230007307A1-20230105-P00025.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00026" he="3.22mm" wi="32.85mm" file="US20230007307A1-20230105-P00026.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00027" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00027.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00028" he="3.22mm" wi="28.62mm" file="US20230007307A1-20230105-P00028.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00029" he="3.22mm" wi="32.09mm" file="US20230007307A1-20230105-P00029.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00030" he="3.22mm" wi="24.38mm" file="US20230007307A1-20230105-P00030.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00031" he="2.79mm" wi="35.31mm" file="US20230007307A1-20230105-P00031.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00032" he="3.22mm" wi="34.97mm" file="US20230007307A1-20230105-P00032.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00033" he="3.22mm" wi="28.62mm" file="US20230007307A1-20230105-P00033.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00034" he="3.22mm" wi="26.84mm" file="US20230007307A1-20230105-P00034.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00035" he="3.22mm" wi="33.19mm" file="US20230007307A1-20230105-P00035.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00036" he="2.79mm" wi="21.17mm" file="US20230007307A1-20230105-P00036.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00037" he="2.79mm" wi="17.61mm" file="US20230007307A1-20230105-P00037.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00038" he="3.22mm" wi="20.15mm" file="US20230007307A1-20230105-P00038.TIF" alt="custom-character" img-content="character" img-format="tif"/> derived as follows:</p><p id="p-0136" num="0000"><tables id="TABLE-US-00018" num="00018"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="203pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( j = 0; j &#x3c;= sps_num_subpics_minus1; j++ )</entry><entry/></row><row><entry>&#x2003;NumSlicesInSubpic[ j ] = 0</entry><entry/></row><row><entry>for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;posX = CtbAddrInSlice[ i ][ 0 ] % PicWidthInCtbsY</entry><entry/></row><row><entry>&#x2003;posY = CtbAddrInSlice[ i ][ 0 ] / PicWidthInCtbsY</entry><entry/></row><row><entry>&#x2003;for( j = 0; j &#x3c;= sps_num_subpics_minus1; j++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( ( posX &#x3e;= subpic_ctu_top_left_x[ j ] ) &#x26;&#x26;</entry><entry>(32)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posX &#x3c; subpic_ctu_top_left_x[ j ] + subpic_width_minus1[ j ] + 1 )</entry></row><row><entry>&#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3e;= subpic_ctu_top_left_y[ j ] ) &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3c; subpic_ctu_top_left_y[ j ] + subpic_height_minus1[ j ] + 1 ) ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00039" he="3.22mm" wi="32.43mm" file="US20230007307A1-20230105-P00039.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00040" he="3.22mm" wi="31.75mm" file="US20230007307A1-20230105-P00040.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; = &#x2009;<img id="CUSTOM-CHARACTER-00041" he="3.22mm" wi="31.07mm" file="US20230007307A1-20230105-P00041.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00042" he="3.22mm" wi="28.62mm" file="US20230007307A1-20230105-P00042.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00043" he="3.22mm" wi="38.10mm" file="US20230007307A1-20230105-P00043.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="203pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2003;NumSlicesInSubpic[ j ]++</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>...</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0137" num="0301">7.4.8.1 General Slice Header Semantics</p><p id="p-0138" num="0000">. . .<br/>slice_address specifies the slice address of the slice. When not present, the value of slice_address is inferred to be equal to 0. When rect_slice_flag is equal to 1 and NumSlicesInSubpic[CurrSubpicIdx] is equal to 1, the value of slice_address is inferred to be equal to 0.<br/>If rect_slice_flag is equal to 0, the following applies:&#x2014;<ul id="ul0072" list-style="none">    <li id="ul0072-0001" num="0000">    <ul id="ul0073" list-style="none">        <li id="ul0073-0001" num="0302">The slice address is the raster scan tile index.</li>        <li id="ul0073-0002" num="0303">The length of slice_address is Ceil(Log2 (NumTilesInPic)) bits.</li>        <li id="ul0073-0003" num="0304">The value of slice_address may be in the range of 0 to NumTilesInPic&#x2212;1, inclusive.<br/>Otherwise (rect_slice_flag is equal to 1), the following applies:</li>        <li id="ul0073-0004" num="0305">The slice_address is the subpicture-level slice index of the slice <img id="CUSTOM-CHARACTER-00044" he="3.22mm" wi="15.49mm" file="US20230007307A1-20230105-P00044.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00045" he="3.22mm" wi="19.73mm" file="US20230007307A1-20230105-P00045.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00046" he="3.22mm" wi="16.59mm" file="US20230007307A1-20230105-P00046.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00047" he="3.22mm" wi="15.92mm" file="US20230007307A1-20230105-P00047.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00048" he="2.79mm" wi="13.38mm" file="US20230007307A1-20230105-P00048.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00049" he="3.22mm" wi="18.03mm" file="US20230007307A1-20230105-P00049.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00050" he="2.79mm" wi="19.39mm" file="US20230007307A1-20230105-P00050.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00051" he="3.22mm" wi="16.93mm" file="US20230007307A1-20230105-P00051.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00052" he="3.22mm" wi="18.37mm" file="US20230007307A1-20230105-P00052.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00053" he="2.79mm" wi="11.68mm" file="US20230007307A1-20230105-P00053.TIF" alt="custom-character" img-content="character" img-format="tif"/></li>        <li id="ul0073-0005" num="0306">The length of slice_address is Ceil(Log2(NumSlicesInSubpic[CurrSubpicIdx])) bits.</li>        <li id="ul0073-0006" num="0307">The value of slice_address may be in the range of 0 to NumSlicesInSubpic[CurrSubpicIdx]&#x2212;1, inclusive.</li>    </ul>    </li></ul></p><p id="p-0139" num="0308">For bitstream conformance, the following constraints may apply:&#x2014;<ul id="ul0074" list-style="none">    <li id="ul0074-0001" num="0000">    <ul id="ul0075" list-style="none">        <li id="ul0075-0001" num="0309">If rect_slice_flag is equal to 0 or subpic_info_present_flag is equal to 0, the value of slice_address may not be equal to the value of slice_address of any other coded slice NAL unit of the same coded picture.</li>        <li id="ul0075-0002" num="0310">Otherwise, the pair of slice_subpic_id and slice_address values may not be equal to the pair of slice_subpic_id and slice_address values of any other coded slice NAL unit of the same coded picture.</li>        <li id="ul0075-0003" num="0311">The shapes of the slices of a picture may be such that each CTU, when decoded, may have its entire left boundary and entire top boundary consisting of a picture boundary or consisting of boundaries of previously decoded CTU(s).<br/>. . .</li>        <li id="ul0075-0004" num="0312">num_tiles_in_slice_minus1 plus 1, when present, specifies the number of tiles in the slice. The value of num_tiles_in_slice_minus1 may be in the range of 0 to NumTilesInPic&#x2212;1, inclusive.</li>        <li id="ul0075-0005" num="0313">The variable NumCtusInCurrSlice, which specifies the number of CTUs in the current slice, and the list CtbAddrInCurrSlice[i], for i ranging from 0 to NumCtusInCurrSlice&#x2212;1, inclusive, specifying the picture raster scan address of the i-th CTB within the slice, are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0140" num="0000"><tables id="TABLE-US-00019" num="00019"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="28pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( rect_slice_flag) {</entry><entry>(117)</entry></row><row><entry>&#x2003;picLevelSliceIdx = &#x2009;<img id="CUSTOM-CHARACTER-00054" he="2.46mm" wi="14.14mm" file="US20230007307A1-20230105-P00054.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00055" he="2.46mm" wi="10.24mm" file="US20230007307A1-20230105-P00055.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00056" he="2.46mm" wi="13.04mm" file="US20230007307A1-20230105-P00056.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; slice address &#x2009;<img id="CUSTOM-CHARACTER-00057" he="2.46mm" wi="1.44mm" file="US20230007307A1-20230105-P00057.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>[[ &#x2003;for( j = 0; j &#x3c; CurrSubpicIdx; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;picLevelSliceIdx += NumSlicesInSubpic[ j ]}]</entry><entry/></row><row><entry>&#x2003;NumCtusInCurrSlice = NumCtusInSlice[ picLevelSliceIdx ]</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c; NumCtusInCurrSlice; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;CtbAddrInCurrSlice[ i ] = CtbAddrInSlice[ picLevelSliceIdx ][ i ]</entry><entry/></row><row><entry>&#x2003;} else {</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInCurrSlice = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;for( tileIdx = slice address; tileIdx &#x3c;= slice address + num tiles in slice minus1;</entry><entry/></row><row><entry>&#x2003;tileIdx++) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( ctbY = tileRowBd[ tileY ]; ctbY &#x3c; tileRowBd[ tileY + 1 ]; ctbY++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( ctbX = tileColBd[ tileX ]; ctbX &#x3c; tileColBd[ tileX + 1 ]; ctbX++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;CtbAddrInCurrSlice[ NumCtusInCurrSlice ] =</entry><entry/></row><row><entry>&#x2003;ctbY * PicWidthInCtb + ctbX</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;NumCtusInCurrSlice++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>. . .</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0026" level="1">6.2. Embodiment 2: Signalling Slices in PPS for Non-Rectangular Mode</heading><p id="p-0141" num="0314">7.3.2.4 Picture parameter set RBSP syntax</p><p id="p-0142" num="0000"><tables id="TABLE-US-00020" num="00020"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;pps_pic_parameter_set_id</entry><entry>ue(v)</entry></row><row><entry>&#x2003;. . .</entry><entry/></row><row><entry>&#x2003;no_pic_partition_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( !no_pic_partition_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_columns_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_rows_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_columns_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_rows_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;rect_slice_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>u(1)</entry></row><row><entry><u style="single"><b>&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00058" he="2.46mm" wi="12.70mm" file="US20230007307A1-20230105-P00058.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00059" he="2.46mm" wi="9.57mm" file="US20230007307A1-20230105-P00059.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00060" he="2.46mm" wi="13.04mm" file="US20230007307A1-20230105-P00060.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;</b><b>&#x2002;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00061" he="2.46mm" wi="13.04mm" file="US20230007307A1-20230105-P00061.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00062" he="2.46mm" wi="15.49mm" file="US20230007307A1-20230105-P00062.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry><img id="CUSTOM-CHARACTER-00063" he="2.46mm" wi="5.67mm" file="US20230007307A1-20230105-P00063.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry><u style="single"><b>&#x2003;</b><b>&#x2002;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00064" he="2.46mm" wi="23.28mm" file="US20230007307A1-20230105-P00064.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;</entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;</b><b>&#x2002;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00065" he="2.46mm" wi="20.49mm" file="US20230007307A1-20230105-P00065.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00066" he="2.46mm" wi="13.38mm" file="US20230007307A1-20230105-P00066.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00067" he="2.46mm" wi="14.14mm" file="US20230007307A1-20230105-P00067.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;&#x2003;</b><b>&#x2002;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00068" he="2.46mm" wi="14.82mm" file="US20230007307A1-20230105-P00068.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00069" he="2.46mm" wi="17.27mm" file="US20230007307A1-20230105-P00069.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry><img id="CUSTOM-CHARACTER-00070" he="2.46mm" wi="5.67mm" file="US20230007307A1-20230105-P00063.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry><u style="single"><b>&#x2003;&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00071" he="2.46mm" wi="1.44mm" file="US20230007307A1-20230105-P00070.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00072" he="2.46mm" wi="4.23mm" file="US20230007307A1-20230105-P00071.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; if( [[rect_slice_flag &#x26;&#x26;]] !single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>[[ &#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)]]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( &#x2003;&#x2003;&#x2003;NumTileRows &#x2003;&#x2003;&#x2003;&#x3e; &#x2003;&#x2003;&#x2003;1 &#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( tile_idx_delta_present_flag | | tileIdx % NumTileColumns = =</entry><entry/></row><row><entry>0 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( &#x2003;slice_width_in_tiles_minus1[ i ] &#x2003;&#x2003;= = &#x2003;&#x2003;0 &#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] &#x2003;&#x2003;= = &#x2003;&#x2003;0 &#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ] &#x3e; 1 )</entry><entry/></row><row><entry>{</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c; num_slices_in_pic_minus1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;loop_filter_across_tiles_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_slices_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0143" num="0315">7.3.7.1 General Slice Header Syntax</p><p id="p-0144" num="0000"><tables id="TABLE-US-00021" num="00021"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="217pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>slice_header( ) {</entry><entry/></row><row><entry>&#x2003;picture_header_in_slice_header_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( picture_header_in_slice_header_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;picture_header_structure( )</entry><entry/></row><row><entry>&#x2003;if( subpic_info_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_subpic_id</entry><entry>u(v)</entry></row><row><entry>&#x2003;if( ( rect_slice_flag &#x26;&#x26; NumSlicesInSubpic[ CurrSubpicIdx ] &#x3e; 1 ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( !rect_slice_flag &#x26;&#x26; &#x2009;<img id="CUSTOM-CHARACTER-00073" he="2.46mm" wi="16.93mm" file="US20230007307A1-20230105-P00072.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; [[NumTilesInPic]] &#x3e; l ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_address</entry><entry>u(v)</entry></row><row><entry>&#x2003;for( I = 0; I &#x3c; NumExtraPhBits; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;sh_extra_bit[ I ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;[[if( !rect_slice_flag &#x26;&#x26; NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;num_tiles_in_slice_minus1</entry><entry>ue(v)]]</entry></row><row><entry>&#x2003;if( ph_inter_slice_allowed_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_type</entry><entry>ue(v)</entry></row><row><entry>. . .</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0145" num="0316">7.4.3.4 Picture Parameter Set RBSP Semantics</p><p id="p-0146" num="0000">num_slices_in_pic_minus1 plus 1 specifies the number of [[rectangular]] slices in each picture referring to the PPS. The value of num_slices_in_pic_minus1 may be in the range of 0 to MaxSlicesPerPicture&#x2212;1, inclusive, where MaxSlicesPerPicture is specified in Annex A. When no_pic_partition_flag is equal to 1, the value of num_slices_in_pic_minus1 is inferred to be equal to 0. <img id="CUSTOM-CHARACTER-00074" he="2.79mm" wi="21.51mm" file="US20230007307A1-20230105-P00073.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00075" he="3.22mm" wi="18.03mm" file="US20230007307A1-20230105-P00074.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00076" he="2.79mm" wi="18.03mm" file="US20230007307A1-20230105-P00075.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00077" he="3.22mm" wi="25.40mm" file="US20230007307A1-20230105-P00076.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00078" he="2.79mm" wi="17.61mm" file="US20230007307A1-20230105-P00077.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00079" he="3.22mm" wi="22.27mm" file="US20230007307A1-20230105-P00078.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00080" he="3.22mm" wi="18.03mm" file="US20230007307A1-20230105-P00079.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00081" he="3.22mm" wi="22.94mm" file="US20230007307A1-20230105-P00080.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00082" he="2.79mm" wi="15.49mm" file="US20230007307A1-20230105-P00081.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00083" he="3.22mm" wi="23.96mm" file="US20230007307A1-20230105-P00082.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00084" he="3.22mm" wi="20.83mm" file="US20230007307A1-20230105-P00083.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00085" he="2.79mm" wi="22.27mm" file="US20230007307A1-20230105-P00084.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00086" he="3.22mm" wi="13.38mm" file="US20230007307A1-20230105-P00085.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00087" he="3.22mm" wi="17.27mm" file="US20230007307A1-20230105-P00086.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00088" he="3.22mm" wi="17.61mm" file="US20230007307A1-20230105-P00087.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00089" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00088.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00090" he="3.22mm" wi="15.16mm" file="US20230007307A1-20230105-P00089.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00091" he="3.22mm" wi="16.26mm" file="US20230007307A1-20230105-P00090.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00092" he="3.22mm" wi="22.27mm" file="US20230007307A1-20230105-P00091.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00093" he="2.79mm" wi="26.08mm" file="US20230007307A1-20230105-P00092.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00094" he="3.22mm" wi="20.83mm" file="US20230007307A1-20230105-P00093.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00095" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00094.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00096" he="3.22mm" wi="18.71mm" file="US20230007307A1-20230105-P00095.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00097" he="3.22mm" wi="16.59mm" file="US20230007307A1-20230105-P00096.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00098" he="3.22mm" wi="15.16mm" file="US20230007307A1-20230105-P00097.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00099" he="3.22mm" wi="18.37mm" file="US20230007307A1-20230105-P00098.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00100" he="3.22mm" wi="15.16mm" file="US20230007307A1-20230105-P00099.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00101" he="3.22mm" wi="20.83mm" file="US20230007307A1-20230105-P00100.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00102" he="3.22mm" wi="19.05mm" file="US20230007307A1-20230105-P00101.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00103" he="3.22mm" wi="20.49mm" file="US20230007307A1-20230105-P00102.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00104" he="3.22mm" wi="19.05mm" file="US20230007307A1-20230105-P00103.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00105" he="3.22mm" wi="18.37mm" file="US20230007307A1-20230105-P00104.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00106" he="3.22mm" wi="23.28mm" file="US20230007307A1-20230105-P00105.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00107" he="3.22mm" wi="19.73mm" file="US20230007307A1-20230105-P00106.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00108" he="3.22mm" wi="16.93mm" file="US20230007307A1-20230105-P00107.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00109" he="3.22mm" wi="22.27mm" file="US20230007307A1-20230105-P00108.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00110" he="3.22mm" wi="19.73mm" file="US20230007307A1-20230105-P00109.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00111" he="3.22mm" wi="20.83mm" file="US20230007307A1-20230105-P00110.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00112" he="3.22mm" wi="21.84mm" file="US20230007307A1-20230105-P00111.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00113" he="3.22mm" wi="14.14mm" file="US20230007307A1-20230105-P00112.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00114" he="3.22mm" wi="31.41mm" file="US20230007307A1-20230105-P00113.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00115" he="2.79mm" wi="25.74mm" file="US20230007307A1-20230105-P00114.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00116" he="3.22mm" wi="24.38mm" file="US20230007307A1-20230105-P00115.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00117" he="3.22mm" wi="16.93mm" file="US20230007307A1-20230105-P00116.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00118" he="3.22mm" wi="19.73mm" file="US20230007307A1-20230105-P00117.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00119" he="3.22mm" wi="28.19mm" file="US20230007307A1-20230105-P00118.TIF" alt="custom-character" img-content="character" img-format="tif"/>=<img id="CUSTOM-CHARACTER-00120" he="3.22mm" wi="24.72mm" file="US20230007307A1-20230105-P00119.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00121" he="3.22mm" wi="19.73mm" file="US20230007307A1-20230105-P00120.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00122" he="2.79mm" wi="22.61mm" file="US20230007307A1-20230105-P00121.TIF" alt="custom-character" img-content="character" img-format="tif"/>=<img id="CUSTOM-CHARACTER-00123" he="2.79mm" wi="22.61mm" file="US20230007307A1-20230105-P00122.TIF" alt="custom-character" img-content="character" img-format="tif"/>+<img id="CUSTOM-CHARACTER-00124" he="3.22mm" wi="25.74mm" file="US20230007307A1-20230105-P00123.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00125" he="3.22mm" wi="32.09mm" file="US20230007307A1-20230105-P00124.TIF" alt="custom-character" img-content="character" img-format="tif"/>=<img id="CUSTOM-CHARACTER-00126" he="3.22mm" wi="26.50mm" file="US20230007307A1-20230105-P00125.TIF" alt="custom-character" img-content="character" img-format="tif"/>+<img id="CUSTOM-CHARACTER-00127" he="3.22mm" wi="25.74mm" file="US20230007307A1-20230105-P00126.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00128" he="3.22mm" wi="1.78mm" file="US20230007307A1-20230105-P00127.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00129" he="2.79mm" wi="21.17mm" file="US20230007307A1-20230105-P00128.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00130" he="3.22mm" wi="21.17mm" file="US20230007307A1-20230105-P00129.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00131" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00130.TIF" alt="custom-character" img-content="character" img-format="tif"/>=<img id="CUSTOM-CHARACTER-00132" he="2.79mm" wi="20.49mm" file="US20230007307A1-20230105-P00131.TIF" alt="custom-character" img-content="character" img-format="tif"/>&#x2212;<img id="CUSTOM-CHARACTER-00133" he="2.79mm" wi="20.83mm" file="US20230007307A1-20230105-P00132.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00134" he="2.79mm" wi="21.17mm" file="US20230007307A1-20230105-P00133.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00135" he="3.22mm" wi="19.05mm" file="US20230007307A1-20230105-P00134.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00136" he="2.79mm" wi="19.05mm" file="US20230007307A1-20230105-P00135.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00137" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00136.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00138" he="2.79mm" wi="32.09mm" file="US20230007307A1-20230105-P00137.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00139" he="2.79mm" wi="21.17mm" file="US20230007307A1-20230105-P00138.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00140" he="3.22mm" wi="19.05mm" file="US20230007307A1-20230105-P00139.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00141" he="2.79mm" wi="19.05mm" file="US20230007307A1-20230105-P00140.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00142" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00141.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00143" he="3.22mm" wi="27.86mm" file="US20230007307A1-20230105-P00142.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/><img id="CUSTOM-CHARACTER-00144" he="3.22mm" wi="22.27mm" file="US20230007307A1-20230105-P00143.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00145" he="3.22mm" wi="19.73mm" file="US20230007307A1-20230105-P00144.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00146" he="3.22mm" wi="26.50mm" file="US20230007307A1-20230105-P00145.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00147" he="3.22mm" wi="21.17mm" file="US20230007307A1-20230105-P00146.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00148" he="3.22mm" wi="14.48mm" file="US20230007307A1-20230105-P00147.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00149" he="3.22mm" wi="21.17mm" file="US20230007307A1-20230105-P00148.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/>. . .</p><p id="p-0147" num="0317">7.4.8.1 General Slice Header Semantics</p><p id="p-0148" num="0000">. . .<br/>slice_address specifies the slice_address of the slice. When not present, the value of slice_address is inferred to be equal to 0. When rect_slice_flag is equal to 1 and NumSlicesInSubpic[CurrSubpicIdx] is equal to 1, the value of slice_address is inferred to be equal to 0. When rect_slice_flag is equal to 0 and NumSlicesInPic is equal to 1, the value of slice_address is inferred to be equal to 0<br/>If rect_slice_flag is equal to 0, the following applies:&#x2014;<ul id="ul0076" list-style="none">    <li id="ul0076-0001" num="0000">    <ul id="ul0077" list-style="none">        <li id="ul0077-0001" num="0318">The slice_address is the <img id="CUSTOM-CHARACTER-00150" he="3.22mm" wi="23.28mm" file="US20230007307A1-20230105-P00149.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00151" he="3.22mm" wi="22.27mm" file="US20230007307A1-20230105-P00150.TIF" alt="custom-character" img-content="character" img-format="tif"/>[[raster scan tile index]].</li>        <li id="ul0077-0002" num="0319">The length of slice_address is Ceil(Log2 (<img id="CUSTOM-CHARACTER-00152" he="3.22mm" wi="21.84mm" file="US20230007307A1-20230105-P00151.TIF" alt="custom-character" img-content="character" img-format="tif"/>[[NumTilesInPic]])) bits.</li>        <li id="ul0077-0003" num="0320">The value of slice_address may be in the range of 0 to <img id="CUSTOM-CHARACTER-00153" he="3.22mm" wi="21.84mm" file="US20230007307A1-20230105-P00152.TIF" alt="custom-character" img-content="character" img-format="tif"/>[[NumTilesInPic]]&#x2212;1, inclusive.<br/>Otherwise (rect_slice_flag is equal to 1), the following applies:</li>        <li id="ul0077-0004" num="0321">The slice_address is the subpicture-level slice index of the slice.</li>        <li id="ul0077-0005" num="0322">The length of slice_address is Ceil(Log2(NumSlicesInSubpic[CurrSubpicIdx])) bits.</li>        <li id="ul0077-0006" num="0323">The value of slice_address may be in the range of 0 to NumSlicesInSubpic[CurrSubpicIdx]&#x2212;1, inclusive.<br/>For bitstream conformance, the following constraints may apply:</li>        <li id="ul0077-0007" num="0324">[[If rect_slice_flag is equal to 0 or subpic_info_present_flag is equal to 0, the value of slice_address may not be equal to the value of slice_address of any other coded slice NAL unit of the same coded picture.</li>        <li id="ul0077-0008" num="0325">Otherwise,]]<img id="CUSTOM-CHARACTER-00154" he="3.22mm" wi="15.92mm" file="US20230007307A1-20230105-P00153.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00155" he="3.22mm" wi="23.28mm" file="US20230007307A1-20230105-P00154.TIF" alt="custom-character" img-content="character" img-format="tif"/> the pair of slice_subpic_id and slice_address values may not be equal to the pair of slice_subpic_id and slice_address values of any other coded slice NAL unit of the same coded picture.</li>        <li id="ul0077-0009" num="0326">The shapes of the slices of a picture may be such that each CTU, when decoded, may have its entire left boundary and entire top boundary consisting of a picture boundary or consisting of boundaries of previously decoded CTU(s).<br/>. . .<br/>The variable NumCtusInCurrSlice, which specifies the number of CTUs in the current slice, and the list CtbAddrInCurrSlice[i], for i ranging from 0 to NumCtusInCurrSlice&#x2212;1, inclusive, specifying the picture raster scan address of the i-th CTB within the slice, are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0149" num="0000"><tables id="TABLE-US-00022" num="00022"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="28pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( rect_slice_flag) {</entry><entry>(117)</entry></row><row><entry>&#x2003;picLevelSliceIdx = slice_address</entry><entry/></row><row><entry>&#x2003;for( j = 0; j &#x3c; CurrSubpicIdx; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;picLevelSliceIdx += NumSlicesInSubpic[ j ]</entry><entry/></row><row><entry>&#x2003;NumCtusInCurrSlice = NumCtusInSlice[ picLevelSliceIdx ]</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c; NumCtusInCurrSlice; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;CtbAddrInCurrSlice[ i ] = CtbAddrInSlice[ picLevelSliceIdx ][ i ]</entry><entry/></row><row><entry>} else {</entry><entry/></row><row><entry>&#x2003;NumCtusInCurrSlice = 0</entry><entry/></row><row><entry>&#x2003;for( tileIdx = <u style="single">&#x2009;</u><img id="CUSTOM-CHARACTER-00156" he="2.46mm" wi="17.27mm" file="US20230007307A1-20230105-P00155.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single">&#x2009;</u> slice_address&#x2009;<img id="CUSTOM-CHARACTER-00157" he="2.46mm" wi="2.46mm" file="US20230007307A1-20230105-P00156.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; tileIdx [[&#x3c;=]] <u style="single"><b>&#x3c;</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00158" he="2.46mm" wi="17.27mm" file="US20230007307A1-20230105-P00157.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>slice_address&#x2009;<img id="CUSTOM-CHARACTER-00159" he="2.46mm" wi="1.44mm" file="US20230007307A1-20230105-P00158.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; + &#x2009;<img id="CUSTOM-CHARACTER-00160" he="2.46mm" wi="11.68mm" file="US20230007307A1-20230105-P00159.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00161" he="2.46mm" wi="11.26mm" file="US20230007307A1-20230105-P00160.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00162" he="2.46mm" wi="9.57mm" file="US20230007307A1-20230105-P00161.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;</b></u>[[num_tiles_in_slice_minus1]];</entry><entry/></row><row><entry>tileIdx++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;for( ctbY = tileRowBd[ tileY ]; ctbY &#x3c; tileRowBd[ tileY + 1 ]; ctbY++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( ctbX = tileColBd[ tileX ]; ctbX &#x3c; tileColBd[ tileX + 1 ]; ctbX++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;CtbAddrInCurrSlice[ NumCtusInCurrSlice ] =</entry><entry/></row><row><entry>ctbY * PicWidthInCtb + ctbX</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;NumCtusInCurrSlice++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0027" level="1">6.3. Embodiment 3: Signalling Tiles Conditioned on Picture Dimensions</heading><p id="p-0150" num="0327">7.3.2.4 Picture Parameter Set RBSP Syntax</p><p id="p-0151" num="0000"><tables id="TABLE-US-00023" num="00023"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;pps_pic_parameter_set_id</entry><entry>ue(v)</entry></row><row><entry>. . .</entry><entry/></row><row><entry>&#x2003;no_pic_partition_flag</entry><entry>u(l)</entry></row><row><entry>&#x2003;if( !no_pic_partition_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;[[num_exp_tile_columns_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_rows_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_columns_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_rows_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue(v)]]</entry></row><row><entry><u style="single"><b>&#x2003;&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00163" he="2.46mm" wi="12.36mm" file="US20230007307A1-20230105-P00162.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00164" he="2.46mm" wi="18.37mm" file="US20230007307A1-20230105-P00163.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>&#x3e;</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00165" he="2.46mm" wi="11.26mm" file="US20230007307A1-20230105-P00164.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00166" he="2.46mm" wi="14.14mm" file="US20230007307A1-20230105-P00165.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00167" he="2.46mm" wi="19.39mm" file="US20230007307A1-20230105-P00166.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry><img id="CUSTOM-CHARACTER-00168" he="2.46mm" wi="5.67mm" file="US20230007307A1-20230105-P00167.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry><u style="single"><b>&#x2003;&#x2003;&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00169" he="2.46mm" wi="9.57mm" file="US20230007307A1-20230105-P00168.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>&#x3c;=</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00170" he="2.46mm" wi="13.04mm" file="US20230007307A1-20230105-P00169.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00171" he="2.46mm" wi="18.71mm" file="US20230007307A1-20230105-P00170.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single">&#x2009;&#x2009;<b>++</b><b>&#x2009;</b><b>)</b></u></entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;&#x2003;</b><b>&#x2002;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00172" he="2.46mm" wi="13.80mm" file="US20230007307A1-20230105-P00171.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00173" he="2.46mm" wi="18.37mm" file="US20230007307A1-20230105-P00172.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry><img id="CUSTOM-CHARACTER-00174" he="2.46mm" wi="5.67mm" file="US20230007307A1-20230105-P00173.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry><u style="single"><b>&#x2003;&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00175" he="2.46mm" wi="2.46mm" file="US20230007307A1-20230105-P00174.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00176" he="2.46mm" wi="15.92mm" file="US20230007307A1-20230105-P00175.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00177" he="2.46mm" wi="18.03mm" file="US20230007307A1-20230105-P00176.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;&#x3e;&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00178" he="2.46mm" wi="12.70mm" file="US20230007307A1-20230105-P00177.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;</entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00179" he="2.46mm" wi="15.92mm" file="US20230007307A1-20230105-P00178.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00180" he="2.46mm" wi="13.80mm" file="US20230007307A1-20230105-P00179.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry><img id="CUSTOM-CHARACTER-00181" he="2.46mm" wi="5.67mm" file="US20230007307A1-20230105-P00173.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry><u style="single"><b>&#x2003;&#x2003;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00182" he="2.46mm" wi="12.70mm" file="US20230007307A1-20230105-P00180.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;&#x3c;=&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00183" he="2.46mm" wi="14.14mm" file="US20230007307A1-20230105-P00181.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00184" he="2.46mm" wi="20.15mm" file="US20230007307A1-20230105-P00182.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;&#x2003;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00185" he="2.46mm" wi="18.03mm" file="US20230007307A1-20230105-P00183.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00186" he="2.46mm" wi="11.26mm" file="US20230007307A1-20230105-P00184.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry><img id="CUSTOM-CHARACTER-00187" he="2.46mm" wi="5.67mm" file="US20230007307A1-20230105-P00173.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry><u style="single"><b>&#x2003;&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00188" he="2.46mm" wi="1.44mm" file="US20230007307A1-20230105-P00185.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;rect_slice_flag</entry><entry>u(l)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>u(l)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(l)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( &#x2003;&#x2003;&#x2003;NumTileRows &#x2003;&#x2003;&#x2003;&#x3e; &#x2003;&#x2003;&#x2003;1 &#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(tile_idx_delta_present_flag | | tileIdx % NumTileColumns = =</entry><entry/></row><row><entry>0 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( &#x2003;slice_width_in_tiles_minus1[ i ] &#x2003;&#x2003;= = &#x2003;&#x2003;0 &#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] &#x2003;&#x2003;= = &#x2003;&#x2003;0 &#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ] &#x3e; 1 )</entry><entry/></row><row><entry>{</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c; num_slices_in_pic_minus1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;loop_filter_across_tiles_enabled_flag</entry><entry>u(l)</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_slices_enabled_flag</entry><entry>u(l)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>. . .</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0028" level="1">6.4. Embodiment 4: Example 1 of Semantics on Tile_Column_Width_Minus1 and Tile_Row_Height_Minus1</heading><p id="p-0152" num="0328">7.4.3.4 Picture Parameter Set RBSP Semantics</p><p id="p-0153" num="0000">. . .<br/>tile_column_width_minus1[i] plus 1 specifies the width of the i-th tile column in units of CTBs for i in the range of 0 to num_exp_tile_columns_minus1&#x2212;1, inclusive<img id="CUSTOM-CHARACTER-00189" he="3.22mm" wi="10.58mm" file="US20230007307A1-20230105-P00186.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00190" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00187.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00191" he="3.22mm" wi="22.61mm" file="US20230007307A1-20230105-P00188.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00192" he="3.22mm" wi="18.37mm" file="US20230007307A1-20230105-P00189.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00193" he="3.22mm" wi="16.93mm" file="US20230007307A1-20230105-P00190.TIF" alt="custom-character" img-content="character" img-format="tif"/> tile_column_width_minus1[num_exp_tile_columns_minus1] is used to derive the width of the tile columns with index greater than or equal to num_exp_tile_columns_minus1 as specified in clause 6.5.1. The value of tile_column_width_minus1[i] may be in the range of 0 to PicWidthInCtbsY&#x2212;1, inclusive. When not present, the value of tile_column_width_minus1[0] is inferred to be equal to PicWidthInCtbsY&#x2212;1.<br/>tile_row_height_minus1[i] plus 1 specifies the height of the i-th tile row in units of CTBs for i in the range of 0 to num_exp_tile_rows_minus1&#x2212;1, inclusive<img id="CUSTOM-CHARACTER-00194" he="3.22mm" wi="9.57mm" file="US20230007307A1-20230105-P00191.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00195" he="3.22mm" wi="18.03mm" file="US20230007307A1-20230105-P00192.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00196" he="3.22mm" wi="20.49mm" file="US20230007307A1-20230105-P00193.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00197" he="3.22mm" wi="33.53mm" file="US20230007307A1-20230105-P00194.TIF" alt="custom-character" img-content="character" img-format="tif"/> tile_row_height_minus1[num_exp_tile_rows_minus1] is used to derive the height of the tile rows with index greater than or equal to num_exp_tile_rows_minus1 as specified in clause 6.5.1. The value of tile_row_height_minus1 [i] may be in the range of 0 to PicHeightInCtbsY&#x2212;1, inclusive. When not present, the value of tile_row_height_minus1[0] is inferred to be equal to PicHeightInCtbsY&#x2212;1.<br/>. . .</p><heading id="h-0029" level="1">6.5. Embodiment 5: Example 2 of Semantics on Tile_Column_Width_Minus1 and Tile_Row_Height_Minus1</heading><p id="p-0154" num="0329">7.4.3.4 Picture Parameter Set RBSP Semantics</p><p id="p-0155" num="0000">. . .<br/>tile_column_width_minus1[i] plus 1 specifies the width of the i-th tile column in units of CTBs for i in the range of 0 to <img id="CUSTOM-CHARACTER-00198" he="3.22mm" wi="12.36mm" file="US20230007307A1-20230105-P00195.TIF" alt="custom-character" img-content="character" img-format="tif"/> num_exp_tile_columns_minus1&#x2212;1<img id="CUSTOM-CHARACTER-00199" he="3.22mm" wi="1.78mm" file="US20230007307A1-20230105-P00196.TIF" alt="custom-character" img-content="character" img-format="tif"/>, inclusive. tile_column_width_minus1[num_exp_tile_columns_minus1] is used to derive the width of the tile columns with index greater than or equal to num_exp_tile_columns_minus1 as specified in clause 6.5.1. The value of tile_column_width_minus1 [i] may be in the range of 0 to PicWidthInCtbsY&#x2212;1, inclusive. When not present, the value of tile_column_width_minus1[0] is inferred to be equal to PicWidthInCtbsY&#x2212;1.<br/>tile_row_height_minus1[i] plus 1 specifies the height of the i-th tile row in units of CTBs for i in the range of 0 to <img id="CUSTOM-CHARACTER-00200" he="3.22mm" wi="14.14mm" file="US20230007307A1-20230105-P00197.TIF" alt="custom-character" img-content="character" img-format="tif"/> num_exp_tile_rows_minus1&#x2212;1<img id="CUSTOM-CHARACTER-00201" he="3.22mm" wi="1.78mm" file="US20230007307A1-20230105-P00198.TIF" alt="custom-character" img-content="character" img-format="tif"/> inclusive. tile_row_height_minus1 [num_exp_tile_rows_minus1] is used to derive the height of the tile rows with index greater than or equal to num_exp_tile_rows_minus1 as specified in clause 6.5.1. The value of tile_row_height_minus1 [i] may be in the range of 0 to PicHeightInCtbsY&#x2212;1, inclusive. When not present, the value of tile_row_height_minus1[0] is inferred to be equal to PicHeightInCtbsY&#x2212;1.<br/>. . .</p><heading id="h-0030" level="1">6.6. Embodiment 6: Example Derivation of CTUs in Slices</heading><p id="p-0156" num="0330">6.5 Scanning Processes</p><p id="p-0157" num="0331">6.5.1 CTB Raster Scanning, Tile Scanning, and Subpicture Scanning Processes</p><p id="p-0158" num="0000">. . .<br/>For rectangular slices, the list NumCtusInSlice[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the number of CTU in the i-th slice, the list SliceTopLeftTileIdx[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the index of the top-left tile of the slice, and the matrix CtbAddrInSlice[i][j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, specifying the picture raster scan address of the j-th CTB within the i-th slice, are derived as follows:</p><p id="p-0159" num="0000"><tables id="TABLE-US-00024" num="00024"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="28pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( single_slice_per_subpic_flag ) {</entry><entry>(29)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sliceIdx = subpic_info_present_flag ? CtbToSubpicIdx[ i ] : 0</entry><entry/></row><row><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] = i</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>} else {</entry><entry/></row><row><entry>&#x2003;tileIdx = 0</entry><entry/></row><row><entry>for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] = tileIdx</entry><entry/></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;if( i = = num_slices_in_pic_minus1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ] = NumTileColumns &#x2212; 1 &#x2212; tileX</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = NumTileRows &#x2212; 1 &#x2212; tileY</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26; slice_height_in_tiles_minus1[ i ]</entry><entry/></row><row><entry>= = 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; NumSlicesInTile[ i ] &#x2212; 1; j++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ],</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + SliceHeightInCtusMinus1[ i ] + 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbY += SliceHeightInCtusMinus1[ i ] + 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ], ctbY,</entry><entry/></row><row><entry>tileRowBd[ tileY + 1 ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;} else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= slice_height_in_tiles_minus1[ i ]; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c;= slice_width_in_tiles_minus1[ i ]; k++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ],</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j + 1 ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00202" he="2.46mm" wi="9.14mm" file="US20230007307A1-20230105-P00199.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00203" he="2.46mm" wi="12.02mm" file="US20230007307A1-20230105-P00200.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00204" he="2.46mm" wi="9.91mm" file="US20230007307A1-20230105-P00201.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += slice_width_in_tiles_minus1[ i ] + 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += slice_height_in_tiles_minus1[i] * NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00205" he="2.46mm" wi="1.78mm" file="US20230007307A1-20230105-P00202.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0031" level="1">6.7. Embodiment 7: About Signalling of MER Size</heading><p id="p-0160" num="0332">7.3.2.3 Sequence Parameter Set RBSP Syntax</p><p id="p-0161" num="0000"><tables id="TABLE-US-00025" num="00025"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="168pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>seq_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;sps_seq_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>. . .</entry><entry/></row><row><entry>&#x2003;log2_parallel_merge_level_minus_log2_mincb</entry><entry>ue(v)</entry></row><row><entry>. . .</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0162" num="0333">7.4.3.3 Sequence Parameter Set RBSP Semantics</p><p id="p-0163" num="0000">log2_parallel_merge_level_minus_log2_mincb plus log2_min_luma_coding_block_size_minus2+2 specifies the value of the variable Log2ParMrgLevel, which is used in the derivation process for spatial merging candidates as specified in clause 8.5.2.3, the derivation process for motion vectors and reference indices in subblock merge mode as specified in clause 8.5.5.2, and to control the invocation of the updating process for the history-based motion vector predictor list in clause 8.5.2.1. The value of log2_parallel_merge_level_minus_log2_mincb may be in the range of 0 to CtbLog2SizeY&#x2212;log2_min_luma_coding_block_size_minus2&#x2212;2, inclusive. The variable Log2ParMrgLevel is derived as follows:</p><p id="p-0164" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Log2ParMrgLevel=log2_parallel_merge_level_minus2+log2_min_luma_coding_block_size_minus2+2&#x2003;&#x2003;(68)<?in-line-formulae description="In-line Formulae" end="tail"?></p><heading id="h-0032" level="1">6.8. Embodiment 8: About Signalling of Rectangular Slices</heading><p id="p-0165" num="0334">6.5.1 CTB Raster</p><p id="p-0166" num="0000">. . .</p><p id="p-0167" num="0335">Scanning, Tile Scanning, and Subpicture Scanning Processes</p><p id="p-0168" num="0000">The list ctbToSubpicIdx[ctbAddrRs] for ctbAddrRs ranging from 0 to PicSizeInCtbsY&#x2212;1, inclusive, specifying the conversion from a CTB address in picture raster scan to a subpicture index, is derived as follows:</p><p id="p-0169" num="0000"><tables id="TABLE-US-00026" num="00026"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="28pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( ctbAddrRs = 0; ctbAddrRs &#x3c; PicSizeInCtbsY; ctbAddrRs++ ) {</entry><entry>(29)</entry></row><row><entry>&#x2003;posX = ctbAddrRs % PicWidthInCtbsY</entry><entry/></row><row><entry>&#x2003;posY = ctbAddrRs / PicWidthInCtbsY</entry><entry/></row><row><entry>&#x2003;ctbToSubpicIdx[ ctbAddrRs ] = &#x2212;1</entry><entry/></row><row><entry>&#x2003;for( i = 0; ctbToSubpicIdx[ ctbAddrRs ]&#x3c; 0 &#x26;&#x26; i &#x3c;= sps_num_subpics_minus1;</entry><entry/></row><row><entry>i++ ) { </entry><entry/></row><row><entry>&#x2003;if( ( posX &#x3e;= subpic_ctu_top_left_x[ i ] ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( posX &#x3c; subpic_ctu_top_left_x[ i ] + subpic_width_minus1[ i ] + 1 ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( posY &#x3e;= subpic_ctu_top_left_y[ i ] ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( posY &#x3c; subpic_ctu_top_left_y[ i ] + subpic_height_minus1[ i ] + 1 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;ctbToSubpicIdx[ ctbAddrRs ] = i</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>When rect_slice_flag is equal to 1, the list NumCtusInSlice[i] for i ranging from 0 to num_slices_inpic_minus1, inclusive, specifying the number of CTUs in the i-th slice, the list SliceTopLeftTileIdx[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the tile index of the tile containing the first CTU in the slice, and the matrix CtbAddrInSlice[i][j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, specifying the picture raster scan address of the j-th CTB within the i-th slice, <img id="CUSTOM-CHARACTER-00206" he="3.22mm" wi="22.94mm" file="US20230007307A1-20230105-P00203.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00207" he="3.22mm" wi="21.17mm" file="US20230007307A1-20230105-P00204.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00208" he="3.22mm" wi="18.37mm" file="US20230007307A1-20230105-P00205.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00209" he="3.22mm" wi="14.48mm" file="US20230007307A1-20230105-P00206.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00210" he="2.79mm" wi="20.49mm" file="US20230007307A1-20230105-P00207.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00211" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00208.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00212" he="3.22mm" wi="22.94mm" file="US20230007307A1-20230105-P00209.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00213" he="2.79mm" wi="15.49mm" file="US20230007307A1-20230105-P00210.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00214" he="3.22mm" wi="15.92mm" file="US20230007307A1-20230105-P00211.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00215" he="3.22mm" wi="14.82mm" file="US20230007307A1-20230105-P00212.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00216" he="3.22mm" wi="21.51mm" file="US20230007307A1-20230105-P00213.TIF" alt="custom-character" img-content="character" img-format="tif"/> are derived as follows:</p><p id="p-0170" num="0000"><tables id="TABLE-US-00027" num="00027"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="28pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( single_slice_per_subpic_flag ) {</entry><entry>(30)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sliceIdx = ctbToSubpicIdx[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] = i</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>} else {</entry><entry/></row><row><entry>&#x2003;tileIdx = 0</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] = tileIdx</entry><entry/></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00217" he="2.46mm" wi="18.03mm" file="US20230007307A1-20230105-P00214.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00218" he="2.46mm" wi="18.71mm" file="US20230007307A1-20230105-P00215.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00219" he="2.46mm" wi="13.38mm" file="US20230007307A1-20230105-P00216.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00220" he="2.46mm" wi="13.80mm" file="US20230007307A1-20230105-P00217.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00221" he="2.46mm" wi="14.48mm" file="US20230007307A1-20230105-P00218.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00222" he="2.46mm" wi="13.04mm" file="US20230007307A1-20230105-P00219.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00223" he="2.46mm" wi="13.80mm" file="US20230007307A1-20230105-P00220.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00224" he="2.46mm" wi="13.38mm" file="US20230007307A1-20230105-P00221.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00225" he="2.46mm" wi="14.14mm" file="US20230007307A1-20230105-P00222.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00226" he="2.46mm" wi="13.04mm" file="US20230007307A1-20230105-P00223.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00227" he="2.46mm" wi="7.45mm" file="US20230007307A1-20230105-P00224.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00228" he="2.46mm" wi="13.04mm" file="US20230007307A1-20230105-P00225.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00229" he="2.46mm" wi="14.14mm" file="US20230007307A1-20230105-P00226.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00230" he="2.12mm" wi="20.49mm" file="US20230007307A1-20230105-P00227.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00231" he="2.46mm" wi="14.14mm" file="US20230007307A1-20230105-P00228.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00232" he="2.46mm" wi="13.80mm" file="US20230007307A1-20230105-P00229.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00233" he="2.46mm" wi="16.59mm" file="US20230007307A1-20230105-P00230.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00234" he="2.46mm" wi="11.26mm" file="US20230007307A1-20230105-P00231.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00235" he="2.46mm" wi="14.14mm" file="US20230007307A1-20230105-P00232.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00236" he="2.46mm" wi="1.44mm" file="US20230007307A1-20230105-P00233.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;if( sliceWidthlnTiles[ i ] = = 1 &#x26;&#x26; sliceHeightInTiles[ i ] = = 1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( num_exp_slices_in_tile[ i ] = = 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00237" he="2.46mm" wi="12.02mm" file="US20230007307A1-20230105-P00234.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00238" he="2.46mm" wi="13.04mm" file="US20230007307A1-20230105-P00235.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2009;<img id="CUSTOM-CHARACTER-00239" he="2.46mm" wi="12.70mm" file="US20230007307A1-20230105-P00236.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00240" he="2.46mm" wi="13.04mm" file="US20230007307A1-20230105-P00237.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00241" he="2.46mm" wi="11.26mm" file="US20230007307A1-20230105-P00238.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;</b><b>&#x2009;</b><b>/</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00242" he="2.46mm" wi="19.73mm" file="US20230007307A1-20230105-P00239.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;remainingHeightInCtbsY =</entry><entry/></row><row><entry>RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; &#x2009;<img id="CUSTOM-CHARACTER-00243" he="2.46mm" wi="13.38mm" file="US20230007307A1-20230105-P00240.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00244" he="2.46mm" wi="16.93mm" file="US20230007307A1-20230105-P00241.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;</b></u>; j++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ &#x2009;<img id="CUSTOM-CHARACTER-00245" he="2.46mm" wi="4.23mm" file="US20230007307A1-20230105-P00242.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; ] = exp_slice_height_in_ctus_minus1[ i ][ j ] + 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= sliceHeightInCtus[ &#x2009;<img id="CUSTOM-CHARACTER-00246" he="2.46mm" wi="4.23mm" file="US20230007307A1-20230105-P00242.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;uniformSliceHeight = sliceHeightInCtus[ &#x2009;<img id="CUSTOM-CHARACTER-00247" he="2.46mm" wi="4.23mm" file="US20230007307A1-20230105-P00242.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; &#x2212; 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;while( remainingHeightInCtbsY &#x3e;= uniformSliceHeight ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ &#x2009;<img id="CUSTOM-CHARACTER-00248" he="2.46mm" wi="4.23mm" file="US20230007307A1-20230105-P00242.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; ] = uniformSliceHeight</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= uniformSliceHeight</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;j++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( remainingHeightInCtbsY &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ &#x2009;<img id="CUSTOM-CHARACTER-00249" he="2.46mm" wi="4.23mm" file="US20230007307A1-20230105-P00242.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; ] = remainingHeightInCtbsY</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;j++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = j</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for(j = 0; j &#x3c; NumSlicesInTile i ] &#x2212; 1; j++) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ],</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + sliceHeightInCtus[ i ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbY += sliceHeightInCtus[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ], ctbY,</entry><entry/></row><row><entry>tileRowBd[ tileY + 1 ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;} else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; sliceHeightInTiles[ i ]; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c; slice WidthInTiles[ i ]; k++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j + 1 ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00250" he="2.46mm" wi="18.03mm" file="US20230007307A1-20230105-P00243.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00251" he="2.46mm" wi="18.71mm" file="US20230007307A1-20230105-P00244.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += sliceWdithInTiles[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += ( sliceHeightInTiles[ i ] &#x2212; 1 ) * NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00252" he="2.46mm" wi="1.44mm" file="US20230007307A1-20230105-P00245.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>For bitstream conformance, the values of NumCtusInSlice[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, may be greater than 0. Additionally, for bitstream conformance, the matrix CtbAddrInSlice[i][j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, may include each of all CTB may address in the range of 0 to PicSizeInCtbsY&#x2212;1, inclusive, once and only once.<br/>. . .</p><p id="p-0171" num="0336">7.3.2.4 Picture Parameter Set RBSP Syntax</p><p id="p-0172" num="0000"><tables id="TABLE-US-00028" num="00028"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;. . .</entry><entry/></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(l)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; l )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( &#x2003;NumTileRows &#x3e; 1 &#x2003;&#x26;&#x26; &#x2003;(tile_idx_delta_present_flag &#x2003;| |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00253" he="2.46mm" wi="13.38mm" file="US20230007307A1-20230105-P00246.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00254" he="2.46mm" wi="9.91mm" file="US20230007307A1-20230105-P00247.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;% NumTileColumns = = 0 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( &#x2003;slice_width_in_tiles_minus1[ i ] &#x2003;&#x2003;= = &#x2003;&#x2003;0 &#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] &#x2003;&#x2003;= = &#x2003;&#x2003;0 &#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ] &#x3e; 1 )</entry><entry/></row><row><entry>{</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; num_exp_slices_in_tile[ i ]; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1&#x2009;<img id="CUSTOM-CHARACTER-00255" he="2.46mm" wi="2.79mm" file="US20230007307A1-20230105-P00248.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;[ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ] &#x2212; 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c; num_slices_in_pic_minus1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;. . .</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0173" num="0337">7.4.3.4 Picture Parameter Set Semantics</p><p id="p-0174" num="0000">. . .<br/>tile_idx_delta_present_flag equal to 0 specifies that tile_idx_delta[i] syntax elements are not present in the PPS and all pictures referring to the PPS are partitioned into rectangular slice rows and rectangular slice columns in slice raster order. tile_idx_delta_present_flag equal to 1 specifies that tile_idx_delta[i] syntax elements may be present in the PPS and all rectangular slices in pictures referring to the PPS are specified in the order indicated by the values of the tile_idx_delta[i] in increasing values of i. When not present, the value of tile_idx_delta_present_flag is inferred to be equal to 0.<br/>slice_width_in_tiles_minus1[i] plus 1 specifies the width of the i-th rectangular slice in units of tile columns. The value of slice_width_in_tiles_minus1 [i] may be in the range of 0 to NumTileColumns&#x2212;1, inclusive.<br/>When i is less than num_slices_in_pic_minus1 and NumTileColumns is equal to 1, the value of slice_width_in_tiles_minus1[i] is inferred to be equal to 0.<br/>slice_height_in_tiles_minus1[i] plus 1 specifies the height of the i-th rectangular slice in units of tile rows when num_exp_slices_in_tile[i] is equal to 0. The value of slice_height_in_tiles_minus1[i] may be in the range of 0 to NumTileRows&#x2212;1, inclusive.<br/>When i is less than num_slices_in_pic_minus1 and slice_height_in_tiles_minus1 [i] is not present, it is inferred to be equal to NumTileRows==1 ? 0: slice_height_in_tiles_minus1 [i&#x2212;1].<br/>num_exp_slices_in_tile[i] specifies the number of explicitly provided slice heights for the slices in the tile containing the i-th slice (i.e., the tile with tile index equal to SliceTopLeftTileldx[i]). The value of num_exp_slices_in_tile[i] may be in the range of 0 to RowHeight[SliceTopLeftTileldx[i]/NumTileColumns]&#x2212;1, inclusive. When not present, the value of num_exp_slices_in_tile[i] is inferred to be equal to 0.<br/><img id="CUSTOM-CHARACTER-00256" he="3.22mm" wi="22.94mm" file="US20230007307A1-20230105-P00249.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00257" he="3.22mm" wi="17.61mm" file="US20230007307A1-20230105-P00250.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00258" he="3.22mm" wi="26.50mm" file="US20230007307A1-20230105-P00251.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00259" he="3.22mm" wi="24.38mm" file="US20230007307A1-20230105-P00252.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00260" he="2.79mm" wi="24.38mm" file="US20230007307A1-20230105-P00253.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00261" he="3.22mm" wi="31.75mm" file="US20230007307A1-20230105-P00254.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00262" he="3.22mm" wi="28.19mm" file="US20230007307A1-20230105-P00255.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00263" he="3.22mm" wi="21.84mm" file="US20230007307A1-20230105-P00256.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00264" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00257.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00265" he="3.22mm" wi="13.38mm" file="US20230007307A1-20230105-P00258.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00266" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00259.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00267" he="3.22mm" wi="21.51mm" file="US20230007307A1-20230105-P00260.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00268" he="3.22mm" wi="20.83mm" file="US20230007307A1-20230105-P00261.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00269" he="3.22mm" wi="25.74mm" file="US20230007307A1-20230105-P00262.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00270" he="3.22mm" wi="20.83mm" file="US20230007307A1-20230105-P00263.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00271" he="3.22mm" wi="21.17mm" file="US20230007307A1-20230105-P00264.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00272" he="3.22mm" wi="18.37mm" file="US20230007307A1-20230105-P00265.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00273" he="3.22mm" wi="16.26mm" file="US20230007307A1-20230105-P00266.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00274" he="3.22mm" wi="18.71mm" file="US20230007307A1-20230105-P00267.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00275" he="3.22mm" wi="26.84mm" file="US20230007307A1-20230105-P00268.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00276" he="3.22mm" wi="32.43mm" file="US20230007307A1-20230105-P00269.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00277" he="3.22mm" wi="25.40mm" file="US20230007307A1-20230105-P00270.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00278" he="3.22mm" wi="29.97mm" file="US20230007307A1-20230105-P00271.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00279" he="3.22mm" wi="19.73mm" file="US20230007307A1-20230105-P00272.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00280" he="3.22mm" wi="22.27mm" file="US20230007307A1-20230105-P00273.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00281" he="3.22mm" wi="21.51mm" file="US20230007307A1-20230105-P00274.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00282" he="3.22mm" wi="20.49mm" file="US20230007307A1-20230105-P00275.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00283" he="3.22mm" wi="17.27mm" file="US20230007307A1-20230105-P00276.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00284" he="3.22mm" wi="26.50mm" file="US20230007307A1-20230105-P00277.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00285" he="3.22mm" wi="16.93mm" file="US20230007307A1-20230105-P00278.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00286" he="3.22mm" wi="16.93mm" file="US20230007307A1-20230105-P00279.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00287" he="3.22mm" wi="14.48mm" file="US20230007307A1-20230105-P00280.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00288" he="3.22mm" wi="23.96mm" file="US20230007307A1-20230105-P00281.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00289" he="3.22mm" wi="20.49mm" file="US20230007307A1-20230105-P00282.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/>tile_idx_delta[i] specifies <img id="CUSTOM-CHARACTER-00290" he="3.22mm" wi="18.37mm" file="US20230007307A1-20230105-P00283.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00291" he="3.22mm" wi="20.49mm" file="US20230007307A1-20230105-P00284.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00292" he="3.22mm" wi="15.92mm" file="US20230007307A1-20230105-P00285.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00293" he="3.22mm" wi="30.31mm" file="US20230007307A1-20230105-P00286.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00294" he="3.22mm" wi="25.06mm" file="US20230007307A1-20230105-P00287.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00295" he="3.22mm" wi="20.15mm" file="US20230007307A1-20230105-P00288.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00296" he="2.79mm" wi="21.51mm" file="US20230007307A1-20230105-P00289.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00297" he="3.22mm" wi="20.83mm" file="US20230007307A1-20230105-P00290.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00298" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00291.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00299" he="3.22mm" wi="16.93mm" file="US20230007307A1-20230105-P00292.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00300" he="2.79mm" wi="10.58mm" file="US20230007307A1-20230105-P00293.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00301" he="3.22mm" wi="15.92mm" file="US20230007307A1-20230105-P00294.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00302" he="2.79mm" wi="7.79mm" file="US20230007307A1-20230105-P00295.TIF" alt="custom-character" img-content="character" img-format="tif"/> The value of tile_idx_delta[i] may be in the range of &#x2212;NumTilesInPic+1 to NumTilesInPic&#x2212;1, inclusive. When not present, the value of tile_idx_delta[i] is inferred to be equal to 0. When present, the value of tile_idx_delta[i] may not be equal to 0.</p><heading id="h-0033" level="1">6.9. Embodiment 9: About Signalling of Rectangular Slices</heading><p id="p-0175" num="0338">6.5.1 CTB Raster Scanning, Tile Scanning, and Subpicture Scanning Processes</p><p id="p-0176" num="0000">. . .<br/>When rect_slice_flag is equal to 1, the list NumCtusInSlice[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the number of CTUs in the i-th slice, the list SliceTopLeftTileldx[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the tile index of the tile containing the first CTU in the slice, and the matrix CtbAddrInSlice[i][j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, specifying the picture raster scan address of the j-th CTB within the i-th slice, the variable NumSlicesInTile[i], specifying the number of slices in the tile containing the i-th slice (i.e., the tile with tile index equal to SliceTopLeftTileldx[i]), are derived as follows:</p><p id="p-0177" num="0000"><tables id="TABLE-US-00029" num="00029"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="266pt" align="left"/><colspec colname="2" colwidth="28pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( single_slice_per_subpic_flag ) {</entry><entry>(30)</entry></row><row><entry>&#x2003;&#x2003;for(i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sliceIdx = ctbToSubpicIdx[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] = i</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;} else {</entry><entry/></row><row><entry>&#x2003;&#x2003;tileIdx = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] = tileIdx</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3c; num_slices_in_pic_minus1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sliceWidthInTiles[ i ] = slice_width_in_tiles_minus1[ i ] + 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInTiles[ i ] = slice_height_in_tiles_minus1[ i ] + 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;} else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sliceWidthInTiles[ i ] = NumTileColumns &#x2212; tileX</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInTiles[ i ] = NumTileRows &#x2212; tileY</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sliceWidthInTiles[ i ] = = 1 &#x26;&#x26; sliceHeightInTiles[ i ] = = 1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( num_exp_slices_in_tile[ i ] = = 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ i ] =</entry><entry/></row><row><entry>&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remainingHeightInCtbsY =</entry><entry/></row><row><entry>&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[[for( j = 0; j &#x3c; num_exp_slices_in_tile[ i ]; j++ ) { }]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00303" he="2.46mm" wi="19.05mm" file="US20230007307A1-20230105-P00296.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00304" he="2.46mm" wi="13.80mm" file="US20230007307A1-20230105-P00297.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00305" he="2.46mm" wi="18.37mm" file="US20230007307A1-20230105-P00298.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ i + j ] = exp_slice_height_in_ctus_minus1[ i ][ j ] + 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= sliceHeightInCtus[ i + j ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[[uniformSliceHeight = sliceHeightInCtus[ i + j &#x2212; 1 ]]]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00306" he="2.46mm" wi="20.83mm" file="US20230007307A1-20230105-P00299.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>=</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00307" he="2.46mm" wi="17.27mm" file="US20230007307A1-20230105-P00300.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00308" he="2.46mm" wi="16.93mm" file="US20230007307A1-20230105-P00301.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00309" he="2.46mm" wi="12.70mm" file="US20230007307A1-20230105-P00302.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;while( remainingHeightInCtbsY &#x3e;= uniformSliceHeight ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ i + j ] = uniformSliceHeight</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= uniformSliceHeight</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;j++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( remainingHeightInCtbsY &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ i + j ] = remainingHeightInCtbsY</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;j++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = j</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; NumSlicesInTile[ i ] &#x2212; 1; j++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ],</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + sliceHeightInCtus[ i ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY += sliceHeightInCtus[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;i++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ], ctbY,</entry><entry/></row><row><entry>&#x2003;tileRowBd[ tileY + 1 ])</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;} else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; sliceHeightInTiles[ i ]; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c; sliceWidthInTiles[ i ]; k++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j + 1 ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3c; num_slices_in_pic_minus1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += sliceWdithInTiles[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += ( sliceHeightInTiles[ i ] &#x2212; 1 ) * NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>. . .</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>Alternatively, in the above, the following line:<ul id="ul0078" list-style="none">    <li id="ul0078-0001" num="0000">    <ul id="ul0079" list-style="none">        <li id="ul0079-0001" num="0339"><img id="CUSTOM-CHARACTER-00310" he="3.22mm" wi="11.26mm" file="US20230007307A1-20230105-P00303.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00311" he="3.22mm" wi="15.92mm" file="US20230007307A1-20230105-P00304.TIF" alt="custom-character" img-content="character" img-format="tif"/>=<img id="CUSTOM-CHARACTER-00312" he="3.22mm" wi="14.14mm" file="US20230007307A1-20230105-P00305.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00313" he="3.22mm" wi="12.70mm" file="US20230007307A1-20230105-P00306.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00314" he="3.22mm" wi="15.16mm" file="US20230007307A1-20230105-P00307.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00315" he="3.22mm" wi="16.93mm" file="US20230007307A1-20230105-P00308.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/>is changed to be as follows:</li>        <li id="ul0079-0002" num="0340"><img id="CUSTOM-CHARACTER-00316" he="3.22mm" wi="10.92mm" file="US20230007307A1-20230105-P00309.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00317" he="3.22mm" wi="15.49mm" file="US20230007307A1-20230105-P00310.TIF" alt="custom-character" img-content="character" img-format="tif"/>=<br/><img id="CUSTOM-CHARACTER-00318" he="3.22mm" wi="12.36mm" file="US20230007307A1-20230105-P00311.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00319" he="3.22mm" wi="12.02mm" file="US20230007307A1-20230105-P00312.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00320" he="3.22mm" wi="17.27mm" file="US20230007307A1-20230105-P00313.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00321" he="3.22mm" wi="16.26mm" file="US20230007307A1-20230105-P00314.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00322" he="3.22mm" wi="16.26mm" file="US20230007307A1-20230105-P00315.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00323" he="3.22mm" wi="15.49mm" file="US20230007307A1-20230105-P00316.TIF" alt="custom-character" img-content="character" img-format="tif"/></li>    </ul>    </li></ul></p><heading id="h-0034" level="1">6.10. Embodiment 10: About Signalling of Subpictures and Tiles</heading><p id="p-0178" num="0341">6.5.1 CTB Raster Scanning, Tile Scanning, and Subpicture Scanning Processes</p><p id="p-0179" num="0000">The variable NumTileColumns, specifying the number of tile columns, and the list colWidth[i] for i ranging from 0 to NumTileColumns&#x2212;1, inclusive, specifying the width of the i-th tile column in units of CTBs, are derived as follows:</p><p id="p-0180" num="0000"><tables id="TABLE-US-00030" num="00030"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="266pt" align="left"/><colspec colname="2" colwidth="28pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>remainingWidthInCtbsY = PicWidthInCtbsY</entry><entry>(23)</entry></row><row><entry>for( i = 0; i <u style="single">&#x3c;=</u> num_exp_tile_columns_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;colWidth[ i ] = tile_column_width_minus1[ i ] + 1</entry><entry/></row><row><entry>&#x2003;remainingWidthInCtbsY &#x2212;= colWidth[ i ]</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>uniformTileColWidth = tile_column_width_minus1[ num_exp_tile_columns_minus1 ] + 1</entry><entry/></row><row><entry>while( remainingWidthInCtbsY &#x3e;= uniformTileColWidth ) {</entry><entry/></row><row><entry>&#x2003;col Width[ i++ ] = uniformTileColWidth</entry><entry/></row><row><entry>&#x2003;remainingWidthInCtbsY &#x2212;= uniformTileColWidth</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>if( remainingWidthInCtbsY &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;colWidth[ i++ ] = remainingWidthInCtbsY</entry><entry/></row><row><entry>NumTileColumns = i</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variable NumTileRows, specifying the number of tile rows, and the list RowHeight[j] for j ranging from 0 to NumTileRows&#x2212;1, inclusive, specifying the height of the j-th tile row in units of CTBs, are derived as follows:</p><p id="p-0181" num="0000"><tables id="TABLE-US-00031" num="00031"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="252pt" align="left"/><colspec colname="2" colwidth="28pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>remainingHeightInCtbsY = PicHeightInCtbsY</entry><entry>(24)</entry></row><row><entry>for( j = 0; j <u style="single">&#x3c;=</u> num_exp_tile_rows_minus1; j++ ) {</entry><entry/></row><row><entry>&#x2003;RowHeight[ j ] = tile_row_height_minus1[ j ] + 1</entry><entry/></row><row><entry>&#x2003;remainingHeightInCtbsY &#x2212;= RowHeight[ j ]</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>uniformTileRowHeight = tile_row_height_minus1[ num_exp_tile_rows_minus1 ] + 1</entry><entry/></row><row><entry>while( remainingHeightInCtbsY &#x3e;= uniformTileRowHeight ) {</entry><entry/></row><row><entry>&#x2003;RowHeight[ j++ ] = uniformTileRowHeight</entry><entry/></row><row><entry>&#x2003;remainingHeightInCtbsY &#x2212;= uniformTileRowHeight</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>if( remainingHeightlnCtbsY &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;RowHeight[ j++ ] = remainingHeightInCtbsY</entry><entry/></row><row><entry>NumTileRows = j</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0182" num="0342">7.3.2.3 Sequence Parameter Set RBSP Syntax</p><p id="p-0183" num="0000"><tables id="TABLE-US-00032" num="00032"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>seq_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;. . .</entry><entry/></row><row><entry>&#x2003;if( subpic_info_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00324" he="2.46mm" wi="14.82mm" file="US20230007307A1-20230105-P00317.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00325" he="2.46mm" wi="14.48mm" file="US20230007307A1-20230105-P00318.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00326" he="2.46mm" wi="8.47mm" file="US20230007307A1-20230105-P00319.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>&#x2003;</b><b>&#x3e;</b><b>&#x2003;</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00327" he="2.46mm" wi="10.24mm" file="US20230007307A1-20230105-P00320.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>&#x2003;&#x2003;&#x2003;</b><b>| |</b></u></entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00328" he="2.46mm" wi="15.92mm" file="US20230007307A1-20230105-P00321.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00329" he="2.46mm" wi="16.93mm" file="US20230007307A1-20230105-P00322.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>&#x3e;</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00330" he="2.79mm" wi="10.58mm" file="US20230007307A1-20230105-P00323.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_num_subpics_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;. . .</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0184" num="0343">7.3.2.4 Picture Parameter Set RBSP Syntax</p><p id="p-0185" num="0000"><tables id="TABLE-US-00033" num="00033"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="238pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;. . .</entry><entry/></row><row><entry>&#x2003;no_pic_partition_flag</entry><entry>u(l)</entry></row><row><entry>&#x2003;if( !no_pic_partition_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry><u style="single"><b>&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00331" he="2.46mm" wi="18.71mm" file="US20230007307A1-20230105-P00324.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00332" he="2.46mm" wi="16.59mm" file="US20230007307A1-20230105-P00325.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>&#x3e;</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00333" he="2.46mm" wi="10.92mm" file="US20230007307A1-20230105-P00326.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;num_exp_tile_columns_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00334" he="2.46mm" wi="17.61mm" file="US20230007307A1-20230105-P00327.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00335" he="2.46mm" wi="14.82mm" file="US20230007307A1-20230105-P00328.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>&#x3e;</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00336" he="2.46mm" wi="10.92mm" file="US20230007307A1-20230105-P00329.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;num_exp_tile_rows_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( &#x2003;i &#x2003;= &#x2003;0; &#x2003;i &#x2003;&#x2003;&#x3c;= &#x2003;&#x2003;num_exp_tile_columns_minus1 &#x2003;&#x2003;&#x2009;<img id="CUSTOM-CHARACTER-00337" he="2.46mm" wi="4.23mm" file="US20230007307A1-20230105-P00330.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00338" he="2.46mm" wi="15.92mm" file="US20230007307A1-20230105-P00331.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00339" he="2.46mm" wi="19.73mm" file="US20230007307A1-20230105-P00332.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>=</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00340" he="2.46mm" wi="21.17mm" file="US20230007307A1-20230105-P00333.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( &#x2003;i &#x2003;= &#x2003;0; &#x2003;i &#x2003;&#x2003;&#x3c;= &#x2003;&#x2003;num_exp_tile_rows_&#x2009;<img id="CUSTOM-CHARACTER-00341" he="2.46mm" wi="16.59mm" file="US20230007307A1-20230105-P00334.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry><entry/></row><row><entry><u style="single"><b>&#x2003;&#x2003;&#x2003;&#x2003;</b><b>&#x2009;</b></u><img id="CUSTOM-CHARACTER-00342" he="2.46mm" wi="14.14mm" file="US20230007307A1-20230105-P00335.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00343" he="2.46mm" wi="17.27mm" file="US20230007307A1-20230105-P00336.TIF" alt="custom-character" img-content="character" img-format="tif"/> <u style="single"><b>&#x2009;&#x2009;</b><b>=</b><b>&#x2009;&#x2009;</b></u><img id="CUSTOM-CHARACTER-00344" he="2.46mm" wi="22.27mm" file="US20230007307A1-20230105-P00337.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;. . .</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0186" num="0344">7.4.3.4 Picture Parameter Set Semantics</p><p id="p-0187" num="0000">. . .<br/>num_exp_tile_columns_minus1 plus 1 specifies the number of explicitly provided tile column widths. The value of num_exp_tile_columns_minus1 may be in the range of 0 to PicWidthInCtbsY&#x2212;1, inclusive. <img id="CUSTOM-CHARACTER-00345" he="3.22mm" wi="23.96mm" file="US20230007307A1-20230105-P00338.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00346" he="3.22mm" wi="22.27mm" file="US20230007307A1-20230105-P00339.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00347" he="3.22mm" wi="34.21mm" file="US20230007307A1-20230105-P00340.TIF" alt="custom-character" img-content="character" img-format="tif"/> <img id="CUSTOM-CHARACTER-00348" he="3.22mm" wi="13.80mm" file="US20230007307A1-20230105-P00341.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00349" he="3.22mm" wi="20.83mm" file="US20230007307A1-20230105-P00342.TIF" alt="custom-character" img-content="character" img-format="tif"/>.<br/>num_exp_tile_rows_minus1 plus 1 specifies the number of explicitly provided tile row heights. The value of num_exp_tile_rows_minus1 may be in the range of 0 to PicHeightInCtbsY&#x2212;1, inclusive. <img id="CUSTOM-CHARACTER-00350" he="3.22mm" wi="23.96mm" file="US20230007307A1-20230105-P00343.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00351" he="3.22mm" wi="22.27mm" file="US20230007307A1-20230105-P00344.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00352" he="3.22mm" wi="23.96mm" file="US20230007307A1-20230105-P00345.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00353" he="3.22mm" wi="16.93mm" file="US20230007307A1-20230105-P00346.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00354" he="3.22mm" wi="17.61mm" file="US20230007307A1-20230105-P00347.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/>tile_column_width_minus1[i] plus 1 specifies the width of the i-th tile column in units of CTBs for i in the range of 0 to <img id="CUSTOM-CHARACTER-00355" he="3.22mm" wi="16.59mm" file="US20230007307A1-20230105-P00348.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00356" he="3.22mm" wi="21.84mm" file="US20230007307A1-20230105-P00349.TIF" alt="custom-character" img-content="character" img-format="tif"/>, inclusive. tile_column_width_minus1[num_exp_tile_columns_minus1] is used to derive the width of the tile columns with index <img id="CUSTOM-CHARACTER-00357" he="3.22mm" wi="16.59mm" file="US20230007307A1-20230105-P00350.TIF" alt="custom-character" img-content="character" img-format="tif"/> num_exp_tile_columns_minus1 as specified in clause 6.5.1. The value of tile_column_width_minus1[i] may be in the range of 0 to PicWidthInCtbsY&#x2212;1, inclusive. When not present, the value of tile_column_width_minus1[i] is inferred to be equal to <img id="CUSTOM-CHARACTER-00358" he="3.22mm" wi="19.39mm" file="US20230007307A1-20230105-P00351.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00359" he="3.22mm" wi="22.94mm" file="US20230007307A1-20230105-P00352.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00360" he="3.22mm" wi="21.84mm" file="US20230007307A1-20230105-P00353.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/>tile_row_height_minus1[i] plus 1 specifies the height of the i-th tile row in units of CTBs for i in the range of 0 to <img id="CUSTOM-CHARACTER-00361" he="3.22mm" wi="18.03mm" file="US20230007307A1-20230105-P00354.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00362" he="3.22mm" wi="18.37mm" file="US20230007307A1-20230105-P00355.TIF" alt="custom-character" img-content="character" img-format="tif"/> inclusive. tile_row_height_minus1 [num_exp_tile_rows_minus1] is used to derive the height of the tile rows with index <img id="CUSTOM-CHARACTER-00363" he="3.22mm" wi="16.59mm" file="US20230007307A1-20230105-P00356.TIF" alt="custom-character" img-content="character" img-format="tif"/> num_exp_tile_rows_minus1 as specified in clause 6.5.1. The value of tile_row_height_minus1[i] may be in the range of 0 to PicHeightInCtbsY&#x2212;1, inclusive. When not present, the value of tile_row_height_minus1[i] is inferred to be equal to <img id="CUSTOM-CHARACTER-00364" he="3.22mm" wi="20.49mm" file="US20230007307A1-20230105-P00357.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00365" he="3.22mm" wi="24.38mm" file="US20230007307A1-20230105-P00358.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00366" he="3.22mm" wi="22.61mm" file="US20230007307A1-20230105-P00359.TIF" alt="custom-character" img-content="character" img-format="tif"/>.</p><p id="p-0188" num="0345"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram showing an example video processing system <b>1900</b> in which various techniques disclosed herein may be implemented. Various implementations may include some or all of the components of the system <b>1900</b>. The system <b>1900</b> may include input <b>1902</b> for receiving video content. The video content may be received in a raw or uncompressed format, e.g., 8 or 10 bit multi-component pixel values, or may be in a compressed or encoded format. The input <b>1902</b> may represent a network interface, a peripheral bus interface, or a storage interface. Examples of network interface include wired interfaces such as Ethernet, passive optical network (PON), etc. and wireless interfaces such as Wi-Fi or cellular interfaces.</p><p id="p-0189" num="0346">The system <b>1900</b> may include a coding component <b>1904</b> that may implement the various coding or encoding methods described in the present document. The coding component <b>1904</b> may reduce the average bitrate of video from the input <b>1902</b> to the output of the coding component <b>1904</b> to produce a coded representation of the video. The coding techniques are therefore sometimes called video compression or video transcoding techniques. The output of the coding component <b>1904</b> may be either stored, or transmitted via a communication connected, as represented by the component <b>1906</b>. The stored or communicated bitstream (or coded) representation of the video received at the input <b>1902</b> may be used by the component <b>1908</b> for generating pixel values or displayable video that is sent to a display interface <b>1910</b>. The process of generating user-viewable video from the bitstream representation is sometimes called video decompression. Furthermore, while certain video processing operations are referred to as &#x201c;coding&#x201d; operations or tools, it will be appreciated that the coding tools or operations are used at an encoder and corresponding decoding tools or operations that reverse the results of the coding will be performed by a decoder.</p><p id="p-0190" num="0347">Examples of a peripheral bus interface or a display interface may include universal serial bus (USB) or high definition multimedia interface (HDMI) or Displayport, and so on. Examples of storage interfaces include serial advanced technology attachment (SATA), peripheral component interconnect (PCI), integrated drive electronics (IDE) interface, and the like. The techniques described in the present document may be embodied in various electronic devices such as mobile phones, laptops, smartphones or other devices that are capable of performing digital data processing and/or video display.</p><p id="p-0191" num="0348"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a block diagram of a video processing apparatus <b>3600</b>. The apparatus <b>3600</b> may be used to implement one or more of the methods described herein. The apparatus <b>3600</b> may be embodied in a smartphone, tablet, computer, Internet of Things (IoT) receiver, and so on. The apparatus <b>3600</b> may include one or more processors <b>3602</b>, one or more memories <b>3604</b> and video processing hardware <b>3606</b>. The processor(s) <b>3602</b> may be configured to implement one or more methods described in the present document. The memory (memories) <b>3604</b> may be used for storing data and code used for implementing the methods and techniques described herein. The video processing hardware <b>3606</b> may be used to implement, in hardware circuitry, some techniques described in the present document.</p><p id="p-0192" num="0349"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram that illustrates an example video coding system <b>100</b> that may utilize the techniques of this disclosure.</p><p id="p-0193" num="0350">As shown in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, video coding system <b>100</b> may include a source device <b>110</b> and a destination device <b>120</b>. Source device <b>110</b> generates encoded video data which may be referred to as a video encoding device. Destination device <b>120</b> may decode the encoded video data generated by source device <b>110</b> which may be referred to as a video decoding device.</p><p id="p-0194" num="0351">Source device <b>110</b> may include a video source <b>112</b>, a video encoder <b>114</b>, and an input/output (I/O) interface <b>116</b>.</p><p id="p-0195" num="0352">Video source <b>112</b> may include a source such as a video capture device, an interface to receive video data from a video content provider, and/or a computer graphics system for generating video data, or a combination of such sources. The video data may comprise one or more pictures. Video encoder <b>114</b> encodes the video data from video source <b>112</b> to generate a bitstream. The bitstream may include a sequence of bits that form a coded representation of the video data. The bitstream may include coded pictures and associated data. The coded picture is a coded representation of a picture. The associated data may include sequence parameter sets, picture parameter sets, and other syntax structures. I/O interface <b>116</b> may include a modulator/demodulator (modem) and/or a transmitter. The encoded video data may be transmitted directly to destination device <b>120</b> via I/O interface <b>116</b> through network <b>130</b><i>a</i>. The encoded video data may also be stored onto a storage medium/server <b>130</b><i>b </i>for access by destination device <b>120</b>.</p><p id="p-0196" num="0353">Destination device <b>120</b> may include an I/O interface <b>126</b>, a video decoder <b>124</b>, and a display device <b>122</b>.</p><p id="p-0197" num="0354">I/O interface <b>126</b> may include a receiver and/or a modem. I/O interface <b>126</b> may acquire encoded video data from the source device <b>110</b> or the storage medium/server <b>130</b><i>b</i>. Video decoder <b>124</b> may decode the encoded video data. Display device <b>122</b> may display the decoded video data to a user. Display device <b>122</b> may be integrated with the destination device <b>120</b>, or may be external to destination device <b>120</b> which may be configured to interface with an external display device.</p><p id="p-0198" num="0355">Video encoder <b>114</b> and video decoder <b>124</b> may operate according to a video compression standard, such as the High Efficiency Video Coding (HEVC) standard, Versatile Video Coding (VVM) standard and other current and/or further standards.</p><p id="p-0199" num="0356"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a block diagram illustrating an example of video encoder <b>200</b>, which may be video encoder <b>114</b> in the system <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>10</b></figref>.</p><p id="p-0200" num="0357">Video encoder <b>200</b> may be configured to perform any or all of the techniques of this disclosure. In the example of <figref idref="DRAWINGS">FIG. <b>11</b></figref>, video encoder <b>200</b> includes a plurality of functional components. The techniques described in this disclosure may be shared among the various components of video encoder <b>200</b>. In some examples, a processor may be configured to perform any or all of the techniques described in this disclosure.</p><p id="p-0201" num="0358">The functional components of video encoder <b>200</b> may include a partition unit <b>201</b>, a predication unit <b>202</b> which may include a mode select unit <b>203</b>, a motion estimation unit <b>204</b>, a motion compensation unit <b>205</b>, an intra prediction unit <b>206</b>, a residual generation unit <b>207</b>, a transform unit <b>208</b>, a quantization unit <b>209</b>, an inverse quantization unit <b>210</b>, an inverse transform unit <b>211</b>, a reconstruction unit <b>212</b>, a buffer <b>213</b>, and an entropy encoding unit <b>214</b>.</p><p id="p-0202" num="0359">In other examples, video encoder <b>200</b> may include more, fewer, or different functional components. In an example, predication unit <b>202</b> may include an intra block copy (IBC) unit. The IBC unit may perform predication in an IBC mode in which at least one reference picture is a picture where the current video block is located.</p><p id="p-0203" num="0360">Furthermore, some components, such as motion estimation unit <b>204</b> and motion compensation unit <b>205</b> may be highly integrated, but are represented in the example of <figref idref="DRAWINGS">FIG. <b>11</b></figref> separately for purposes of explanation.</p><p id="p-0204" num="0361">Partition unit <b>201</b> may partition a picture into one or more video blocks. Video encoder <b>200</b> and video decoder <b>300</b> may support various video block sizes.</p><p id="p-0205" num="0362">Mode select unit <b>203</b> may select one of the coding modes, intra or inter, e.g., based on error results, and provide the resulting intra- or inter-coded block to a residual generation unit <b>207</b> to generate residual block data and to a reconstruction unit <b>212</b> to reconstruct the encoded block for use as a reference picture. In some examples, the mode select unit <b>203</b> may select a combination of intra and inter predication (CIIP) mode in which the predication is based on an inter predication signal and an intra predication signal. Mode select unit <b>203</b> may also select a resolution for a motion vector (e.g., a sub-pixel or integer pixel precision) for the block in the case of inter predication.</p><p id="p-0206" num="0363">To perform inter prediction on a current video block, motion estimation unit <b>204</b> may generate motion information for the current video block by comparing one or more reference frames from buffer <b>213</b> to the current video block. Motion compensation unit <b>205</b> may determine a predicted video block for the current video block based on the motion information and decoded samples of pictures from buffer <b>213</b> other than the picture associated with the current video block.</p><p id="p-0207" num="0364">Motion estimation unit <b>204</b> and motion compensation unit <b>205</b> may perform different operations for a current video block, for example, depending on whether the current video block is in an I slice, a P slice, or a B slice.</p><p id="p-0208" num="0365">In some examples, motion estimation unit <b>204</b> may perform uni-directional prediction for the current video block, and motion estimation unit <b>204</b> may search reference pictures of list 0 or list 1 for a reference video block for the current video block. Motion estimation unit <b>204</b> may then generate a reference index that indicates the reference picture in list 0 or list 1 that contains the reference video block and a motion vector that indicates a spatial displacement between the current video block and the reference video block. Motion estimation unit <b>204</b> may output the reference index, a prediction direction indicator, and the motion vector as the motion information of the current video block. Motion compensation unit <b>205</b> may generate the predicted video block of the current block based on the reference video block indicated by the motion information of the current video block.</p><p id="p-0209" num="0366">In other examples, motion estimation unit <b>204</b> may perform bi-directional prediction for the current video block, motion estimation unit <b>204</b> may search the reference pictures in list 0 for a reference video block for the current video block and may also search the reference pictures in list 1 for another reference video block for the current video block. Motion estimation unit <b>204</b> may then generate reference indexes that indicate the reference pictures in list 0 and list 1 containing the reference video blocks and motion vectors that indicate spatial displacements between the reference video blocks and the current video block. Motion estimation unit <b>204</b> may output the reference indexes and the motion vectors of the current video block as the motion information of the current video block. Motion compensation unit <b>205</b> may generate the predicted video block of the current video block based on the reference video blocks indicated by the motion information of the current video block.</p><p id="p-0210" num="0367">In some examples, motion estimation unit <b>204</b> may output a full set of motion information for decoding processing of a decoder.</p><p id="p-0211" num="0368">In some examples, motion estimation unit <b>204</b> may not output a full set of motion information for the current video. Rather, motion estimation unit <b>204</b> may signal the motion information of the current video block with reference to the motion information of another video block. For example, motion estimation unit <b>204</b> may determine that the motion information of the current video block is sufficiently similar to the motion information of a neighboring video block.</p><p id="p-0212" num="0369">In one example, motion estimation unit <b>204</b> may indicate, in a syntax structure associated with the current video block, a value that indicates to the video decoder <b>300</b> that the current video block has the same motion information as the other video block.</p><p id="p-0213" num="0370">In another example, motion estimation unit <b>204</b> may identify, in a syntax structure associated with the current video block, another video block and a motion vector difference (MVD). The motion vector difference indicates a difference between the motion vector of the current video block and the motion vector of the indicated video block. The video decoder <b>300</b> may use the motion vector of the indicated video block and the motion vector difference to determine the motion vector of the current video block.</p><p id="p-0214" num="0371">As discussed above, video encoder <b>200</b> may predictively signal the motion vector. Two examples of predictive signalling techniques that may be implemented by video encoder <b>200</b> include advanced motion vector predication (AMVP) and merge mode signalling.</p><p id="p-0215" num="0372">Intra prediction unit <b>206</b> may perform intra prediction on the current video block. When intra prediction unit <b>206</b> performs intra prediction on the current video block, intra prediction unit <b>206</b> may generate prediction data for the current video block based on decoded samples of other video blocks in the same picture. The prediction data for the current video block may include a predicted video block and various syntax elements.</p><p id="p-0216" num="0373">Residual generation unit <b>207</b> may generate residual data for the current video block by subtracting (e.g., indicated by the minus sign) the predicted video block(s) of the current video block from the current video block. The residual data of the current video block may include residual video blocks that correspond to different sample components of the samples in the current video block.</p><p id="p-0217" num="0374">In other examples, there may be no residual data for the current video block for the current video block, for example in a skip mode, and residual generation unit <b>207</b> may not perform the subtracting operation.</p><p id="p-0218" num="0375">Transform processing unit <b>208</b> may generate one or more transform coefficient video blocks for the current video block by applying one or more transforms to a residual video block associated with the current video block.</p><p id="p-0219" num="0376">After transform processing unit <b>208</b> generates a transform coefficient video block associated with the current video block, quantization unit <b>209</b> may quantize the transform coefficient video block associated with the current video block based on one or more quantization parameter (QP) values associated with the current video block.</p><p id="p-0220" num="0377">Inverse quantization unit <b>210</b> and inverse transform unit <b>211</b> may apply inverse quantization and inverse transforms to the transform coefficient video block, respectively, to reconstruct a residual video block from the transform coefficient video block. Reconstruction unit <b>212</b> may add the reconstructed residual video block to corresponding samples from one or more predicted video blocks generated by the predication unit <b>202</b> to produce a reconstructed video block associated with the current block for storage in the buffer <b>213</b>.</p><p id="p-0221" num="0378">After reconstruction unit <b>212</b> reconstructs the video block, loop filtering operation may be performed to reduce video blocking artifacts in the video block.</p><p id="p-0222" num="0379">Entropy encoding unit <b>214</b> may receive data from other functional components of the video encoder <b>200</b>. When entropy encoding unit <b>214</b> receives the data, entropy encoding unit <b>214</b> may perform one or more entropy encoding operations to generate entropy encoded data and output a bitstream that includes the entropy encoded data.</p><p id="p-0223" num="0380"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a block diagram illustrating an example of video decoder <b>300</b> which may be video decoder <b>124</b> in the system <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>10</b></figref>.</p><p id="p-0224" num="0381">The video decoder <b>300</b> may be configured to perform any or all of the techniques of this disclosure. In the example of <figref idref="DRAWINGS">FIG. <b>12</b></figref>, the video decoder <b>300</b> includes a plurality of functional components. The techniques described in this disclosure may be shared among the various components of the video decoder <b>300</b>. In some examples, a processor may be configured to perform any or all of the techniques described in this disclosure.</p><p id="p-0225" num="0382">In the example of <figref idref="DRAWINGS">FIG. <b>12</b></figref>, video decoder <b>300</b> includes an entropy decoding unit <b>301</b>, a motion compensation unit <b>302</b>, an intra prediction unit <b>303</b>, an inverse quantization unit <b>304</b>, an inverse transformation unit <b>305</b>, and a reconstruction unit <b>306</b> and a buffer <b>307</b>. Video decoder <b>300</b> may, in some examples, perform a decoding pass generally reciprocal to the encoding pass described with respect to video encoder <b>200</b> (<figref idref="DRAWINGS">FIG. <b>11</b></figref>).</p><p id="p-0226" num="0383">Entropy decoding unit <b>301</b> may retrieve an encoded bitstream. The encoded bitstream may include entropy coded video data (e.g., encoded blocks of video data). Entropy decoding unit <b>301</b> may decode the entropy coded video data, and from the entropy decoded video data, motion compensation unit <b>302</b> may determine motion information including motion vectors, motion vector precision, reference picture list indexes, and other motion information. Motion compensation unit <b>302</b> may, for example, determine such information by performing the AMVP and merge mode.</p><p id="p-0227" num="0384">Motion compensation unit <b>302</b> may produce motion compensated blocks, possibly performing interpolation based on interpolation filters. Identifiers for interpolation filters to be used with sub-pixel precision may be included in the syntax elements.</p><p id="p-0228" num="0385">Motion compensation unit <b>302</b> may use interpolation filters as used by video encoder <b>200</b> during encoding of the video block to calculate interpolated values for sub-integer pixels of a reference block. Motion compensation unit <b>302</b> may determine the interpolation filters used by video encoder <b>200</b> according to received syntax information and use the interpolation filters to produce predictive blocks.</p><p id="p-0229" num="0386">Motion compensation unit <b>302</b> may use some of the syntax information to determine sizes of blocks used to encode frame(s) and/or slice(s) of the encoded video sequence, partition information that describes how each macroblock of a picture of the encoded video sequence is partitioned, modes indicating how each partition is encoded, one or more reference frames (and reference frame lists) for each inter-encoded block, and other information to decode the encoded video sequence.</p><p id="p-0230" num="0387">Intra prediction unit <b>303</b> may use intra prediction modes for example received in the bitstream to form a prediction block from spatially adjacent blocks. Inverse quantization unit <b>304</b> inverse quantizes, i.e., de-quantizes, the quantized video block coefficients provided in the bitstream and decoded by entropy decoding unit <b>301</b>. Inverse transform unit <b>305</b> applies an inverse transform.</p><p id="p-0231" num="0388">Reconstruction unit <b>306</b> may sum the residual blocks with the corresponding prediction blocks generated by motion compensation unit <b>302</b> or intra prediction unit <b>303</b> to form decoded blocks. If desired, a deblocking filter may also be applied to filter the decoded blocks in order to remove blockiness artifacts. The decoded video blocks are then stored in buffer <b>307</b>, which provides reference blocks for subsequent motion compensation/intra predication and also produces decoded video for presentation on a display device.</p><p id="p-0232" num="0389">A listing of solutions preferred by some embodiments is provided next.</p><p id="p-0233" num="0390">The following solutions show example embodiments of techniques discussed in the previous section (e.g., item 1).</p><p id="p-0234" num="0391">1. A video processing method (e.g., method <b>900</b> depicted in <figref idref="DRAWINGS">FIG. <b>9</b></figref>), comprising: performing (<b>902</b>) a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more subpictures that comprise one or more slices and a coded representation of a video, wherein the coded representation conforms to a format rule; wherein the format rule specifies that, in case that a rectangular slices mode is enabled for a video picture, then a picture-level slice index for each slice in each subpicture in the video picture is derived without explicit signalling in the coded representation; and wherein the format rule specifies that a number of coding tree units in each slice is derivable from the picture-level slice index.</p><p id="p-0235" num="0392">The following solutions show example embodiments of techniques discussed in the previous section (e.g., item 2).</p><p id="p-0236" num="0393">2. A video processing method, comprising: performing a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more subpictures that comprise one or more slices and a coded representation of a video, wherein the coded representation conforms to a format rule; wherein the format rule specifies that a subpicture level slice index is derivable based on information in the coded representation without signalling the sub-picture level slice index in the coded representation.</p><p id="p-0237" num="0394">3. The method of solution 2, wherein the format rule specifies that, due to use of a rectangular slice structure, the subpicture level slice index corresponds to an index to the slice in a list of slices in a subpicture.</p><p id="p-0238" num="0395">4. The method of solution 2, wherein the format rule specifies that the subpicture level slice index is derived from a particular value of picture-level slice index.</p><p id="p-0239" num="0396">The following solutions show example embodiments of techniques discussed in the previous sections (e.g., items 5, 6).</p><p id="p-0240" num="0397">5. A video processing method, comprising: performing a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more subpictures and/or one or more tiles and a coded representation of a video, wherein the coded representation conforms to a format rule; and wherein the conversion conforms to a constraint rule.</p><p id="p-0241" num="0398">6. The method of solution 5, wherein the constraint rule specifies that a tile cannot be in more than one subpictures.</p><p id="p-0242" num="0399">7. The method of solution 5, wherein the constraint rule specifies that a subpicture cannot include two slices that are smaller than corresponding tiles to which the two slices belong.</p><p id="p-0243" num="0400">The following solutions show example embodiments of techniques discussed in the previous section (e.g., items 7, 8).</p><p id="p-0244" num="0401">8. A video processing method, comprising: performing a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more tiles and/or one more slices; wherein the coded representation conforms to a format rule; wherein the format rule specifies that a field at a video picture level carries information about portioning of slices and/or tiles in the video picture.</p><p id="p-0245" num="0402">9. The method of solution 8, wherein the field comprises a video picture header.</p><p id="p-0246" num="0403">10. The method of solution 8, wherein the field comprises a picture parameter set.</p><p id="p-0247" num="0404">11. The method of any of solutions 8-10, wherein the format rule specifies to omit slice partitioning information at slice level by including the slice partitioning information in the field at the video picture level.</p><p id="p-0248" num="0405">The following solutions show example embodiments of techniques discussed in the previous section (e.g., item 9).</p><p id="p-0249" num="0406">12. A video processing method, comprising: performing a conversion between a video comprising one or more pictures and a coded representation of the video, wherein the conversion conforms to a partitioning rule that a minimum number of slices in which a video picture is partitioned is a function of whether rectangular partitioning is used for partitioning the video picture.</p><p id="p-0250" num="0407">13. The method of solution 12, wherein the partitioning rule specifies to use at least two slices for non-rectangular partitioning and at least one slice for rectangular partitioning.</p><p id="p-0251" num="0408">14. The method of solution 12, wherein the partitioning rule is also a function of whether and/or how many subpictures are used for partitioning the video picture.</p><p id="p-0252" num="0409">The following solutions show example embodiments of techniques discussed in the previous section (e.g., items 10, 11).</p><p id="p-0253" num="0410">15. A method of video processing, comprising: performing a conversion between a video slice of a video region of a video and a coded representation of the video; wherein the coded representation conforms to a format rule; wherein the format rule specifies that the coded representation signals the video slice based on a top-left location of the video slice and wherein the format rule specifies that the coded representation signals a height and/or a width of the video slice in partitioning information that is signalled at a video unit level.</p><p id="p-0254" num="0411">16. The method of solution 15, wherein the format rule specifies that the video slice is signalled in an order of slices defined by the format rule.</p><p id="p-0255" num="0412">17. The method of solution 15, wherein the video region corresponds to a subpicture and wherein the video unit level corresponds to a video picture.</p><p id="p-0256" num="0413">The following solutions show example embodiments of techniques discussed in the previous section (e.g., item 12).</p><p id="p-0257" num="0414">18. A method of video processing, comprising: performing a conversion between a video comprising video pictures and a coded representation of the video; wherein the coded representation conforms to a format rule; wherein the format rule specifies to omit signalling a difference between a tile index of a first tile in a rectangular slice and a tile index of a first tile in a next rectangular slice.</p><p id="p-0258" num="0415">19. The method of solution 18, wherein the difference is derivable from a zeroth slice in the video picture and the rectangular slice.</p><p id="p-0259" num="0416">The following solutions show example embodiments of techniques discussed in the previous section (e.g., item 13).</p><p id="p-0260" num="0417">20. A video processing method, comprising: performing a conversion between a video and a coded representation of the video, wherein the coded representation conforms to a format rule, wherein the format rule specifies that a relationship between a width of a video picture and a size of a coding tree unit controls signalling of information used for deriving a number of tile columns or rows in the video picture.</p><p id="p-0261" num="0418">21. The method of solution 20, wherein the format rule specifies to exclude signalling a number of tile rows or a number of tile columns in case that the width of the video picture is smaller than or equal to a width of the coding tree unit.</p><p id="p-0262" num="0419">The following solutions show example embodiments of techniques discussed in the previous section (e.g., item 16).</p><p id="p-0263" num="0420">22. A method of video processing, comprising: performing a conversion between a video comprising one or more video pictures and a coded representation of the video, wherein the coded representation conforms to a format rule, wherein the format rule specifies that a tile layout information is included in the coded representation for a video picture that comprises uniform spacing tiles and non-uniform spacing tiles.</p><p id="p-0264" num="0421">23. The method of solution 22, wherein the tile layout information includes in a syntax flag that is included in a picture parameter set.</p><p id="p-0265" num="0422">24. The method of any of solutions 22-23, wherein a number of explicitly signalled number of tile rows or columns is no less than a number of non-uniform spacing tiles.</p><p id="p-0266" num="0423">25. The method of any of solutions 22-23, wherein a number of explicitly signalled number of tile rows or columns is no less than a number of uniform spacing tiles.</p><p id="p-0267" num="0424">26. The method of any of above solutions, wherein the video region comprises a video coding unit.</p><p id="p-0268" num="0425">27. The method of any of above solutions, wherein the video region comprises a video picture.</p><p id="p-0269" num="0426">28. The method of any of solutions 1 to 27, wherein the conversion comprises encoding the video into the coded representation.</p><p id="p-0270" num="0427">29. The method of any of solutions 1 to 27, wherein the conversion comprises decoding the coded representation to generate pixel values of the video.</p><p id="p-0271" num="0428">30. A video decoding apparatus comprising a processor configured to implement a method recited in one or more of solutions 1 to 29.</p><p id="p-0272" num="0429">31. A video encoding apparatus comprising a processor configured to implement a method recited in one or more of solutions 1 to 29.</p><p id="p-0273" num="0430">32. A computer program product having computer code stored thereon, the code, when executed by a processor, causes the processor to implement a method recited in any of solutions 1 to 29.</p><p id="p-0274" num="0431">33. A method, apparatus or system described in the present document.</p><p id="p-0275" num="0432"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>1300</b> includes, at operation <b>1310</b>, performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more slices. The rule specifies that a syntax element indicating a difference between tile indices of two rectangular slices is signalled responsive to a condition being satisfied, wherein one of the slice indices is represented as i, where i is an integer.</p><p id="p-0276" num="0433">In some embodiments, a second rectangular slice of the two rectangular slices is represented as (i+1)-th rectangular slice, and the syntax element indicates the difference between a first tile index of a first tile containing a first coding tree unit in the (i+1)-th rectangular slice and a second tile index of a second tile containing a first coding tree unit in the i-th rectangular slice. In some embodiments, the at least one condition being satisfied comprises i being smaller than (a number of rectangular slices in the video picture&#x2212;1). In some embodiments, the at least one condition being satisfied comprises i being not equal to (a number of rectangular slices in the video picture&#x2212;1).</p><p id="p-0277" num="0434"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>1400</b> includes, at operation <b>1410</b>, performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more sub-pictures and each sub-picture comprises one or more rectangular slices. The rule specifies that a slice index at a sub-picture level for each rectangular slice in each sub-picture is derived to determine a number of coding tree units in each slice.</p><p id="p-0278" num="0435">In some embodiments, the slice index at the sub-picture level is determined based on a decoding order of a corresponding slice in a list of slices in a sub-picture. In some embodiments, in case a first slice index at the sub-picture level for a first slice is smaller than a second slice index at the sub-picture level for a second slice, the first slice is processed ahead of the second slice according to the decoding order. In some embodiments, the slice index at the sub-picture level is represented using a variable SubpicLevelSliceIdx. In some embodiments, a slice address is determined based on the slice index at the sub-picture level. In some embodiments, the slice index at the sub-picture level of a slice is determined based on a first sub-picture that includes the slice. In some embodiments, the slice index at the sub-picture level is a non-negative integer. In some embodiments, the slice index at the sub-picture level is greater than or equal to 0 and smaller than N, N being a number of slices in a sub-picture.</p><p id="p-0279" num="0436">In some embodiments, a first slice index at the sub-picture level for a first slice is different than a second slice index at the sub-picture level for a second slice in case the first slice and the second slice are different, where the first slice and the second slice are in a same sub-picture. In some embodiments, in case a first slice index at the sub-picture level for a first slice is smaller than a second slice index at the sub-picture level for a second slice, a first slice index at a picture-level for the first slice is smaller than a second slice index at the picture-level for the second slice. In some embodiments, the slice index at the sub-picture level of a slice is determined based on a slice index at a picture level of the slice.</p><p id="p-0280" num="0437"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>1500</b> includes, at operation <b>1510</b>, determining, for a conversion between a video picture of a video that comprises one or more sub-pictures and a bitstream of the video, a mapping relationship between a sub-picture-level slice index of a slice in a sub-picture and a picture level slice index of the slice. The method <b>1500</b> also includes, at operation <b>1520</b>, performing the conversion based on the determining.</p><p id="p-0281" num="0438">In some embodiments, the mapping relationship is represented as a two-dimensional array that is indexed using the picture-level slice index and a sub-picture index of the sub-picture. In some embodiments, the picture-level slice index is determined based on an array indicating a number of slices in each of the one or more sub-pictures. In some embodiments, the two-dimensional array and the array indicating the number of slices in each of the one or more sub-pictures are determined based on a process that scans all slices in an order of picture-level slice index. In some embodiments, the picture-level slice index of the slice is determined using the mapping relationship, and a number of coding tree blocks and/or addresses of the coding tree blocks in the slice are determined based on the picture-level slice index of the slice.</p><p id="p-0282" num="0439"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>1600</b> includes, at operation <b>1610</b>, performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more sub-pictures. The rule specifies that a tile of the video is positioned entirely within a single sub-picture of the video picture.</p><p id="p-0283" num="0440">In some embodiments, a first slice is located in a first tile, the first slice being smaller than the first tile. A second slice is located in a second tile, the second slice being smaller than the second tile. The first tile is different than the second tile, and the first slice and the second slice are located in different slices of a sub-picture.</p><p id="p-0284" num="0441"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>1700</b> includes, at operation <b>1710</b>, performing a conversion between a video picture of a video and a bitstream of the video. The video picture comprises one or more sub-pictures. The bitstream conforms to a format rule specifying that information of partitioning a picture is included in a syntax structure associated with the picture.</p><p id="p-0285" num="0442">In some embodiments, the syntax structure comprises a picture header or a picture parameter set. In some embodiments, a video unit includes a flag indicating whether the information of partitioning a picture is included in the syntax structure. In some embodiments, the video unit comprises a picture header, a picture parameter set, or a sequence parameter set. In some embodiments, in case the information of partitioning a picture is included in both the picture header and the picture parameter set, the information included in the picture header is used for the conversion.</p><p id="p-0286" num="0443"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>1800</b> includes, at operation <b>1810</b>, determining, for a conversion between a video picture of a video that comprises one or more slices having a non-rectangular shape and a bitstream of the video, slice partitioning information of the video picture. The method <b>1800</b> also includes, at operation <b>1820</b>, performing the conversion based on the determining.</p><p id="p-0287" num="0444">In some embodiments, the slice partitioning information is stored in a video unit of the video, and wherein the video unit comprises a picture parameter set or a picture header. In some embodiments, the bitstream conforms to a format rule specifying that the slice partitioning information of the video picture is included in a syntax structure associated with a video unit that includes the one or more slices. In some embodiments, the slice partitioning information of the video picture includes a value indicating a number of slices in a picture. In some embodiments, the slice partitioning information of the video picture comprises a value that indicates an index of a block-unit within a slice. In some embodiments, a value that indicates an index of a block-unit within a slice is omitted from the slice partitioning information of the video picture. In some embodiments, the slice partitioning information of the video picture comprises a value that indicates a number of block-units within a slice. In some embodiments, a value that indicates a number of block-units within a slice is omitted from the slice partitioning information of the video picture. In some embodiments, the block-unit is a coding tree unit or a tile. In some embodiments, the slice partitioning information of the video picture is omitted in a slice header. In some embodiments, a slice index of a slice is included in a slice header, and a picture-level slice index of the slice is determined based on an address of the slice.</p><p id="p-0288" num="0445">In some embodiments, the slice partitioning information of each of the one or more slices is organized in an order in the syntax structure associated with the video unit. In some embodiments, the slice partitioning information of each of the one or more slices is included in the syntax structure in an ascending order. In some embodiments, the slice partitioning information of each of the one or more slices is included in the syntax structure in a descending order.</p><p id="p-0289" num="0446">In some embodiments, the slice partitioning information of at least one of the one or more slices is omitted in the bitstream. In some embodiments, the slice partitioning information of the at least one of the one or more slices is inferred from slice partitioning information of other slices included in the bitstream. In some embodiments, a number of block-units for slice S&#x2212;1 is not included in the bitstream, where S represent a number of slices in the video picture, S being greater than 1.</p><p id="p-0290" num="0447"><figref idref="DRAWINGS">FIG. <b>19</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>1900</b> includes, at operation <b>1910</b>, performing a conversion between a video picture of a video that comprises one or more slices and a bitstream of the video according to a rule. The rule specifies that a number of slices in the video picture is equal to or greater than a minimum number of slices determined based on whether rectangular partitioning or non-rectangular partitioning is applied to the video picture.</p><p id="p-0291" num="0448">In some embodiments, the minimum number of slices is two in case the non-rectangular partitioning is applied, and the minimum number of slices is one in case the rectangular partitioning is applied. In some embodiments, the minimum number of slices is one in case the non-rectangular partitioning is applied, and the minimum number of slices is one in case the rectangular partitioning is applied. In some embodiments, the minimum number of slices is further determined based on a number of sub-pictures in the video picture.</p><p id="p-0292" num="0449"><figref idref="DRAWINGS">FIG. <b>20</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2000</b> includes, at operation <b>2010</b>, performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more slices. In case slice partitioning information of the video picture is included in a syntax structure of a video unit, a slice is represented by a top-left location and a dimension of the slice.</p><p id="p-0293" num="0450">In some embodiments, the top-left location and the dimension of the slice are indicated using a top-left location of a block-unit that is within the slice, a dimension of the block-unit, and the dimension of the slice measured using the dimension of the block-unit. In some embodiments, a top-left location of each slice and a dimension of each slice is included in the syntax structure in an order.</p><p id="p-0294" num="0451"><figref idref="DRAWINGS">FIG. <b>21</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2100</b> includes, at operation <b>2110</b>, performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more sub-pictures and each sub-picture comprises one or more slices. The rule specifies a manner by which partitioning information of the one or more slices in each sub-picture is present in the bitstream.</p><p id="p-0295" num="0452">In some embodiments, the video unit comprises a sequence parameter set, a picture parameter set, or a picture header. In some embodiments, the partitioning information of the one or more sub-pictures is arranged in an ascending order based on sub-picture indices. In some embodiments, the partitioning information of the one or more slices in each sub-picture is arranged in an ascending order based on sub-picture-level slice indices.</p><p id="p-0296" num="0453"><figref idref="DRAWINGS">FIG. <b>22</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2200</b> includes, at operation <b>2210</b>, performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more rectangular slices and each slice comprises one or more tiles. The rule specifies that signalling between a difference between a first tile index of a first tile in i<sup>th </sup>rectangular slice and a second tile index of a first tile in (i+1)<sup>th </sup>rectangular slice is omitted in the bitstream.</p><p id="p-0297" num="0454">In some embodiments, the second tile index of the first tile in (i+1)<sup>th </sup>rectangular slice is derived based on rectangular slices indexed from 0<sup>th </sup>to i<sup>th</sup>. In some embodiments, the second tile index of the first tile in (i+1)<sup>th </sup>rectangular slice is derived to be a minimum tile index that is out of a range defined by rectangular slices indexed from 0<sup>th </sup>to i<sup>th</sup>.</p><p id="p-0298" num="0455"><figref idref="DRAWINGS">FIG. <b>23</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2300</b> includes, at operation <b>2310</b>, determining, for a conversion between a video picture of a video and a bitstream of the video, that information for deriving a number of columns of tiles and a number of rows of tiles in the video picture is conditionally included in the bitstream responsive to a relationship between a dimension of the video picture and a dimension of a coding tree block. The method <b>2300</b> also includes, at operation <b>2320</b>, performing the conversion based on the determining.</p><p id="p-0299" num="0456">In some embodiments, the information is omitted in case a width of the video picture is smaller than or equal to a width of the coding tree block. In some embodiments, the information is omitted in case a height of the video picture is smaller than or equal to a height of the coding tree block.</p><p id="p-0300" num="0457"><figref idref="DRAWINGS">FIG. <b>24</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2400</b> includes, at operation <b>2410</b>, performing a conversion between a video picture of a video and a bitstream of the video. The video picture comprises one or more sub-pictures. The bitstream conforms to a format rule specifying that, in case a variable that specifies a subpicture identifier of a subpicture that includes a slice is present in the bitstream, there is one and only one syntax element that satisfies a condition that a second variable corresponding to the syntax element is equal to the variable.</p><p id="p-0301" num="0458">In some embodiments, the variable is represented as slice_subpic_id and the second variable is represented as SubpicIdVal. The syntax element corresponding to the syntax element is represented as SubpicIdVal [CurrSubpicIdx].</p><p id="p-0302" num="0459"><figref idref="DRAWINGS">FIG. <b>25</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2500</b> includes, at operation <b>2510</b>, performing a conversion between a video picture of a video and a bitstream of the video. The video picture comprises one or more sub-pictures. In case a non-rectangular partitioning is applied or sub-picture information is omitted in the bitstream, two tiles in a slice have different addresses.</p><p id="p-0303" num="0460">In some embodiments, a first syntax flag rect_slice_flag indicates whether the non-rectangular partitioning is applied, and a second syntax flag subpic_info_present_info indicates whether the sub-picture information is present in the bitstream.</p><p id="p-0304" num="0461"><figref idref="DRAWINGS">FIG. <b>26</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2600</b> includes, at operation <b>2610</b>, performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The video picture comprises one or more tiles. The rule specifies that a syntax element is used to indicate a type of tile layout in case the one or more tiles are organized in both uniform spacing and non-uniform spacing.</p><p id="p-0305" num="0462">In some embodiments, the syntax element is included in a picture parameter set indicating whether uniform spacing is followed by non-uniform spacing or non-uniform spacing is followed by uniform spacing in the tile layout. In some embodiments, the tile layout includes non-uniformly spaced tiles and wherein a number of explicitly indicated tile columns or rows is equal to or greater than a total number of the non-uniformly spaced tiles. In some embodiments, the tile layout includes uniformly spaced tiles, and a number of explicitly indicated tile columns or rows is equal to or greater than a total number of the uniformly spaced tiles. In some embodiments, uniform spacing is followed by non-uniform spacing in the tile layout, dimensions of non-uniformly spaced tiles are determined first according to a first inverse order, and dimensions of uniformly spaced tiles are determined next according to a second inverse order. In some embodiments, the dimensions comprise widths of tile columns or heights of tile rows.</p><p id="p-0306" num="0463"><figref idref="DRAWINGS">FIG. <b>27</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2700</b> includes, at operation <b>2710</b>, performing a conversion between a video picture of a video and a bitstream of the video according to a rule. The rule specifies that whether or how a Merge Estimation Region (MER) size is processed in the conversion is conditioned on a minimum allowed coding block size.</p><p id="p-0307" num="0464">In some embodiments, the MER size is equal to or greater than the minimum allowed coding block size. In some embodiments, the MER size is indicated by MER_size and the minimum allowed coding block size is indicated by MinCbSizeY, and a difference between Log2(MER_size) and Log2(MinCbSizeY) is included in the bitstream.</p><p id="p-0308" num="0465"><figref idref="DRAWINGS">FIG. <b>28</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2800</b> includes, at operation <b>2810</b>, performing a conversion between a video that comprises at least a video tile and a bitstream of the video according to a rule. The rule specifies that a height of a slice in the video tile in units of coding tree units is derived based on a value of a first syntax element in the bitstream indicating a number of explicitly provided slice heights for slices in the video tile that includes the slice.</p><p id="p-0309" num="0466">In some embodiments, the height of the slice in the video tile in units of coding tree units is derived from information for the video in response to the value of the first syntax element being equal to 0. In some embodiments, the height of the slice in the video tile in units of coding tree units is represented as sliceHeightInCtus [i]. sliceHeightInCtus [i] is equal to a value of a row height RowHeight [SliceTopLeftTileIdx[i]/NumTileColumns], where SliceTopLeftTileldx specifies a tile index of a tile that includes a first coding tree unit in the slice and NumTileColumns specifies a number of tile columns, and the value of the row height RowHeight[j] specifies a height of a j-th tile row in units of coding tree blocks.</p><p id="p-0310" num="0467">In some embodiments, the height of the slice in the video tile in units of coding tree units is derived from information for the video in response to the height for the slice in the video tile being not present in the bitstream. In some embodiments, the height of the slice in the video tile in units of coding tree units is derived according to a second syntax element present in the bitstream that indicates the height of the slice in the video tile. In some embodiments, in response to the first syntax element being equal to 0, the video tile that includes the slice is not split into multiple slices.</p><p id="p-0311" num="0468"><figref idref="DRAWINGS">FIG. <b>29</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>2900</b> includes, at operation <b>2910</b>, performing a conversion between a video comprising a video picture comprising a video tile including one or more slices and a bitstream of the video according to a rule. The rule specifies that a second slice in a tile that includes a first slice in a picture has a height that is represented in a unit of coding tree units. The first slice has a first slice index, and the second slice has a second slice index that is determined based on the first slice index and a number of explicitly provided slice heights in the video tile. The height of the second slice is determined based on the first slice index and the second slice index.</p><p id="p-0312" num="0469">In some embodiments, the first slice index is represented as i, and the second slice index is represented as (num_exp_slices_in_tile[i]&#x2212;1), where num_exp_slices_in_tile specifies a number of explicitly provided slice heights in the video tile. The height of the second slice is determined based on exp_slice_height_in_ctus_minus1[i][num_exp_slices_in_tile[i]&#x2212;1]+1, where exp_slice_height_in_ctus_minus1 specifies slice heights in the unit of coding tree units in the video tile. In some embodiments, a height of uniform slices that partition the video tile is indicated by a last entry of exp_slice_height_in_ctus_minus1. In some embodiments, the second slice always exists in the picture. In some embodiments, the height of the second slice is disallowed to be reset for the conversion. In some embodiments, a height of a third slice having an index greater than (num_exp_slices_in_tile[i]&#x2212;1) is determined based on exp_slice_height_in_ctus_minus1[i][num_exp_slices_in_tile[i]&#x2212;1]. In some embodiments, the second slice does not exist in the video tile. In some embodiments, the height of the second slice is smaller than or equal to exp_slice_height_in_ctus_minus1[i][num_exp_slices_in_tile[i]&#x2212;1]+1.</p><p id="p-0313" num="0470"><figref idref="DRAWINGS">FIG. <b>30</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>3000</b> includes, at operation <b>3010</b>, performing a conversion between a video comprising a video picture including one or more tiles and a bitstream of the video. The video picture refers to a picture parameter set. The picture parameter set conforms to a format rule specifying that the picture parameter set includes a list of column widths for N tile columns, where N is an integer. An (N&#x2212;1)-th tile column exists in the video picture and the (N&#x2212;1)-th tile column has a width that is equal to an (N&#x2212;1)-th entry in a list of explicitly included tile column widths plus one number of coding tree blocks.</p><p id="p-0314" num="0471">In some embodiments, N&#x2212;1 is represented as num_exp_tile_columns_minus1. In some embodiments, a width of the tile column in a unit of coding tree blocks is determined based on tile_column_width_minus1[num_exp_tile_columns_minus1]+1, where tile_column_width_minus1 specifies a width of a tile column in the unit of coding tree blocks. In some embodiments, the width of the tile column in the unit of coding tree blocks is disallowed to be reset and is determined solely based on tile_column_width_minus1[num_exp_tile_columns_minus1]. In some embodiments, the width of the tile column in the unit of coding tree blocks is equal to tile_column_width_minus1[num_exp_tile_columns_minus1]+1. In some embodiments, a width of a second tile column having an index that is greater than num_exp_tile_columns_minus1 is determined based on tile_column_width_minus1 [num_exp_tile_columns_minus1].</p><p id="p-0315" num="0472"><figref idref="DRAWINGS">FIG. <b>31</b></figref> is flowchart representation of a method for video processing in accordance with the present technology. The method <b>3100</b> includes, at operation <b>3110</b>, performing a conversion between a video comprising a video picture including one or more tiles and a bitstream of the video. The video picture refers to a picture parameter set. The picture parameter set conforms to a format rule specifying that the picture parameter set includes a list of row heights for N tile rows, where N is an integer. An (N&#x2212;1)-th tile row exists in the video picture and the (N&#x2212;1)-th tile row has a height that is equal to an (N&#x2212;1)-th entry in a list of explicitly included tile row heights plus one number of coding tree blocks.</p><p id="p-0316" num="0473">In some embodiments, N&#x2212;1 is represented as num_exp_tile_rows_minus1. In some embodiments, a height of the tile row in a unit of coding tree blocks is determined based on tile_row_height_minus1[num_exp_tile_row_minus1]+1, where tile_row_height_minus1 specifies a height of a tile row in the unit of coding tree blocks. In some embodiments, the height of the tile row in the unit of coding tree blocks is disallowed to be reset and is determined solely based on tile_row_height_minus1[num_exp_tile_row_minus1]. In some embodiments, the height of the tile row in the unit of coding tree blocks is equal to tile_row_height_minus1[num_exp_tile_row_minus1]+1. In some embodiments, a height of a second tile row having an index that is greater than num_exp_tile_rows_minus1 is determined based on tile_row_height_minus1[num_exp_tile_row_minus1].</p><p id="p-0317" num="0474">In some embodiments, the conversion includes encoding the video into the bitstream. In some embodiments, the conversion includes decoding the video from the bitstream.</p><p id="p-0318" num="0475">In the solutions described herein, an encoder may conform to the format rule by producing a coded representation according to the format rule. In the solutions described herein, a decoder may use the format rule to parse syntax elements in the coded representation with the knowledge of presence and absence of syntax elements according to the format rule to produce decoded video.</p><p id="p-0319" num="0476">In the present document, the term &#x201c;video processing&#x201d; may refer to video encoding, video decoding, video compression or video decompression. For example, video compression algorithms may be applied during conversion from pixel representation of a video to a corresponding bitstream representation or vice versa. The bitstream representation of a current video block may, for example, correspond to bits that are either co-located or spread in different places within the bitstream, as is defined by the syntax. For example, a macroblock may be encoded in terms of transformed and coded error residual values and also using bits in headers and other fields in the bitstream. Furthermore, during conversion, a decoder may parse a bitstream with the knowledge that some fields may be present, or absent, based on the determination, as is described in the above solutions. Similarly, an encoder may determine that certain syntax fields are or are not to be included and generate the coded representation accordingly by including or excluding the syntax fields from the coded representation.</p><p id="p-0320" num="0477">The disclosed and other solutions, examples, embodiments, modules and the functional operations described in this document can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this document and their structural equivalents, or in combinations of one or more of them. The disclosed and other embodiments can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer readable medium for execution by, or to control the operation of, data processing apparatus. The computer readable medium can be a machine-readable storage device, a machine-readable storage substrate, a memory device, a composition of matter effecting a machine-readable propagated signal, or a combination of one or more them. The term &#x201c;data processing apparatus&#x201d; encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them. A propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus.</p><p id="p-0321" num="0478">A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.</p><p id="p-0322" num="0479">The processes and logic flows described in this document can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an field programmable gate array (FPGA) or an application specific integrated circuit (ASIC).</p><p id="p-0323" num="0480">Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random-access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., erasable programmable read-only memory (EPROM), electrically EPROM (EEPROM), and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and compact disc read-only memory (CD ROM) and digital versatile disc read-only memory (DVD-ROM) disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.</p><p id="p-0324" num="0481">While this patent document contains many specifics, these should not be construed as limitations on the scope of any subject matter or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular techniques. Certain features that are described in this patent document in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.</p><p id="p-0325" num="0482">Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. Moreover, the separation of various system components in the embodiments described in this patent document should not be understood as requiring such separation in all embodiments.</p><p id="p-0326" num="0483">Only a few implementations and examples are described and other implementations, enhancements and variations can be made based on what is described and illustrated in this patent document.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of processing video data, comprising:<claim-text>determining, for a conversion between a video comprising a video picture referring to a picture parameter set and a bitstream of the video, a scanning process is applied to the video picture, wherein the video picture is partitioned into one or more tiles, one or more slices, and a plurality of coding tree units;</claim-text><claim-text>determining, in the scanning process, that the picture parameter set includes a list of syntax elements indicating tile column widths for N tile columns having N indexes, respectively, wherein N is an integer; and</claim-text><claim-text>performing the conversion based on the determining,</claim-text><claim-text>wherein the list of syntax elements comprises a first syntax element, a value of which plus 1 specifies directly a width of a N-th tile column of the N tile columns in units of coding tree blocks without referring to other information, and</claim-text><claim-text>wherein the value of the first syntax element is used to derive a width of a tile column with an index greater than the N indexes.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a value of N is indicated by a second syntax element included in the picture parameter set.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the width of the N-th tile column of the N tile columns in units of coding tree blocks is disallowed to be reset.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first syntax element is a N-th entry in the list of syntax elements, wherein a uniform tile column width is set to the width of the N-th tile column of the N tile columns, and wherein when a difference between a picture width of a luma component in units of coding tree blocks and a sum of the tile column widths of the N tile columns is greater than or equal to the width of the N-th tile column of the N tile columns, a width of a (N+1)-th tile column is set to be equal to the width of the N-th tile column of the N tile columns.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein when a difference between a picture width of a luma component in units of coding tree blocks and a sum of the tile column widths for the N tile columns is less than the width of the N-th tile column of the N tile columns, a width of a (N+1)-th tile column is set to be equal to the difference.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the picture parameter set further includes a second list of syntax elements indicating tile row heights for M tile rows having M indexes, respectively, wherein M is an integer,<claim-text>wherein the second list of syntax elements comprises a third syntax element, a value of which plus 1, specifies directly a height of a M-th tile row of the M tile rows in units of coding tree blocks without referring to other information, and</claim-text><claim-text>wherein the value of the third syntax element is used to derive a height of a tile row with a second index greater than the M indexes.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein a value of M is indicated by a fourth syntax element included in the picture parameter set.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the height of the M-th tile row of the M tile rows in units of coding tree blocks is disallowed to be reset.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the third syntax element is a M-th entry in the second list of syntax elements, wherein a uniform tile row height is set to the height of the M-th tile row of the M tile rows, and wherein when a difference between a picture height of a luma component in units of coding tree blocks and a sum of the tile row heights for the M tile rows is greater than or equal to the height of the M-th tile row of the M tile rows, a height of a (M+1)-th tile row is set to be equal to the height of the M-th tile row of the M tile rows.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein when a difference between a picture height of a luma component in units of coding tree blocks and a sum of the tile row heights for the M tile rows is greater than or equal to the height of the M-th tile row of the M tile rows, a height of a (M+1)-th tile row is set to be equal to the difference.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conversion includes encoding the video into the bitstream.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conversion includes decoding the video from the bitstream.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. An apparatus for processing video data comprising a processor and a non-transitory memory with instructions thereon, wherein the instructions upon execution by the processor, cause the processor to:<claim-text>determine, for a conversion between a video comprising a video picture referring to a picture parameter set and a bitstream of the video, a scanning process is applied to the video picture, wherein the video picture is partitioned into one or more tiles, one or more slices, and a plurality of coding tree units;</claim-text><claim-text>determine, in the scanning process, that the picture parameter set includes a list of syntax elements indicating tile column widths for N tile columns having N indexes, respectively, wherein N is an integer; and</claim-text><claim-text>perform the conversion based on the determining,</claim-text><claim-text>wherein the list of syntax elements comprises a first syntax element, a value of which plus 1 specifies directly a width of a N-th tile column of the N tile columns in units of coding tree blocks without referring to other information, and</claim-text><claim-text>wherein the value of the first syntax element is used to derive a width of a tile column with an index greater than the N indexes.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein a value of N is indicated by a second syntax element included in the picture parameter set.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the width of the N-th tile column of the N tile columns in units of coding tree blocks is disallowed to be reset.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The apparatus of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the first syntax element is a N-th entry in the list of syntax elements, wherein a uniform tile column width is set to the width of the N-th tile column of the N tile columns, and wherein when a difference between a picture width of a luma component in units of coding tree blocks and a sum of the tile column widths of the N tile columns is greater than or equal to the width of the N-th tile column of the N tile columns, a width of a (N+1)-th tile column is set to be equal to the width of the N-th tile column of the N tile columns.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A non-transitory computer-readable storage medium storing instructions that cause a processor to:<claim-text>determine, for a conversion between a video comprising a video picture referring to a picture parameter set and a bitstream of the video, a scanning process is applied to the video picture, wherein the video picture is partitioned into one or more tiles, one or more slices, and a plurality of coding tree units;</claim-text><claim-text>determine, in the scanning process, that the picture parameter set includes a list of syntax elements indicating tile column widths for N tile columns having N indexes, respectively, wherein N is an integer; and</claim-text><claim-text>perform the conversion based on the determining,</claim-text><claim-text>wherein the list of syntax elements comprises a first syntax element, a value of which plus 1 specifies directly a width of a N-th tile column of the N tile columns in units of coding tree blocks without referring to other information, and</claim-text><claim-text>wherein the value of the first syntax element is used to derive a width of a tile column with an index greater than the N indexes.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein a value of N is indicated by a second syntax element included in the picture parameter set.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A non-transitory computer-readable recording medium storing a bitstream of a video which is generated by a method performed by a video processing apparatus, wherein the method comprises:<claim-text>determining, for a video comprising a video picture referring to a picture parameter set, a scanning process is applied to the video picture, wherein the video picture is partitioned into one or more tiles, one or more slices, and a plurality of coding tree units;</claim-text><claim-text>determining, in the scanning process, that the picture parameter set includes a list of syntax elements indicating tile column widths for N tile columns having N indexes, respectively, wherein N is an integer; and</claim-text><claim-text>generating the bitstream based on the determining,</claim-text><claim-text>wherein the list of syntax elements comprises a first syntax element, a value of which plus 1 specifies directly a width of a N-th tile column of the N tile columns in units of coding tree blocks without referring to other information, and</claim-text><claim-text>wherein the value of the first syntax element is used to derive a width of a tile column with an index greater than the N indexes.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The non-transitory computer-readable recording medium of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein a value of N is indicated by a second syntax element included in the picture parameter set.</claim-text></claim></claims></us-patent-application>