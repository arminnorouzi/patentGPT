<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007296A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007296</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17894735</doc-number><date>20220824</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>52</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>105</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>577</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>52</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>105</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>577</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">DMVR-BASED INTER-PREDICTION METHOD AND DEVICE</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17470899</doc-number><date>20210909</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11451820</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17894735</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/KR2020/001861</doc-number><date>20200211</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17470899</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62818075</doc-number><date>20190313</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>LG Electronics Inc.</orgname><address><city>Seoul</city><country>KR</country></address></addressbook><residence><country>KR</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>PARK</last-name><first-name>Naeri</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>NAM</last-name><first-name>Junghak</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>JANG</last-name><first-name>Hyeongmoon</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">An image decoding method includes: acquiring, from a bitstream, luma weight L0 flag information indicating whether there is an L0 prediction-related weight factor and luma weight L1 flag information indicating whether there is an L1 prediction-related weight factor; determining to apply decoder-side motion vector refinement (DMVR) to an L0 motion vector and L1 motion vector for a current block, when the luma weight L0 flag information and the luma weight L1 flag information are both zero; when it has been determined to apply DMVR, deriving a refined L0 motion vector and a refined L1 motion vector by applying the DMVR to the current block; deriving prediction samples for the current block on the basis of L0 prediction using the refined L0 motion vector and L1 prediction using the refined L1 motion vector; and generating reconstruction samples for the current block on the basis of the prediction samples.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="75.10mm" wi="95.50mm" file="US20230007296A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="124.54mm" wi="97.54mm" file="US20230007296A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="197.61mm" wi="136.23mm" orientation="landscape" file="US20230007296A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="192.79mm" wi="130.81mm" orientation="landscape" file="US20230007296A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="167.47mm" wi="137.92mm" orientation="landscape" file="US20230007296A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="165.86mm" wi="111.00mm" orientation="landscape" file="US20230007296A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="205.99mm" wi="83.14mm" file="US20230007296A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="190.58mm" wi="83.14mm" file="US20230007296A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="205.99mm" wi="83.14mm" file="US20230007296A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="143.26mm" wi="115.15mm" file="US20230007296A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="179.07mm" wi="126.41mm" file="US20230007296A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="165.44mm" wi="126.41mm" file="US20230007296A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="173.91mm" wi="149.52mm" orientation="landscape" file="US20230007296A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of U.S. application Ser. No. 17/470,899, filed on Sep. 9, 2021, which is a continuation pursuant to 35 U.S.C. &#xa7; 119(e) of International Application PCT/KR2020/001861, with an international filing date of Feb. 11, 2020, which claims the benefit of U.S. Provisional Patent Application No. 62/818,075, filed on Mar. 13, 2019, the contents of which are hereby incorporated by reference herein in their entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND OF THE DISCLOSURE</heading><heading id="h-0003" level="1">Field of the Disclosure</heading><p id="p-0003" num="0002">This document relates to an image coding technology, and more specifically, to a method and an apparatus for performing inter prediction based on a Decoder-side Motion Vector Refinement (DMVR).</p><heading id="h-0004" level="1">Related Art</heading><p id="p-0004" num="0003">The demands for high-resolution and high-quality images and video, such as an ultra-high definition (UHD) image and video of 4K or 8K or more, are recently increasing in various fields. As image and video data become high resolution and high quality, the amount of information or the number of bits that is relatively transmitted is increased compared to the existing image and video data. Accordingly, if image data is transmitted using a medium, such as the existing wired or wireless wideband line, or image and video data are stored using the existing storage medium, transmission costs and storage costs are increased.</p><p id="p-0005" num="0004">Furthermore, interests and demands for immersive media, such as virtual reality (VR), artificial reality (AR) content or a hologram, are recently increasing. The broadcasting of an image and video having image characteristics different from those of real images, such as game images, is increasing.</p><p id="p-0006" num="0005">Accordingly, there is a need for a high-efficiency image and video compression technology in order to effectively compress and transmit or store and playback information of high-resolution and high-quality images and video having such various characteristics.</p><heading id="h-0005" level="1">SUMMARY</heading><p id="p-0007" num="0006">This document provides a method and an apparatus for increasing image coding efficiency.</p><p id="p-0008" num="0007">This document also provides a method and an apparatus of an efficient inter prediction.</p><p id="p-0009" num="0008">This document also provides a method and an apparatus for performing an inter prediction based on a decoder-side motion Vector refinement (DMVR).</p><p id="p-0010" num="0009">This document also provides a method and an apparatus for performing an inter prediction based on a bi-directional optical flow (BDOF).</p><p id="p-0011" num="0010">This document also provides a method and an apparatus for enhancing prediction performance by providing a condition for determining whether to apply a DMVR for enhancing image coding efficiency and/or a condition for determining whether to apply a BDOF.</p><p id="p-0012" num="0011">According to one exemplary embodiment of this document, an image decoding method performed by a decoding apparatus is provided. The method includes: obtaining luma weight L0 flag information indicating whether a weight factor for L0 prediction is present and luma weight L1 flag information indicating whether a weight factor for L1 prediction is present from a bitstream; determining to apply decoder-side motion vector refinement (DMVR) to an L0 motion vector and an L1 motion vector of a current block, when a value of the luma weight L0 flag information and a value of the luma weight L1 flag information are both equal to 0; deriving a refined L0 motion vector and a refined L1 motion vector by applying the DMVR to the current block, when it is determined to apply the DMVR; deriving prediction samples for the current block based on the L0 prediction using the refined L0 motion vector and the L1 prediction using the refined L1 motion vector; and generating reconstructed samples for the current block based on the prediction samples.</p><p id="p-0013" num="0012">According to another exemplary embodiment of this document, an image encoding method performed by an encoding apparatus is provided. The method includes: determining luma weight L0 flag information indicating whether a weight factor for L0 prediction is present and luma weight L1 flag information indicating whether a weight factor for L1 prediction is present; determining to apply decoder-side motion vector refinement (DMVR) to an L0 motion vector and an L1 motion vector of a current block, when a value of the luma weight L0 flag information and a value of the luma weight L1 flag information are both equal to 0; deriving a refined L0 motion vector and a refined L1 motion vector by applying the DMVR to the current block, when it is determined to apply the DMVR; deriving prediction samples for the current block based on the L0 prediction using the refined L0 motion vector and the L1 prediction using the refined L1 motion vector; deriving residual samples based on the prediction samples; and encoding image information including information on the residual samples.</p><p id="p-0014" num="0013">According to this document, overall image/video compression efficiency can be increased.</p><p id="p-0015" num="0014">According to this document, calculation complexity can be reduced and overall coding efficiency can be enhanced through an efficient inter prediction.</p><p id="p-0016" num="0015">According to this document, various application conditions are proposed in applying a DMVR and/or BDOF of refining motion information during a motion compensation process to enhance efficiency in terms of complexity and performance.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0006" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>1</b></figref> schematically illustrates an example of a video/image coding system that is applicable to embodiments of this document.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a diagram schematically explaining the configuration of a video/image encoding apparatus that is applicable to embodiments of this document.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram schematically explaining the configuration of a video/image decoding apparatus that is applicable to embodiments of this document.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a diagram explaining an embodiment of a process of performing decoder-side motion vector refinement (DMVR) in a true bi-prediction.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a diagram explaining an embodiment of a process of performing decoder-side motion vector refinement (DMVR) using a sum of absolute differences (SAD).</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates an example representing a method for performing a decoding process through checking of application conditions of DMVR and BDOF.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIGS. <b>7</b> and <b>8</b></figref> illustrate another example representing a method for performing a decoding process through checking of application conditions of DMVR and BDOF.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a diagram illustrated to explain the concept of BDOF.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flowchart schematically illustrating an encoding method that can be performed by an encoding apparatus according to an embodiment of this document.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flowchart schematically illustrating a decoding method that can be performed by a decoding apparatus according to an embodiment of this document.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates an example of a content streaming system to which embodiments disclosed in this document are applicable.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0007" level="1">DESCRIPTION OF EXEMPLARY EMBODIMENTS</heading><p id="p-0028" num="0027">This document may be modified in various ways and may have various embodiments, and specific embodiments will be illustrated in the drawings and described in detail. However, this does not intend to limit this document to the specific embodiments. Terms commonly used in this specification are used to describe a specific embodiment and is not used to limit the technical spirit of this document. An expression of the singular number includes plural expressions unless evidently expressed otherwise in the context. A term, such as &#x201c;include&#x201d; or &#x201c;have&#x201d; in this specification, should be understood to indicate the existence of a characteristic, number, step, operation, element, part, or a combination of them described in the specification and not to exclude the existence or the possibility of the addition of one or more other characteristics, numbers, steps, operations, elements, parts or a combination of them.</p><p id="p-0029" num="0028">Meanwhile, elements in the drawings described in this document are independently illustrated for convenience of description related to different characteristic functions. This does not mean that each of the elements is implemented as separate hardware or separate software. For example, at least two of elements may be combined to form a single element, or a single element may be divided into a plurality of elements. An embodiment in which elements are combined and/or separated is also included in the scope of rights of this document unless it deviates from the essence of this document.</p><p id="p-0030" num="0029">Hereinafter, preferred embodiments of this document are described more specifically with reference to the accompanying drawings. Hereinafter, in the drawings, the same reference numeral is used in the same element, and a redundant description of the same element may be omitted.</p><p id="p-0031" num="0030">This document relates to video/image coding. For example, the methods/embodiments disclosed in this document may be applied to a method disclosed in the versatile video coding (VVC), the EVC (essential video coding) standard, the AOMedia Video 1 (AV1) standard, the 2nd generation of audio video coding standard (AVS2), or the next generation video/image coding standard (ex. H.267 or H.268, etc.).</p><p id="p-0032" num="0031">This document presents various embodiments of video/image coding, and the embodiments may be performed in combination with each other unless otherwise mentioned.</p><p id="p-0033" num="0032">In this document, video may refer to a series of images over time. Picture generally refers to a unit representing one image in a specific time zone, and a slice/tile is a unit constituting part of a picture in coding. The slice/tile may include one or more coding tree units (CTUs). One picture may consist of one or more slices/tiles. One picture may consist of one or more tile groups. One tile group may include one or more tiles. A brick may represent a rectangular region of CTU rows within a tile in a picture. A tile may be partitioned into multiple bricks, each of which consisting of one or more CTU rows within the tile. A tile that is not partitioned into multiple bricks may be also referred to as a brick. A brick scan is a specific sequential ordering of CTUs partitioning a picture in which the CTUs are ordered consecutively in CTU raster scan in a brick, bricks within a tile are ordered consecutively in a raster scan of the bricks of the tile, and tiles in a picture are ordered consecutively in a raster scan of the tiles of the picture. A tile is a rectangular region of CTUs within a particular tile column and a particular tile row in a picture. The tile column is a rectangular region of CTUs having a height equal to the height of the picture and a width specified by syntax elements in the picture parameter set. The tile row is a rectangular region of CTUs having a height specified by syntax elements in the picture parameter set and a width equal to the width of the picture. A tile scan is a specific sequential ordering of CTUs partitioning a picture in which the CTUs are ordered consecutively in CTU raster scan in a tile whereas tiles in a picture are ordered consecutively in a raster scan of the tiles of the picture. A slice includes an integer number of bricks of a picture that may be exclusively contained in a single NAL unit. A slice may consists of either a number of complete tiles or only a consecutive sequence of complete bricks of one tile. Tile groups and slices may be used interchangeably in this document. For example, in this document, a tile group/tile group header may be called a slice/slice header.</p><p id="p-0034" num="0033">A pixel or a pel may mean a smallest unit constituting one picture (or image). Also, &#x2018;sample&#x2019; may be used as a term corresponding to a pixel. A sample may generally represent a pixel or a value of a pixel, and may represent only a pixel/pixel value of a luma component or only a pixel/pixel value of a chroma component.</p><p id="p-0035" num="0034">A unit may represent a basic unit of image processing. The unit may include at least one of a specific region of the picture and information related to the region. One unit may include one luma block and two chroma (ex. cb, cr) blocks. The unit may be used interchangeably with terms such as block or area in some cases. In a general case, an M&#xd7;N block may include samples (or sample arrays) or a set (or array) of transform coefficients of M columns and N rows.</p><p id="p-0036" num="0035">In this document, the term &#x201c;/&#x201d; and &#x201c;,&#x201d; should be interpreted to indicate &#x201c;and/or.&#x201d; For instance, the expression &#x201c;A/B&#x201d; may mean &#x201c;A and/or B.&#x201d; Further, &#x201c;A, B&#x201d; may mean &#x201c;A and/or B.&#x201d; Further, &#x201c;A/B/C&#x201d; may mean &#x201c;at least one of A, B, and/or C.&#x201d; Also, &#x201c;A, B, C&#x201d; may mean &#x201c;at least one of A, B, and/or C.&#x201d;</p><p id="p-0037" num="0036">Further, in the document, the term &#x201c;or&#x201d; should be interpreted to indicate &#x201c;and/or.&#x201d; For instance, the expression &#x201c;A or B&#x201d; may comprise 1) only A, 2) only B, and/or 3) both A and B. In other words, the term &#x201c;or&#x201d; in this document should be interpreted to indicate &#x201c;additionally or alternatively.&#x201d;</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>1</b></figref> schematically illustrates an example of a video/image coding system to which embodiments of this document may be applied.</p><p id="p-0039" num="0038">Referring to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, a video/image coding system may include a first device (source device) and a second device (receiving device). The source device may deliver encoded video/image information or data in the form of a file or streaming to the receiving device via a digital storage medium or network.</p><p id="p-0040" num="0039">The source device may include a video source, an encoding apparatus, and a transmitter. The receiving device may include a receiver, a decoding apparatus, and a renderer. The encoding apparatus may be called a video/image encoding apparatus, and the decoding apparatus may be called a video/image decoding apparatus. The transmitter may be included in the encoding apparatus. The receiver may be included in the decoding apparatus. The renderer may include a display, and the display may be configured as a separate device or an external component.</p><p id="p-0041" num="0040">The video source may acquire video/image through a process of capturing, synthesizing, or generating the video/image. The video source may include a video/image capture device and/or a video/image generating device. The video/image capture device may include, for example, one or more cameras, video/image archives including previously captured video/images, and the like. The video/image generating device may include, for example, computers, tablets and smartphones, and may (electronically) generate video/images. For example, a virtual video/image may be generated through a computer or the like. In this case, the video/image capturing process may be replaced by a process of generating related data.</p><p id="p-0042" num="0041">The encoding apparatus may encode input video/image. The encoding apparatus may perform a series of procedures such as prediction, transform, and quantization for compression and coding efficiency. The encoded data (encoded video/image information) may be output in the form of a bitstream.</p><p id="p-0043" num="0042">The transmitter may transmit the encoded image/image information or data output in the form of a bitstream to the receiver of the receiving device through a digital storage medium or a network in the form of a file or streaming. The digital storage medium may include various storage mediums such as USB, SD, CD, DVD, Blu-ray, HDD, SSD, and the like. The transmitter may include an element for generating a media file through a predetermined file format and may include an element for transmission through a broadcast/communication network. The receiver may receive/extract the bitstream and transmit the received bitstream to the decoding apparatus.</p><p id="p-0044" num="0043">The decoding apparatus may decode the video/image by performing a series of procedures such as dequantization, inverse transform, and prediction corresponding to the operation of the encoding apparatus.</p><p id="p-0045" num="0044">The renderer may render the decoded video/image. The rendered video/image may be displayed through the display.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a schematic diagram illustrating a configuration of a video/image encoding apparatus to which the embodiment(s) of the present document may be applied. Hereinafter, the video encoding apparatus may include an image encoding apparatus.</p><p id="p-0047" num="0046">Referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the encoding apparatus <b>200</b> includes an image partitioner <b>210</b>, a predictor <b>220</b>, a residual processor <b>230</b>, and an entropy encoder <b>240</b>, an adder <b>250</b>, a filter <b>260</b>, and a memory <b>270</b>. The predictor <b>220</b> may include an inter predictor <b>221</b> and an intra predictor <b>222</b>. The residual processor <b>230</b> may include a transformer <b>232</b>, a quantizer <b>233</b>, a dequantizer <b>234</b>, and an inverse transformer <b>235</b>. The residual processor <b>230</b> may further include a subtractor <b>231</b>. The adder <b>250</b> may be called a reconstructor or a reconstructed block generator. The image partitioner <b>210</b>, the predictor <b>220</b>, the residual processor <b>230</b>, the entropy encoder <b>240</b>, the adder <b>250</b>, and the filter <b>260</b> may be configured by at least one hardware component (ex. an encoder chipset or processor) according to an embodiment. In addition, the memory <b>270</b> may include a decoded picture buffer (DPB) or may be configured by a digital storage medium. The hardware component may further include the memory <b>270</b> as an internal/external component.</p><p id="p-0048" num="0047">The image partitioner <b>210</b> may partition an input image (or a picture or a frame) input to the encoding apparatus <b>200</b> into one or more processors. For example, the processor may be called a coding unit (CU). In this case, the coding unit may be recursively partitioned according to a quad-tree binary-tree ternary-tree (QTBTTT) structure from a coding tree unit (CTU) or a largest coding unit (LCU). For example, one coding unit may be partitioned into a plurality of coding units of a deeper depth based on a quad tree structure, a binary tree structure, and/or a ternary structure. In this case, for example, the quad tree structure may be applied first and the binary tree structure and/or ternary structure may be applied later. Alternatively, the binary tree structure may be applied first. The coding procedure according to this document may be performed based on the final coding unit that is no longer partitioned. In this case, the largest coding unit may be used as the final coding unit based on coding efficiency according to image characteristics, or if necessary, the coding unit may be recursively partitioned into coding units of deeper depth and a coding unit having an optimal size may be used as the final coding unit. Here, the coding procedure may include a procedure of prediction, transform, and reconstruction, which will be described later. As another example, the processor may further include a prediction unit (PU) or a transform unit (TU). In this case, the prediction unit and the transform unit may be split or partitioned from the aforementioned final coding unit. The prediction unit may be a unit of sample prediction, and the transform unit may be a unit for deriving a transform coefficient and/or a unit for deriving a residual signal from the transform coefficient.</p><p id="p-0049" num="0048">The unit may be used interchangeably with terms such as block or area in some cases. In a general case, an M&#xd7;N block may represent a set of samples or transform coefficients composed of M columns and N rows. A sample may generally represent a pixel or a value of a pixel, may represent only a pixel/pixel value of a luma component or represent only a pixel/pixel value of a chroma component. A sample may be used as a term corresponding to one picture (or image) for a pixel or a pel.</p><p id="p-0050" num="0049">In the encoding apparatus <b>200</b>, a prediction signal (predicted block, prediction sample array) output from the inter predictor <b>221</b> or the intra predictor <b>222</b> is subtracted from an input image signal (original block, original sample array) to generate a residual signal residual block, residual sample array), and the generated residual signal is transmitted to the transformer <b>232</b>. In this case, as shown, a unit for subtracting a prediction signal (predicted block, prediction sample array) from the input image signal (original block, original sample array) in the encoder <b>200</b> may be called a subtractor <b>231</b>. The predictor may perform prediction on a block to be processed (hereinafter, referred to as a current block) and generate a predicted block including prediction samples for the current block. The predictor may determine whether intra prediction or inter prediction is applied on a current block or CU basis. As described later in the description of each prediction mode, the predictor may generate various information related to prediction, such as prediction mode information, and transmit the generated information to the entropy encoder <b>240</b>. The information on the prediction may be encoded in the entropy encoder <b>240</b> and output in the form of a bitstream.</p><p id="p-0051" num="0050">The intra predictor <b>222</b> may predict the current block by referring to the samples in the current picture. The referred samples may be located in the neighborhood of the current block or may be located apart according to the prediction mode. In the intra prediction, prediction modes may include a plurality of non-directional modes and a plurality of directional modes. The non-directional mode may include, for example, a DC mode and a planar mode. The directional mode may include, for example, 33 directional prediction modes or 65 directional prediction modes according to the degree of detail of the prediction direction. However, this is merely an example, more or less directional prediction modes may be used depending on a setting. The intra predictor <b>222</b> may determine the prediction mode applied to the current block by using a prediction mode applied to a neighboring block.</p><p id="p-0052" num="0051">The inter predictor <b>221</b> may derive a predicted block for the current block based on a reference block (reference sample array) specified by a motion vector on a reference picture. Here, in order to reduce the amount of motion information transmitted in the inter prediction mode, the motion information may be predicted in units of blocks, subblocks, or samples based on correlation of motion information between the neighboring block and the current block. The motion information may include a motion vector and a reference picture index. The motion information may further include inter prediction direction (L0 prediction, L1 prediction, Bi prediction, etc.) information. In the case of inter prediction, the neighboring block may include a spatial neighboring block present in the current picture and a temporal neighboring block present in the reference picture. The reference picture including the reference block and the reference picture including the temporal neighboring block may be the same or different. The temporal neighboring block may be called a collocated reference block, a co-located CU (colCU), and the like, and the reference picture including the temporal neighboring block may be called a collocated picture (colPic). For example, the inter predictor <b>221</b> may configure a motion information candidate list based on neighboring blocks and generate information indicating which candidate is used to derive a motion vector and/or a reference picture index of the current block. Inter prediction may be performed based on various prediction modes. For example, in the case of a skip mode and a merge mode, the inter predictor <b>221</b> may use motion information of the neighboring block as motion information of the current block. In the skip mode, unlike the merge mode, the residual signal may not be transmitted. In the case of the motion vector prediction (MVP) mode, the motion vector of the neighboring block may be used as a motion vector predictor and the motion vector of the current block may be indicated by signaling a motion vector difference.</p><p id="p-0053" num="0052">The predictor <b>220</b> may generate a prediction signal based on various prediction methods described below. For example, the predictor may not only apply intra prediction or inter prediction to predict one block but also simultaneously apply both intra prediction and inter prediction. This may be called combined inter and intra prediction (CIIP). In addition, the predictor may be based on an intra block copy (IBC) prediction mode or a palette mode for prediction of a block. The IBC prediction mode or palette mode may be used for content image/video coding of a game or the like, for example, screen content coding (SCC). The IBC basically performs prediction in the current picture but may be performed similarly to inter prediction in that a reference block is derived in the current picture. That is, the IBC may use at least one of the inter prediction techniques described in this document. The palette mode may be considered as an example of intra coding or intra prediction. When the palette mode is applied, a sample value within a picture may be signaled based on information on the palette table and the palette index.</p><p id="p-0054" num="0053">The prediction signal generated by the predictor (including the inter predictor <b>221</b> and/or the intra predictor <b>222</b>) may be used to generate a reconstructed signal or to generate a residual signal. The transformer <b>232</b> may generate transform coefficients by applying a transform technique to the residual signal. For example, the transform technique may include at least one of a discrete cosine transform (DCT), a discrete sine transform (DST), a karhunen-lo&#xe9;ve transform (KLT), a graph-based transform (GBT), or a conditionally non-linear transform (CNT). Here, the GBT means transform obtained from a graph when relationship information between pixels is represented by the graph. The CNT refers to transform generated based on a prediction signal generated using all previously reconstructed pixels. In addition, the transform process may be applied to square pixel blocks having the same size or may be applied to blocks having a variable size rather than square.</p><p id="p-0055" num="0054">The quantizer <b>233</b> may quantize the transform coefficients and transmit them to the entropy encoder <b>240</b> and the entropy encoder <b>240</b> may encode the quantized signal (information on the quantized transform coefficients) and output a bitstream. The information on the quantized transform coefficients may be referred to as residual information. The quantizer <b>233</b> may rearrange block type quantized transform coefficients into a one-dimensional vector form based on a coefficient scanning order and generate information on the quantized transform coefficients based on the quantized transform coefficients in the one-dimensional vector form. Information on transform coefficients may be generated. The entropy encoder <b>240</b> may perform various encoding methods such as, for example, exponential Golomb, context-adaptive variable length coding (CAVLC), context-adaptive binary arithmetic coding (CABAC), and the like. The entropy encoder <b>240</b> may encode information necessary for video/image reconstruction other than quantized transform coefficients (ex. values of syntax elements, etc.) together or separately. Encoded information (ex. encoded video/image information) may be transmitted or stored in units of NALs (network abstraction layer) in the form of a bitstream. The video/image information may further include information on various parameter sets such as an adaptation parameter set (APS), a picture parameter set (PPS), a sequence parameter set (SPS), or a video parameter set (VPS). In addition, the video/image information may further include general constraint information. In this document, information and/or syntax elements transmitted/signaled from the encoding apparatus to the decoding apparatus may be included in video/picture information. The video/image information may be encoded through the above-described encoding procedure and included in the bitstream. The bitstream may be transmitted over a network or may be stored in a digital storage medium. The network may include a broadcasting network and/or a communication network, and the digital storage medium may include various storage media such as USB, SD, CD, DVD, Blu-ray, HDD, SSD, and the like. A transmitter (not shown) transmitting a signal output from the entropy encoder <b>240</b> and/or a storage unit (not shown) storing the signal may be included as internal/external element of the encoding apparatus <b>200</b>, and alternatively, the transmitter may be included in the entropy encoder <b>240</b>.</p><p id="p-0056" num="0055">The quantized transform coefficients output from the quantizer <b>233</b> may be used to generate a prediction signal. For example, the residual signal (residual block or residual samples) may be reconstructed by applying dequantization and inverse transform to the quantized transform coefficients through the dequantizer <b>234</b> and the inverse transformer <b>235</b>. The adder <b>250</b> adds the reconstructed residual signal to the prediction signal output from the inter predictor <b>221</b> or the intra predictor <b>222</b> to generate a reconstructed signal (reconstructed picture, reconstructed block, reconstructed sample array). If there is no residual for the block to be processed, such as a case where the skip mode is applied, the predicted block may be used as the reconstructed block. The adder <b>250</b> may be called a reconstructor or a reconstructed block generator. The generated reconstructed signal may be used for intra prediction of a next block to be processed in the current picture and may be used for inter prediction of a next picture through filtering as described below.</p><p id="p-0057" num="0056">Meanwhile, luma mapping with chroma scaling (LMCS) may be applied during picture encoding and/or reconstruction.</p><p id="p-0058" num="0057">The filter <b>260</b> may improve subjective/objective image quality by applying filtering to the reconstructed signal. For example, the filter <b>260</b> may generate a modified reconstructed picture by applying various filtering methods to the reconstructed picture and store the modified reconstructed picture in the memory <b>270</b>, specifically, a DPB of the memory <b>270</b>. The various filtering methods may include, for example, deblocking filtering, a sample adaptive offset, an adaptive loop filter, a bilateral filter, and the like. The filter <b>260</b> may generate various information related to the filtering and transmit the generated information to the entropy encoder <b>240</b> as described later in the description of each filtering method. The information related to the filtering may be encoded by the entropy encoder <b>240</b> and output in the form of a bitstream.</p><p id="p-0059" num="0058">The modified reconstructed picture transmitted to the memory <b>270</b> may be used as the reference picture in the inter predictor <b>221</b>. When the inter prediction is applied through the encoding apparatus, prediction mismatch between the encoding apparatus <b>200</b> and the decoding apparatus may be avoided and encoding efficiency may be improved.</p><p id="p-0060" num="0059">The DPB of the memory <b>270</b> DPB may store the modified reconstructed picture for use as a reference picture in the inter predictor <b>221</b>. The memory <b>270</b> may store the motion information of the block from which the motion information in the current picture is derived (or encoded) and/or the motion information of the blocks in the picture that have already been reconstructed. The stored motion information may be transmitted to the inter predictor <b>221</b> and used as the motion information of the spatial neighboring block or the motion information of the temporal neighboring block. The memory <b>270</b> may store reconstructed samples of reconstructed blocks in the current picture and may transfer the reconstructed samples to the intra predictor <b>222</b>.</p><p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic diagram illustrating a configuration of a video/image decoding apparatus that is applicable to embodiments of this document.</p><p id="p-0062" num="0061">Referring to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the decoding apparatus <b>300</b> may include an entropy decoder <b>310</b>, a residual processor <b>320</b>, a predictor <b>330</b>, an adder <b>340</b>, a filter <b>350</b>, a memory <b>360</b>. The predictor <b>330</b> may include an inter predictor <b>331</b> and an intra predictor <b>332</b>. The residual processor <b>320</b> may include a dequantizer <b>321</b> and an inverse transformer <b>321</b>. The entropy decoder <b>310</b>, the residual processor <b>320</b>, the predictor <b>330</b>, the adder <b>340</b>, and the filter <b>350</b> may be configured by a hardware component (ex. a decoder chipset or a processor) according to an embodiment. In addition, the memory <b>360</b> may include a decoded picture buffer (DPB) or may be configured by a digital storage medium. The hardware component may further include the memory <b>360</b> as an internal/external component.</p><p id="p-0063" num="0062">When a bitstream including video/image information is input, the decoding apparatus <b>300</b> may reconstruct an image corresponding to a process in which the video/image information is processed in the encoding apparatus of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. For example, the decoding apparatus <b>300</b> may derive units/blocks based on block partition related information obtained from the bitstream. The decoding apparatus <b>300</b> may perform decoding using a processor applied in the encoding apparatus. Thus, the processor of decoding may be a coding unit, for example, and the coding unit may be partitioned according to a quad tree structure, binary tree structure and/or ternary tree structure from the coding tree unit or the largest coding unit. One or more transform units may be derived from the coding unit. The reconstructed image signal decoded and output through the decoding apparatus <b>300</b> may be reproduced through a reproducing apparatus.</p><p id="p-0064" num="0063">The decoding apparatus <b>300</b> may receive a signal output from the encoding apparatus of <figref idref="DRAWINGS">FIG. <b>2</b></figref> in the form of a bitstream, and the received signal may be decoded through the entropy decoder <b>310</b>. For example, the entropy decoder <b>310</b> may parse the bitstream to derive information (ex. video/image information) necessary for image reconstruction (or picture reconstruction). The video/image information may further include information on various parameter sets such as an adaptation parameter set (APS), a picture parameter set (PPS), a sequence parameter set (SPS), or a video parameter set (VPS). In addition, the video/image information may further include general constraint information. The decoding apparatus may further decode picture based on the information on the parameter set and/or the general constraint information. Signaled/received information and/or syntax elements described later in this document may be decoded may decode the decoding procedure and obtained from the bitstream. For example, the entropy decoder <b>310</b> decodes the information in the bitstream based on a coding method such as exponential Golomb coding, CAVLC, or CABAC, and output syntax elements required for image reconstruction and quantized values of transform coefficients for residual. More specifically, the CABAC entropy decoding method may receive a bin corresponding to each syntax element in the bitstream, determine a context model using a decoding target syntax element information, decoding information of a decoding target block or information of a symbol/bin decoded in a previous stage, and perform an arithmetic decoding on the bin by predicting a probability of occurrence of a bin according to the determined context model, and generate a symbol corresponding to the value of each syntax element. In this case, the CABAC entropy decoding method may update the context model by using the information of the decoded symbol/bin for a context model of a next symbol/bin after determining the context model. The information related to the prediction among the information decoded by the entropy decoder <b>310</b> may be provided to the predictor (the inter predictor <b>332</b> and the intra predictor <b>331</b>), and the residual value on which the entropy decoding was performed in the entropy decoder <b>310</b>, that is, the quantized transform coefficients and related parameter information, may be input to the residual processor <b>320</b>. The residual processor <b>320</b> may derive the residual signal (the residual block, the residual samples, the residual sample array). In addition, information on filtering among information decoded by the entropy decoder <b>310</b> may be provided to the filter <b>350</b>. Meanwhile, a receiver (not shown) for receiving a signal output from the encoding apparatus may be further configured as an internal/external element of the decoding apparatus <b>300</b>, or the receiver may be a component of the entropy decoder <b>310</b>. Meanwhile, the decoding apparatus according to this document may be referred to as a video/image/picture decoding apparatus, and the decoding apparatus may be classified into an information decoder (video/image/picture information decoder) and a sample decoder (video/image/picture sample decoder). The information decoder may include the entropy decoder <b>310</b>, and the sample decoder may include at least one of the dequantizer <b>321</b>, the inverse transformer <b>322</b>, the adder <b>340</b>, the filter <b>350</b>, the memory <b>360</b>, the inter predictor <b>332</b>, and the intra predictor <b>331</b>.</p><p id="p-0065" num="0064">The dequantizer <b>321</b> may dequantize the quantized transform coefficients and output the transform coefficients. The dequantizer <b>321</b> may rearrange the quantized transform coefficients in the form of a two-dimensional block form. In this case, the rearrangement may be performed based on the coefficient scanning order performed in the encoding apparatus. The dequantizer <b>321</b> may perform dequantization on the quantized transform coefficients by using a quantization parameter (ex. quantization step size information) and obtain transform coefficients.</p><p id="p-0066" num="0065">The inverse transformer <b>322</b> inversely transforms the transform coefficients to obtain a residual signal (residual block, residual sample array).</p><p id="p-0067" num="0066">The predictor may perform prediction on the current block and generate a predicted block including prediction samples for the current block. The predictor may determine whether intra prediction or inter prediction is applied to the current block based on the information on the prediction output from the entropy decoder <b>310</b> and may determine a specific intra/inter prediction mode.</p><p id="p-0068" num="0067">The predictor <b>320</b> may generate a prediction signal based on various prediction methods described below. For example, the predictor may not only apply intra prediction or inter prediction to predict one block but also simultaneously apply intra prediction and inter prediction. This may be called combined inter and intra prediction (CIIP). In addition, the predictor may be based on an intra block copy (IBC) prediction mode or a palette mode for prediction of a block. The IBC prediction mode or palette mode may be used for content image/video coding of a game or the like, for example, screen content coding (SCC). The IBC basically performs prediction in the current picture but may be performed similarly to inter prediction in that a reference block is derived in the current picture. That is, the IBC may use at least one of the inter prediction techniques described in this document. The palette mode may be considered as an example of intra coding or intra prediction. When the palette mode is applied, a sample value within a picture may be signaled based on information on the palette table and the palette index.</p><p id="p-0069" num="0068">The intra predictor <b>331</b> may predict the current block by referring to the samples in the current picture. The referenced samples may be located in the neighborhood of the current block or may be located apart according to the prediction mode. In intra prediction, prediction modes may include a plurality of non-directional modes and a plurality of directional modes. The intra predictor <b>331</b> may determine the prediction mode applied to the current block by using the prediction mode applied to the neighboring block.</p><p id="p-0070" num="0069">The inter predictor <b>332</b> may derive a predicted block for the current block based on a reference block (reference sample array) specified by a motion vector on a reference picture. In this case, in order to reduce the amount of motion information transmitted in the inter prediction mode, motion information may be predicted in units of blocks, subblocks, or samples based on correlation of motion information between the neighboring block and the current block. The motion information may include a motion vector and a reference picture index. The motion information may further include inter prediction direction (L0 prediction, L1 prediction, Bi prediction, etc.) information. In the case of inter prediction, the neighboring block may include a spatial neighboring block present in the current picture and a temporal neighboring block present in the reference picture. For example, the inter predictor <b>332</b> may configure a motion information candidate list based on neighboring blocks and derive a motion vector of the current block and/or a reference picture index based on the received candidate selection information. Inter prediction may be performed based on various prediction modes, and the information on the prediction may include information indicating a mode of inter prediction for the current block.</p><p id="p-0071" num="0070">The adder <b>340</b> may generate a reconstructed signal (reconstructed picture, reconstructed block, reconstructed sample array) by adding the obtained residual signal to the prediction signal (predicted block, predicted sample array) output from the predictor (including the inter predictor <b>332</b> and/or the intra predictor <b>331</b>). If there is no residual for the block to be processed, such as when the skip mode is applied, the predicted block may be used as the reconstructed block.</p><p id="p-0072" num="0071">The adder <b>340</b> may be called reconstructor or a reconstructed block generator. The generated reconstructed signal may be used for intra prediction of a next block to be processed in the current picture, may be output through filtering as described below, or may be used for inter prediction of a next picture.</p><p id="p-0073" num="0072">Meanwhile, luma mapping with chroma scaling (LMCS) may be applied in the picture decoding process.</p><p id="p-0074" num="0073">The filter <b>350</b> may improve subjective/objective image quality by applying filtering to the reconstructed signal. For example, the filter <b>350</b> may generate a modified reconstructed picture by applying various filtering methods to the reconstructed picture and store the modified reconstructed picture in the memory <b>360</b>, specifically, a DPB of the memory <b>360</b>. The various filtering methods may include, for example, deblocking filtering, a sample adaptive offset, an adaptive loop filter, a bilateral filter, and the like.</p><p id="p-0075" num="0074">The (modified) reconstructed picture stored in the DPB of the memory <b>360</b> may be used as a reference picture in the inter predictor <b>332</b>. The memory <b>360</b> may store the motion information of the block from which the motion information in the current picture is derived (or decoded) and/or the motion information of the blocks in the picture that have already been reconstructed. The stored motion information may be transmitted to the inter predictor <b>260</b> so as to be utilized as the motion information of the spatial neighboring block or the motion information of the temporal neighboring block. The memory <b>360</b> may store reconstructed samples of reconstructed blocks in the current picture and transfer the reconstructed samples to the intra predictor <b>331</b>.</p><p id="p-0076" num="0075">In this document, the embodiments described in the filter <b>260</b>, the inter predictor <b>221</b>, and the intra predictor <b>222</b> of the encoding apparatus <b>200</b> may be the same as or respectively applied to correspond to the filter <b>350</b>, the inter predictor <b>332</b>, and the intra predictor <b>331</b> of the decoding apparatus <b>300</b>. The same may also apply to the unit <b>332</b> and the intra predictor <b>331</b>.</p><p id="p-0077" num="0076">As described above, in performing video coding, a prediction is performed to enhance compression efficiency. A predicted block including prediction samples for a current block, that is, a target coding block, can be generated through the prediction. In this case, the predicted block includes the prediction samples in a spatial domain (or pixel domain). The predicted block is identically derived in the encoding apparatus and the decoding apparatus. The encoding apparatus can enhance image coding efficiency by signaling, to the decoding apparatus, information on a residual (residual information) between the original block not an original sample value itself of the original block and the predicted block. The decoding apparatus may derive a residual block including residual samples based on the residual information, may generate a reconstructed including reconstructed samples by adding the residual block and the predicted block, and may generate a reconstructed picture including the reconstructed blocks.</p><p id="p-0078" num="0077">The residual information may be generated through a transform and quantization procedure. For example, the encoding apparatus may derive the residual block between the original block and the predicted block, may derive transform coefficients by performing a transform procedure on the residual samples (residual sample array) included in the residual block, may derive quantized transform coefficients by performing a quantization procedure on the transform coefficients, and may signal related residual information to the decoding apparatus (through a bitstream). In this case, the residual information may include information, such as value information, location information, transform scheme, transform kernel, and quantization parameter of the quantized transform coefficients. The decoding apparatus may perform a dequantization/inverse transform procedure based on the residual information, and may derive residual samples (or residual block). The decoding apparatus may generate a reconstructed picture based on the predicted block and the residual block. Furthermore, the encoding apparatus may derive a residual block by dequantizing/inverse-transforming the quantized transform coefficients for reference to the inter prediction of a subsequent picture, and may generate a reconstructed picture.</p><p id="p-0079" num="0078">Meanwhile, as described above, the intra prediction or inter prediction may be applied when performing the prediction on the current block. Hereinafter, a case of applying the inter prediction to the current block will be described.</p><p id="p-0080" num="0079">The predictor (more specifically, inter predictor) of the encoding/decoding apparatus may derive prediction samples by performing the inter prediction in units of the block. The inter prediction may represent prediction derived by a method dependent to the data elements (e.g., sample values or motion information) of a picture(s) other than the current picture. When the inter prediction is applied to the current block, a predicted block (prediction sample array) for the current block may be derived based on a reference block (reference sample array) specified by the motion vector on the reference picture indicated by the reference picture index. In this case, in order to reduce an amount of motion information transmitted in the inter-prediction mode, the motion information of the current block may be predicted in units of a block, a subblock, or a sample based on a correlation of the motion information between the neighboring block and the current block. The motion information may include the motion vector and the reference picture index. The motion information may further include inter-prediction type (L0 prediction, L1 prediction, Bi prediction, etc.) information. In the case of applying the inter prediction, the neighboring block may include a spatial neighboring block which is present in the current picture and a temporal neighboring block which is present in the reference picture. A reference picture including the reference block and a reference picture including the temporal neighboring block may be the same as each other or different from each other. The temporal neighboring block may be referred to as a name such as a collocated reference block, a collocated CU (colCU), etc., and the reference picture including the temporal neighboring block may be referred to as a collocated picture (colPic). For example, a motion information candidate list may be configured based on the neighboring blocks of the current block and a flag or index information indicating which candidate is selected (used) may be signaled in order to derive the motion vector and./or reference picture index of the current block. The inter prediction may be performed based on various prediction modes and for example, in the case of a skip mode and a merge mode, the motion information of the current block may be the same as the motion information of the selected neighboring block. In the case of the skip mode, the residual signal may not be transmitted unlike the merge mode. In the case of a motion vector prediction (MVP) mode, the motion vector of the selected neighboring block may be used as a motion vector predictor and a motion vector difference may be signaled. In this case, the motion vector of the current block may be derived by using a sum of the motion vector predictor and the motion vector difference.</p><p id="p-0081" num="0080">The motion information may further include L0 motion information and/or L1 motion information according to the inter-prediction type (L0 prediction, L1 prediction, Bi prediction, etc.). A L0-direction motion vector may be referred to as an L0 motion vector or MVL0 and an L1-direction motion vector may be referred to as an L1 motion vector or MVL1. A prediction based on the L0 motion vector may be referred to as an L0 prediction, a prediction based on the L1 motion vector may be referred to as an L1 prediction, and a prediction based on both the L0 motion vector and the L1 motion vector may be referred to as a bi-prediction. Here, the L0 motion vector may indicate a motion vector associated with a reference picture list L0 and the L1 motion vector may indicate a motion vector associated with a reference picture list L1. The reference picture list L0 may include pictures prior to the current picture in an output order and the reference picture list L1 may include pictures subsequent to the current picture in the output order, as the reference pictures. The prior pictures may be referred to as a forward (reference) picture and the subsequent pictures may be referred to as a reverse (reference) picture. The reference picture list L0 may further include the pictures subsequent to the current picture in the output order as the reference pictures. In this case, the prior pictures may be first indexed in the reference picture list L0 and the subsequent pictures may then be indexed. The reference picture list L1 may further include the pictures prior to the current picture in the output order as the reference pictures. In this case, the subsequent pictures may be first indexed in the reference picture list L1 and the prior pictures may then be indexed. Here, the output order may correspond to a picture order count (POC) order.</p><p id="p-0082" num="0081">Further, various inter prediction modes may be used in applying the inter prediction to the current block. For example, various modes including a merge mode, a skip mode, a motion vector prediction (MVP) mode, an affine mode, a historical motion vector prediction (HMVP) mode, and the like may be used. A decoder side motion vector refinement (DMVR) mode, an adaptive motion vector resolution (AMVR) mode, a bi-directional optical flow (BDOF) etc., may be further used as an ancillary mode. The affine mode may be referred to as an affine motion prediction mode. The MVP mode may be referred to as an advanced motion vector prediction (AMVP) mode. In the present disclosure, some modes and/or motion information candidates derived by some modes may be included in one of motion information related candidates of other modes.</p><p id="p-0083" num="0082">The prediction mode information indicating the inter prediction mode of the current block may be signaled from the encoding apparatus to the decoding apparatus. In this case, the prediction mode information may be included in the bitstream and received by the decoding apparatus. The prediction mode information may include index information indicating one of multiple candidate modes. Alternatively, the inter prediction mode may be indicated through a hierarchical signaling of flag information. In this case, the prediction mode information may include one or more flags. For example, whether to apply the skip mode may be indicated by signaling a skip flag, whether to apply the merge mode may be indicated by signaling a merge flag when the skip mode is not applied, and it is indicated that the MVP mode is applied or a flag for additional distinguishing may be further signaled when the merge mode is not applied. The affine mode may be signaled as an independent mode or signaled as a dependent mode on the merge mode or the MVP mode. For example, the affine mode may include an affine merge mode and an affine MVP mode.</p><p id="p-0084" num="0083">Further, the motion information of the current block may be used in applying the inter prediction to the current block. The encoding device may derive optimal motion information for the current block through a motion estimation procedure. For example, the encoding device may search a similar reference block having a high correlation in units of a fractional pixel within a predetermined search range in the reference picture by using an original block in an original picture for the current block and derive the motion information through the searched reference block. The similarity of the block may be derived based on a difference of phase based sample values. For example, the similarity of the block may be calculated based on a sum of absolute differences (SAD) between the current block (or a template of the current block) and the reference block (or the template of the reference block). In this case, the motion information may be derived based on a reference block having a smallest SAD in a search area. The derived motion information may be signaled to the decoding device according to various methods based on the inter prediction mode.</p><p id="p-0085" num="0084">A predicted block for the current block may be derived based on the motion information derived according to the inter prediction mode. The predicted block may include prediction samples (prediction sample array) of the current block. When the motion vector (MV) of the current block indicates a fractional sample unit, an interpolation procedure may be performed and the prediction samples of the current block may be derived based on reference samples of the fractional sample unit in the reference picture through the interpolation procedure. When the affine inter prediction is applied to the current block, the prediction samples may be generated based on a sample/subblock-unit MV. When the bi-prediction is applied, prediction samples derived through a weighted sum or a weighted average of prediction samples derived based on the L0 prediction (i.e., a prediction using a reference picture in the reference picture list L0 and MVL0) and prediction samples (according to a phase) derived based on the L1 prediction (i.e., a prediction using a reference picture in the reference picture list L1 and MVL1) may be used as the prediction samples of the current block. When the bi-prediction is applied, if the reference picture used for the L0 prediction and the reference picture used for the L1 prediction are located in different temporal directions based on the current picture (i.e., if the prediction corresponds to the bi-prediction and the bi-directional prediction), this may be referred to as a true bi-prediction.</p><p id="p-0086" num="0085">Reconstruction samples and reconstruction pictures may be generated based on the derived prediction samples and thereafter, the procedure such as in-loop filtering, etc., may be performed as described above.</p><p id="p-0087" num="0086">Meanwhile, since the motion of the current block is predicted based on the motion vector of the neighboring block without a motion vector difference (MVD) in the skip mode and/or the merge mode, the skip mode and/or the merge mode shows a limitation in a motion prediction. In order to improve the limitation of the skip mode and/or the merge mode, the motion vector may be refined by applying a Decoder-side Motion Vector Refinement (DMVR) mode, a Bi-directional optical flow (BDOF) mode, etc. The DMVR and BDOF modes may be used when the true bi-prediction is applied to the current block.</p><p id="p-0088" num="0087"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a diagram for describing an embodiment of a process of performing a Decoder-side Motion Vector Refinement (DMVR) in a true pair prediction.</p><p id="p-0089" num="0088">The DMVR is a method in which the decoder performs the motion prediction by refining the motion information of the neighboring block. When the DMVR is applied, the decoder may derive the refined motion information through cost comparison based on a template generated by using the motion information of the neighboring block in the merge/skip mode. In this case, precision of the motion prediction may be increased and compression performance may be enhanced without additional signaling information.</p><p id="p-0090" num="0089">In the present disclosure, for convenience of description, the decoding apparatus is mainly described, but the DMVR according to the embodiment of the present disclosure may be performed in the same method even in the encoding apparatus.</p><p id="p-0091" num="0090">Referring to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the decoding apparatus may derive prediction blocks (i.e., reference blocks) identified by list0 and list1-direction initial motion vectors (or motion information) (e.g., MV0 and MV1) and generate a template (or a bilateral template) by a weighted sum (e.g., averaging) of the derived prediction samples (step <b>1</b>). Here, the initial motion vectors (MV0 and MV1) may represent motion vectors derived by using the motion information of the neighboring block in the merge/skip mode.</p><p id="p-0092" num="0091">In addition, the decoding apparatus may derive motion vectors (e.g., MV0&#x2032; and MV1&#x2032;) for minimizing a difference between the template and the sample area of the reference picture through a template matching operation (step <b>2</b>). Here, the sample area may indicate a neighboring area of an initial prediction block in the reference picture and the sample area may be referred to as the neighboring area, a reference area, a search area, a search range, a search space, etc. The template matching operation may include an operation of calculating a cost measurement value between the template and the sample area of the reference picture. For example, the sum of absolute differences (SAD) may be used for the cost measurement. As one example, as a cost function, the normalized SAD may be used. In this case, matching cost may be given as SAD(T&#x2212;mean(T), 2*P[x]&#x2212;2*mean(P[x])). Here, T represents the template and P[x] represents the block in the search area. In addition, a motion vector for calculating minimum template cost for each of two reference pictures may be considered as an updated motion vector (replacing the initial motion vector). As illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the decoding apparatus may generate a final bilateral prediction result (i.e. a final bilateral prediction block) by using the updated motion vectors MV0&#x2032; and MV1&#x2032;. As an embodiment, multi-iteration for deriving the updated (or new) motion vector may e used for acquiring the final bilateral prediction result.</p><p id="p-0093" num="0092">In an embodiment, the decoding apparatus may call a DMVR process in order to enhance accuracy of an initial motion compensation prediction (i.e., the motion compensation prediction through the conventional merge/skip mode). For example, the decoding apparatus may perform the DMVR process when the prediction mode of the current block is the merge mode or the skip mode and the bilateral bi-prediction in which the bilateral reference pictures are located at opposite directions based on the current picture in a display order is applied to the current block.</p><p id="p-0094" num="0093"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a diagram for describing an embodiment of a process of performing a Decoder-side Motion Vector Refinement (DMVR) by using sum of absolute differences (SAD).</p><p id="p-0095" num="0094">As described above, the decoding apparatus may measure matching cost by using the SAD in performing the DMVR. As an embodiment, in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, a method for refining the motion vector by calculating a mean sum of absolute difference (MRSAD) between the prediction samples in two reference pictures without generating the template will be described. In other words, the method of <figref idref="DRAWINGS">FIG. <b>5</b></figref> shows an embodiment of bilateral matching using the MRSAD.</p><p id="p-0096" num="0095">Referring to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the decoding apparatus may derive an adjacent pixel of a pixel (sample) indicated by the list0 (L0) direction motion vector MV0 on the L0 reference picture and derive an adjacent pixel of a pixel (sample) indicated by the list1 (L1) direction motion vector MV1 on the L1 reference picture. In addition, the decoding apparatus may measure the matching cost by calculating the MRSAD between the L0 prediction block (i.e., L0 reference block) identified by the motion vector indicating the adjacent pixel derived on the L0 reference picture and the L1 prediction block (i.e., L1 reference block) identified by the motion vector indicating the adjacent pixel derived on the L1 reference picture. In this case, the decoding apparatus may select a search point (i.e., a search area having the minimum SAD between the L0 prediction block and the L1 prediction block) having minimum cost as a refined motion vector pair. In other words, the refined motion vector pair may include a refined L0 motion vector indicating a pixel position (L0 prediction block) having the minimum cost in the L0 reference picture and a refined L1 motion vector indicating a pixel position (L1 prediction block) having the minimum cost in the L1 reference picture.</p><p id="p-0097" num="0096">As the embodiment, in calculating the matching cost, after the search area of the reference picture is set, a unilateral prediction may be performed by using a regular 8 tap DCTIF interpolation filter. Further, as one example, 16-bit precision may be used for calculation of the MRSAD and clipping and/or rounding operations may not be applied before the calculation of the MRSAD by considering an internal buffer.</p><p id="p-0098" num="0097">When the true bi-prediction is applied to the current block as described above, the BDOF may be used in order to refine a bi-prediction signal. When the bi-prediction is applied to the current block, the bi-directional optical flow (BDOF) may be used to calculate improved motion information and generate the prediction samples based on the calculated motion information. For example, the BDOF may be applied at a 4&#xd7;4 subblock level. In other words, the BDOF may be performed in units of 4&#xd7;4 subblocks in the current block. Alternatively, the BDOF may be applied only to a luma component. Alternatively, the BDOF may be applied only to a chroma component and applied to the luma component and the chroma component.</p><p id="p-0099" num="0098">The BDOF mode is based on an optical flow concept assuming that an object motion is smooth as indicated by a name of the BDOF mode. A motion refinement (vx, vy) may be calculated by minimizing a difference value between the L0 and L1 prediction samples for each of 4&#xd7;4 subblocks. In addition, the motion refinement may be used for adjusting the bi-prediction sample values in 4&#xd7;4 subblocks.</p><p id="p-0100" num="0099">Meanwhile, it can be seen that the DMVR and the BDOF as techniques that perform the prediction by refining the motion information (in this case, the true bi-prediction represents a case of performing the motion prediction/compensation in a reference picture of the other direction based on the picture of the current block) at the time of applying the true bi-prediction is a refinement technique having a similar concept in that it is assumed that the motion of an object in the picture is made at a predetermined speed and in a predetermined direction. However, when the true bi-prediction is performed, since a condition for applying the DMVR and a condition for applying the BDOF are different from each other, a process of checking the conditions repeatedly multiple times for each technique should be performed. Therefore, the present disclosure proposes a method that may enhance efficiency in terms of decoder complexity and performance by improving the process of checking the condition in determining the prediction mode applied to the current block.</p><p id="p-0101" num="0100">Table 1 below shows a condition for applying the DMVR during the conventional true bi-prediction. When all conditions listed below are satisfied, the DMVR may be applied.</p><p id="p-0102" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1. : Signaling in SPS</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1. : Applied in case of</entry></row><row><entry/><entry>MERGE/SKIP</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0. : Applied in case of not</entry></row><row><entry/><entry>MMVD</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1. : Bi-directional</entry></row><row><entry/><entry>prediction</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt</entry></row><row><entry/><entry>(currPic, RefPicList1 [ refIdxL1 ] ) is equal to 0. : TrueBi, and</entry></row><row><entry/><entry>distances from current picture and bi-directional reference picture are</entry></row><row><entry/><entry>equal to each other (hereinafter, &#x201d;reference picture distance&#x201d;</entry></row><row><entry/><entry>may represent the above-described meaning).</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8. : In case that the block length</entry></row><row><entry/><entry>(or size) is larger than Threshold (ex. 8) (here, Threshold may be</entry></row><row><entry/><entry>variously exemplified)</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64. : In case that the</entry></row><row><entry/><entry>block size (or magnitude) is larger than Threshold (ex. 64) (here,</entry></row><row><entry/><entry>Threshold may be variously exemplified)</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0103" num="0101">Referring to Table 1, 1) whether to apply the DMVR may be determined based on flag information (e.g., sps_dmvr_enabled_flag) signaled in a sequence parameter set (SPS) syntax. Here, the flag information (e.g., sps_dmvr_enabled_flag) may represent whether the true bi-prediction based DMVR is enabled. For example, when sps_dmvr_enabled_flag is 1 (i.e., when the true bi-prediction based DMVR is enabled), it may be determined that a condition for whether the DMVR is enabled is satisfied.</p><p id="p-0104" num="0102">2) Whether to apply the DMVR may be determined based on flag information (e.g., merge_flag) representing whether the inter prediction is performed by using the merge mode/skip mode. For example, when merge_flag is 1 (i.e., when the inter prediction is performed by using the merge mode/skip mode), it may be determined that a condition for whether to apply the merge mode/skip mode is satisfied.</p><p id="p-0105" num="0103">3) Whether to apply the DMVR may be determined based on flag information (e.g., mmvd_flag) representing whether the inter prediction is performed by using the merge mode with motion vector difference (MMVD) mode. For example, when mmvd_flag is 0 (i.e., when the MMVD mode is not used), it may be determined that a condition for whether to apply the MMVD mode is satisified.</p><p id="p-0106" num="0104">4) Whether to apply the DMVR may be determined based on whether the bilateral prediction (bi-prediction) is used. Here, the bilateral prediction may represent an inter prediction performed based on reference pictures which exist in different directions based on the current picture. For example, when predFlagL0[0][0]=1 and predFlagL0[1][1]=1, it may be determined that the bilateral prediction is applied and it may be determined that a condition for whether to perform the bilateral prediction is satisified.</p><p id="p-0107" num="0105">5) Whether to apply the DMVR may be determined based on whether the true bi-prediction is performed and the distances between the current picture and the bilateral reference pictures are the same as each other. In other words, it may be determined whether a distance between the current picture and an L0 reference picture (i.e., a reference picture in the reference picture list L0) and a distance between the current picture and an L1 reference picture (i.e., a reference picture in the reference picture list L1) are the same as each other. For example, when DiffPicOrderCnt(currPic, RefPicList0 [refldxL0])&#x2212;DiffPicOrderCnt(currPic, RefPicList1 [refldxL1])=0, it is determined that the true bi-prediction is performed and the distances between the current picture and the bilateral reference pictures are the same as each other to determine that a condition for whether the distances of the bilateral reference pictures are the same as each other is satisfied.</p><p id="p-0108" num="0106">6) Whether to apply the DMVR may be determined based on whether a height of a current block is larger than a threshold. For example, when the height of the current block is equal to or larger than 8, it may be determined that a current block size (height) condition is satisfied.</p><p id="p-0109" num="0107">7) Whether to apply the DMVR may be determined based on whether the size of the current block is larger than the threshold. For example, when the size of the current block, height*width is equal to or larger than 64, it may be determined that the current block size (height*width) condition is satisfied.</p><p id="p-0110" num="0108">The decoding apparatus may determine whether to apply the DMVR according to whether conditions 1) to 7) of Table 1 above are satisfied. In other words, when conditions 1) to 7) of Table 1 above are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR and when even any one of the conditions of Table 1 above is not satisfied, the decoding apparatus does not apply the DMVR.</p><p id="p-0111" num="0109">Table 2 below shows a condition for applying the BDOF during the conventional true bi-prediction. When all conditions listed below are satisfied, the BDOF may be applied.</p><p id="p-0112" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 2</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1. : Signaling through SPS</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ]</entry></row><row><entry/><entry>are both equal to 1. : Bi-directional prediction</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt(</entry></row><row><entry/><entry>currPic, refPicList1[ refIdxL1 ] ) is less than 0. : TrueBi</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.: In case of not affine</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0. : subblock</entry></row><row><entry/><entry>&#x26;&#x26; w &#x3e;=8 &#x26;&#x26; h&#x3e;=8</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.: In case that GBi index is default</entry></row><row><entry>-</entry><entry>cIdx is equal to 0. : Applied to Luma only</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0113" num="0110">Referring to Table 2 above, 1) whether to apply the BDOF may be determined based on flag information (e.g., sps_bdof_enabled_flag) signaled in the sequence parameter set (SPS) syntax. Here, the flag information (e.g., sps_dmvr_enabled_flag) may represent whether the true bi-prediction based BDOF is enabled. For example, when sps_bdof_enabled_flag is 1 (i.e., when the true bi-prediction based BDOF is enabled), it may be determined that a condition for whether the BDOF is enabled is satisified.</p><p id="p-0114" num="0111">2) Whether to apply the BDOF may be determined based on whether the bilateral prediction is used. Here, the bilateral prediction may represent an inter prediction performed based on reference pictures which exist in different directions based on the current picture. For example, when both predFlagL0] and predFlagL1 are 1, it may be determined that the bilateral prediction is applied and it may be determined that a condition for whether to perform the bilateral prediction is satisified.</p><p id="p-0115" num="0112">3) Whether to apply the BDOF may be determined based on whether the true bi-prediction is performed. In other words, it may be determined whether the L0 reference picture (i.e., the reference picture in the reference picture list L0) and the L1 reference picture (i.e., the reference picture in the reference picture list L1) are located in temporally different directions based on the current picture. For example, when DiffPicOrderCnt(currPic, refPicList0[refldxL0])*DiffPicOrderCnt(currPic, refPicList1[refldxL1]) is smaller 0, it is determined that the bilateral reference pictures are located in different directions based on the current picture to determine that the condition for whether the true vi-prediction is performed is satisfied.</p><p id="p-0116" num="0113">4) Whether to apply the BDOF may be determined based on whether the affine mode is used. Here, whether the affine mode is used may be determined by deriving MotionModelIdc. For example, when the derived MotionModelIdc is 0, it may be determined that the affine mode is not used and in this case, it may be determined that a condition for whether to apply the affine mode is satisfied.</p><p id="p-0117" num="0114">5) Whether to apply the BDOF may be determined based on flag information (e.g., merge_subblock_flag) representing whether the inter prediction is performed in units of the subblocks. For example, when merge_subblock_flag is 0 (i.e., when the merge mode is not applied in units of the subblocks), it may be determined that a condition for whether to apply the merge mode in units of the subblocks is satisified.</p><p id="p-0118" num="0115">6) Whether to apply the BDOF may be determined based on whether GBi exists.</p><p id="p-0119" num="0116">Here, whether the GBi exists may be determined based on GBi index information (e.g., GbiIdx). For example, when GbiIdx is 0 (i.e., when the GbiIdx is default), it may be determined that a condition for whether the GBi exists is satisified.</p><p id="p-0120" num="0117">7) Whether to apply the BDOF may be determined based on whether the current block is a luma block including the luma component. For example, when an index (e.g., cIdx) indicating whether the current block is the luma block (i.e., when the current block is the luma block), it may be determined that a condition for whether the current block is the luma block is satisfied.</p><p id="p-0121" num="0118">The decoding apparatus may determine whether to apply the DMVR according to whether conditions 1) to 7) of Table 2 above are satisfied. In other words, when conditions 1) to 7) of Table 2 above are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF and when even any one of the conditions of Table 2 above is not satisfied, the decoding apparatus does not apply the BDOF.</p><p id="p-0122" num="0119">Here, the GBi may represent a generalized bi-prediction in which different weights may be applied to the L0 prediction and the L1 prediction and may be represented by using GbiIdx, for example. The GbiIdx may exist in the case of the bi-prediction and represent a bi-prediction weight index. In the present disclosure, the motion information may further include GbiIdx. For example, GbiIdx may be derived from the neighboring block in the case of the merge mode or signaled from the encoding apparatus to the decoding apparatus through a GbiIdx syntax element (e.g., gbi_idx) in the case of the MVP mode. As one example, GbiIdx may indicate a weight w applied to the L1 prediction and in this case, a weight of (1&#x2212;w) may be applied to the L0 prediction. As another example, GbiIdx may indicate the weight w applied to the L0 prediction and in this case, the weight 1&#x2212;w may be applied to the L1 prediction. The weight indicated by GbiIdx may be variously configured and may be configured as shown in Tables 3 and 4 below, for example.</p><p id="p-0123" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="42pt" align="center"/><colspec colname="2" colwidth="140pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 3</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>GBi Index</entry><entry>Weight value of w<sub>1</sub></entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>0</entry><entry>1/2</entry></row><row><entry/><entry>1</entry><entry>&#x2212;1/4&#x2002;</entry></row><row><entry/><entry>2</entry><entry>3/8</entry></row><row><entry/><entry>3</entry><entry>5/8</entry></row><row><entry/><entry>4</entry><entry>5/4</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0124" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="42pt" align="center"/><colspec colname="2" colwidth="140pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 4</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>GBi Index</entry><entry>Weight value of w<sub>1</sub></entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>0</entry><entry>&#x2212;1/4&#x2002;</entry></row><row><entry/><entry>1</entry><entry>3/8</entry></row><row><entry/><entry>2</entry><entry>1/2</entry></row><row><entry/><entry>3</entry><entry>5/8</entry></row><row><entry/><entry>4</entry><entry>5/4</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0125" num="0120">Referring to Tables 3 and 4 above, a weight of w<sub>1 </sub>may represent a weight applied to the L1 prediction and the GbiIdx value may indicate the weight w<sub>1 </sub>applied to the L1 prediction. For example, according to the embodiment of Table 3, when the value of GbiIdx represents 0, a &#xbd; weight may be applied to the L1 prediction and the &#xbd; weight which is a value of (1&#x2212;w<sub>1</sub>) may be applied to the L0 prediction. According to the embodiment, the weight of w<sub>1 </sub>may represent the weight applied to the L0 prediction and in this case, the GbiIdx value may indicate the weight w<sub>1 </sub>applied to the L0 prediction.</p><p id="p-0126" num="0121">As described above, some of the application conditions of the DMVR and the BDOF are the same and some are similar or different. In the conventional scheme, since condition check is performed for each technique even when the condition is the same, complexity for performing the bi-prediction increases. Therefore, this document proposes an efficient condition for applying the DMVR and the BDOF during the bi-prediction.</p><p id="p-0127" num="0122">When the merge/skip mode is compared with the AMVP mode, the merge/skip mode has relatively lower accuracy than the AMVP mode, and as a result, refining the motion information by using the DMVR method is effective in terms of the performance. However, the BDOF mode may be applied even in the AMVP mode in addition to the merge/skip mode unlike the DMVR and as such, complexity for performing the BDOF compared with the performance may increase when applying the BDOF in the AMVP mode. Accordingly, the embodiment proposes a method for applying even the BDOF in the merge/skip mode similarly to the DMVR.</p><p id="p-0128" num="0123">In this case, as an embodiment proposed in this document, the application condition of the BDOF may include conditions presented in Table 5 below.</p><p id="p-0129" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 5</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ]</entry></row><row><entry/><entry>are both equal to 1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt(</entry></row><row><entry/><entry>currPic, refPicList1[ refIdxL1 ] ) is less than 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0130" num="0124">Referring to Table 5 above, whether to apply the BDOF may be determined based on flag information (e.g., merge_flag) representing whether the inter prediction is performed by using the merge mode/skip mode. For example, when merge_flag is 1 (i.e., when the inter prediction is performed by using the merge mode/skip mode), it may be determined that a condition for whether to apply the merge mode/skip mode is satisfied. Accordingly, the BDOF may also be applied in the merge/skip mode similarly to the DMVR.</p><p id="p-0131" num="0125">In other words, in the embodiment, together with a condition applied in the case of the merge/skip mode, whether to apply the BDOF may be determined based on a condition applied when the BDOF is enabled, a condition applied in the case of the bilateral prediction, a condition applied when the true bi-prediction is performed, a condition applied when the affine prediction is used, a condition applied when the subblock based merge mode is not applied, a condition applied when the GBi index is default, and a condition applied when the current block is the luma block.</p><p id="p-0132" num="0126">Accordingly, the decoding apparatus may determine whether all conditions listed in Table 5 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 5 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 5 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0133" num="0127">The method for performing the true bi-prediction based on the conditions listed in Table 5 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0134" num="0128">Meanwhile, when the conditions listed in the embodiment are the same as the conditions described in Tables 1 and 2 above, a detailed operation or meaning is similarly applied, and as a result, a detailed description for each condition will be omitted. Further, duplicated contents even in embodiments to be described below will be omitted.</p><p id="p-0135" num="0129">The encoding/decoding apparatus may be configured by various hardware and a preference of a ratio of complexity to performance may be different. Therefore, the embodiment proposes a method that may refine the motion information by applying the DMVR even in the AMVP mode in addition to the merge/skip mode.</p><p id="p-0136" num="0130">In this case, as an embodiment proposed in the present disclosure, the application condition of the DMVR may include conditions presented in Table 6 below.</p><p id="p-0137" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 6</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>(Delete conditions limited to MERGE / SKIP mode)</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt</entry></row><row><entry/><entry>(currPic, RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8.</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0138" num="0131">Referring to Table 6 above, a process of determining whether to apply the DMVR may be omitted based on the flag information (e.g., merge_flag) representing whether the inter prediction is performed by using the merge mode/skip mode. As such, by omitting a condition for whether to apply the merge mode/skip mode, the DMVR may be applied even in the AMVP mode in addition to the merge mode/skip mode.</p><p id="p-0139" num="0132">According to Table 6 above, whether to apply the DMVR may be determined based on a condition applied when the DMVR is enabled, a condition applied when the MMVD mode is not used, a condition applied in the case of the bilateral prediction, a condition applied in the case of the true bi-prediction in which the distances between the current picture and the bilateral reference pictures are the same as each other, a condition applied when the height of the current block is equal to or larger than 8, and a condition applied when the size (height*width) of the current block is equal to or larger than 64.</p><p id="p-0140" num="0133">In other words, the decoding apparatus may determine whether all conditions listed in Table 6 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 6 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 6 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0141" num="0134">The method for performing the true bi-prediction based on the conditions listed in Table 6 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0142" num="0135">Meanwhile, as an embodiment of the present disclosure, both the DMVR and the BDOF may be applied to a normal merge mode. In other words, the DMVR and the BDOF may be applied when the advanced temporal motion vector prediction (ATMVP) mode is not used, the affine mode is not used, and the CPR is not used. In this case, the application condition of the DMVR may include conditions presented in Table 7 below.</p><p id="p-0143" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 7</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt</entry></row><row><entry/><entry>(currPic, RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8.</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0. : !Affine</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0. : subblock</entry></row><row><entry/><entry>&#x26;&#x26; w &#x3e;=8 &#x26;&#x26; h&#x3e;=8</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0144" num="0136">Referring to Table 7 above, whether the condition applied when the affine mode is not used (e.g., when MotionModelIdc is 0) and the condition applied when the subblock based merge mode is not used (e.g., when merge_subblock_flag is 0) are satisfied is determined to apply the DMVR only in the normal merge mode.</p><p id="p-0145" num="0137">Further, in the embodiment, together with the condition for whether the affine mode is used and the condition for whether the subblock based merge mode is used, whether to apply the DMVR may be determined based on the condition applied when the DMVR is enabled, the condition applied when the merge mode/skip mode is used, the condition applied when the MMVD mode is not used, the condition applied in the case of the bilateral prediction, the condition applied in the case of the true bi-prediction in which the distances between the current picture and the bilateral reference pictures are the same as each other, the condition applied when the height of the current block is equal to or larger than 8, and the condition applied when the size (height*width) of the current block is equal to or larger than 64.</p><p id="p-0146" num="0138">In other words, the decoding apparatus may determine whether all conditions listed in Table 7 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 7 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 7 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0147" num="0139">The condition for whether to apply the subblock based merge mode (e.g., merge_subblock_flag) among the application conditions of Table 7 above includes a duplicated condition among the conventional DMVR application conditions. Accordingly, as an embodiment of the present disclosure, a condition duplicated with the condition (e.g., merge_subblock_flag) for whether to apply the subblock based merge mode may be removed. In this case, the corresponding condition may be removed as proposed in Table 8 below.</p><p id="p-0148" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 8</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt</entry></row><row><entry/><entry>(currPic, RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.: !Affine</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0. : subblock</entry></row><row><entry/><entry>&#x26;&#x26; w &#x3e;=8 &#x26;&#x26; h&#x3e;=8</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0149" num="0140">Referring to Table 8 above, the subblock based merge mode may be applied when the size of the current block is equal to or larger than 8&#xd7;8. Accordingly, since the condition (e.g., merge_subblock_flag=0) for whether to apply the subblock based merge mode includes a condition related to the size of the current block, conditions (e.g., CbHeight and CbHeight*CbWidth) related to the size of the current block among the application conditions of the conventional DMVR may be excluded. For example, the condition for whether the height of the current block is equal to or larger than 8 and the condition for whether the height*width of the current block is equal to or larger than 64 may be omitted and whether to apply the DMVR may be determined by using the remaining conditions listed in Table 8 above.</p><p id="p-0150" num="0141">In other words, the decoding apparatus may determine whether all conditions listed in Table 8 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 8 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 8 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0151" num="0142">The method for performing the true bi-prediction based on the conditions listed in Table 7 or 8 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0152" num="0143">As an embodiment of the present disclosure, in order to increase the accuracy of the motion vector in low complexity, when the size of the block is small, the refinement techniques such as the DMVR and the BDOF may not be applied. In the conventional scheme, the refinement technique may be applied when the current block is a block which is equal to or larger than 8&#xd7;8 and in the case of the DMVR of the refinement techniques, when the size of the current block is large, the refinement is applied by separating the current block into 16&#xd7;16 units, and as a result, the DMVR may not be applied to a block which is smaller than 16&#xd7;16. In this case, the application condition of the DMVR may include conditions presented in Table 9 below.</p><p id="p-0153" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 9</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt</entry></row><row><entry/><entry>(currPic, RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 16.</entry></row><row><entry>-</entry><entry>CbWidth is greater than or equal to 16.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0154" num="0144">Referring to Table 9 above, the DMVR may not be applied to the block which is smaller than 16&#xd7;16 by changing the conditions (e.g., CbHeight and CbWidth) related to the size of the current block. For example, a condition applied when the height of the current block (e.g., CbHeight) is equal to or larger than 16 and a condition applied when the width of the current block (e.g., CbWidth) is equal to or larger than 16 may be used. When the application conditions related to the size of the current block are satisfied (i.e., when the size of the current block is equal to or larger than 16&#xd7;16, the DMVR may be applied and when the application conditions related to the size of the current block are not satisfied (i.e., when the size of the current block is smaller than 16&#xd7;16), the DMVR may not be applied.</p><p id="p-0155" num="0145">Further, in the embodiment, together with the conditions (e.g., CbHeight and CbWidth) related to the size of the current block, whether to apply the DMVR may be determined based on the remaining application conditions listed in Table 9 above.</p><p id="p-0156" num="0146">In other words, the decoding apparatus may determine whether all conditions listed in Table 9 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 9 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 9 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0157" num="0147">As an embodiment of the present disclosure, when the current block is the block which is smaller than 16&#xd7;16, the BDOF may not be applied in addition to the DMVR. In this case, the application condition of the BDOF may include conditions presented in Table 10 below.</p><p id="p-0158" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 10</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ]</entry></row><row><entry/><entry>are both equal to 1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt(</entry></row><row><entry/><entry>currPic, refPicList1[ refIdxL1 ] ) is less than 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 16</entry></row><row><entry>-</entry><entry>CbWidth is greater than or equal to 16</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0159" num="0148">Referring to Table 10 above, the BDOF may not be applied to the block which is smaller than 16&#xd7;16 by changing the conditions (e.g., CbHeight and CbWidth) related to the size of the current block. For example, a condition applied when the height of the current block (e.g., CbHeight) is equal to or larger than 16 and a condition applied when the width of the current block (e.g., CbWidth) is equal to or larger than 16 may be used. When the application conditions related to the size of the current block are satisfied (i.e., when the size of the current block is equal to or larger than 16&#xd7;16, the BDOF may be applied and when the application conditions related to the size of the current block are not satisfied (i.e., when the size of the current block is smaller than 16&#xd7;16), the BDOF may not be applied.</p><p id="p-0160" num="0149">Further, in the embodiment, together with the conditions (e.g., CbHeight and CbWidth) related to the size of the current block, whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 10 above.</p><p id="p-0161" num="0150">In other words, the decoding apparatus may determine whether all conditions listed in Table 10 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 10 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 10 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0162" num="0151">The method for performing the true bi-prediction based on the conditions listed in Table 9 or 10 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0163" num="0152">As described above, the DMVR is applied when the distances between the current picture and the bilateral reference pictures are the same as each other, while the BDOF is continuously applied in the case of the true bi-prediction even though the distances between the current picture and the bilateral reference pictures are different from each other. Accordingly, the present disclosure proposes a method that may integrally apply the condition related to the bilateral reference picture distance to the DMVR and the BDOF in order to increase coding efficiency.</p><p id="p-0164" num="0153">As an embodiment proposed in the present disclosure, the application condition of the BDOF may include conditions presented in Table 11 below.</p><p id="p-0165" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 11</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ]</entry></row><row><entry/><entry>are both equal to 1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt</entry></row><row><entry/><entry>(currPic, RefPicList1 [ refIdxL1 ] ) is equal to 0 : True bi, and</entry></row><row><entry/><entry>bi-directional reference picture distances are equal to each other</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0166" num="0154">Referring to Table 11 above, a condition related to the reference picture distance among the application conditions of the BDOF (e.g., DiffPicOrderCnt) is changed to similarly apply the corresponding condition to the DMVR and the BDOF. For example, whether DiffPicOrderCnt(currPic, RefPicList0 [refldxL0])&#x2212;DiffPicOrderCnt(currPic, RefPicList1 [refldxL1]) is 0 is determined to determine whether a distance between the current picture and an L0 reference picture (i.e., a reference picture in the reference picture list L0) and a distance between the current picture and an L1 reference picture (i.e., a reference picture in the reference picture list L1) are the same as each other. In other words, the BDOF may be applied only when the distances between the current picture and the bilateral reference pictures are the same as each other. As such, as a condition in which the true bi-prediction is performed and the bilateral reference picture distances are the same as each other is added, a BDOF application range is limited, thereby saving decoding complexity.</p><p id="p-0167" num="0155">Further, in the embodiment, together with the conditions (e.g., DiffPicOrderCnt) related to the reference picture distance, whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 11 above.</p><p id="p-0168" num="0156">In other words, the decoding apparatus may determine whether all conditions listed in Table 11 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 11 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 11 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0169" num="0157">As an embodiment proposed in the present disclosure, the application condition of the DMVR may include conditions presented in Table 12 below.</p><p id="p-0170" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 12</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[refIdxL0 ] ) * DiffPicOrderCnt(</entry></row><row><entry/><entry>currPic, refPicList1[ refIdxL1 ] ) is less than 0. : TrueBi</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0171" num="0158">Referring to Table 12 above, a condition related to the reference picture distance among the application conditions of the DMVR (e.g., DiffPicOrderCnt) is changed to similarly apply the corresponding condition to the DMVR and the BDOF. For example, it is determined whether DiffPicOrderCnt(currPic, refPicList0[refldxL0])*DiffPicOrderCnt(currPic, refPicList1[refldxL1]) is smaller 0 to determine whether a true bi-prediction is performed in which the bilateral reference pictures are located in different directions based on the current picture. In other words, the DMVR may be continuously applied in the case of the true bi-prediction even though the distances between the current picture and the bilateral reference pictures are not the same as each other. As such, as the condition for whether the true bi-prediction is performed is applied, a motion vector derived by considering the decoding complexity may be used without scaling even when the bilateral reference picture distances are different.</p><p id="p-0172" num="0159">Further, in the embodiment, together with the condition (e.g., DiffPicOrderCnt) related to the reference picture distance, whether to apply the DMVR may be determined based on the remaining application conditions listed in Table 12 above.</p><p id="p-0173" num="0160">In other words, the decoding apparatus may determine whether all conditions listed in Table 12 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 12 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 12 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0174" num="0161">The method for performing the true bi-prediction based on the conditions listed in Table 11 or 12 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0175" num="0162">Meanwhile, in each reference block, a case where motion compensation is performed by a weighted sum by a change in light may occur. In this case, since a phenomenon may be determined by GBi or local illumination compensation (LIC), the application conditions of the DMVR and the BDOF may be determined by considering the GBi or LIC condition.</p><p id="p-0176" num="0163">As an embodiment of the present disclosure, proposed is a method for determining whether to apply the DMVR by considering the GBi and LIC conditions. In this case, the application condition of the DMVR may include conditions presented in Table 13 below.</p><p id="p-0177" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 13</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt</entry></row><row><entry/><entry>(currPic, RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8.</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64.</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>LICFlag is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0178" num="0164">Referring to Table 13 above, whether to apply the DMVR may be determined by adding the GBi condition (e.g., GbiIdx) and the LIC condition (e.g., LICFlag). For example, when GbiIdx is 0 (i.e., when GbiIdx is default), it is determined that the condition for whether GBi exists is satisfied and when LICFlag is 0 (i.e., when LIC exists), it may be determined that a condition for whether LIC exists is satisfied.</p><p id="p-0179" num="0165">Further, in the embodiment, together with the GBi condition (e.g., GbiIdx) and the LIC condition (e.g., LICFlag), whether to apply the DMVR may be determined based on the remaining application conditions listed in Table 13 above.</p><p id="p-0180" num="0166">In other words, the decoding apparatus may determine whether all conditions listed in Table 13 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 13 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 13 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0181" num="0167">As an embodiment of the present disclosure, proposed is a method for determining whether to apply the BDOF by considering the GBi and LIC conditions. In this case, the application condition of the BDOF may include conditions presented in Table 14 below.</p><p id="p-0182" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 14</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ]</entry></row><row><entry/><entry>are both equal to 1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt(</entry></row><row><entry/><entry>currPic, refPicList1[ refIdxL1 ] ) is less than 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>LICFlag is equal to 0.</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0183" num="0168">According to Table 14 above, whether to apply the BDOF may be determined by adding an LIC condition (e.g., LICFlag) together with the conventional GBi condition (e.g., GbiIdx). For example, when GbiIdx is 0 (i.e., when GbiIdx is default), it is determined that the condition for whether GBi exists is satisfied and when LICFlag is 0 (i.e., when LIC exists), it may be determined that a condition for whether LIC exists is satisfied.</p><p id="p-0184" num="0169">Accordingly, in the embodiment, together with the GBi condition (e.g., GbiIdx) and the LIC condition (e.g., LICFlag), whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 14 above.</p><p id="p-0185" num="0170">In other words, the decoding apparatus may determine whether all conditions listed in Table 14 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 14 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 14 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0186" num="0171">The method for performing the true bi-prediction based on the conditions listed in Table 13 or 14 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0187" num="0172">Meanwhile, since the DMVR and the BDOF derive the motion information through the refinement process in the decoding apparatus, a decoding complexity problem occurs. Accordingly, the present disclosure proposes a method that may reduce the decoding complexity by allowing whether to apply the DMVR and the BDOF to be determined by using the merge index. In this case, since both the DMVR and the BDOF perform refinement of the motion vector in a limited range, an effect of refinement may be reduced when the motion vector is inaccurate. Accordingly, the present disclosure proposes a method that may limitatively apply the DMVR and the BDOF only when a value indicating the merge index is small by considering efficiency of the refinement.</p><p id="p-0188" num="0173">Here, the merge index may be a syntax element signaled from the encoding apparatus to the decoding apparatus. For example, the encoding/decoding apparatus may configure the merge candidate list based on the neighboring blocks of the current block when the merge mode/skip mode is applied to the current block. In this case, the encoding apparatus may select an optimal merge candidate among the merge candidates included in the merge candidate list based on rate-distortion (RD) cost and signal merge index information indicating the selected merge candidate to the decoding apparatus. The decoding apparatus may select the merge candidate applied to the current block based on the merge candidate list and the merge index information.</p><p id="p-0189" num="0174">As an embodiment of the present disclosure, a method for determining whether to apply the DMVR by using the merge index may include conditions presented in Table 15 below.</p><p id="p-0190" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 15</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_idx[ xCb ][ yCb ] &#x3c; 2.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt</entry></row><row><entry/><entry>(currPic, RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8.</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0191" num="0175">Referring to Table 15 above, whether to apply the DMVR may be determined by adding a merge index condition (e.g., merge_idx). For example, when the merge index (e.g., merge_idx) is smaller than 2, it may be determined that the merge index condition is satisfied. Here, a value (threshold) of the merge index may be set to 2, but this is just one example and the corresponding value may be changed according to the coding efficiency.</p><p id="p-0192" num="0176">Accordingly, in the embodiment, together with the merge index condition (e.g., merge_idx), whether to apply the DMVR may be determined based on the remaining application conditions listed in Table 15 above.</p><p id="p-0193" num="0177">In other words, the decoding apparatus may determine whether all conditions listed in Table 15 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 15 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 15 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0194" num="0178">As an embodiment of the present disclosure, a method for determining whether to apply the BDOF by using the merge index may include conditions presented in Table 16 below.</p><p id="p-0195" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 16</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ]</entry></row><row><entry/><entry>are both equal to 1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt(</entry></row><row><entry/><entry>currPic, refPicList1[ refIdxL1 ] ) is less than 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>!(merge_flag[ xCb ][ yCb ] is equal to 1 &#x26;&#x26;</entry></row><row><entry/><entry>merge_idx[ xCb ][ yCb ] &#x3e;= 2)</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0196" num="0179">Referring to Table 16 above, whether to apply the BDOF may be determined by adding the condition for whether the merge mode/skip mode is applied (e.g., merge_flag) and the merge index condition (e.g., merge_idx). For example, when merge flag is not 1 (i.e., when the inter prediction is performed by using the merge mode/skip mode) and merge_idex is not equal to or larger than 2, only if the value of the merge index is small, it may be determined that the condition for limitatively applying the BDOF is satisfied. In other words, when merge_flag is 1 (i.e., when the inter prediction is performed by using the merge mode/skip mode) and merge_idex is smaller than 2, only if the value of the merge index is small, it may be determined that the merge index condition is satisfied and the BDOF may be applied. Here, the value (threshold) of the merge index may be set to 2, but this is just one example and the corresponding value may be changed according to the coding efficiency.</p><p id="p-0197" num="0180">In other words, in the embodiment, together with the condition for whether the merge mode/skip mode is applied (e.g., merge_flag) and the merge index condition (e.g., merge_idx), whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 16 above.</p><p id="p-0198" num="0181">In other words, the decoding apparatus may determine whether all conditions listed in Table 16 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 16 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 16 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0199" num="0182">The method for performing the true bi-prediction based on the conditions listed in Table 15 or 16 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0200" num="0183">Meanwhile, in the merge/skip mode, the motion information may be refined through the MMVD and in this case, since the decoding complexity increases, the DMVR is not performed when the MMVD is applied. However, when the DMVR is applied without considering the MMVD, the DMVR may be applied without the MMVD condition by considering performance enhancement. In this case, according to an embodiment of the present disclosure, the application condition of the DMVR may include conditions presented in Table 17 below.</p><p id="p-0201" num="0000"><tables id="TABLE-US-00017" num="00017"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 17</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt (currPic,</entry></row><row><entry/><entry>RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8.</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0202" num="0184">Referring to Table 17 above, a condition (e.g., mmvd_flag) for whether to apply the MMVD mode among the application conditions of the conventional DMVR may be excluded. In other words, a process of determining whether mmvd_flag is 0 (i.e., whether the MMVD mode is not used) may be omitted and whether to apply the DMVR may be determined based on the conditions listed in Table 17 above.</p><p id="p-0203" num="0185">In other words, the decoding apparatus may determine whether all conditions listed in Table 17 above are satisfied (excluding the condition (e.g., mmvd_flag) for whether to apply the MMVD mode) and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 17 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 17 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0204" num="0186">Further, contrary to the embodiment of Table 17 described above, when the motion information is refined through the MMVD in the merge/skip mode, whether to perform the BDOF may be determined by considering the decoding complexity. Accordingly, the present disclosure proposes a method for determining whether to apply the BDOF by considering the MMVD condition. In this case, according to an embodiment of the present disclosure, the application condition of the BDOF may include conditions presented in Table 18 below.</p><p id="p-0205" num="0000"><tables id="TABLE-US-00018" num="00018"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="252pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 18</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ] are both equal to</entry></row><row><entry/><entry>1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt( currPic,</entry></row><row><entry/><entry>refPicList1[ refIdxL1 ] ) is less than 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0206" num="0187">Referring to Table 18 above, the BDOF may not be applied when the motion information is refined through the MMVD by adding the condition (e.g., mmvd_flag) for whether to apply the MMVD mode. For example, when mmvd_flag is 0 (i.e., when the MMVD mode is not used), it may be determined that the condition for whether to apply the MMVD mode is satisified.</p><p id="p-0207" num="0188">Accordingly, in the embodiment, together with the condition (e.g., mmvd_flag) for whether to apply the MMVD mode, whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 18 above.</p><p id="p-0208" num="0189">In other words, the decoding apparatus may determine whether all conditions listed in Table 18 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 18 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 18 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0209" num="0190">The method for performing the true bi-prediction based on the conditions listed in Table 17 or 18 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0210" num="0191">Meanwhile, in the case of the AMVP, an Adaptive Motion Vector Resolution (AMVR) technique may be applied. In this case, when a resolution of the motion vector is high, i.e., when an integer-pel rounding or 4 integer-pel rounding is provided, it may not be appropriate to apply the technique in the case of the BDOF of performing the refinement in the limited area. Accordingly, the present disclosure proposes a method that may determine performing the BDOF according to the AMVR condition. In this case, according to an embodiment of the present disclosure, the application condition of the BDOF may include conditions presented in Table 19 below.</p><p id="p-0211" num="0000"><tables id="TABLE-US-00019" num="00019"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="252pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 19</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ] are both equal to</entry></row><row><entry/><entry>1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt( currPic,</entry></row><row><entry/><entry>refPicList1[ refIdxL1 ] ) is less than 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>amvr_flag != 0</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0212" num="0192">Referring to Table 19 above, whether to apply the BDOF may be determined by adding the AMVR condition (e.g., amvr_flag). Here, amvr_flag may be information representing the solution of a motion vector difference (MVD). For example, in a case where amvr_flag is 0, the case may indicate that the resolution of the MVD is derived in units of &#xbc; sample (quarter-luma-sample) and in a case where amvr_flag is not 0, the case may indicate that the resolution of the MVD is derived in units of integer-luma-sample or four-luma-sample. Alternatively, a reverse case thereto may be determined. According to an embodiment, as presented in Table 19 above, in the case where amvr_flag is not 0, the condition that the BDOF is applied may be set. In other words, in the case where amvr_flag is 0, the BDOF may be limited not to be applied.</p><p id="p-0213" num="0193">Accordingly, in the embodiment, together with the AMVR condition (e.g., amvr_flag), whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 19 above.</p><p id="p-0214" num="0194">In other words, the decoding apparatus may determine whether all conditions listed in Table 19 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 19 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 19 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0215" num="0195">Meanwhile, the DMVR and the BDOF may be each signaled in a sequence parameter set (SPS) syntax. Table 20 below shows one example of a syntax element indicating whether the DMVR signaled through the SPS syntax is enabled and whether the BDOF is enabled.</p><p id="p-0216" num="0000"><tables id="TABLE-US-00020" num="00020"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="154pt" align="left"/><colspec colname="1" colwidth="63pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 20</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="28pt" align="left"/><colspec colname="1" colwidth="126pt" align="left"/><colspec colname="2" colwidth="63pt" align="left"/><tbody valign="top"><row><entry/><entry>seq_parameter_set_rbsp( ) {</entry><entry/></row><row><entry/><entry>&#x2003;......</entry><entry>......</entry></row><row><entry/><entry>&#x2003;sps_dmvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;sps_bdof_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;......</entry><entry>......</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0217" num="0196">Referring to Table 20 above, sps_dmvr_enabled_flag may be signaled in the SPS syntax and whether true bi-prediction based DMVR is enabled may be represented based on the syntax element. For example, in a case where sps_dmvr_enabled_flag is 1, the case may indicate that the true bi-prediction based DMVR is enabled and in a case where sps_dmvr_enabled_flag is 0, the case may indicate that the true bi-prediction based DMVR is not enabled.</p><p id="p-0218" num="0197">Further, sps_bdof_enabled_flag may be signaled in the SPS syntax and whether true bi-prediction based BDOF is enabled may be represented based on the syntax element. For example, in a case where sps_bdof_enabled_flag is 1, the case may indicate that the true bi-prediction based BDOF is enabled and in a case where sps_bdof_enabled_flag is 0, the case may indicate that the true bi-prediction based BDOF is not enabled.</p><p id="p-0219" num="0198">As shown in Table 20, the application conditions of the DMVR and the BDOF may be checked by using a syntax element (e.g., sps_dmvr_enabled_flag) representing whether the DMVR is enabled and a syntax element (e.g., sps_bdof_enabled_flag) representing whether the BDOF is enabled.</p><p id="p-0220" num="0199"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates one example illustrating a method for performing a decoding process by checking application conditions of a DMVR and a BDOF.</p><p id="p-0221" num="0200">As shown in Table 20, the method of <figref idref="DRAWINGS">FIG. <b>6</b></figref> may be applied when using a syntax element (e.g., sps_dmvr_enabled_flag) representing whether the DMVR is enabled and a syntax element (e.g., sps_bdof_enabled_flag) representing whether the BDOF is enabled.</p><p id="p-0222" num="0201">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the decoding apparatus may derive motion information (e.g., a motion vector, a reference picture index, etc.) for a current block (S<b>600</b>).</p><p id="p-0223" num="0202">The decoding apparatus may check an application of the DMVR (S<b>610</b>). In this case, the application condition of the DMVR may be checked based on the syntax element (e.g., sps_dmvr_enabled_flag) representing whether the DMVR is enabled. For example, when the DMVR is enabled (e.g., when sps_dmvr_enabled_flag is 1), the application condition of the DMVR may be checked.</p><p id="p-0224" num="0203">The decoding apparatus may determine whether to apply a DMVR process according to whether the application condition of the DMVR is satisfied (S<b>620</b>).</p><p id="p-0225" num="0204">When all application conditions of the DMVR are satisfied, the decoding apparatus may derive refined motion information by applying the DMVR process (S<b>630</b>). When at least one of the application conditions of the DMVR is not satisfied, the decoding apparatus may not apply the DMVR process.</p><p id="p-0226" num="0205">The decoding apparatus may derive prediction samples of the current block based on motion information derived (not refined) when refined motion information or DMVR derived when applying the DMVR is not applied (S<b>640</b>).</p><p id="p-0227" num="0206">In addition, the decoding apparatus may check an application condition of the BDOF (S<b>650</b>). In this case, the application condition of the BDOF DMVR may be checked based on the syntax element (e.g., sps_bdof_enabled_flag) representing whether the BDOF is enabled. For example, when the DMVR is enabled (e.g., when sps_bdof_enabled_flag is 1), the application condition of the DMVR may be checked.</p><p id="p-0228" num="0207">When all application conditions of the BDOF are satisfied, the decoding apparatus may refine prediction samples by applying the BDOF process (S<b>670</b>). When at least one of the application conditions of the BDOF is not satisfied, the decoding apparatus may not apply the BDOF process.</p><p id="p-0229" num="0208">The decoding apparatus may derive the residual samples for the current block (S<b>680</b>) and derive reconstructed samples based on the refined prediction samples derived when applying the residual samples and the BDOF or prediction samples (not refined) derived when not applying the BDOF (S<b>690</b>).</p><p id="p-0230" num="0209">The present disclosure proposes various embodiments that may enhance coding efficiency and reduce complexity by harmonizing mutual application conditions of the DMVR and the BDOF at the time of applying the DMVR and the BDOF as described above. In checking the application conditions of the DMVR and the BDOF according to the embodiments of the present disclosure and applying the application conditions to a decoding process, respective conditions may be separately checked and applied, but the application conditions may be checked at once in order to enhance the coding efficiency. In other words, the present disclosure proposes a method that may integrate and check the application conditions of the DMVR and the BDOF at once.</p><p id="p-0231" num="0210">As an embodiment of the present disclosure, information (e.g., sps_refinement_enabled_flag) indicating whether to apply the refinement in the decoding apparatus in the sequence parameter set (SPS) syntax is signaled to perform a process of checking the application condition of the DMVR/BDOF. Next, Table 21 shows one example of a syntax element (e.g., sps_refinement_enabled_flag) representing whether to apply the refinement in the decoding apparatus signaled through the SPS syntax.</p><p id="p-0232" num="0000"><tables id="TABLE-US-00021" num="00021"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="161pt" align="left"/><colspec colname="1" colwidth="56pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 21</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="140pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><tbody valign="top"><row><entry/><entry>seq_parameter_set_rbsp( ) {</entry><entry/></row><row><entry/><entry>&#x2003;......</entry><entry>......</entry></row><row><entry/><entry>&#x2003;sps_refinement_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;if(sps_refinement_enabled_flag) {</entry></row><row><entry/><entry>&#x2003;&#x2003;sps_dmvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;&#x2003;sps_bdof_enabled_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>&#x2003;......</entry><entry>......</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0233" num="0211">Referring to Table 21 above, sps_refinement_enabled_flag may be signaled in the SPS syntax and may represent whether the refinement is applicable in the decoding apparatus based on the syntax element. For example, when sps_refinement_enabled_flag exists (i.e., when sps_refinement_enabled_flag is true), it may be determined that the refinement is applicable in the decoding apparatus. In this case, the decoding apparatus obtains the sps_dmvr_enabled_flag syntax element representing whether the DMVR is enabled and the sps_bdof_enabled_flag syntax element representing whether the BDOF is enabled to determine the application conditions of the DMVR and the BDOF.</p><p id="p-0234" num="0212"><figref idref="DRAWINGS">FIGS. <b>7</b> and <b>8</b></figref> illustrate another example illustrating a method for performing a decoding process by checking application conditions of a DMVR and a BDOF.</p><p id="p-0235" num="0213">The method of <figref idref="DRAWINGS">FIG. <b>7</b></figref> and the method of <figref idref="DRAWINGS">FIG. <b>8</b></figref> may be applied when the syntax element (e.g., sps_refinement_enabled_flag) representing whether the refinement is applicable in the decoding apparatus is used as shown in Table 21 above. Further, description of duplicated contents of <figref idref="DRAWINGS">FIGS. <b>7</b> and <b>8</b></figref> with <figref idref="DRAWINGS">FIG. <b>6</b></figref> described above will be omitted.</p><p id="p-0236" num="0214">Referring to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, it can be seen that the application conditions are checked at once in the previous stage without checking the respective application conditions of the DMVR and the BDOF by comparing with the process of <figref idref="DRAWINGS">FIG. <b>6</b></figref> above. As an embodiment, in step S<b>710</b> of <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the decoding apparatus may check a refinement application condition. In this case, the refinement application condition may be checked based on sps_refinement_enabled_flag shown in Table 21 above. For example, the decoding apparatus may obtain the sps_dmvr_enabled_flag syntax element representing whether the DMVR is enabled and the sps_bdof_enabled_flag syntax element representing whether the BDOF is enabled when sps_refinement_enabled_flag is 1 and check the application conditions of the DMVR and the BDOF based on the obtained syntax elements.</p><p id="p-0237" num="0215">Further, referring to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the application conditions are checked at once in the previous stage without checking the respective application conditions of the DMVR and the BDOF by comparing with the process of <figref idref="DRAWINGS">FIG. <b>6</b></figref> above and a simple checking process (the application condition of the BDOF) may be performed with respect to a different condition. As an embodiment, in step S<b>810</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the decoding apparatus may check the refinement application condition. Thereafter, in step S<b>850</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the decoding apparatus may additionally simply check the application condition of the BDOF having a condition different from the refinement application condition.</p><p id="p-0238" num="0216">Meanwhile, when the height or the size (Height*Width) of the current block is smaller than a specific length or a specific size, a calculation ratio of multiplication/addition for motion compensation increases. Accordingly, in an embodiment of the present disclosure, the application of the BDOF to a block having a small height or a small size may be limited as in the application condition of the DMVR in order to reduce a worst case. In this case, the application condition of the BDOF may include conditions presented in Table 22 below.</p><p id="p-0239" num="0000"><tables id="TABLE-US-00022" num="00022"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="252pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 22</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ] are both equal to</entry></row><row><entry/><entry>1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt( currPic,</entry></row><row><entry/><entry>refPicList1[ refIdxL1 ] ) is less than 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8. : In case that block length (or size) is larger</entry></row><row><entry/><entry>than Threshold (here, Threshold may be variously exemplified)</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64. : In case that block size (or</entry></row><row><entry/><entry>magnitude) is larger than Threshold (here, Threshold may be variously exemplified)</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0240" num="0217">Referring to Table 22 above, the BDOF may not be applied to a block which is smaller than a specific size by adding the conditions (e.g., CbHeight and CbWidth) related to the size of the current block. For example, a condition applied when the height of the current block (e.g., CbHeight) is equal to or larger than 8 and a condition applied when the size of the current block (e.g., CbHeight*CbWidth) is equal to or larger than 64 may be used. When the application conditions related to the size of the current block are satisfied (i.e., when the height of the current block is equal to or larger than 8 and the height*width of the current block is equal to or larger than 64), the BDOF may be applied and when the application conditions related to the size of the current block are not satisfied, the BDOF may not be applied.</p><p id="p-0241" num="0218">Further, in the embodiment, together with the conditions (e.g., CbHeight and CbHeight*CbWidth) related to the size of the current block, whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 22 above.</p><p id="p-0242" num="0219">In other words, the decoding apparatus may determine whether all conditions listed in Table 22 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 22 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 22 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0243" num="0220">Meanwhile, when the MMVD is applied to the current block, the motion information may be derived based on information (e.g., mmvd index) on the MMVD. Here, the information on the MMVD may include an index of a base MV, a distance index, a direction index, and the like. In particular, the distance index (more specifically, mmvd_distance_index[xCb][yCb]) may be used for representing a distance from the base MV and for example, distance indexes 0 to 7 may be represented as {&#xbc;, &#xbd;, 1, 2, 4, 8, 16, 32}, respectively. In determining refinement of the motion information in the DMVR and the BDOF, whether the refinement is performed by considering an adjacent pixel (adjacent sample) and in this case, when a distance between the adjacent pixel and the base MV is far, the value of the distance index also increases. In such a case, it is difficult that considering the adjacent pixel helps performance enhancement of the DMVR and the BDOF.</p><p id="p-0244" num="0221">Accordingly, the present disclosure proposes a method that may determine whether to apply the DMVR and the BDOF according to the distance index (more specifically, mmvd_distance_index[xCb][yCb]) value.</p><p id="p-0245" num="0222">As an embodiment of the present disclosure, whether to apply the DMVR may be determined by considering the distance index and in this case, the application condition of the DMVR may include conditions presented in Table 23 below.</p><p id="p-0246" num="0000"><tables id="TABLE-US-00023" num="00023"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 23</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 1 and mmvd_distance_index[ xCb ][ yCb ] &#x3e; 4.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt (currPic,</entry></row><row><entry/><entry>RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8.</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0247" num="0223">Referring to Table 23 above, a condition (e.g., mmvd_flag) related to the MMVD among the application conditions of the DMVR is changed to limitatively apply the DMVR in the MMVD mode. For example, when mmvd_flag is 1 and mmvd_distance_index is larger than 4, it may be determined that a distance index condition of the MMVD is satisfied. Accordingly, when the MMVD mode is applied, whether to apply the DMVR may be determined according to the distance index (more specifically, mmvd_distance_index[xCb][yCb]) value.</p><p id="p-0248" num="0224">Here, the value (threshold) of mmvd_distance_index may be set to 4, but this is just one example and the corresponding value may be changed to various values according to the performance and the coding efficiency.</p><p id="p-0249" num="0225">Accordingly, in the embodiment, together with the condition (e.g., mmvd_flag) for whether to apply the MMVD and the distance index condition (e.g., mmvd_distance_index) of the MMVD, whether to apply the DMVR may be determined based on the remaining application conditions listed in Table 23 above.</p><p id="p-0250" num="0226">In other words, the decoding apparatus may determine whether all conditions listed in Table 23 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 23 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 23 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0251" num="0227">Further, as an embodiment of the present disclosure, whether to apply the BDOF may be determined by considering the distance index and in this case, the application condition of the BDOF may include conditions presented in Table 24 below.</p><p id="p-0252" num="0000"><tables id="TABLE-US-00024" num="00024"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="252pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 24</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ] are both equal to</entry></row><row><entry/><entry>1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt( currPic,</entry></row><row><entry/><entry>refPicList1[ refIdxL1 ] ) is less than 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>!merge_flag || (merge_flag &#x26;&#x26; mmvd_flag[ xCb ][ yCb ] is equal to 1 and</entry></row><row><entry/><entry>mmvd_distance_index[ xCb ][ yCb ] &#x3e; 4)</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0253" num="0228">Referring to Table 24 above, the BDOF may be limitatively applied in the MMVD mode by adding the condition for whether the merge mode/skip mode is applied (e.g., merge_flag) and conditions (e.g., mmvd_flag and mmvd_distance_index) related to the MMVD. For example, when merge_flag does not exist (i.e., when merge_flag is not 1) or when merge_flag is 1, mmvd_flag is 1, and mmvd_distance_index is larger than 4, it may be determined that the condition of limitatively applying the BDOF in the MMVD mode is satisfied. Accordingly, when the MMVD mode is applied, whether to apply the BDOF may be determined according to the distance index (e.g., mmvd_distance_index[xCb][yCb]) value.</p><p id="p-0254" num="0229">Here, the value (threshold) of mmvd_distance_index may be set to 4, but this is just one example and the corresponding value may be changed to various values according to the performance and the coding efficiency.</p><p id="p-0255" num="0230">Accordingly, in the embodiment, together with the condition for whether the merge mode/skip mode is applied (e.g., merge_flag) and the condition related to the MMVD (e.g., mmvd_flag, mmvd_distance_index), whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 24 above.</p><p id="p-0256" num="0231">In other words, the decoding apparatus may determine whether all conditions listed in Table 24 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 24 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 24 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0257" num="0232">The method for performing the true bi-prediction based on the conditions listed in Table 23 or 24 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0258" num="0233">Meanwhile, a combined intra-inter prediction (CIIP) mode of simultaneously performing the intra prediction and the inter prediction may be applied to the current block as described above. In this case, a prediction block (inter block) in which the inter prediction is performed is combined with an intra prediction method to finally generate prediction sample values, thereby enhancing prediction accuracy. However, since the DMVR and the BDOF are techniques of refining the inter block, application of the CIIP mode may not be required in terms of the performance compared with the complexity. Accordingly, the present disclosure proposes a method that may determine whether to apply the DMVR and the BDOF by considering the CIIP.</p><p id="p-0259" num="0234">As an embodiment of the present disclosure, whether to apply the DMVR may be determined by considering the CIIP and in this case, the application condition of the DMVR may include conditions presented in Table 25 below.</p><p id="p-0260" num="0000"><tables id="TABLE-US-00025" num="00025"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="245pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 25</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) &#x2212; DiffPicOrderCnt (currPic,</entry></row><row><entry/><entry>RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry>-</entry><entry>CbHeight is greater than or equal to 8.</entry></row><row><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64.</entry></row><row><entry>-</entry><entry>ciip_flag is equal to 0. : That is, when CIIP is not applied, DMVR may be applied.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0261" num="0235">Referring to Table 25 above, the DMVR may be limitatively applied according to whether to apply the CIIP by adding a condition for whether to apply the CIIP mode (e.g., ciip_flag). For example, when ciip_flag is 0 (i.e., when the CIIP mode is not applied), the DMVR may be applied by determining that the condition for whether to apply the CIIP mode is satisified.</p><p id="p-0262" num="0236">Accordingly, in the embodiment, together with the condition (e.g., ciip_flag) for whether to apply the CIIP mode, whether to apply the DMVR may be determined based on the remaining application conditions listed in Table 25 above.</p><p id="p-0263" num="0237">In other words, the decoding apparatus may determine whether all conditions listed in Table 25 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 25 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 25 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0264" num="0238">Further, as an embodiment of the present disclosure, whether to apply the BDOF may be determined by considering the CIIP and in this case, the application condition of the BDOF may include conditions presented in Table 26 below.</p><p id="p-0265" num="0000"><tables id="TABLE-US-00026" num="00026"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="252pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 26</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ] are both equal to</entry></row><row><entry/><entry>1.</entry></row><row><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) * DiffPicOrderCnt( currPic,</entry></row><row><entry/><entry>refPicList1 [ refIdxL1 ] ) is less than 0.</entry></row><row><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>-</entry><entry>ciip_flag is equal to 0. : That is, when CIIP is not applied, BDOF may be applied.</entry></row><row><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0266" num="0239">Referring to Table 26 above, the BDOF may be limitatively applied according to whether to apply the CIIP by adding the condition for whether to apply the CIIP mode (e.g., ciip_flag). For example, when ciip_flag is 0 (i.e., when the CIIP mode is not applied), the BDOF may be applied by determining that the condition for whether to apply the CIP mode is satisified.</p><p id="p-0267" num="0240">Accordingly, in the embodiment, together with the condition (e.g., ciip_flag) for whether to apply the CIIP mode, whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 26 above.</p><p id="p-0268" num="0241">In other words, the decoding apparatus may determine whether all conditions listed in Table 26 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 26 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 26 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0269" num="0242">The method for performing the true bi-prediction based on the conditions listed in Table 25 or 26 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0270" num="0243">The methods listed in Tables 5 to 26 according to the embodiment of the present disclosure described above may be applied in combination. In other words, whether to apply the DMVR and the BDOF may be determined by checking the refinement application condition and conditions shown in Table 27 below may be applied.</p><p id="p-0271" num="0000"><tables id="TABLE-US-00027" num="00027"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 27</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>DMVR</entry><entry>-</entry><entry>sps_dmvr_enabled_flag is set to 1.</entry></row><row><entry/><entry>-</entry><entry>merge_flag[ xCb ][ yCb ] is equal to 1.</entry></row><row><entry/><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry/><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) - DiffPicOrderCnt</entry></row><row><entry/><entry/><entry>(currPic,&#x2003;RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry/><entry>-</entry><entry>CbHeight is greater than or equal to 8.</entry></row><row><entry/><entry>-</entry><entry>CbHeight*CbWidth is greater than or equal to 64.</entry></row><row><entry>BDOF</entry><entry>-</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry/><entry>-</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ]</entry></row><row><entry/><entry/><entry>are both equal to 1.</entry></row><row><entry/><entry>-</entry><entry>DiffPicOrderCnt( currPic, refPicList0[ refIdxL0 ] ) *</entry></row><row><entry/><entry/><entry>DiffPicOrderCnt( currPic, refPicList1[ refIdxL1 ] ) is less than 0.</entry></row><row><entry/><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>-</entry><entry>cIdx is equal to 0.</entry></row><row><entry>DMVR + BDOF</entry><entry>-</entry><entry>predFlagL0[0][0]=1 and predFlagL0[1][1]=1.</entry></row><row><entry/><entry>-</entry><entry>DiffPicOrderCnt (currPic, RefPicList0 [refIdxL0]) - DiffPicOrderCnt</entry></row><row><entry/><entry/><entry>(currPic,&#x2003;RefPicList1 [ refIdxL1 ] ) is equal to 0.</entry></row><row><entry/><entry>-</entry><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>-</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>-</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>-</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0272" num="0244">Referring to Table 27 above, a condition in the bilateral prediction when the DMVR or BDOF is applied, a condition applied in the case of the true bi-prediction in which the distances between the current picture and the bilateral reference pictures are the same as each other, a condition applied when the MMVD mode is not used, a condition applied when the affine prediction is not performed, a condition applied when the subblock based merge mode is applied, and a condition applied when the GBi index is default may be used. In other words, whether to apply the DMVR or BDOF may be determined according to whether the conditions are satisfied.</p><p id="p-0273" num="0245">Further, a condition for determining whether the merge mode is applied for the DMVR or determining whether the current block is the luma block for the BDOF may be added.</p><p id="p-0274" num="0246">The application conditions listed in Table 27 above are examples and it is apparent that various conditions listed in the aforementioned embodiments (the embodiments in Tables 5 to 26 above) may be used in combination.</p><p id="p-0275" num="0247">Meanwhile, in the DMVR, an SAD function is adopted as a cost function instead of a mean-removed SAD (MRSAD) function by considering the decoding complexity. However when the GBi index is not default (e.g., when GbiIdx is not 0), two reference blocks may have different weighting factors, and as a result, DMVR using the SAD may not be preferable. Accordingly, the condition of the DMVR may be fixed by considering the GBi index. According to an experimental result, a 0.00% RD-rate change is shown with 100% encoding and decoding run-time by comparing with VVC Test Model (VTM) 4.0.</p><p id="p-0276" num="0248">In the case of versatile video coding (VVC), the DMVR process may be performed when all conditions listed in Table 28 below are satisfied.</p><p id="p-0277" num="0000"><tables id="TABLE-US-00028" num="00028"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 28</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>sps_dmvr_enabled_flag is equal to 1</entry></row><row><entry/><entry>merge_flag[ xCb ][ yCb ] is equal to 1</entry></row><row><entry/><entry>both predFlagL0[ 0 ][ 0 ] and predFlagL1[ 0 ][ 0 ] are equal to 1</entry></row><row><entry/><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0</entry></row><row><entry/><entry>DiffPicOrderCnt( currPic, RefPicList[ 0 ][ refIdxL0 ]) is equal to</entry></row><row><entry/><entry>DiffPicOrderCnt( RefPicList[ 1 ][ refIdxL1 ], currPic )</entry></row><row><entry/><entry>cbHeight is greater than or equal to 8</entry></row><row><entry/><entry>cbHeight*cbWidth is greater than or equal to 64</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0278" num="0249">In current DMVR, a block which is not matched may be searched by comparing with SAD of reference blocks to be weighted and averaged later. In the present disclosure, since two reference blocks may have different weights, the condition of the DMVR may be determined by considering such a case. According to an embodiment of the present disclosure, the DMVR may not be performed for the block in which the GBi index is not default. In this case, the application condition of the DMVR may be shown in Table 29 below.</p><p id="p-0279" num="0000"><tables id="TABLE-US-00029" num="00029"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 29</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>sps_dmvr_enabled_flag is equal to 1</entry></row><row><entry/><entry>merge_flag[ xCb ][ yCb ] is equal to 1</entry></row><row><entry/><entry>both predFlagL0[ 0 ][ 0 ] and predFlagL1[ 0 ][ 0 ] are equal to 1</entry></row><row><entry/><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0</entry></row><row><entry/><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>DiffPicOrderCnt( currPic, RefPicList[ 0 ][ refIdxL0 ]) is equal to</entry></row><row><entry/><entry>DiffPicOrderCnt( RefPicList[ 1 ][ refIdxL1 ], currPic )</entry></row><row><entry/><entry>cbHeight is greater than or equal to 8</entry></row><row><entry/><entry>cbHeight*cbWidth is greater than or equal to 64</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0280" num="0250">As shown in Table 29 above, when the value of the GBi index (e.g., GbiIdx) is 0, a condition of performing the DMVR may be added. In other words, when the value of the GBi index (e.g., GbiIdx) is not 0, different weights are applied to tow reference blocks (i.e., a reference block referred for L0 prediction and a reference block referred for L1 prediction), and as a result, in this case, the DMVR may be limited not to be performed.</p><p id="p-0281" num="0251">Meanwhile, the BDOF is performed when the current block (i.e., a current coding unit; a current CU) satisfies a true bi-prediction condition. When it is considered that an optical flow equation is designed to predict a motion of an object which moves at a predetermined speed (i.e., momentum), the current true bi-prediction condition is not an optimal condition for applying the BDOF. Accordingly, the condition of the BDOF may be fixed by considering the distance of the reference picture. According to an experimental result, a 0.01% RD-rate change is shown with 100% encoding and decoding run-time by comparing with VVC Test Model (VTM) 4.0.</p><p id="p-0282" num="0252"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a diagram illustrated for describing a concept of a BDOF.</p><p id="p-0283" num="0253">As described above, the BDOF is designed to enhance the performance of the motion compensation by using an optical flow concept. According to the BDOF, as illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, it may be assumed that the object moves at a predetermined speed (constant motion) and while the object moves, the luminance of each pixel is not changed. In the case of the assumption, the optical flow equation may be expressed as Equation 1 below.</p><p id="p-0284" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>&#x394;</mi>      <mo>&#x2062;</mo>      <mrow>       <mo>(</mo>       <mrow>        <mi>i</mi>        <mo>,</mo>        <mi>j</mi>       </mrow>       <mo>)</mo>      </mrow>     </mrow>     <mo>=</mo>     <mrow>      <mrow>       <mi>A</mi>       <mo>-</mo>       <mi>B</mi>      </mrow>      <mo>=</mo>      <mrow>       <mrow>        <mi>I</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mrow>           <mi>x</mi>           <mo>+</mo>           <mrow>            <mi>&#x3b4;</mi>            <mo>&#x2062;</mo>            <mi>x</mi>           </mrow>          </mrow>          <mo>,</mo>          <mrow>           <mi>y</mi>           <mo>+</mo>           <mrow>            <mi>&#x3b4;</mi>            <mo>&#x2062;</mo>            <mi>y</mi>           </mrow>          </mrow>          <mo>,</mo>          <mrow>           <mi>t</mi>           <mo>+</mo>           <mrow>            <mi>&#x3b4;</mi>            <mo>&#x2062;</mo>            <mi>t</mi>           </mrow>          </mrow>         </mrow>         <mo>)</mo>        </mrow>       </mrow>       <mo>-</mo>       <mrow>        <mi>I</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mrow>           <mi>x</mi>           <mo>-</mo>           <mrow>            <mi>&#x3b4;</mi>            <mo>&#x2062;</mo>            <mi>x</mi>           </mrow>          </mrow>          <mo>,</mo>          <mrow>           <mi>y</mi>           <mo>-</mo>           <mrow>            <mi>&#x3b4;</mi>            <mo>&#x2062;</mo>            <mi>y</mi>           </mrow>          </mrow>          <mo>,</mo>          <mrow>           <mi>t</mi>           <mo>-</mo>           <mrow>            <mi>&#x3b4;</mi>            <mo>&#x2062;</mo>            <mi>t</mi>           </mrow>          </mrow>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>[</mo>     <mrow>      <mi>Equation</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mn>1</mn>     </mrow>     <mo>]</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0285" num="0254">As described above, when the current CU satisfies the true bi-prediction condition, the BDOF is performed. However, the true bi-prediction condition does not mean a case where the object moves at a predetermined speed. Accordingly, the present disclosure proposes a method that may apply the BDOF when the object has a predetermined motion and may enhance the performance of the motion compensation.</p><p id="p-0286" num="0255">According to an embodiment of the present disclosure, in Equation 1 above, as St, the BDOF may be applied when the distance from the L0 reference picture (reference 0 of <figref idref="DRAWINGS">FIG. <b>9</b></figref>) and the distance from the L1 reference picture (reference 1 of <figref idref="DRAWINGS">FIG. <b>9</b></figref>) based on the current picture are the same as each other. In this case, the application condition of the BDOF may be changed as shown in Table 30 below.</p><p id="p-0287" num="0000"><tables id="TABLE-US-00030" num="00030"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 30</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>The variable currPic specifies the current picture and the variable bdofFlag is derived as</entry></row><row><entry>follows:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="245pt" align="left"/><tbody valign="top"><row><entry>&#x2003;-</entry><entry>If all of the following conditions are true, bdofFlag is set equal to TRUE.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="231pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x25aa;</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ] are both</entry></row><row><entry/><entry/><entry>equal to 1.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>DiffPicOrderCnt( currPic, RefPicList[ 0 ][ refIdxL0 ]) is equal to</entry></row><row><entry/><entry/><entry>DiffPicOrderCnt( RefPicList[ 1 ][ refIdxL1 ], currPic )</entry></row><row><entry/><entry>&#x25aa;</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>cIdx is equal to 0.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="245pt" align="left"/><tbody valign="top"><row><entry>&#x2003;-</entry><entry>Otherwise, bdofFlag is set equal to FALSE.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0288" num="0256">Referring to Table 30 above, a condition related to the reference picture distance among the application conditions of the BDOF (e.g., DiffPicOrderCnt) is changed to apply the BDOF only when the object has a predetermined motion speed. For example, whether DiffPicOrderCnt(currPic, RefPicList[0][refldxL0]) and DiffPicOrderCnt(RefPicList[1][refldxL1], currPic) are the same as each other is determined to determine whether a distance between the current picture and an L0 reference picture (i.e., a reference picture in the reference picture list L0) and a distance between the current picture and an L1 reference picture (i.e., a reference picture in the reference picture list L1) are the same as each other. In other words, the BDOF may be applied only when the distance from the L0 reference picture and the distance from the L1 reference picture based on the current picture are the same as each other. As such, a condition in which the bilateral reference picture distances are the same based on the current picture is used to determine whether the true bi-prediction is performed and an object which moves at a predetermined speed is included. The BDOF is applied to the block satisfying the condition to obtain a more enhanced motion information refinement result.</p><p id="p-0289" num="0257">Further, in the embodiment, together with the conditions (e.g., DiffPicOrderCnt) related to the reference picture distance, whether to apply the BDOF may be determined based on the remaining application conditions listed in Table 30 above.</p><p id="p-0290" num="0258">In other words, the decoding apparatus may determine whether all conditions listed in Table 30 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 30 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 30 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0291" num="0259">Meanwhile, the present disclosure proposes a method for determining whether to apply the BDOF according to the block size. Table 31 below shows a case where a block size limit according to an embodiment of the present disclosure is included as the application condition.</p><p id="p-0292" num="0000"><tables id="TABLE-US-00031" num="00031"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 31</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>The variable currPic specifies the current picture and the variable bdofFlag is derived as</entry></row><row><entry>follows:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="245pt" align="left"/><tbody valign="top"><row><entry>&#x2003;-</entry><entry>If all of the following conditions are true, bdofFlag is set equal to TRUE.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="231pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x25aa;</entry><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ] are both</entry></row><row><entry/><entry/><entry>equal to 1.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>DiffPicOrderCnt( currPic, RefPicList[ 0 ][ refIdxL0 ] ) *</entry></row><row><entry/><entry/><entry>DffPicOrderCnt( currPic, RefPicList[ 1 ][ refIdxL1 ] ) is less than 0.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>cIdx is equal to 0.</entry></row><row><entry/><entry>&#x25aa;</entry><entry>cbHeight is greater than or equal to 8</entry></row><row><entry/><entry>&#x25aa;</entry><entry>cbHeight*cbWidth is greater than or equal to 64</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="245pt" align="left"/><tbody valign="top"><row><entry>&#x2003;-</entry><entry>Otherwise, bdofFlag is set equal to FALSE.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0293" num="0260">Referring to Table 31 above, in applying the BDOF, when the height of the current block (e.g., CbHeight) is equal to or larger than 8, a case where the size (e.g., CbHeight* CbWidth) of the current block is equal to or larger than 64 may be added as the condition.</p><p id="p-0294" num="0261">Accordingly, in the embodiment, together with the condition for whether the height of the current block is equal to or larger than 8 and the condition for whether the height*width of the current block is equal to or larger than 64, whether to apply the BDOF may be determined by using the remaining conditions listed in Table 31 above.</p><p id="p-0295" num="0262">In other words, the decoding apparatus may determine whether all conditions listed in Table 31 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 31 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 31 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0296" num="0263">The DMVR process described in the present disclosure may be implemented according to a specification shown in Table 32 below. Table 32 below shows one example of a motion vector refinement process based on the SAD as an embodiment of the present disclosure.</p><p id="p-0297" num="0000"><tables id="TABLE-US-00032" num="00032"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 32</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>8.5.3.1 General</entry></row><row><entry>Inputs to this process are:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>a luma location ( xSb, ySb ) specifying the top-left sample of the current coding subblock relative to</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><tbody valign="top"><row><entry>the top left luma sample of the current picture.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>a variable sbWidth specifying the width of the current coding subblock in luma samples.</entry></row><row><entry>-</entry><entry>a variable sbHeight specifying the height of the current coding subblock in luma samples,</entry></row><row><entry>-</entry><entry>the luma motion vectors in 1/16 fractional-sample accuracy mvL0 and mvL1,</entry></row><row><entry>-</entry><entry>the selected luma reference picture sample arrays refPicL0L and refPicL1L.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><tbody valign="top"><row><entry>Outputs of this process are:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>delta luma motion vectors dMvL0 and dMvL1.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><tbody valign="top"><row><entry>The variable subPelFlag is set to 0. and the variables srRange, offsetH0, offsetH1, offsetV0, and offsetV1 are</entry></row><row><entry>all set equal to 2.</entry></row><row><entry>Both components of the delta luma motion vectors dMvL0 and dMvL1 are set equal to zero and modified as</entry></row><row><entry>follows:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>For each X being 0 or 1, the ( sbWidth + 2 * srRange ) x ( sbHeight + 2 * srRange ) array</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><tbody valign="top"><row><entry>predSamplesLXL of prediction luma sample values is derived by invoking the fractional sample bilinear</entry></row><row><entry>interpolation process specified in 8.5.3.2.1 with the luma location ( xSb, ySb ), the prediction block width set</entry></row><row><entry>equal to ( sbWidth + 2 * srRange ), the prediction block height set equal to ( sbHeight + 2 * srRange ), the</entry></row><row><entry>reference picture sample array refPicLXL, the motion vector mvLX and the refinement search range srRange</entry></row><row><entry>as inputs.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>The list sadList[ i ] with i = 0..8 is derived by invoking the sum of absolute differences calculation</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><tbody valign="top"><row><entry>process specified in 8.5.3.3 with sbWidth, sbHeight, offsetH0, offsetH1, offsetV0, offsetV1, predSamplesL0L</entry></row><row><entry>and predSamplesL1L as inputs.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>When sadList[ 4 ] is greater than or equal to 4 * (sbHeight &#x3e;&#x3e; 1) * sbWidth, the following applies:</entry></row><row><entry>-</entry><entry>The variable bestIdx is derived by invoking the array entry selection process specified in clause</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><tbody valign="top"><row><entry>8.5.3.4 with the list sadList[ i ] with i = 0..8 as input.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>If bestIdx is equal to 4, subPelFlag is set equal to 1.</entry></row><row><entry>-</entry><entry>Otherwise, the following applies:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><tbody valign="top"><row><entry>dX = bestIdx % 3 &#x2212; 1</entry><entry>&#x2003;(8 436)</entry></row><row><entry>dY = bestIdx / 3 &#x2212; 1</entry><entry>&#x2003;(8 437)</entry></row><row><entry>dMvL0[ 0 ] += 16 * dX</entry><entry>&#x2003;(8 438)</entry></row><row><entry>dMvL0[ 1 ] += 16 * dY</entry><entry>&#x2003;(8 439)</entry></row><row><entry>offsetH0 += dX</entry><entry>(8 440)</entry></row><row><entry>offsetV0 += dY</entry><entry>(8 441)</entry></row><row><entry>offsetH1 &#x2212;= dX</entry><entry>(8 442)</entry></row><row><entry>offsetV1 &#x2212;= dY</entry><entry>(8 443)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>The list sadList[ i ] with i = 0..8 is modifed by invoking the sum of absolute differences calculation</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><tbody valign="top"><row><entry>process specified in 8.5.3.3 with sbWidth, sbHeight, offsetH0, offsetH1, offsetV0, offsetV1, predSamplesL0L</entry></row><row><entry>and predSamplesL1L as inputs.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>The variable bestIdx is modified by invoking the array entry selection process specified in clause</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><tbody valign="top"><row><entry>8.5.3.4 with the list sadList[ i ] with i = 0..8 as input.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>If bestIdx is equal to 4, subPelFlag is set equal to 1</entry></row><row><entry>-</entry><entry>Otherwise (bestIdx is not equal to 4). the following applies:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><tbody valign="top"><row><entry>dMvL0[ 0 ] += 16 * ( bestIdx % 3 &#x2212; 1 )</entry><entry>&#x2003;(8 444)</entry></row><row><entry>dMvL0[ 1 ] += 16 * ( bestIdx / 3 &#x2212; 1 )</entry><entry>&#x2003;(8 445)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>When subPelFlag is equal to 1, the parametric motion vector refinement process specified in clause</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="392pt" align="left"/><tbody valign="top"><row><entry>8.5.3.5 is invoked with the list sadList[ i ] with i = 0..8, and the delta motion vector dMvL0 as inputs and the</entry></row><row><entry>modified dMvL0 as output.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>-</entry><entry>The delta motion vector dMvL1 is derived as follows:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><tbody valign="top"><row><entry>dMvL1[ 0 ] = &#x2212;dMvL0[ 0 ]</entry><entry>(8 446)</entry></row><row><entry>dMvL1[ 1 ] = &#x2212;dMvL0[ 1 ]</entry><entry>(8 447)</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0298" num="0264">Meanwhile, as described above, in the DMVR, the SAD function is adopted as the cost function instead of the mean-removed SAD (MRSAD) function by considering the decoding complexity. However, when the GBi index is not default (e.g., when GbiIdx is not 0) and a weighting flag by an explicit weight prediction is not 0, the DMVR using the SAD may not be preferable. Accordingly, the condition of the DMVR may be fixed by considering the GBi index and the weighting flag of the explicit weight prediction. Further, the same condition may be applied even to the BDOF. According to the experimental result, a 0.00% RD-rate change is shown with 100% encoding and decoding run-time by comparing with VVC Test Model (VTM) 4.0.</p><p id="p-0299" num="0265">In the current DMVR, a block which is not matched may be searched by comparing with SAD of reference blocks to be weighted and averaged later. In the present disclosure, since two reference blocks may have different weights, the condition of the DMVR may be determined by considering such a case. According to an embodiment of the present disclosure, the DMVR may not be performed for the block in which the GBi index is not default. Further, the DMVR may not be performed for a block in which the weighting flag by the explicit weight prediction is not 0.</p><p id="p-0300" num="0266">In an embodiment of the present disclosure, proposed is a method that may determine whether to apply the DMVR by considering the weighted bi-prediction is performed. In this case, the application condition of the DMVR may include conditions presented in Table 33 below.</p><p id="p-0301" num="0000"><tables id="TABLE-US-00033" num="00033"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 33</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>sps_dmvr_enabled_flag is equal to 1</entry></row><row><entry>merge_flag[ xCb ][ yCb ] is equal to 1</entry></row><row><entry>both predFlagL0[ 0 ][ 0 ] and predFlagL1[ 0 ][ 0 ] are equal to 1</entry></row><row><entry>mmvd_flag[ xCb ][ yCb ] is equal to 0</entry></row><row><entry>GbiIdx[ xCb ][ yCb ] is equal to 0</entry></row><row><entry>luma_weight_l0_flag[ refIdxL0 ] and luma_weight_l1_flag[ refIdxL1 ] are equal to 0</entry></row><row><entry>DiffPicOrderCnt( currPic, RefPicList[ 0 ][ refIdxL0 ]) is equal to</entry></row><row><entry>DiffPicOrderCnt( RefPicList[ 1 ][ refIdxL1 ], currPic )</entry></row><row><entry>cbHeight is greater than or equal to 8</entry></row><row><entry>cbHeight*cbWidth is greater than or equal to 64</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0302" num="0267">Referring to Table 33 above, a condition indicating whether the weight is explicitly applied to the L0 prediction and the L1 prediction (e.g., luma_weight_l0_flag and luma_weight_l1_flag) and an index condition (e.g., GbiIdx) indicating weights applied to the L0 prediction and the L1 prediction are added to determine whether to apply the DMVR according to whether the weighted bi-prediction is performed.</p><p id="p-0303" num="0268">For example, it may be determined whether the explicit weight prediction is applied to the current block based on flag information (e.g., luma_weight_l0_flag) representing whether to explicitly apply the weight to the L0 prediction and flag information (e.g., luma_weight_l1_flag) representing whether to explicitly apply the weight to the L1 prediction. In other words, when the value of luma_weight_l0_flag is 0 and the value of luma_weight_l1_flag is 0, the DMVR may be limitatively applied. In other words, when the weight prediction is not explicitly applied to the L0 and L1 predictions, it may be determined that the DMVR is applied.</p><p id="p-0304" num="0269">Further, whether bi-prediction (i.e., L0 prediction and L1 prediction) of using different weights is applied to the current block may be determined based on a value of a bi-prediction weight index (e.g., GbiIdx) representing the weights applied to the L0 prediction and the L1 prediction. In other words, the case where the value of the bi-prediction weight index (e.g., GbiIdx) is 0 may be a default case in which different weights are not applied to the L0 prediction and the L1 prediction as described in the embodiment of Table 3 above. Accordingly, when the value of the bi-prediction weight index (e.g., GbiIdx) is 0, the DMVR may be limitatively applied.</p><p id="p-0305" num="0270">According to the embodiment, when the weight prediction is not explicitly applied to the L0 and L1 predictions (when the value of luma_weight_l0_flag is 0 and when the value of luma_weight_l1_flag is 0), information on the bi-prediction weight index (e.g., GbiIdx) is further obtained to determine whether the value of the bi-prediction weight index (e.g., GbiIdx) is 0.</p><p id="p-0306" num="0271">In the embodiment, together with the condition indicating whether the weight is explicitly applied to the L0 prediction and the L1 prediction (e.g., luma_weight_l0_flag and luma_weight_l1_flag) and the index condition (e.g., GbiIdx) indicating weights applied to the L0 prediction and the L1 prediction, it may be determined whether to apply the DMVR based on the remaining conditions listed in Table 33 above.</p><p id="p-0307" num="0272">In other words, the decoding apparatus may determine whether all conditions listed in Table 33 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the DMVR. When even any of the conditions listed in Table 33 above is not satisfied, the decoding apparatus may not apply the DMVR. The encoding apparatus may also apply the conditions of Table 33 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0308" num="0273">Meanwhile, in the case of the BDOF, the GBi index is considered, but the weighting flag of the explicit weight prediction is not considered. Accordingly, the present disclosure proposes a method for determining whether to apply the BDOF by considering the GBi index and the weighting flag of the explicit weight prediction.</p><p id="p-0309" num="0274">As an embodiment of the present disclosure, whether to apply the BDOF may be determined by considering whether the weighted bi-prediction is performed and in this case, the application condition of the BDOF may include conditions presented in Table 34 below.</p><p id="p-0310" num="0000"><tables id="TABLE-US-00034" num="00034"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 34</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>sps_bdof_enabled_flag is equal to 1.</entry></row><row><entry>predFlagL0[ xSbIdx ][ ySbIdx ] and predFlagL1[ xSbIdx ][ ySbIdx ] are both equal to 1.</entry></row><row><entry>DiffPicOrderCnt( currPic, RefPicList[ 0 ][ refIdxL0 ] ) * DiffPicOrderCnt( currPic,</entry></row><row><entry>RefPicList[ 1 ][ refIdxL1 ]) is less than 0.</entry></row><row><entry>MotionModelIdc[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>merge_subblock_flag[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>GbiIdx[ xCb ][ yCb ] is equal to 0.</entry></row><row><entry>luma_weight_l0_flag[ refIdxL0 ] and luma_weight_l1_flag[ refIdxL1 ] are equal to 0.</entry></row><row><entry>cIdx is equal to 0.</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0311" num="0275">Referring to Table 34 above, a condition indicating whether the weight is explicitly applied to the L0 prediction and the L1 prediction (e.g., luma_weight_l0_flag and luma_weight_l1_flag) is added to determine whether to apply the BDOF according to whether the weighted bi-prediction is performed.</p><p id="p-0312" num="0276">For example, it may be determined whether the explicit weight prediction is applied to the current block based on flag information (e.g., luma_weight_l0_flag) representing whether to explicitly apply the weight to the L0 prediction and flag information (e.g., luma_weight_l1_flag) representing whether to explicitly apply the weight to the L1 prediction. In other words, when the value of luma_weight_l0_flag is 0 and the value of luma_weight_l1_flag is 0, the BDOF may be limitatively applied. In other words, when the weight prediction is not explicitly applied to the L0 and L1 predictions, it may be determined that the BDOF is applied.</p><p id="p-0313" num="0277">In the embodiment, together with a condition indicating whether the weight is explicitly applied to the L0 prediction and the L1 prediction (e.g., luma_weight_l0_flag and luma_weight_l1_flag), whether to apply the BDOF may be determined based on the remaining conditions listed in Table 34 above.</p><p id="p-0314" num="0278">In other words, the decoding apparatus may determine whether all conditions listed in Table 34 above are satisfied and when all conditions are satisfied, the decoding apparatus may perform the true bi-prediction by applying the BDOF. When even any of the conditions listed in Table 34 above is not satisfied, the decoding apparatus may not apply the BDOF. The encoding apparatus may also apply the conditions of Table 34 above and the encoding apparatus may perform the true bi-prediction by a corresponding method in the decoding apparatus.</p><p id="p-0315" num="0279">The method for performing the true bi-prediction based on the conditions listed in Table 33 or 34 above may be independently applied to the DMVR and the BDOF or may be applied under the same condition for the DMVR and the BDOF.</p><p id="p-0316" num="0280">This document may derive DMVR flag information related to indicating whether to apply DMVR and BDOF flag information related to indicating whether to apply BDOF based on the application conditions of Tables 1 to 34 described above.</p><p id="p-0317" num="0281">For example, the DMVR flag information (e.g., dmvrFlag) may be derived based on DMVR application conditions (e.g., at least one of application conditions or a combination of application conditions disclosed in Tables 1 to 34). In this case, when a value of the dmvrFlag is equal to 1 (or true), it may indicate that the DMVR is applied, and when the value of the dmvrFlag is equal to 0 (or false), it may indicate that the DMVR is not applied. In addition, the BDOF flag information (e.g., bdofFlag) may be derived based on BDOF application conditions (e.g., at least one of application conditions or a combination of application conditions disclosed in Tables 1 to 34). In this case, when a value of the bdofFlag is equal to 1 (or true), it may indicate that the BDOF is applied, and when the value of the bdofFlag is equal to 0 (or false), it may indicate that the BDOF is not applied.</p><p id="p-0318" num="0282"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flowchart schematically illustrating an encoding method that can be performed by an encoding apparatus according to an embodiment of this document.</p><p id="p-0319" num="0283">The method disclosed in <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be performed by the encoding apparatus <b>200</b> disclosed in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Specifically, step S<b>1000</b> of <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be performed by the predictor <b>220</b>, the inter predictor <b>221</b> and/or the entropy encoder <b>240</b> disclosed in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, and steps S<b>1010</b> to S<b>1030</b> of <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be performed by the predictor <b>220</b> and the inter predictor <b>221</b> disclosed in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, step S<b>1040</b> of <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be performed by the residual processor <b>230</b> disclosed in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, and step S<b>1050</b> of <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be performed by the entropy encoder <b>240</b> disclosed in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Further, the method disclosed in <figref idref="DRAWINGS">FIG. <b>10</b></figref> may include the above-described embodiments in this document. Accordingly, the detailed explanation of the contents duplicate to the above-described embodiments in <figref idref="DRAWINGS">FIG. <b>10</b></figref> will be omitted or simplified.</p><p id="p-0320" num="0284">Referring to <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the encoding apparatus may determine luma weight L0 flag information related to indicating whether a weight factor for an L0 prediction is present and luma weight L1 flag information related to indicating whether a weight factor for an L1 prediction is present (S<b>1000</b>).</p><p id="p-0321" num="0285">In an embodiment, the encoding apparatus may determine an inter prediction type (L0 prediction, L1 prediction, Bi prediction, and the like). Further, the encoding apparatus may determine whether to apply weighted prediction according to the inter prediction type. In this case, when it is determined as a bi-prediction type to which both the L0 prediction and the L1 prediction are applied, the encoding apparatus may determine whether to apply weighted prediction (weight) to the L0 prediction and the L1 prediction, respectively. That is, the encoding apparatus may determine a value of the luma weight L0 flag information according to whether a weight is applied to the L0 prediction, and may determine a value of the luma weight L1 flag information according to whether a weight is applied to the L1 prediction.</p><p id="p-0322" num="0286">For example, when the value of the luma weight L0 flag information is equal to 1, it explicitly indicates that weight information (i.e., a weight factor) to be applied to the L0 prediction is present. When the value of the luma weight L0 flag information is equal to 0, it explicitly indicates that weight information (i.e., a weight factor) to be applied to the L0 prediction is not present. In addition, when the value of the luma weight L1 flag information is equal to 1, it explicitly indicates that weight information (i.e., a weight factor) to be applied to the L1 prediction is present. When the value of the luma weight L1 flag information is equal to 0, it explicitly indicates that weight information (i.e., a weight factor) to be applied to the L1 prediction is not present.</p><p id="p-0323" num="0287">Here, the luma weight L0 flag information may be the luma_weight_l0_flag of Tables 33 and 34 described above, and may be information related to indicating whether the weight factor related to the L0 prediction for the luma component of a current block is present. The luma weight L1 flag information may be the luma_weight_l1_flag of Tables 33 and 34 described above, and may be information related to indicating whether the weight factor related to the L1 prediction for the luma component of the current block is present.</p><p id="p-0324" num="0288">The encoding apparatus may generate the luma weight L0 flag information and the luma weight L1 flag information determined as described above, and may encode them into image information. In addition, the encoding apparatus may signal image information including the luma weight L0 flag information and the luma weight L1 flag information to the decoding apparatus.</p><p id="p-0325" num="0289">When the value of the luma weight L0 flag information and the value of the luma weight L1 flag information are both equal to 0, the encoding apparatus may determine to apply DMVR to an L0 motion vector and an L1 motion vector of a current block (S<b>1010</b>).</p><p id="p-0326" num="0290">That is, the encoding apparatus may determine whether to apply the DMVR to the current block in consideration of coding efficiency, complexity, prediction performance, and the like. In this case, the encoding apparatus may determine whether to apply the DMVR to the current block using the various application conditions described in Tables 1 to 34 above, and may derive DMVR flag information related to indicating whether to apply the DMVR.</p><p id="p-0327" num="0291">In an embodiment, the encoding apparatus may derive the DMVR flag information based on the luma weight L0 flag information and the luma weight L1 flag information. For example, when both the value of the luma weight L0 flag information and the value of the luma weight L1 flag information are equal to 0, the encoding apparatus may derive the value of the DMVR flag information to be equal to 1 or true. When at least one of the luma weight L0 flag information and the luma weight L1 flag information is not equal to 0, the encoding apparatus may derive the value of the DMVR flag information to be equal to 0 or false. In this case, the DMVR flag information may represent, for example, the above-described dmvrFlag, when the value of the dmvrFlag is equal to 1 (or true), it represents that the DMVR is applied, and when the value of the dmvrFlag is equal to 0 (or false), it represents that the DMVR is not applied.</p><p id="p-0328" num="0292">Further, according to an embodiment, the encoding apparatus may determine bi-prediction weight index information of the current block and may derive the DMVR flag information based thereon. For example, when a value of the bi-prediction weight index information is equal to 0, the encoding apparatus may derive the value of the DMVR flag information to be equal to 1 or true. When the value of the bi-prediction weight index information is not equal to 0, the encoding apparatus may derive the value of the DMVR flag information to be equal to 0 or false. Here, the bi-prediction weight index information may represent the above-described GbiIdx, and when the value of the bi-prediction weight index information (e.g., the GbiIdx) is equal to 0, it may be a default case which does not apply different weight values to the L0 prediction and the L1 prediction. As an example, as shown in Table 3 above, when the value of the bi-prediction weight index information is equal to 0, it may be a case in which &#xbd; weight is applied to the L0 prediction and the L1 prediction, respectively.</p><p id="p-0329" num="0293">In an embodiment, in determining the bi-prediction weight index information, when weighted prediction is not explicitly applied to the L0 and L1 predictions (e.g., the value of the luma weight L0 flag information (e.g., luma_weight_l0_flag) and the value of the luma weight L1 flag information (e.g., luma_weight_l1_flag) are both equal to 0), the bi-prediction weight index information (e.g., GbiIdx) may be determined. In this case, the determined bi-prediction weight index information (e.g., GbiIdx) may be encoded by being included in the image information, and may be signaled from the encoding apparatus to the decoding apparatus.</p><p id="p-0330" num="0294">Further, the encoding apparatus may derive the DMVR flag information by determining whether conditions such as a case that DMVR-based inter bi-prediction is enabled, a case that bi-prediction performed based on an L0 reference picture and an L1 reference picture is applied to the current block, a case that a merge mode is applied to the current block, a case that a merge mode with motion vector difference (MMVD) mode is not applied to the current block, a case that a prediction mode (i.e., CIIP mode) in which an inter prediction and an intra prediction are combined is not applied to the current block, a case that a first POC difference between the current picture and the L0 reference picture and a second POC difference between the current picture and the L1 reference picture are the same, a case that a height of the current block is equal to or larger than 8 are satisfied. For example, if all of the above conditions are satisfied, the value of the DMVR flag information may be set to true or 1, and if at least one of the above conditions is not satisfied, the value of the DMVR flag information may be set to false or 0.</p><p id="p-0331" num="0295">Here, in deriving the DMVR flag information, the DMVR application conditions listed above are merely exemplary, and various combinations of the conditions of Tables 1 to 34 may be used.</p><p id="p-0332" num="0296">When it is determined to apply the DMVR to the current block based on the DMVR flag information (e.g., when the DMVR flag information is derived as true or a value of 1), the encoding apparatus may derive a refined L0 motion vector and a refined L1 motion vector by applying the DMVR to the current block (S<b>1020</b>).</p><p id="p-0333" num="0297">In an embodiment, the encoding apparatus may derive motion information (motion vector, reference picture index, and the like) of the current block. For example, the encoding apparatus may search for blocks similar to the current block within a predetermined area (search area) of reference pictures through motion estimation, and may derive a reference block having a difference from the current block, which is minimal or equal to or lower than a predetermined level. Based on this, the encoding apparatus may derive a reference picture index indicating a reference picture in which the reference block is located, and may derive a motion vector based on a difference in location between the reference block and the current block.</p><p id="p-0334" num="0298">Here, the motion information may include information, such as a motion vector, a reference picture index, and the like, and may include L0 motion information and/or L1 motion information depending on an inter prediction type (L0 prediction, L1 prediction, Bi prediction, and the like). When a bi-prediction is applied to the current block, the motion information may include a motion vector (L0 motion vector) in an L0 direction and a motion vector (L1 motion vector) in an L1 direction. Further, the motion information may include an L0 reference picture index and an L0 reference picture indicated by the L0 reference picture index in an L0 reference picture list, and an L1 reference picture index and an L1 reference picture indicated by the L1 reference picture index in an L1 reference picture list.</p><p id="p-0335" num="0299">Further, the encoding apparatus may determine an inter prediction mode being applied to the current block among various prediction modes. The encoding apparatus may compare RD costs for various prediction modes with one another, and may determine an optimum prediction mode for the current block. For example, the encoding apparatus may determine whether to apply a merge mode as the optimum prediction mode for the current block. In case of applying the merge mode to the current block, the encoding apparatus may configure a merge candidate list based on neighboring blocks of the current block, and may generate merge index information. Specifically, the encoding apparatus may derive a reference block having a difference from the current block, which is minimal or equal to or lower than a predetermined level, among reference blocks (i.e., neighboring blocks) indicated by merge candidates included in the merge candidate list. In this case, a merge candidate related to the derived reference block may be selected, and merge index information indicating the selected merge candidate may be generated and signaled to a decoding apparatus. Motion information of the current block may be derived using motion information of the selected merge candidate.</p><p id="p-0336" num="0300">That is, when the merge mode is applied to the current block, the encoding apparatus may use a motion vector of a neighboring block indicated by merge index in the merge candidate list derived based on the neighboring blocks of the current block as L0 and L1 motion vectors of the current block.</p><p id="p-0337" num="0301">In addition, when it is determined to apply the DMVR to the current block based on the DMVR flag information (e.g., when the value of the DMVR flag information is derived as true or a value of 1), the encoding apparatus may apply the DMVR to the L0 motion vector and the L1 motion vector of the current block.</p><p id="p-0338" num="0302">For example, the encoding apparatus may calculate a minimum sum of absolute differences (SAD) based on reference samples (i.e., L0 prediction samples) in an L0 reference picture being derived based on the L0 motion vector and reference samples (i.e., L1 prediction samples) in an L1 reference picture being derived based on the L1 motion vector. Further, the encoding apparatus may derive the refined L0 motion vector and the refined L1 motion vector based on a sample location corresponding to the minimum SAD. That is, the refined L0 motion vector may be a motion vector related to indicating the sample location corresponding to the minimum SAD in the L0 reference picture, and the refined L1 motion vector may be a motion vector related to indicating the sample location corresponding to the minimum SAD in the L1 reference picture. Since the process of deriving the refined motion vector by applying the DMVR has been described in detail with reference to <figref idref="DRAWINGS">FIGS. <b>4</b> and <b>5</b></figref>, the explanation thereof will be omitted hereinafter.</p><p id="p-0339" num="0303">The encoding apparatus may derive prediction samples for the current block based on the L0 prediction using the refined L0 motion vector and the L1 prediction using the refined L1 motion vector (S<b>1030</b>).</p><p id="p-0340" num="0304">In deriving the prediction samples, the encoding apparatus may determine whether to apply BDOF process to the current block in consideration of coding efficiency, complexity, prediction performance, and the like. In this case, the encoding apparatus may determine whether to apply the BDOF to the current block by using the various application conditions described in Tables 1 to 34 above, and may derive BDOF flag information related to indicating whether to applying the BDOF.</p><p id="p-0341" num="0305">In an embodiment, the encoding apparatus may derive the BDOF flag information based on the luma weight L0 flag information and the luma weight L1 flag information. For example, when the value of the luma weight L0 flag information and the value of the luma weight L1 flag information are both equal to 0, the encoding apparatus may derive the value of the BDOF flag information to be equal to 1 or true. When at least one of the luma weight L0 flag information and the luma weight L1 flag information is not equal to 0, the encoding apparatus may derive the value of the BDOF flag information to be equal to 0 or false. In this case, the BDOF flag information may represent, for example, the above-described bdofFlag, when the value of the bdofFlag is equal to 1 (or true), it represents that the BDOF is applied, and when the value of the bdofFlag is equal to 0 (or false), it represents that the BDOF is not applied.</p><p id="p-0342" num="0306">Further, according to an embodiment, the encoding apparatus may derive the BDOF flag information based on bi-prediction weight index information of the current block. For example, when a value of the bi-prediction weight index information is equal to 0, the encoding apparatus may derive the value of the BDOF flag information to be equal to 1 or true. When the value of the bi-prediction weight index information is not equal to 0, the encoding apparatus may derive the value of the BDOF flag information to be equal to 0 or false. For example, as described above, when the value of the bi-prediction weight index information is equal to 0, it may be a case in which &#xbd; weight is applied to the L0 prediction and the L1 prediction, respectively.</p><p id="p-0343" num="0307">Further, the encoding apparatus may derive the BDOF flag information by determining whether conditions such as a case that BDOF-based inter prediction is enabled, a case that bi-prediction performed based on an L0 reference picture and an L1 reference picture is applied to the current block, a case that a first POC difference between the current picture and the L0 reference picture and a second POC difference between the current picture and the L1 reference picture are the same, a case that an affine mode is not applied to the current block, a case that a subblock-based merge mode is not applied to the current block, a case that a prediction mode (i.e., CIIP mode) in which an inter prediction and an intra prediction are combined is not applied to the current block, a case that a height of the current block is equal to or larger than 8 are satisfied. For example, if all of the above conditions are satisfied, the value of the BDOF flag information may be set to true or 1, and if at least one of the above conditions is not satisfied, the value of the BDOF flag information may be set to false or 0.</p><p id="p-0344" num="0308">Here, in deriving the BDOF flag information, the BDOF application conditions listed above are merely exemplary, and various combinations of the conditions of Tables 1 to 34 may be used.</p><p id="p-0345" num="0309">When it is determined to apply the BDOF to the current block based on the BDOF flag information (e.g., when the value of the BDOF flag information is derived as true or 1), the encoding apparatus may derive the prediction samples by applying the BDOF to the current block.</p><p id="p-0346" num="0310">In an embodiment, the encoding apparatus may derive L0 prediction samples based on the L0 prediction using the refined L0 motion vector, and may derive L1 prediction samples based on the L1 prediction using the refined L1 motion vector. In this case, the encoding apparatus may finally derive the (refined) prediction samples based on a gradient for the L0 prediction samples and a gradient for the L1 prediction samples.</p><p id="p-0347" num="0311">The encoding apparatus may derive residual samples for the current block based on the prediction samples (S<b>1040</b>), and encode image information including information on the residual samples (S<b>1050</b>).</p><p id="p-0348" num="0312">That is, the encoding apparatus may derive the residual samples based on the original samples of the current block and the prediction samples of the current block. And, the encoding apparatus may generate the information on the residual samples. Here, the information on the residual samples may include information, such as value information, location information, transform technique, transform kernel, and quantization parameter information of quantized transform coefficients derived by performing transform and quantization of the residual samples.</p><p id="p-0349" num="0313">The encoding apparatus may encode the information on the residual samples to output the encoded information in the form of a bitstream, and may transmit the bitstream to the decoding apparatus through a network or a storage medium.</p><p id="p-0350" num="0314">Further, the encoding apparatus may encode information derived through the above-described steps S<b>1000</b> to S<b>1050</b>, and may output the encoded information in the form of a bitstream. For example, merge flag information, merge index information, L0 reference picture index, L1 reference picture index, luma weight L0 flag information, luma weight L1 flag information, bi-prediction weight index information, etc. may be included in the image information to be encoded, and the encoded image information may be signaled to the decoding apparatus.</p><p id="p-0351" num="0315"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flowchart schematically illustrating a decoding method that can be performed by a decoding apparatus according to an embodiment of this document.</p><p id="p-0352" num="0316">The method disclosed in <figref idref="DRAWINGS">FIG. <b>11</b></figref> may be performed by the decoding apparatus <b>300</b> disclosed in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. Specifically, step S<b>1100</b> of <figref idref="DRAWINGS">FIG. <b>11</b></figref> may be performed by the entropy decoder <b>310</b> disclosed in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, steps S<b>1110</b> to S<b>1130</b> of <figref idref="DRAWINGS">FIG. <b>11</b></figref> may be performed by the predictor <b>330</b> and the inter predictor <b>332</b> disclosed in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, and step S<b>1140</b> of <figref idref="DRAWINGS">FIG. <b>11</b></figref> may be performed by the adder <b>340</b> disclosed in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. Further, the method disclosed in <figref idref="DRAWINGS">FIG. <b>11</b></figref> may include the above-described embodiments in this document. Accordingly, the detailed explanation of the contents duplicate to the above-described embodiments in <figref idref="DRAWINGS">FIG. <b>11</b></figref> will be omitted or simplified.</p><p id="p-0353" num="0317">Referring to <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the decoding apparatus may obtain luma weight L0 flag information related to indicating whether a weight factor for an L0 prediction is present and luma weight L1 flag information related to indicating whether a weight factor for an L1 prediction is present from a bitstream (S<b>1100</b>).</p><p id="p-0354" num="0318">In an embodiment, the decoding apparatus may obtain by decoding the luma weight L0 flag information and the luma weight L1 flag information from the bitstream. For example, when a value of the luma weight L0 flag information is decoded as 1, the decoding apparatus may determine that weight information (i.e., a weight factor) to be applied in L0 prediction is present. When the value of the luma weight L0 flag information is decoded as 0, the decoding apparatus may determine that weight information (i.e., a weight factor) to be applied in L0 prediction is not present. Further, when a value of the luma weight L1 flag information is decoded as 1, the decoding apparatus may determine that weight information (i.e., a weight factor) to be applied in L1 prediction is present. When the value of the luma weight L1 flag information is decoded as 0, the decoding apparatus may determine that weight information (i.e., a weight factor) to be applied in L1 prediction is not present.</p><p id="p-0355" num="0319">Here, the luma weight L0 flag information may be the luma_weight_l0_flag of Tables 33 and 34 described above, and may be information related to indicating whether the weight factor related to the L0 prediction for the luma component of a current block is present. The luma weight L1 flag information may be the luma_weight_l1_flag of Tables 33 and 34 described above, and may be information related to indicating whether the weight factor related to the L1 prediction for the luma component of the current block is present.</p><p id="p-0356" num="0320">When the value of the luma weight L0 flag information and the value of the luma weight L1 flag information are both equal to 0, the decoding apparatus may determine to apply DMVR to an L0 motion vector and an L1 motion vector of a current block (S<b>1110</b>).</p><p id="p-0357" num="0321">That is, the decoding apparatus may determine whether to apply the DMVR to the current block in consideration of coding efficiency, complexity, prediction performance, and the like. In this case, the decoding apparatus may determine whether to apply the DMVR to the current block using the various application conditions described in Tables 1 to 34 above, and may derive DMVR flag information related to indicating whether to apply the DMVR.</p><p id="p-0358" num="0322">In an embodiment, the decoding apparatus may derive the DMVR flag information based on the luma weight L0 flag information and the luma weight L1 flag information. For example, when both the value of the luma weight L0 flag information and the value of the luma weight L1 flag information are equal to 0, the decoding apparatus may derive the value of the DMVR flag information to be equal to 1 or true. When at least one of the luma weight L0 flag information and the luma weight L1 flag information is not equal to 0, the decoding apparatus may derive the value of the DMVR flag information to be equal to 0 or false. In this case, the DMVR flag information may represent, for example, the above-described dmvrFlag, when the value of the dmvrFlag is equal to 1 (or true), it represents that the DMVR is applied, and when the value of the dmvrFlag is equal to 0 (or false), it represents that the DMVR is not applied.</p><p id="p-0359" num="0323">Further, according to an embodiment, the decoding apparatus may obtain bi-prediction weight index information of the current block from the bitstream, and may derive the DMVR flag information based thereon. For example, when a value of the bi-prediction weight index information is equal to 0, the decoding apparatus may derive the value of the DMVR flag information to be equal to 1 or true. When the value of the bi-prediction weight index information is not equal to 0, the decoding apparatus may derive the value of the DMVR flag information to be equal to 0 or false. Here, the bi-prediction weight index information may represent the above-described GbiIdx, and when the value of the bi-prediction weight index information (e.g., the GbiIdx) is equal to 0, it may be a default case which does not apply different weight values to the L0 prediction and the L1 prediction. As an example, as shown in Table 3 above, when the value of the bi-prediction weight index information is equal to 0, it may be a case in which &#xbd; weight is applied to the L0 prediction and the L1 prediction, respectively.</p><p id="p-0360" num="0324">In an embodiment, in obtaining the bi-prediction weight index information, when weighted prediction is not explicitly applied to the L0 and L1 predictions (e.g., the value of the luma weight L0 flag information (e.g., luma_weight_l0_flag) and the value of the luma weight L1 flag information (e.g., luma_weight_l1_flag) are both equal to 0), the decoding apparatus may additionally obtain the bi-prediction weight index information (e.g., GbiIdx) from the bitstream.</p><p id="p-0361" num="0325">Further, the decoding apparatus may derive the DMVR flag information by determining whether conditions such as a case that DMVR-based inter bi-prediction is enabled, a case that bi-prediction performed based on an L0 reference picture and an L1 reference picture is applied to the current block, a case that a merge mode is applied to the current block, a case that a merge mode with motion vector difference (MMVD) mode is not applied to the current block, a case that a prediction mode (i.e., CLIP mode) in which an inter prediction and an intra prediction are combined is not applied to the current block, a case that a first POC difference between the current picture and the L0 reference picture and a second POC difference between the current picture and the L1 reference picture are the same, a case that a height of the current block is equal to or larger than 8 are satisfied. For example, if all of the above conditions are satisfied, the value of the DMVR flag information may be set to true or 1, and if at least one of the above conditions is not satisfied, the value of the DMVR flag information may be set to false or 0.</p><p id="p-0362" num="0326">Here, in deriving the DMVR flag information, the DMVR application conditions listed above are merely exemplary, and various combinations of the conditions of Tables 1 to 34 may be used.</p><p id="p-0363" num="0327">When it is determined to apply the DMVR to the current block based on the DMVR flag information (e.g., when the DMVR flag information is derived as true or a value of 1), the decoding apparatus may derive a refined L0 motion vector and a refined L1 motion vector by applying the DMVR to the current block (S<b>1120</b>).</p><p id="p-0364" num="0328">In an embodiment, the decoding apparatus may determine a prediction mode for the current block based on prediction information signaled from the encoding apparatus. And, the decoding apparatus may derive motion information (motion vector, reference picture index, and the like) of the current block based on the prediction mode. Here, the prediction mode may include a skip mode, a merge mode, and (A)MVP mode and the like.</p><p id="p-0365" num="0329">Here, the motion information may include information, such as a motion vector, a reference picture index, and the like, and may include L0 motion information and/or L1 motion information depending on an inter prediction type (L0 prediction, L1 prediction, Bi prediction, and the like). When a bi-prediction is applied to the current block, the motion information may include a motion vector (L0 motion vector) in an L0 direction and a motion vector (L1 motion vector) in an L1 direction. Further, the motion information may include an L0 reference picture index and an L0 reference picture indicated by the L0 reference picture index in an L0 reference picture list, and an L1 reference picture index and an L1 reference picture indicated by the L1 reference picture index in an L1 reference picture list.</p><p id="p-0366" num="0330">For example, when the merge mode is applied to the current block, the decoding apparatus may configure a merge candidate list based on neighboring blocks of the current block, and select one merge candidate from among merge candidates included in the merge candidate list. In this case, one merge candidate may be selected from the merge candidate list based on the above-described merge index information. The decoding apparatus may derive the motion information of the current block by using motion information of the selected merge candidate. That is, the motion information of the merge candidate selected by the merge index among the merge candidates included in the merge candidate list may be used as the motion information of the current block.</p><p id="p-0367" num="0331">That is, when the merge mode is applied, the decoding apparatus may use a motion vector of a neighboring block indicated by merge index in the merge candidate list derived based on the neighboring blocks of the current block as L0 and L1 motion vectors of the current block.</p><p id="p-0368" num="0332">As described above, when it is determined to apply the DMVR to the current block based on the DMVR flag information (e.g., when the value of the DMVR flag information is derived as true or a value of 1), the decoding apparatus may apply the DMVR to the L0 motion vector and the L1 motion vector of the current block.</p><p id="p-0369" num="0333">For example, the decoding apparatus may calculate a minimum sum of absolute differences (SAD) based on reference samples (i.e., L0 prediction samples) in an L0 reference picture being derived based on the L0 motion vector and reference samples (i.e., L1 prediction samples) in an L1 reference picture being derived based on the L1 motion vector. Further, the decoding apparatus may derive the refined L0 motion vector and the refined L1 motion vector based on a sample location corresponding to the minimum SAD. That is, the refined L0 motion vector may be a motion vector related to indicating the sample location corresponding to the minimum SAD in the L0 reference picture, and the refined L1 motion vector may be a motion vector related to indicating the sample location corresponding to the minimum SAD in the L1 reference picture. Since the process of deriving the refined motion vector by applying the DMVR has been described in detail with reference to <figref idref="DRAWINGS">FIGS. <b>4</b> and <b>5</b></figref>, the explanation thereof will be omitted hereinafter.</p><p id="p-0370" num="0334">The decoding apparatus may derive prediction samples for the current block based on the L0 prediction using the refined L0 motion vector and the L1 prediction using the refined L1 motion vector (S<b>1130</b>).</p><p id="p-0371" num="0335">In deriving the prediction samples, the decoding apparatus may determine whether to apply BDOF process to the current block in consideration of coding efficiency, complexity, prediction performance, and the like. In this case, the decoding apparatus may determine whether to apply the BDOF to the current block by using the various application conditions described in Tables 1 to 34 above, and may derive BDOF flag information related to indicating whether to applying the BDOF.</p><p id="p-0372" num="0336">In an embodiment, the decoding apparatus may derive the BDOF flag information based on the luma weight L0 flag information and the luma weight L1 flag information. For example, when the value of the luma weight L0 flag information and the value of the luma weight L1 flag information are both equal to 0, the decoding apparatus may derive the value of the BDOF flag information to be equal to 1 or true. When at least one of the luma weight L0 flag information and the luma weight L1 flag information is not equal to 0, the decoding apparatus may derive the value of the BDOF flag information to be equal to 0 or false. In this case, the BDOF flag information may represent, for example, the above-described bdofFlag, when the value of the bdofFlag is equal to 1 (or true), it represents that the BDOF is applied, and when the value of the bdofFlag is equal to 0 (or false), it represents that the BDOF is not applied.</p><p id="p-0373" num="0337">Further, according to an embodiment, the decoding apparatus may derive the BDOF flag information based on bi-prediction weight index information of the current block. For example, when a value of the bi-prediction weight index information is equal to 0, the decoding apparatus may derive the value of the BDOF flag information to be equal to 1 or true. When the value of the bi-prediction weight index information is not equal to 0, the decoding apparatus may derive the value of the BDOF flag information to be equal to 0 or false. For example, as described above, when the value of the bi-prediction weight index information is equal to 0, it may be a case in which &#xbd; weight is applied to the L0 prediction and the L1 prediction, respectively.</p><p id="p-0374" num="0338">Further, the decoding apparatus may derive the BDOF flag information by determining whether conditions such as a case that BDOF-based inter prediction is enabled, a case that bi-prediction performed based on an L0 reference picture and an L1 reference picture is applied to the current block, a case that a first POC difference between the current picture and the L0 reference picture and a second POC difference between the current picture and the L1 reference picture are the same, a case that an affine mode is not applied to the current block, a case that a subblock-based merge mode is not applied to the current block, a case that a prediction mode (i.e., CIIP mode) in which an inter prediction and an intra prediction are combined is not applied to the current block, a case that a height of the current block is equal to or larger than 8 are satisfied. For example, if all of the above conditions are satisfied, the value of the BDOF flag information may be set to true or 1, and if at least one of the above conditions is not satisfied, the value of the BDOF flag information may be set to false or 0.</p><p id="p-0375" num="0339">Here, in deriving the BDOF flag information, the BDOF application conditions listed above are merely exemplary, and various combinations of the conditions of Tables 1 to 34 may be used.</p><p id="p-0376" num="0340">When it is determined to apply the BDOF to the current block based on the BDOF flag information (e.g., when the value of the BDOF flag information is derived as true or 1), the decoding apparatus may derive the prediction samples by applying the BDOF to the current block.</p><p id="p-0377" num="0341">In an embodiment, the decoding apparatus may derive L0 prediction samples based on the L0 prediction using the refined L0 motion vector, and may derive L1 prediction samples based on the L1 prediction using the refined L1 motion vector. In this case, the decoding apparatus may finally derive the (refined) prediction samples based on a gradient for the L0 prediction samples and a gradient for the L1 prediction samples.</p><p id="p-0378" num="0342">The decoding apparatus may generate reconstructed samples for the current block based on the prediction samples (S<b>1140</b>).</p><p id="p-0379" num="0343">In an embodiment, the decoding apparatus may directly use the prediction samples as the reconstructed samples according to the prediction mode, or may generate the reconstructed samples by adding the residual samples to the prediction samples.</p><p id="p-0380" num="0344">If the residual sample for the current block exists, the decoding apparatus may receive information on the residual for the current block. The information on the residual may include transform coefficients about the residual samples. The decoding apparatus may derive the residual samples (or residual sample array) for the current block based on the residual information. The decoding apparatus may generate the reconstructed samples based on the prediction samples and the residual samples, and may derive a reconstructed block or a reconstructed picture based on the reconstructed samples.</p><p id="p-0381" num="0345">In the aforementioned embodiments, although the methods have been described based on the flowcharts in the form of a series of steps or units, the embodiments of this document are not limited to the order of the steps, and some of the steps may be performed in a different order from that of other steps or may be performed simultaneous to other steps. Furthermore, those skilled in the art will understand that the steps shown in the flowchart are not exclusive and the steps may include additional steps or that one or more steps in the flowchart may be deleted without affecting the scope of rights of this document.</p><p id="p-0382" num="0346">The aforementioned method according to this document may be implemented in a software form, and the encoding apparatus and/or the decoding apparatus according to this document may be included in an apparatus for performing image processing, for example, TV, a computer, a smartphone, a set-top box or a display device.</p><p id="p-0383" num="0347">In this document, when embodiments are implemented in a software form, the aforementioned method be implemented as a module (process, function, etc.) for performing the aforementioned function. The module may be stored in the memory and executed by the processor. The memory may be placed inside or outside the processor and connected to the processor by various well-known means. The processor may include application-specific integrated circuits (ASICs), other chipsets, logic circuits and/or data processing devices. The memory may include read-only memory (ROM), random access memory (RAM), flash memory, memory cards, storage media and/or other storage devices. That is, the embodiments described in this document may be implemented and performed on a processor, a micro processor, a controller or a chip. For example, the function units illustrated in the drawings may be implemented and performed on a computer, a processor, a micro processor, a controller or a chip. In this case, information (e.g., information on instructions) or an algorithm for such implementation may be stored in a digital storage medium.</p><p id="p-0384" num="0348">Furthermore, the decoding apparatus and the encoding apparatus to which this document is applied may be included in a multimedia broadcasting transmission and reception device, a mobile communication terminal, a home cinema video device, a digital cinema video device, a camera for monitoring, a video dialogue device, a real-time communication device such as video communication, a mobile streaming device, a storage medium, a camcorder, a video on-demand (VoD) service provision device, an over the top (OTT) video device, an Internet streaming service provision device, a three-dimensional (3D) video device, a virtual reality (VR) device, an augmented reality (AR) device, a video telephony device, transportation means terminal (e.g., a vehicle (including autonomous vehicle) terminal, an aircraft terminal, and a vessel terminal), and a medical video device, and may be used to process a video signal or a data signal. For example, the over the top (OTT) video device may include a game console, a Blueray player, Internet access TV, a home theater system, a smartphone, a tablet PC, and a digital video recorder (DVR).</p><p id="p-0385" num="0349">Furthermore, the processing method to which this document is applied may be produced in the form of a program executed by a computer, and may be stored in a computer-readable recording medium. Multimedia data having a data structure according to this document may also be stored in a computer-readable recording medium. The computer-readable recording medium includes all types of storage devices in which computer-readable data is stored. The computer-readable recording medium may include Blueray disk (BD), a universal serial bus (USB), a ROM, a PROM, an EPROM, an EEPROM, a RAM, a CD-ROM, a magnetic tape, a floppy disk, and an optical data storage device, for example. Furthermore, the computer-readable recording medium includes media implemented in the form of carriers (e.g., transmission through the Internet). Furthermore, a bit stream generated using an encoding method may be stored in a computer-readable recording medium or may be transmitted over wired and wireless communication networks.</p><p id="p-0386" num="0350">Furthermore, an embodiment of this document may be implemented as a computer program product using program code. The program code may be performed by a computer according to an embodiment of this document. The program code may be stored on a carrier readable by a computer.</p><p id="p-0387" num="0351"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates an example of a content streaming system to which embodiments disclosed in this document may be applied.</p><p id="p-0388" num="0352">Referring to <figref idref="DRAWINGS">FIG. <b>12</b></figref>, the content streaming system to which the embodiments of the present document are applied may basically include an encoding server, a streaming server, a web server, a media storage, a user device, and a multimedia input device.</p><p id="p-0389" num="0353">The encoding server compresses content input from multimedia input devices such as a smartphone, a camera, a camcorder, etc. into digital data to generate a bitstream and transmit the bitstream to the streaming server. As another example, when the multimedia input devices such as smartphones, cameras, camcorders, etc. directly generate a bitstream, the encoding server may be omitted.</p><p id="p-0390" num="0354">The bitstream may be generated by an encoding method or a bitstream generating method to which the embodiment(s) of the present document is applied, and the streaming server may temporarily store the bitstream in the process of transmitting or receiving the bitstream.</p><p id="p-0391" num="0355">The streaming server transmits the multimedia data to the user device based on a user's request through the web server, and the web server serves as a medium for informing the user of a service. When the user requests a desired service from the web server, the web server delivers it to a streaming server, and the streaming server transmits multimedia data to the user. In this case, the content streaming system may include a separate control server. In this case, the control server serves to control a command/response between devices in the content streaming system.</p><p id="p-0392" num="0356">The streaming server may receive content from a media storage and/or an encoding server. For example, when the content is received from the encoding server, the content may be received in real time. In this case, in order to provide a smooth streaming service, the streaming server may store the bitstream for a predetermined time.</p><p id="p-0393" num="0357">Examples of the user device may include a mobile phone, a smartphone, a laptop computer, a digital broadcasting terminal, a personal digital assistant (PDA), a portable multimedia player (PMP), navigation, a slate PC, tablet PCs, ultrabooks, wearable devices (ex. smartwatches, smart glasses, head mounted displays), digital TVs, desktops computer, digital signage, and the like.</p><p id="p-0394" num="0358">Each server in the content streaming system may be operated as a distributed server, in which case data received from each server may be distributed.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230007296A1-20230105-M00001.NB"><img id="EMI-M00001" he="8.81mm" wi="76.20mm" file="US20230007296A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. An image decoding method performed by a decoding apparatus, the image decoding method comprising:<claim-text>obtaining image information including prediction mode information and residual information from a bitstream;</claim-text><claim-text>deriving an L0 motion vector and an L1 motion vector of a current block based on the prediction mode information;</claim-text><claim-text>deriving a refined L0 motion vector and a refined L1 motion vector based on whether a decoder-side motion vector refinement (DMVR) is applied to the current block;</claim-text><claim-text>deriving prediction samples for the current block based on L0 prediction using the refined L0 motion vector and L1 prediction using the refined L1 motion vector;</claim-text><claim-text>deriving residual samples for the current block based on the residual information; and</claim-text><claim-text>generating reconstructed samples for the current block based on the prediction samples and the residual samples,</claim-text><claim-text>wherein the image information includes bi-prediction weight index information, luma weight L0 flag information and luma weight L1 flag information,</claim-text><claim-text>wherein whether the DMVR is applied to the current block is determined based on a value of bi-prediction weight index information being equal to 0, and a value of the luma weight L0 flag information and a value of the luma weight L1 flag information being both equal to 0,</claim-text><claim-text>wherein the prediction samples for the current block are derived based on whether a bi-directional optical flow (BDOF) is applied to the current block, and</claim-text><claim-text>wherein whether the BDOF is applied to the current block is determined based on the value of the bi-prediction weight index information being equal to 0, and the value of the luma weight L0 flag information and the value of the luma weight L1 flag information being both equal to 0.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The image decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising deriving DMVR flag information related to whether to apply the DMVR,<claim-text>wherein the DMVR flag information related to applying the DMVR is derived as 1 or true,</claim-text><claim-text>wherein the DMVR flag information related to not applying the DMVR is derived as 0 or false, and</claim-text><claim-text>wherein a value of the DMVR flag information is derived as 1 or true based on the value of the luma weight L0 flag information and the value of the luma weight L1 flag information being both equal to 0.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The image decoding method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the value of the DMVR flag information is derived as 1 or true based on the value of the bi-prediction weight index information being equal to 0.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The image decoding method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein a &#xbd; weight is applied to each of the L0 prediction and the L1 prediction based on the value of the bi-prediction weight index information being equal to 0.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The image decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising deriving BDOF flag information related to whether to apply the BDOF,<claim-text>wherein the BDOF flag information related to applying the BDOF is derived as 1 or true,</claim-text><claim-text>wherein the BDOF flag information related to not applying the BDOF is derived as 0 or false, and</claim-text><claim-text>wherein a value of the BDOF flag information is derived as 1 or true based on the value of the luma weight L0 flag information and the value of the luma weight L1 flag information being both equal to 0.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The image decoding method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the value of the BDOF flag information is derived as 1 or true based on the value of the bi-prediction weight index information being equal to 0.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The image decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the L0 motion vector and the L1 motion vector are derived based on a motion vector of a neighboring block indicated by merge index in a merge candidate list derived based on neighboring blocks of the current block, based on a case where a merge mode is applied to the current block, and<claim-text>wherein the refined L0 motion vector and the refined L1 motion vector are derived based on a sample position corresponding to a minimum sum of absolute differences (SAD) by calculating the minimum SAD based on reference samples in an L0 reference picture derived based on the L0 motion vector and reference samples in an L1 reference picture derived based on the L1 motion vector.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The image decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein in the deriving of the prediction samples for the current block, based on a case where the BDOF is applied to the current block, L0 prediction samples are derived based on the L0 prediction using the refined L0 motion vector and L1 prediction samples are derived based on the L1 prediction using the refined L1 motion vector, and<claim-text>wherein the prediction samples are derived based on a gradient for the L0 prediction samples and a gradient for the L1 prediction samples.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The image decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein whether the DMVR is applied to the current block is determined further based on a case where a first picture order count (POC) difference between a current picture and an L0 reference picture and a second POC difference between the current picture and an L1 reference picture are same.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. An image encoding method performed by an encoding apparatus, the image encoding method comprising:<claim-text>deriving an L0 motion vector and an L1 motion vector of a current block;</claim-text><claim-text>deriving a refined L0 motion vector and a refined L1 motion vector based on whether a decoder-side motion vector refinement (DMVR) is applied to the current block;</claim-text><claim-text>deriving prediction samples for the current block based on L0 prediction using the refined L0 motion vector and L1 prediction using the refined L1 motion vector;</claim-text><claim-text>deriving residual samples based on the prediction samples; and</claim-text><claim-text>encoding image information including information on the residual samples,</claim-text><claim-text>wherein whether the DMVR is applied to the current block is determined based on a value of bi-prediction weight index information being equal to 0, and a value of luma weight L0 flag information and a value of luma weight L1 flag information being both equal to 0,</claim-text><claim-text>wherein the prediction samples for the current block are derived based on whether a bi-directional optical flow (BDOF) is applied to the current block, and</claim-text><claim-text>wherein whether the BDOF is applied to the current block is determined based on the value of the bi-prediction weight index information being equal to 0, and the value of the luma weight L0 flag information and the value of the luma weight L1 flag information being both equal to 0.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The image encoding method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising deriving DMVR flag information related to whether to apply the DMVR,<claim-text>wherein the DMVR flag information related to applying the DMVR is derived as 1 or true,</claim-text><claim-text>wherein the DMVR flag information related to not applying the DMVR is derived as 0 or false, and</claim-text><claim-text>wherein a value of the DMVR flag information is derived as 1 or true based on the value of the luma weight L0 flag information and the value of the luma weight L1 flag information being both equal to 0.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The image encoding method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the value of the DMVR flag information is derived as 1 or true based on the value of the bi-prediction weight index information being equal to 0.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The image encoding method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein a &#xbd; weight is applied to each of the L0 prediction and the L1 prediction based on the value of the bi-prediction weight index information being equal to 0.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The image encoding method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising deriving BDOF flag information related to whether to apply the BDOF,<claim-text>wherein the BDOF flag information related to applying the BDOF is derived as 1 or true,</claim-text><claim-text>wherein the BDOF flag information related to not applying the BDOF is derived as 0 or false, and</claim-text><claim-text>wherein a value of the BDOF flag information is derived as 1 or true based on the value of the luma weight L0 flag information and the value of the luma weight L1 flag information being both equal to 0.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The image encoding method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the value of the BDOF flag information is derived as 1 or true based on the value of the bi-prediction weight index information being equal to 0.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The image encoding method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein whether the DMVR is applied to the current block is determined further based on a case where a first picture order count (POC) difference between a current picture and an L0 reference picture and a second POC difference between the current picture and an L1 reference picture are same.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A non-transitory computer-readable storage medium storing a bitstream generated by a method, the method comprising:<claim-text>deriving an L0 motion vector and an L1 motion vector of a current block;</claim-text><claim-text>deriving a refined L0 motion vector and a refined L1 motion vector based on whether a decoder-side motion vector refinement (DMVR) is applied to the current block;</claim-text><claim-text>deriving prediction samples for the current block based on L0 prediction using the refined L0 motion vector and L1 prediction using the refined L1 motion vector; and</claim-text><claim-text>deriving residual samples based on the prediction samples; and</claim-text><claim-text>encoding image information including information on the residual samples,</claim-text><claim-text>wherein whether the DMVR is applied to the current block is determined based on a value of bi-prediction weight index information being equal to 0, and a value of luma weight L0 flag information and a value of luma weight L1 flag information being both equal to 0,</claim-text><claim-text>wherein the prediction samples for the current block are derived based on whether a bi-directional optical flow (BDOF) is applied to the current block, and</claim-text><claim-text>wherein whether the BDOF is applied to the current block is determined based on the value of the bi-prediction weight index information being equal to 0, and the value of the luma weight L0 flag information and the value of the luma weight L1 flag information being both equal to 0.</claim-text></claim-text></claim></claims></us-patent-application>