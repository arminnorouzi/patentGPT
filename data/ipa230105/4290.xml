<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004291A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004291</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17367026</doc-number><date>20210702</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>06</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>064</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>0679</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>0604</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">MANAGING METHOD FOR FLASH STORAGE AND STORAGE SYSTEM</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>SK hynix Inc.</orgname><address><city>Icheon</city><country>KR</country></address></addressbook><residence><country>KR</country></residence></us-applicant><us-applicant sequence="01" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>WISCONSIN ALUMNI RESEARCH FOUNDATION</orgname><address><city>MADISON</city><state>WI</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>KIM</last-name><first-name>Younghyun</first-name><address><city>MADISON</city><state>WI</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>LEE</last-name><first-name>Yongwoo</first-name><address><city>MADISON</city><state>WI</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>PARK</last-name><first-name>Jaehyun</first-name><address><city>MADISON</city><state>WI</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>RYU</last-name><first-name>Junhee</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A managing method for a flash storage includes: sorting a plurality of blocks within the flash storage into precise blocks and imprecise blocks; and managing the sorted blocks as a plurality of free block pools. The management includes performing garbage collection and wear leveling, and the wear leveling is performed based on CEW (Cumulative Effective Wearing), the CEW indicating cumulative cell damage induced by performing a plurality of operations on a specific block. A storage system includes a memory array; and a memory controller sorting a plurality of blocks of the memory array based on error rates, applying erase voltages corresponding to the error rates, respectively, when data stored in the blocks are erased, controlling each of the erase voltages to have a value scaled down from a standard voltage, and performing incremental step pulse programming on one or more of the blocks.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="92.96mm" wi="147.83mm" file="US20230004291A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="174.75mm" wi="138.09mm" file="US20230004291A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="122.00mm" wi="149.86mm" file="US20230004291A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="108.03mm" wi="161.12mm" file="US20230004291A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="209.38mm" wi="158.83mm" file="US20230004291A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="125.39mm" wi="153.84mm" file="US20230004291A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="139.78mm" wi="157.65mm" file="US20230004291A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="211.16mm" wi="159.09mm" file="US20230004291A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="114.55mm" wi="154.18mm" file="US20230004291A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><heading id="h-0002" level="1">1. Field</heading><p id="p-0002" num="0001">Embodiments relate to a method for effectively managing a flash storage and a flash storage system including the same.</p><heading id="h-0003" level="1">2. Discussion of the Related Art</heading><p id="p-0003" num="0002">Recently, storage technology for a memory (e.g., a flash memory) has been developed to store multi-bit binary information in one memory cell. Commercially, a memory cell capable of storing 2-bit binary information therein is referred to as an MLC (Multi Level Cell), and a memory cell capable of storing 3-bit binary information therein is referred to as a TLC (Triple Level Cell). In a broad sense, the MLC may also be used to collectively represent memory cells each capable of storing 2 or more-bit binary information therein. Since a multi-bit flash memory is used as a NAND flash memory, the multi-bit flash memory has a capacity of storing a larger amount of data in the same silicon area. Therefore, an SSD (Solid State Drive) using the multi-bit flash memory has similar performance in price competitiveness to an HDD (Hard Disk Drive), and thus is gradually replacing the HDD. Furthermore, the multi-bit NAND flash memory already has a considerable market share in the field of data storages of personal computing systems or mobile devices.</p><p id="p-0004" num="0003">While a volatile memory such as DRAM performs two kinds of operations such as read and write operations, a flash memory further requires an erase operation. This results from the physical characteristics of flash memory cells. In order to store information in a specific bit, a flash memory needs to perform an erase operation in advance. When an erase operation is not performed in advance, a flash memory may not store binary information. That is, while a write operation in a volatile memory indicates an over-write operation of writing information over information stored therein, a write operation in a flash memory indicates an operation of writing information after erasing information stored at the moment. Hereafter, the write operation in a flash memory is also referred to as programming, and the erase operation in the flash memory is also referred to as erasing. When programming and erasing operations in a flash memory cell are repeated, a tunnel oxide layer of a memory cell illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref> gradually wears due to stress applied by electrons, and thus the insulating performance of the memory cell is reduced. Therefore, the programming performance and the erasing performance of the memory cell are also gradually reduced. For this reason, the endurance of the flash memory is determined by P/E (Program/Erase) cycles in which the flash memory can perform programming/erasing without an error. Conventionally, an SLC (Single Level Cell) has been commercially required to endure approximately 100,000 P/E cycles for the past few decades. However, the recent TLCs can endure only 3,000 P/E cycles or less, and some applications guarantee only 1,000 P/E cycles or less.</p><p id="p-0005" num="0004">When a flash memory cell exceeds the P/E cycle limit, the flash memory cell may contain an error which cannot be corrected even through ECC (Error Correction Code). In this case, the flash memory cell cannot be used any more. Conventional approaches to manage P/E cycles more efficiently include evenly distributing P/E cycle counts among blocks within a flash memory (wear leveling) or reusing bad blocks. Furthermore, a method to introduce a cache to absorb write requests from a system or application program, a method to exploit the locality of data, or a method to avoid a refresh operation of recently written data has also been used. Wear leveling ensures substantially all blocks degrade at an even rate to prevent some blocks from becoming prematurely unusable while others are healthy, thereby extending the lifetime of a flash memory. Reusing bad blocks includes reusing worn-out multi-bit cells as single-bit cells and reusing good pages in worn-out blocks.</p><p id="p-0006" num="0005">The above-described existing techniques may extend the lifetime of a flash memory or a flash storage including a flash memory. However, even if there is a single uncorrectable error in a block, the block may be considered worn-out. Such a problem may be overcome by discarding a bad block or mapping a bad cell of the block to an SLC. In this case, the storage capacity of the flash memory or the flash storage is inevitably reduced. Therefore, the above-described existing techniques may not be suitable for some applications (e.g., video applications) in which the quality of video is allowed to be degraded to a certain degree, because a few errors are allowed in data.</p><p id="p-0007" num="0006">In order to understand the core technical idea of the present disclosure, some background knowledge on video compression may be helpful. The background knowledge will be described with reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0008" num="0007">Video data are so voluminous that compression is a must for efficient storage and transmission. Various video compression algorithms have been proposed for decades, driven by the growing demand for high-resolution videos and enabled by increasing computing power. Most algorithms heavily rely on motion estimation to identify and eliminate redundancy between frames. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, video frames compressed by a well-known MPEG (Motion Picture Experts Group) codec are encoded into either I frames, P frames, or B frames. I frames are intra-coded frames that are treated as still images. The compression of I frames exploits spatial redundancy within each frame, but does not exploit temporal redundancy between frames. Therefore, the compression ratio of I frames is relatively low compared to predictive frames (P and B frames) that exploit temporal redundancy as well. However, since I frames are used as a reference frame for decoding other predictive frames, I frames should periodically appear in the stream to prevent temporal propagation of errors. P frames are predictive-coded frames that only contain the difference from a proceeding I frame or P frame. Because temporally adjacent frames are similar to each other, the difference can be encoded using much smaller data size than the original frames, typically 20% to 70% of the size of an I frame. B frames are bidirectional predictive-coded frames that exploit temporal redundancy more aggressively by referencing both proceeding and following I, P, or B frames. B frames provide an even higher compression ratio, and the size of a B frame is typically only 5% to 40% of that of an I frame. Despite the high compression ratio, however, a video cannot be encoded only into P frames and B frames because the temporal propagation of errors can be stopped only by I frames that are self-contained.</p><p id="p-0009" num="0008">This interframe dependency naturally introduces the unequal importance of encoded frames. <figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates one I frame, two P frames, and six B frames and their dependency due to predictive coding. In <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the I frame is not dependent on any frame because the I frame is a self-contained image. However, all the following P frames and B frames are dependent on this I frame, because they are predictive-coded using the I frame as a reference. Therefore, errors in the I frame will affect not only itself but also all other subsequent frames. On the other hand, no frames are dependent on the B frames in the example of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. The impact of errors is illustrated as a prediction direction in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, i.e., forward precision or backward precision.</p><p id="p-0010" num="0009">The impact of errors in a B frame will be limited to the frame and will not propagate to other frames. In <figref idref="DRAWINGS">FIG. <b>2</b></figref>, errors in frames I<b>1</b>, P<b>2</b>, and B<b>1</b> will affect nine, four and one frames, respectively. The impact is represented by error propagation in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Although described below in detail, embodiments of the present disclosure exploit the frame-level unequal importance to distinguish data, but the technical idea of the present disclosure is not limited only to any specific data type or any specific scheme to evaluate the importance of the data.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0011" num="0010">Various embodiments are directed to a managing method for a flash storage, which can extend the lifetime of a flash storage that sorts blocks of a flash storage according to erase modes, and allocates blocks based on error rates, in order to exploit a flash memory, and a system using the same.</p><p id="p-0012" num="0011">In an embodiment, a managing method for a flash storage, the method comprising: sorting a plurality of blocks within the flash storage into precise blocks and imprecise blocks; and managing the sorted blocks as a plurality of free block pools. The management is performed by a garbage collection and wear leveling, and the wear leveling is performed based on CEW (Cumulative Effective Wearing), the CEW indicating cumulative cell damage induced by performing a plurality of operations on a specific block.</p><p id="p-0013" num="0012">In an embodiment, a storage system comprising: a memory array; and a memory controller configured to: sort a plurality of blocks of the memory array based on error rates; apply erase voltages corresponding to the error rates, respectively, when data stored in the blocks are erased; control each of the erase voltages to have a value scaled down from a standard voltage; and perform incremental step pulse programming on one or more of the blocks.</p><p id="p-0014" num="0013">In accordance with the embodiment of the present disclosure, the managing method may adopt the shallow erase technique and the ISPP technique in order to reduce damage caused by erase, which significantly influences storage in a flash storage including a flash memory (e.g., a NAND flash memory), and to address issues accompanied by the damage, and algorithms corresponding to the shallow erase technique and the ISPP technique are developed to efficiently extend the lifetime of the flash storage using a NAND flash memory. The managing method may reduce cell damage across steps over the lifetime of the flash storage.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a cross-sectional view illustrating a flash memory cell.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates correlations among MPEG frames and error propagation and compression ratios in the MPEG frames.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates shallow erase and ISPP (Incremental Step Pulse Programming) in accordance with an embodiment of the present disclosure.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates block allocation for each erase mode.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates block degradation and effective wearing.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>6</b></figref> schematically illustrates a system in accordance with an embodiment of the present disclosure.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates distributions of threshold voltages.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates allocation of precise blocks and imprecise blocks in a free block pool.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates an example of counter reset.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates block migration in a free block pool and a used block pool.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates selection of a victim block associated with cumulative effective wearing.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0026" num="0025">Hereafter, embodiments of the present disclosure will be described in detail with reference to the accompanying drawings such that various embodiments of the present disclosure can be carried out by those skilled in the art to which the present disclosure pertains. Among reference numerals marked on the respective drawings, like reference numerals represent the same components.</p><p id="p-0027" num="0026">In describing the present disclosure, detailed descriptions for related publicly-known technologies may be omitted in order not to unnecessarily obscure subject matters of the present disclosure.</p><p id="p-0028" num="0027">The terms such as first and second may be used to describe various components, but the components are not limited by the terms, and the terms are used only to distinguish one component from another component.</p><p id="p-0029" num="0028">The terms used in this specification will be briefly described as follows.</p><p id="p-0030" num="0029">&#x2018;Flash storage&#x2019; may refer to a storage including a flash memory among nonvolatile memories.</p><p id="p-0031" num="0030">&#x2018;Memory cell&#x2019; or &#x2018;cell&#x2019; may refer to one unit element capable of storing binary information therein.</p><p id="p-0032" num="0031">&#x2018;Flash translation layer&#x2019; or &#x2018;FTL&#x2019; may refer to middleware for sector-block translation in order to use a block-based flash memory in a sector-based system or application program.</p><p id="p-0033" num="0032">In the present disclosure, an expression &#x2018;deeply&#x2019; in a program operation or erase operation may indicate that a standard voltage or normal voltage which does not cause an error is applied. However, an expression &#x2018;shallowly&#x2019; in a program operation or erase operation may indicate that a weak voltage is applied to such an extent to endure or allow a few errors, in order to reduce damage to a memory cell. &#x2018;Shallow&#x2019; voltage may be used to indicate a voltage lower than &#x2018;deep&#x2019; voltage. Furthermore, it should be noted that various numerical values presented throughout this specification are only used for convenience of description, or used for an experiment or simulation for verifying the effects of the present disclosure, and the technical ideas of the present disclosure are not limited thereto.</p><heading id="h-0007" level="2">Error Tolerance-Aware Block Allocation</heading><p id="p-0034" num="0033">One of aspects of embodiments of the present disclosure relates to a method capable of improving the lifetime of a storage using a flash memory by selectively applying shallow erase to a block having error-tolerant data stored therein. More specifically, a shallow erase technique is adopted to manage blocks having different erase modes. Furthermore, while ISPP (Incremental Step Pulse Programming) is more rapidly and normally performed on a block which has been erased shallowly, data matched with an error tolerance level is allocated to the corresponding block. For example, ISPP may be performed on a first block (e.g., an imprecise block) having been erased shallowly during a first time interval that is shorter than a second time interval during which ISPP is performed on a second block (e.g., a precise block) having been erased deeply. As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref> which comparatively illustrates applying a shallow erase voltage and a deep erase voltage, the interval between voltage distributions of program states by shallow erase and fine-grained ISSP is narrower than the interval between voltage distributions of program states by deep erase. For reference, in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, memory cells each capable of storing 2-bit binary information therein are taken as example for description.</p><p id="p-0035" num="0034">When a first block of a flash memory is deeply erased, the first block is referred to as a precise block, and when a second block of the flash memory is shallowly erased, the second block is referred to as an imprecise block. Since different levels of erase voltages have been used in the respective blocks, the blocks have different error rates. When a write request is received from a system, a controller or application program which controls an operation of the flash memory, a block which meets the error tolerance of data is allocated. Error-intolerant data should be allocated only to a precise block, while error-tolerant data can be allocated to either a precise block or an imprecise block. Using a precise block may be avoided as much as possible since it is more costly in terms of EW (Effective Wearing). Block allocation is performed for each erase mode according to the precision (e.g., an error tolerance level) of each block in a free block pool. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, a first erase mode for a precise block which tolerates no errors (e.g., error tolerance level <b>0</b>) is represented by erase mode <b>0</b>, a second erase mode for an imprecise block with a middle error tolerance level (e.g., error tolerance level <b>1</b>) is represented by erase mode <b>1</b>, and a third erase mode for an imprecise block which tolerates relatively many errors (e.g., error tolerance level <b>2</b>) is represented by erase mode <b>2</b>. <figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates that the deep erase and the shallow erase divided into two steps correspond the erase modes <b>0</b>, <b>1</b> and <b>2</b>, respectively. Although will be described below, a shallow erase voltage lower than a deep erase voltage may be scaled down to an extent in order to perform such an erase method.</p><p id="p-0036" num="0035">Whenever a flash memory cell is erased, a tunnel oxide layer thereof gradually wears. During deep erase and shallow erase, different impacts are applied to the tunnel oxide layer because voltages having different magnitudes are applied during deep erase and shallow erase. In an embodiment, effective wearing (EW) indicates the cell damage that is induced by an erase operation depending on an erase voltage and has a value equal to the erase voltage normalized with a standard erase voltage used in deep erase. When shallow erase and deep erase are represented by EW, the EW of shallow erase may be less than 1 under the supposition that the EW of deep erase is normalized to 1. In consideration of normalization, CEW (Cumulative Effective Wearing) may be calculated as follows. The CEW may indicate cumulative cell damage induced by performing a plurality of operations (e.g., a plurality of erase operations) on a specific block. For example, if a block is deep-erased two times and shallow-erased five times with an EW of 0.5, the CEW of the block is 5.5 (=2&#xd7;1+5&#xd7;0.5). That is, deep erase and shallow erase have different weights (e.g., 1 and 0.5), and shallow erases may be divided into a plurality of steps. <figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates examples in which EWs given to blocks for the respective erase modes <b>0</b>, <b>1</b>, and <b>2</b> are set to 1, 0.61, and 0.51, respectively.</p><heading id="h-0008" level="2">Erase Mode-Aware Garbage Collection and Wear Leveling</heading><p id="p-0037" num="0036">Hereafter, erase mode-aware garbage collection and wear leveling, which are other features of embodiments of the present disclosure, will be described. In embodiments of the present disclosure, garbage collection and wear leveling schemes are designed to take into account multiple erase modes and different cell damages induced by the erase modes. The schemes jointly manage FBPs (Free Block Pools). That is, the schemes are operated to maintain the required numbers (or target numbers) of precise blocks and imprecise blocks while ensuring even block wearing. In particular, block wearing is evaluated in terms of CEW rather than P/E cycle counts. <figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates the overview of an AxFTL (Approximate Flash Translation Layer) with functional blocks in accordance with an embodiment of the present disclosure. Suppose that all write requests each are marked with an error tolerance determined by a controller or application. The AxFTL in accordance with the embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, manages multiples FBPs, one for each error tolerance level, and selects a free block from one of the FBPs which meets the error tolerance requirement. When a block is erased, the erase mode is determined based on the current size of the FPBs and the recent request history to minimize extra erase. Garbage collection and wear leveling are performed based on this determination as well as the CEW of the blocks.</p><p id="p-0038" num="0037">The system <b>600</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref> includes a memory controller <b>610</b>, a file system <b>630</b>, and a memory array <b>650</b> (e.g., NAND flash memory array). The memory controller <b>610</b> may refer to a hardware controller as well as firmware and software controller. In an embodiment, the memory controller <b>610</b> may include an internal memory (not shown) storing the AxFTL and a core (not shown) executing the AxFTL. For example, the core may include a micro control unit (MCU) or a central processing unit (CPU). In another embodiment, the AxFTL may be loaded on a dedicated memory (not shown) provided within the core, rather than the internal memory. The AxFTL according to an embodiment of the present disclosure may be implemented as an application program, and the memory controller <b>610</b> may operate using the application program. In an embodiment, the memory controller <b>610</b> may include the application program. In another embodiment, the file system <b>630</b> may include the application program.</p><heading id="h-0009" level="2">Erase Voltage Scaling and Error Modeling</heading><p id="p-0039" num="0038">Hereafter, a method in accordance with an embodiment of the present disclosure, which models the scaling of erase voltage and a long-term impact to data retention error, will be described. Voltage scaling may be performed for shallow erase. Since voltage for shallow erase will be lower than voltage for deep erase, the magnitude of the voltage for shallow erase is scaled to a value of 0 to 1, when the voltage for deep erase is normalized to 1. It may be assumed that the threshold voltage distributions of cell data stored at multi levels statistically follow a Gaussian distribution as illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, even though the threshold voltage distributions are not perfectly symmetric. <figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates that an error occurs because some tails of the threshold voltage distributions of states S<sub>1 </sub>to S<sub>3 </sub>overlap each other. It should be noted that <figref idref="DRAWINGS">FIG. <b>7</b></figref> is exaggerated for clear illustration of errors. The voltages marked in <figref idref="DRAWINGS">FIG. <b>7</b></figref> represent reference voltages for a read operation and a voltage for verifying erase. The scaling is subjected to the following process. First, the probability density function of the threshold voltages is calculated. The probability density function is given by:</p><p id="p-0040" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>P</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mi>v</mi>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mrow>      <msubsup>       <mo>&#x2211;</mo>       <mrow>        <mi>k</mi>        <mo>=</mo>        <mn>1</mn>       </mrow>       <mrow>        <mi>K</mi>        <mo>-</mo>        <mn>1</mn>       </mrow>      </msubsup>      <mrow>       <mrow>        <msub>         <mi>P</mi>         <mi>S</mi>        </msub>        <mo>(</mo>        <msub>         <mi>S</mi>         <mi>k</mi>        </msub>        <mo>)</mo>       </mrow>       <mo>&#x2062;</mo>       <mfrac>        <mn>1</mn>        <mrow>         <msub>          <mi>&#x3c3;</mi>          <mi>k</mi>         </msub>         <mo>&#x2062;</mo>         <msqrt>          <mrow>           <mn>2</mn>           <mo>&#x2062;</mo>           <mi>&#x3c0;</mi>          </mrow>         </msqrt>        </mrow>       </mfrac>       <mo>&#x2062;</mo>       <mrow>        <mrow>         <mi>exp</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mfrac>          <mrow>           <mo>-</mo>           <msup>            <mrow>             <mo>(</mo>             <mrow>              <mi>v</mi>              <mo>-</mo>              <msub>               <mi>&#x3bc;</mi>               <mi>k</mi>              </msub>             </mrow>             <mo>)</mo>            </mrow>            <mn>2</mn>           </msup>          </mrow>          <mrow>           <mn>2</mn>           <mo>&#x2062;</mo>           <msubsup>            <mi>&#x3c3;</mi>            <mi>k</mi>            <mn>2</mn>           </msubsup>          </mrow>         </mfrac>         <mo>)</mo>        </mrow>        <mo>.</mo>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mi>Equatoion</mi>     <mo>&#x2062;</mo>     <mtext>   </mtext>     <mn>1</mn>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0041" num="0039">In Equation 1, K is the number of states, P<sub>S</sub>(S<sub>K</sub>) is the probability of state S<sub>K</sub>, and &#x3bc;<sub>k </sub>and &#x3c3;<sub>k </sub>are the mean and the standard deviation of state S<sub>K</sub>.</p><p id="p-0042" num="0040">Second, an RBER (Raw Bit Error Rate) is calculated from the calculated probability density function. The error rate indicates that the tails of the probability density functions, which lie outside the reference voltage boundaries, overlap each other in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, and RBERp due to program error may be calculated from the probability density function of threshold voltages as expressed by Equation 2 below:</p><p id="p-0043" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <msub>      <mi>RBER</mi>      <mi>p</mi>     </msub>     <mo>=</mo>     <mrow>      <msubsup>       <mo>&#x2211;</mo>       <mrow>        <mi>k</mi>        <mo>=</mo>        <mn>1</mn>       </mrow>       <mrow>        <mi>K</mi>        <mo>-</mo>        <mn>1</mn>       </mrow>      </msubsup>      <mrow>       <mrow>        <mo>(</mo>        <mrow>         <mrow>          <msubsup>           <mo>&#x222b;</mo>           <mrow>            <mo>-</mo>            <mi>&#x221e;</mi>           </mrow>           <msubsup>            <mi>V</mi>            <msub>             <mi>S</mi>             <mi>k</mi>            </msub>            <mi>read</mi>           </msubsup>          </msubsup>          <mrow>           <mrow>            <msub>             <mi>P</mi>             <mi>k</mi>            </msub>            <mo>(</mo>            <mi>v</mi>            <mo>)</mo>           </mrow>           <mo>&#x2062;</mo>           <mi>dv</mi>          </mrow>         </mrow>         <mo>+</mo>         <mrow>          <msubsup>           <mo>&#x222b;</mo>           <msubsup>            <mi>V</mi>            <msub>             <mi>S</mi>             <mrow>              <mi>k</mi>              <mo>+</mo>              <mn>1</mn>             </mrow>            </msub>            <mi>read</mi>           </msubsup>           <mi>&#x221e;</mi>          </msubsup>          <mrow>           <mrow>            <msub>             <mi>P</mi>             <mi>k</mi>            </msub>            <mo>(</mo>            <mi>v</mi>            <mo>)</mo>           </mrow>           <mo>&#x2062;</mo>           <mi>dv</mi>          </mrow>         </mrow>        </mrow>        <mo>)</mo>       </mrow>       <mo>.</mo>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mi>Equation</mi>     <mo>&#x2062;</mo>     <mtext>   </mtext>     <mn>2</mn>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0044" num="0041">Third, when data is retained for a long time, charges stored in the floating gate of a memory cell gradually leak to increase program errors. Thus, this needs to be considered. It is natural that an error occurs due to data retention. The retention error is initially 0, and gradually increases over time. That is, the retention error becomes a function of time. Typically, retention error dominates program error by order of magnitude typically by up to 450 times after the maximum retention time of one year, and the RBER increases approximately 450 times. Specifically, although the retention error is initially zero and gradually increases over time, the worst-case retention error that is about 450 times as great as RBERp may be assumed at all times for conservative error estimation. Thus, the RBER that is the sum of RBERp and the worst-case retention error may be expressed as Equation 3 below:</p><p id="p-0045" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>RBER&#x2248;450&#xb7;RBERp &#x2003;&#x2003;Equation 3.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0046" num="0042">Fourth, as a result of shallow erase that applies a low erase voltage, the verify voltage for verifying erase is shifted to the right by Equation 4 below:</p><p id="p-0047" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>&#x394;<i>W</i><sub>v</sub><sub><sub2>th</sub2></sub>=&#x3b1;<sub>c</sub><i>&#xb7;V</i><sub>nom</sub><sup>erase</sup>&#xb7;(1<i>&#x2212;rv</i><sub>e</sub>) &#x2003;&#x2003;Equation 4.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0048" num="0043">In Equation 4, V<sub>nom</sub><sup>erase </sup>is the nominal erase voltage, rv<sub>e </sub>is the erase voltage scaling factor between 0 and 1, and &#x3b1;<sub>c </sub>is a scaling parameter required when the shifted value is numerically scaled. Therefore, the distribution centers &#x3bc;<sub>k </sub>of all the threshold voltages v<sub>th </sub>and the reference voltages V<sub>S</sub><sub><sub2>k</sub2></sub><sup>read </sup>should be shifted to the right accordingly to maximize the margins between adjacent states. The shifted distribution centers and the shifted reference voltages are represented by &#x3bc;<sub>k</sub>&#x2032; and V<sub>S</sub><sub><sub2>k</sub2></sub><sup>read</sup>&#x2032;, respectively. Fifth, the distances between the distribution centers &#x3bc;<sub>k </sub>and the reference voltages V<sub>S</sub><sub><sub2>k</sub2></sub><sup>read </sup>are scaled by the same scaling factor rv<sub>e</sub>, in order to set the new distribution center as Equation 5 below:</p><p id="p-0049" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>&#x3bc;<sub>k</sub>&#x2032;=&#x3bc;<sub>k</sub>+(<i>V</i><sub>S</sub><sub><sub2>k</sub2></sub><sup>read</sup>&#x2212;&#x3bc;<sub>k</sub>)&#xb7;<i>rv</i><sub>e </sub>&#x2003;&#x2003;Equation 5.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0050" num="0044">On the other hand, the distribution widths of the threshold voltages remain unchanged since the same ISPP step voltage V<sub>p </sub>is used, and the width of the threshold voltage is proportional to V<sub>p</sub>. The reduced distance between reference voltages and the unchanged width of the threshold voltage result in a higher RBER. Therefore, V<sub>S</sub><sub><sub2>k</sub2></sub><sup>read </sup>may be numerically optimized from Equations 1 and 2 with new &#x3bc;<sub>k</sub>&#x2032; to minimize the RBER.</p><p id="p-0051" num="0045">Sixth, in order to promote convenience when applying the contents of the present disclosure, the RBER is mapped or inversely mapped to UBER (Uncorrectable Bit Error Rate) as expressed by Equation 6 below:</p><p id="p-0052" num="0000"><maths id="MATH-US-00003" num="00003"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mi>UBER</mi>     <mo>=</mo>     <mrow>      <mfrac>       <mrow>        <msubsup>         <mo>&#x2211;</mo>         <mrow>          <mi>i</mi>          <mo>=</mo>          <mrow>           <mi>t</mi>           <mo>+</mo>           <mn>1</mn>          </mrow>         </mrow>         <mi>i</mi>        </msubsup>        <mrow>         <mrow>          <mo>(</mo>          <mtable>           <mtr>            <mtd>             <mi>i</mi>            </mtd>           </mtr>           <mtr>            <mtd>             <mi>j</mi>            </mtd>           </mtr>          </mtable>          <mo>)</mo>         </mrow>         <mo>&#xb7;</mo>         <msup>          <mi>RBER</mi>          <mi>j</mi>         </msup>         <mo>&#xb7;</mo>         <msup>          <mrow>           <mo>(</mo>           <mrow>            <mn>1</mn>            <mo>-</mo>            <mi>RBER</mi>           </mrow>           <mo>)</mo>          </mrow>          <mrow>           <mi>l</mi>           <mo>-</mo>           <mi>j</mi>          </mrow>         </msup>        </mrow>       </mrow>       <mi>l</mi>      </mfrac>      <mo>.</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mi>Equation</mi>     <mo>&#x2062;</mo>     <mtext>   </mtext>     <mn>6</mn>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0053" num="0046">In Equation 6, l is the codeword length, and t is the error correction capability of the ECC. The above-described AxFTL model is not only used to determine the scaling factor rv<sub>e</sub>, but also used to evaluate the effect of embodiments of the present disclosure.</p><heading id="h-0010" level="2">Specific Example of Error Tolerance-Aware Block Allocation</heading><p id="p-0054" num="0047">To take advantage of varying error tolerance of data, the AxFTL in accordance with an embodiment of the present disclosure performs error tolerance-aware block allocation that maps a free block to a write request based on the error tolerance. The AxFTL in accordance with an embodiment maintains M free block pools (FBPs), FBP<sub>0 </sub>through FBP<sub>M&#x2212;1</sub>, grouped by their RBER. Each FBP is a pool of free blocks that are erased by one of M erase modes, resulting in substantially the same RBER as modeled in the above descriptions. Specifically, for m=0, 1, . . . , M&#x2212;1, FPB<sub>m </sub>is a pool of free blocks with a RBER of RBER<sub>blk </sub>under a condition of (RBER<sub>m</sub>&#x3c;RBER<sub>blk</sub>&#x2264;RBER<sub>m+1</sub>). Here, RBER<sub>0</sub>&#x3c;RBER<sub>1</sub>&#x3c;. . . &#x3c;RBER<sub>M </sub>are the preset error tolerance boundaries. Among them, FBP<sub>0 </sub>is the pool of precise free blocks with virtually zero RBER. That is, FBP<sub>0 </sub>is bounded by RBER<sub>0</sub>=0 and very small RBER<b>1</b>. <figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates the architectures of FBPs which are divided by the RBER according to such a principle.</p><p id="p-0055" num="0048">A write request's UBER tolerance is first converted into the corresponding RBER tolerance, denoted by RBER<sub>app</sub>, based on Equation 6. When a write request with a RBER tolerance of RBER<sub>m</sub>&#x3c;RBER<sub>app</sub>&#x2264;RBER<sub>m+1 </sub>is received, this write request is defined as &#x2018;a write request of Mode m&#x2019; that demands a free block of erase mode m. To the write request of Mode m, a free block is allocated based on the following priorities.</p><p id="p-0056" num="0049">1) If N(FBP<sub>m</sub>)&#x3e;0, where N(FBP<sub>m</sub>) is the number of free blocks in FBP<sub>m</sub>, a free block is allocated from FBP<sub>m</sub>.</p><p id="p-0057" num="0050">If N(FBP<sub>m</sub>)&#x2264;N<sub>min </sub>after allocation, where N<sub>min </sub>is the minimum number of free blocks for garbage collection, garbage collection is invoked for FBP<sub>m</sub>.</p><p id="p-0058" num="0051">2) If N(FBP<sub>m</sub>)=0, a free block from the next available highest FBP is allocated, and garbage collection is invoked for FBP<sub>m</sub>.</p><p id="p-0059" num="0052">3) If N(FBP<sub>i</sub>)=0 for all 0&#x2264;i&#x2264;m, i.e., if there exists no free block that meets the error tolerance requirement, garbage collection is invoked to replenish FBP<sub>m </sub>with a free block, which is then allocated to the data.</p><p id="p-0060" num="0053">The selection of a block within an FBP can be done by any conventional free block selection criteria. In an embodiment, each FBP keeps its free blocks sorted by CEW, and the one with the lowest CEW located at the head is selected.</p><p id="p-0061" num="0054">The above-mentioned priority ensures that the most error-prone free block is preferred as long as it does not violate the application's error tolerance, which is the least costly in terms of storage lifetime. &#x2018;Erase-on-demand&#x2019; is avoided whenever possible to minimize the performance degradation caused by maintaining multiple FBPs.</p><heading id="h-0011" level="2">Hot and Cold Mode Prediction</heading><p id="p-0062" num="0055">To facilitate the preferred block allocation and avoid the non-preferred block allocation described above, it is desirable to maintain the size of the FBPs so that none of them become prematurely depleted before the storage is full. The AxFTL in accordance with an embodiment of the present disclosure proactively manages the number of free blocks in the FBPs based on the recent request history and the number of remaining free blocks in each FBP. Whenever a block is being erased, the most demanded and the least demanded erase modes are determined. The sufficiency and the deficiency of free blocks in each mode are measured by the ratio between the number of recent write requests and the number of remaining free blocks. Specifically, for Mode m, the ratio is defined as Equation 7 below:</p><p id="p-0063" num="0000"><maths id="MATH-US-00004" num="00004"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <msub>      <mi>R</mi>      <mi>m</mi>     </msub>     <mo>=</mo>     <mrow>      <mfrac>       <msub>        <mi>W</mi>        <mi>m</mi>       </msub>       <mrow>        <mrow>         <mi>N</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <msub>          <mi>FBP</mi>          <mi>M</mi>         </msub>         <mo>)</mo>        </mrow>        <mo>-</mo>        <msub>         <mi>N</mi>         <mi>min</mi>        </msub>       </mrow>      </mfrac>      <mo>.</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mi>Equation</mi>     <mo>&#x2062;</mo>     <mtext>   </mtext>     <mn>7</mn>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0064" num="0056">In Equation 7, W<sub>m </sub>is the number of recent write requests of Mode m, and N<sub>min </sub>is the minimum number of free blocks for garbage collection.</p><p id="p-0065" num="0057">The hot mode, m<sub>hot</sub>, and the cold mode, m<sub>cold</sub>, are the modes that are most demanded and least demanded, respectively, which are defined as Equation 8 below:</p><p id="p-0066" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>m</i><sub>hot</sub>=arg<sub>m </sub>max <i>R</i><sub>m</sub><i>, m</i><sub>cold</sub>=arg<sub>m </sub>min <i>R</i><sub>m </sub>&#x2003;&#x2003;Equation 8.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0067" num="0058">In case that the above-described ratios (e.g., R<sub>0 </sub>to R<sub>M&#x2212;1</sub>) are equal to one another, the hot and cold modes are selected based on the size of FBPs, which is another indirect measure of demand for write request modes. During garbage collection and wear leveling, which will be described below, m<sub>hot </sub>and m<sub>cold </sub>are used to determine which erase modes should be used and how the free blocks should move among FBPs.</p><p id="p-0068" num="0059">To obtain W<sub>m </sub>efficiently, the number of write requests of Mode m is counted until the sum of the counters reaches W<sub>max</sub>. When the sum of the counters reaches W<sub>max</sub>, the counters are reset, and the counter values are used as W<sub>m </sub>until the next counter reset. <figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates how m<sub>hot </sub>and m<sub>cold </sub>are selected in an example where M=3, W<sub>max</sub>=100, and N<sub>min</sub>=0. In <figref idref="DRAWINGS">FIG. <b>9</b></figref>, at time t<sub>0</sub>, three counters are reset. Between t<sub>0 </sub>and t<sub>1</sub>, 100 writes requests are received, including 20, 50, and 30 requests in Modes <b>0</b>, <b>1</b>, and <b>2</b>, respectively, i.e., W<sub>0</sub>=20, W<sub>1</sub>=50, and W<sub>2</sub>=30. Since W<sub>0</sub>+W<sub>1</sub>+W<sub>2</sub>=W<sub>max</sub>, the counters are reset at t<sub>2</sub>, and these values are used until the next counter reset. An erase occurs at t<sub>2 </sub>before the next count reset, at which the size of three FBPs are 100, 200, and 100, respectively. R<sub>0</sub>, R<sub>1</sub>, and R<sub>2 </sub>are calculated as in Equation 7. As a result, the most demanded write mode is Mode <b>2</b> (i.e., m<sub>hot</sub>=2), and the least demanded write request mode is Mode <b>0</b> (i.e., m<sub>cold</sub>=0).</p><heading id="h-0012" level="2">Erase Mode-Aware Garbage Collection</heading><p id="p-0069" num="0060">Garbage collection is invoked to replenish an FBP with a new free block when the number of available free blocks in the FBP falls below a certain threshold. Unlike in conventional FTLs, garbage collection in the AxFTL in accordance with an embodiment of the present disclosure involves the selection of a victim mode in addition to the selection of a victim block because garbage collection is one mechanism to address the possible imbalance between the demand and supply of free blocks in each mode. Specifically, as a result of garbage collection, a block in a less demanded mode should be freed and moved to the most demanded mode.</p><p id="p-0070" num="0061">According to an embodiment of the present disclosure, Algorithm 1 in Table 1 shows the detailed procedure of the erase mode-aware garbage collection. This procedure is invoked when N(FBP<sub>m</sub>)&#x3c;N<sub>min </sub>for any FBP<sub>m </sub>due to data allocation, and whenever it is invoked, by definition, m<sub>hot </sub>is the mode whose free block is most lacking. First, the mode with the lowest R<sub>m</sub>, i.e., m<sub>cold</sub>, which indicates the least demand for free blocks, is considered as the victim mode. Subsequently, the mode with the next lowest R<sub>m </sub>(lines <b>2</b>-<b>7</b>) is considered. The used block pool (UBP) B of the considered mode, which is a pool of blocks that have at least one non-free page, is searched to find the block that has the most invalid pages (lines <b>3</b>-<b>5</b>). Then, the function NUMINVPAGE(x) returns the number of invalid pages in block x, and NUMINVPAGE(NULL) is defined as zero. The selected b<sub>victim </sub>is the block that has at least one non-free page in the least demanded mode. If b<sub>victim </sub>has any valid pages that have to be preserved, the valid pages are migrated to a precise (Mode <b>0</b>) block. That is because migration to an imprecise block will introduce additional errors that will accumulate over time and eventually violate the error tolerance of the data (lines <b>8</b> and <b>9</b>). The function NUMVALPAGE(x) returns the number of valid pages in block x. Finally, b<sub>victim </sub>is erased in Mode m<sub>hot </sub>and moved into FBPm<sub>hot </sub>(lines <b>10</b> and <b>11</b>).</p><p id="p-0071" num="0062"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates an example of garbage collection in which a victim block is selected by the above-described Algorithm 1 and migrated to a free block pool.</p><p id="p-0072" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Algorithm 1: Erase Mode-Aware Garbage Collection</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="182pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2002;1</entry><entry>b<sub>victim </sub>&#x2190; NULL</entry></row><row><entry/><entry>&#x2002;2</entry><entry>for each UBP B sorted by R<sub>m </sub>in ascending order do</entry></row><row><entry/><entry>&#x2002;3</entry><entry>&#x2002;|&#x2003;for each block b &#x2208; B do</entry></row><row><entry/><entry>&#x2002;4</entry><entry>&#x2002;|&#x2003;&#x2002;|&#x2003;if NUMINVPAGE(b<sub>victim</sub>) &#x3c; NUMINVPAGE(b)</entry></row><row><entry/><entry/><entry>&#x2002;|&#x2003;&#x2002;|&#x2003;&#x2002;then</entry></row><row><entry/><entry>&#x2002;5</entry><entry>&#x2002;|&#x2003;&#x2002;|&#x2003;&#x2002;|&#x2003;b<sub>victim </sub>&#x2190; b</entry></row><row><entry/><entry>&#x2002;6</entry><entry>&#x2002;|&#x2003;if b<sub>victim </sub>&#x2260; NULL then</entry></row><row><entry/><entry>&#x2002;7</entry><entry>&#x2002;|&#x2003;&#x2002;|&#x2003;break</entry></row><row><entry/><entry>&#x2002;8</entry><entry>if NUMVALPAGE(b<sub>victim</sub>) &#x3e; 0 then</entry></row><row><entry/><entry>&#x2002;9</entry><entry>&#x2002;|&#x2003;MIGRATE(b<sub>victim</sub>, Mode 0)</entry></row><row><entry/><entry>10</entry><entry>ERASE(b<sub>victim</sub>, m<sub>hot</sub>)</entry></row><row><entry/><entry>11</entry><entry>Move b<sub>victim </sub>into FBP<sub>m</sub><sub><sub2>hot</sub2></sub></entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0013" level="2">Erase Mode-Aware Wear Leveling</heading><p id="p-0073" num="0063">Static wear leveling prevents uneven wearing among blocks due to cold data sitting in one block for a long time while other blocks undergo many P/E cycles. Similarly to the above-described garbage collection, wear leveling in the AxFTL in accordance with an embodiment of the present disclosure takes different erase modes into account. The wear leveling in the AxFTL in accordance with an embodiment of the present disclosure is another mechanism to balance the demand and supply of free blocks in each mode by moving blocks in a less demanded mode into a more demanded mode.</p><p id="p-0074" num="0064">Algorithm 2 describes how a potential victim block b<sub>victim </sub>is selected for wear leveling. Unlike conventional FTLs, the AxFTL in accordance with an embodiment of the present disclosure should consider not only UBPs but also FBPs to select the victim block. That is because a free block can be unused for a long time if no write request with a matching error tolerance is received. Therefore, as shown in Table 2, the victim block b<sub>victim </sub>that has the lowest CEW from all UBPs and FBPs that satisfy N (FBP)&#x2265;N<sub>min </sub>(lines <b>1</b> to <b>4</b>) is selected. If the difference between the CEW of b<sub>victim </sub>and the highest CEW is greater than a threshold &#x394;CEW<sub>th</sub>, wear leveling is invoked for the selected b<sub>victim </sub>(lines <b>5</b> and <b>6</b>). <figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates an example in which a victim block for wear leveling is selected by Algorithm 2 described above.</p><p id="p-0075" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Algorithm 2: Selection of Victim Block for Wear leveling</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="154pt" align="left"/><tbody valign="top"><row><entry/><entry>1</entry><entry>b<sub>victim </sub>&#x2190; NULL</entry></row><row><entry/><entry>2</entry><entry>for each block b in all UBPs and FBPs that</entry></row><row><entry/><entry/><entry>&#x2003;N(FBP) &#x2265; N<sub>min </sub>do</entry></row><row><entry/><entry>3</entry><entry>&#x2003;|&#x2003;if CEW(b) &#x2264; CEW(b<sub>victim</sub>) then</entry></row><row><entry/><entry>4</entry><entry>&#x2003;|&#x2003;&#x2002;|&#x2003;b<sub>victim </sub>&#x2190; b</entry></row><row><entry/><entry>5</entry><entry>if CEW<sub>max </sub>&#x2212; CEW(b<sub>victim</sub>) &#x3e; &#x394;CEW<sub>th </sub>then</entry></row><row><entry/><entry>6</entry><entry>&#x2003;|&#x2003;Call Algorithm 3</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0076" num="0065">Algorithm 3 shows how the erase mode-aware wear leveling is performed for the selected b<sub>victim</sub>. The objective of this algorithm is to bring b<sub>victim </sub>into the FBP of the most demanded mode so that it can be used soon. If b<sub>victim </sub>is not a free block, all valid pages, if any, in the block are migrated to a precise (Mode <b>0</b>) block to prevent additional errors, erased in Mode m<sub>hot</sub>, and moved into FBPm<sub>hot </sub>(lines <b>1</b> to <b>5</b>). If b<sub>victim </sub>is a free block, it is moved into FBPm<sub>hot </sub>with or without re-erase (lines <b>6</b> to <b>10</b>). In case that the erase mode of b<sub>victim </sub>greater than m<sub>hot</sub>, it is re-erased in Mode m<sub>hot </sub>to meet the error tolerance requirement of FBPm<sub>hot </sub>(lines <b>8</b> and <b>9</b>). If b<sub>victim </sub>is already a free block in FBPm<sub>hot</sub>, no action is taken because it is expected to be allocated soon.</p><p id="p-0077" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 3</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Algorithm 3: Erase Mode-Aware Wear Leveling</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="28pt" align="left"/><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="147pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2002;1</entry><entry>if b<sub>victim </sub>is not a free block then</entry></row><row><entry/><entry>&#x2002;2</entry><entry>&#x2002;|&#x2003;if NUMVALPAGE(b<sub>victim</sub>) &#x3e; 0 then</entry></row><row><entry/><entry>&#x2002;3</entry><entry>&#x2002;|&#x2003;&#x2002;|&#x2003;MIGRATE(b<sub>victim</sub>, Mode 0)</entry></row><row><entry/><entry>&#x2002;4</entry><entry>&#x2002;|&#x2003;ERASE(b<sub>victim</sub>, m<sub>hot</sub>)</entry></row><row><entry/><entry>&#x2002;5</entry><entry>&#x2002;|&#x2003;MOVE b<sub>victim </sub>into FBP<sub>m</sub><sub><sub2>hot</sub2></sub></entry></row><row><entry/><entry>&#x2002;6</entry><entry>else</entry></row><row><entry/><entry>&#x2002;7</entry><entry>&#x2002;|&#x2003;if m<sub>victim </sub>&#x2260; m<sub>hot </sub>then</entry></row><row><entry/><entry>&#x2002;8</entry><entry>&#x2002;|&#x2003;&#x2002;|&#x2003;if m<sub>victim </sub>&#x3e; m<sub>hot </sub>then</entry></row><row><entry/><entry>&#x2002;9</entry><entry>&#x2002;|&#x2003;&#x2002;|&#x2003;&#x2002;|&#x2003;ERASE(b<sub>victim</sub>, m<sub>hot</sub>)</entry></row><row><entry/><entry>10</entry><entry>&#x2002;|&#x2003;&#x2002;|&#x2003;MOVE b<sub>victim </sub>into FBP<sub>m</sub><sub><sub2>hot</sub2></sub></entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0078" num="0066">Although various embodiments have been described for illustrative purposes, it will be apparent to those skilled in the art that various changes and modifications may be made without departing from the spirit and scope of the invention as defined in the following claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230004291A1-20230105-M00001.NB"><img id="EMI-M00001" he="7.03mm" wi="76.20mm" file="US20230004291A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230004291A1-20230105-M00002.NB"><img id="EMI-M00002" he="8.47mm" wi="76.20mm" file="US20230004291A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00003" nb-file="US20230004291A1-20230105-M00003.NB"><img id="EMI-M00003" he="8.47mm" wi="76.20mm" file="US20230004291A1-20230105-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00004" nb-file="US20230004291A1-20230105-M00004.NB"><img id="EMI-M00004" he="6.01mm" wi="76.20mm" file="US20230004291A1-20230105-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A managing method for a flash storage, the method comprising:<claim-text>sorting a plurality of blocks within the flash storage into precise blocks and imprecise blocks; and</claim-text><claim-text>managing the sorted blocks as a plurality of free block pools,</claim-text><claim-text>wherein the management includes performing garbage collection and wear leveling, and</claim-text><claim-text>wherein the wear leveling is performed based on CEW (Cumulative Effective Wearing), the CEW indicating cumulative cell damage induced by performing a plurality of operations on a specific block.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The managing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the management is performed to maintain target numbers of the precise and imprecise blocks while ensuring even block wearing.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The managing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein deep erase and shallow erase are performed on each of the precise blocks and each of the imprecise blocks, respectively.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The managing method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein a voltage applied during the shallow erase is lower than a voltage applied during the deep erase.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The managing method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein a plurality of voltages are applied to divide the shallow erase into a plurality of steps, the plurality of steps corresponding to a plurality of erase modes, respectively.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The managing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the plurality of free block pools corresponds to a plurality of error tolerance levels, respectively, and a free block is selected from a corresponding one of the free block pools meeting an error tolerance requirement.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The managing method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein, when shallow erase or deep erase is performed on the selected block, an erase mode is determined based on a current size of the corresponding one of the free block pools and recent request history.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The managing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein incremental step pulse programming is performed in a P/E (Program/Erase) cycle.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The managing method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the incremental step pulse programming is performed on a first block among the imprecise blocks during a first time interval and on a second block among the precise blocks during a second time interval, the first time interval being shorter time interval than the second time interval.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The managing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a first block among the precise blocks and a second block among the imprecise blocks are allocated to allow different error rates.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The managing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the CEW is obtained based on a first weight of shallow erase and a second weight of deep erase, and<claim-text>wherein the first weight of the shallow erase is different from the second weight of the deep erase.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. A managing method for a flash storage, the method comprising:<claim-text>sorting a plurality of blocks based on error rates; and</claim-text><claim-text>applying erase voltages corresponding to the error rates, respectively, when data stored in the blocks are erased,</claim-text><claim-text>wherein each of the erase voltages is controlled to have a value scaled down from a standard voltage.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The managing method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the reference voltage is used during deep erase, and each of the erase voltages having the scaled-down value is used during shallow erase.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The managing method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the sorted blocks are managed as a plurality of free block pools, and<claim-text>wherein when erase is performed, an erase mode is determined based on a current size of a corresponding one of the free block pools and recent request history.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The managing method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein incremental step pulse programming is performed on one or more of the blocks.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The managing method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the blocks include precise blocks and imprecise blocks, and<claim-text>wherein the incremental step pulse programming is performed on a first block among the imprecise blocks during a first time interval and on a second block among the precise blocks during a second time interval, the first time interval being shorter than the second time interval.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A storage system comprising:<claim-text>a memory array; and</claim-text><claim-text>a memory controller configured to:</claim-text><claim-text>sort a plurality of blocks of the memory array based on error rates;</claim-text><claim-text>apply erase voltages corresponding to the error rates, respectively, when data stored in the blocks are erased;</claim-text><claim-text>control each of the erase voltages to have a value scaled down from a standard voltage; and</claim-text><claim-text>perform incremental step pulse programming on one or more of the blocks.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The storage system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the memory controller determines an erase mode based on the error rates.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The storage system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the memory controller manages the sorted blocks as a plurality of free block pools and determines an erase mode based on a current size of a corresponding one of the free block pools and recent request history, when erase is performed.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The storage system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the memory controller operates using an application program, the memory controller including the application program, or a file system including the application program.</claim-text></claim></claims></us-patent-application>