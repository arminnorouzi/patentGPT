<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004398A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004398</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17940731</doc-number><date>20220908</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>38</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0855</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3871</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0855</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3842</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">ASYNCHRONOUS PIPELINE MERGING USING LONG VECTOR ARBITRATION</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17074991</doc-number><date>20201020</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11467845</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17940731</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Micron Technology, Inc.</orgname><address><city>Boise</city><state>ID</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Grassi</last-name><first-name>Michael</first-name><address><city>Shokan</city><state>NY</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Devices and techniques for asynchronous pipeline merging are described herein. An apparatus, includes a memory controller, which includes merge circuitry; where the memory controller chiplet is configured to perform operations including those to: perform a bitwise logical operation on a first logging bit vector and a second logging bit vector to obtain a result vector, wherein the first logging bit vector is associated with a first pipeline and the second logging bit vector is associated with a second pipeline, and wherein bits in respective index positions of the first and second logging bit vectors represent transactions; select a completed transaction from the result vector using a round-robin technique; and forward the completed transaction from the set of completed transactions to an output pipeline.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="72.14mm" wi="158.75mm" file="US20230004398A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="230.72mm" wi="150.71mm" file="US20230004398A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="207.43mm" wi="155.28mm" orientation="landscape" file="US20230004398A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="219.20mm" wi="123.70mm" orientation="landscape" file="US20230004398A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="233.68mm" wi="126.49mm" file="US20230004398A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="235.63mm" wi="145.88mm" file="US20230004398A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">PRIORITY APPLICATION</heading><p id="p-0002" num="0001">This application is a continuation of U.S. application Ser. No. 17/074,991, filed Oct. 20, 2020, which is incorporated herein by reference in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">Chiplets are an emerging technique for integrating various processing functionalities. Generally, a chiplet system is made up of discrete modules (each a &#x201c;chiplet&#x201d;) that are integrated on an interposer, and in many examples interconnected as desired through one or more established networks, to provide a system with the desired functionality. The interposer and included chiplets may be packaged together to facilitate interconnection with other components of a larger system. Each chiplet may include one or more individual integrated circuits (ICs), or &#x201c;chips&#x201d;, potentially in combination with discrete circuit components, and commonly coupled to a respective substrate to facilitate attachment to the interposer. Most or all chiplets in a system may be individually configured for communication through the one or more established networks.</p><p id="p-0004" num="0003">The configuration of chiplets as individual modules of a system is distinct from such a system being implemented on single chips that contain distinct device blocks (e.g., intellectual property (IP) blocks) on one substrate (e.g., single die), such as a system-on-a-chip (SoC), or multiple discrete packaged devices integrated on a printed circuit board (PCB). In general, chiplets provide better performance (e.g., lower power consumption, reduced latency, etc.) than discrete packaged devices, and chiplets provide greater production benefits than single die chips. These production benefits can include higher yields or reduced development costs and time.</p><p id="p-0005" num="0004">Chiplet systems may include, for example, one or more application (or processor) chiplets and one or more support chiplets. Here, the distinction between application and support chiplets is simply a reference to the likely design scenarios for the chiplet system. Thus, for example, a synthetic vision chiplet system can include, by way of example only, an application chiplet to produce the synthetic vision output along with support chiplets, such as a memory controller chiplet, a sensor interface chiplet, or a communication chiplet. In a typical use case, the synthetic vision designer can design the application chiplet and source the support chiplets from other parties. Thus, the design expenditure (e.g., in terms of time or complexity) is reduced because by avoiding the design and production of functionality embodied in the support chiplets. Chiplets also support the tight integration of IP blocks that can otherwise be difficult, such as those manufactured using different processing technologies or using different feature sizes (or utilizing different contact technologies or spacings). Thus, multiple ICs or IC assemblies, with different physical, electrical, or communication characteristics may be assembled in a modular manner to provide an assembly providing desired functionalities. Chiplet systems can also facilitate adaptation to suit needs of different larger systems into which the chiplet system will be incorporated. In an example, ICs or other assemblies can be optimized for the power, speed, or heat generation for a specific function&#x2014;as can happen with sensors&#x2014;can be integrated with other devices more easily than attempting to do so on a single die. Additionally, by reducing the overall size of the die, the yield for chiplets tends to be higher than that of more complex, single die devices.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0006" num="0005">The disclosure will be understood more fully from the detailed description given below and from the accompanying drawings of various embodiments of the disclosure. The drawings, however, should not be taken to limit the disclosure to the specific embodiments, but are for explanation and understanding only.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIGS. <b>1</b>A and <b>1</b>B</figref> illustrate an example of a chiplet system, according to an embodiment.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates components of an example of a memory controller chiplet, according to an embodiment.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates processing flow through electronic components, according to an embodiment.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow chart of an example of a method for asynchronous pipeline merging, according to an embodiment.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram of an example of a machine with which, in which, or by which embodiments of the present disclosure can operate.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0004" level="1">DETAILED DESCRIPTION</heading><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIGS. <b>1</b>A-<b>1</b>B</figref>, described below, offers an example of a chiplet system and the components operating therein. The illustrated chiplet system includes a memory controller. Additional details about the memory controller are described below with respect to <figref idref="DRAWINGS">FIGS. <b>1</b>A-<b>1</b>B and <b>2</b></figref>.</p><p id="p-0013" num="0012">As described further below, the memory controller can include a local cache for off-die memory (e.g., dynamic random access memory (DRAM). The memory controller may receive a memory request. The memory controller then attempts to satisfy the request from the cache. If the requested data is not found in cache, the data is retrieved from off-die memory. Generally, in comparison to each other, the cache is considered a fast path with low latency and the off-die memory access is considered a slow path with higher latency. Because some memory requests may be satisfied by cache while others may need to access off-die memory, any memory requests that are satisfied by a combination of cache and off-die memory fetch can present timing issues for coordinating these accesses with other units in a pipeline.</p><p id="p-0014" num="0013">Although the issue is posed in the context of a memory request, the presently disclosed implementation may be applied to any system where operations are executed in parallel asynchronous paths. In such systems, the operations may need to be eventually combined or coordinated before being forwarded further into a compute pipeline. If the parallel processing pipelines have characteristics that can cause related operations to have very different and unpredictable response times, these responses need to be logged independently and asynchronously.</p><p id="p-0015" num="0014">In order to address these issues, the present disclosure discusses the use of vectors that are used to represented transactions, such as memory request transactions, in a parallel path pipeline. Each vector may be associated with one path. Each thread, operation, instruction, or transaction that is executing in the parallel paths is represented at a shared bit index in the vectors. Once the transaction is complete, as represented by bit values in the shared bit index, the data of each path may be merged and used in further processing down the pipeline. The bit values represent a sub-completion step in the operation. This marshalling and merging of data across asynchronous multi-path pipelines, maintains integrity across portions of transactions regardless of the varying latencies for the different paths. As a result, the systems and techniques described here are able to accommodate a large number of in-flight operations, which may have vastly different timing.</p><p id="p-0016" num="0015">Using a bitwise AND operation between the logging vectors, the completed transactions are easy to identify. Every pair of comparable bits in each vector is ANDed making a third vector of the same length. This vector essentially takes the sub-completion logging vectors and determines which sets of bits in comparable positions are ready for further completion processing.</p><p id="p-0017" num="0016">This third vector is fed to a wide, fast, fair Round-Robin arbiter, the width being equal to the length of the vectors. The arbiter will ensure that pairs or sets of sub-completion bits meeting the completion criteria will be handled completely and fairly. Once the arbiter grants completion status to a set of sub-completion bits, those sub-completion bits are cleared, and the processing goes forward into the next stage of the pipeline for the transaction associated with the set of sub-completion bits.</p><p id="p-0018" num="0017">Without the control mechanism discussed herein, transactions may have to wait for memory access from the slowest path (e.g., a memory request to an off-die memory device). The pipeline may stall or become significantly inefficient. These stall cycles result in wasted time and energy.</p><p id="p-0019" num="0018">The control mechanism provides distinct advantages by allowing transactions to complete asynchronously and independently. Overall pipeline throughput is increased, and power draw is reduced as fewer resources are wasted due to stalled operations. These efficiencies can be of particular benefit in a chiplet system including a memory controller, as such systems offer modular capabilities that can, in some embodiments, be configured for enabling relatively high performance memory operations required for systems performing a large number of, and/or relatively high complexity computations.</p><p id="p-0020" num="0019">For example, various forms of navigation-directed systems may need to coordinate data from multiple sensors essentially simultaneously to perform the navigation function. An example use for such a chiplet system implementing a memory system including a memory controller with one or more forms of memory would be a self-driving vehicle in which data from various ranging sensors such as radar, lidar, and/or ultrasonic sensors, may be correlated with data from multiple optical sensors (potentially requiring image processing and pattern identification), gyroscopes, skid sensors, etc.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIGS. <b>1</b>A and <b>1</b>B</figref> illustrate an example of a chiplet system <b>110</b>, according to an embodiment. <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> is a representation of the chiplet system <b>110</b> mounted on a peripheral board <b>105</b>, that can be connected to a broader computer system by a peripheral component interconnect express (PCIe) interface, for example. The chiplet system <b>110</b> includes a package substrate <b>115</b>, an interposer <b>120</b>, and four chiplets: an application chiplet <b>125</b>, a host interface chiplet <b>135</b>, a memory controller chiplet <b>140</b>, and a memory device chiplet <b>150</b>. Other systems may include many additional chiplets to provide additional functionalities as will be apparent from the following discussion. The package of the chiplet system <b>110</b> is illustrated with a lid or cover <b>165</b>, though other packaging techniques and structures for the chiplet system can be used. <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> is a block diagram labeling the components in the chiplet system for clarity.</p><p id="p-0022" num="0021">The application chiplet <b>125</b> is illustrated as including a network-on-chip (NOC) <b>130</b> to support a chiplet network <b>155</b> for inter-chiplet communications. In example embodiments NOC <b>130</b> may be included on the application chiplet <b>125</b>. In an example, NOC <b>130</b> may be defined in response to selected support chiplets (e.g., chiplets <b>135</b>, <b>140</b>, and <b>150</b>) thus enabling a designer to select an appropriate number or chiplet network connections or switches for the NOC <b>130</b>. In an example, the NOC <b>130</b> can be located on a separate chiplet, or even within the interposer <b>120</b>. In examples as discussed herein, the NOC <b>130</b> implements a chiplet protocol interface (CPI) network.</p><p id="p-0023" num="0022">The CPI is a packet-based network that supports virtual channels to enable a flexible and high-speed interaction between chiplets. CPI enables bridging from intra-chiplet networks to the chiplet network <b>155</b>. For example, the Advanced eXtensible Interface (AXI) is a widely used specification to design intra-chip communications. AXI specifications, however, cover a great variety of physical design options, such as the number of physical channels, signal timing, power, etc. Within a single chip, these options are generally selected to meet design goals, such as power consumption, speed, etc. However, to achieve the flexibility of the chiplet system, an adapter, such as CPI, is used to interface between the various AXI design options that can be implemented in the various chiplets. By enabling a physical channel to virtual channel mapping and encapsulating time-based signaling with a packetized protocol, CPI bridges intra-chiplet networks across the chiplet network <b>155</b>.</p><p id="p-0024" num="0023">CPI can use a variety of different physical layers to transmit packets. The physical layer can include simple conductive connections, or can include drivers to increase the voltage, or otherwise facilitate transmitting the signals over longer distances. An example of one such physical layer can include the Advanced Interface Bus (AIB), which in various examples, can be implemented in the interposer <b>120</b>. AIB transmits and receives data using source synchronous data transfers with a forwarded clock. Packets are transferred across the AIB at single data rate (SDR) or dual data rate (DDR) with respect to the transmitted clock. Various channel widths are supported by AIB. AIB channel widths are in multiples of 20 bits when operated in SDR mode (20, 40, 60, . . . ), and multiples of 40 bits for DDR mode: (40, 80, 120, . . . ). The AIB channel width includes both transmit and receive signals. The channel can be configured to have a symmetrical number of transmit (TX) and receive (RX) input/outputs (I/Os), or have a non-symmetrical number of transmitters and receivers (e.g., either all transmitters or all receivers). The channel can act as an AIB control or subordinate (i.e., &#x201c;master&#x201d; or &#x201c;slave&#x201d;) depending on which chiplet provides the master clock. AIB I/O cells support three clocking modes: asynchronous (i.e., non-clocked), SDR, and DDR. In various examples, the non-clocked mode is used for clocks and some control signals. The SDR mode can use dedicated SDR only I/O cells, or dual use SDR/DDR I/O cells.</p><p id="p-0025" num="0024">In an example, CPI packet protocols (e.g., point-to-point or routable) can use symmetrical receive and transmit I/O cells within an AIB channel. The CPI streaming protocol allows more flexible use of the AIB I/O cells. In an example, an AIB channel for streaming mode can configure the I/O cells as all TX, all RX, or half TX and half RX. CPI packet protocols can use an AIB channel in either SDR or DDR operation modes. In an example, the AIB channel is configured in increments of 80 I/O cells (i.e., 40 TX and 40 RX) for SDR mode and 40 I/O cells for DDR mode. The CPI streaming protocol can use an AIB channel in either SDR or DDR operation modes. Here, in an example, the AIB channel is in increments of 40 I/O cells for both SDR and DDR modes. In an example, each AIB channel is assigned a unique interface identifier. The identifier is used during CPI reset and initialization to determine paired AIB channels across connected chiplets. In an example, the interface identifier is a 20-bit value comprising a seven-bit chiplet identifier, a seven-bit column identifier, and a six-bit link identifier. The AIB physical layer transmits the interface identifier using an AIB out-of-band shift register. The 20-bit interface identifier is transferred in both directions across an AIB interface using bits <b>32</b>-<b>51</b> of the shift registers.</p><p id="p-0026" num="0025">AIB defines a stacked set of AIB channels as an AIB channel column. An AIB channel column has some number of AIB channels, plus an auxiliary channel. The auxiliary channel contains signals used for AIB initialization. All AIB channels (other than the auxiliary channel) within a column are of the same configuration (e.g., all TX, all RX, or half TX and half RX, as well as having the same number of data I/O signals). In an example, AIB channels are numbered in continuous increasing order starting with the AIB channel adjacent to the AUX channel. The AIB channel adjacent to the AUX is defined to be AIB channel zero.</p><p id="p-0027" num="0026">Generally, CPI interfaces on individual chiplets can include serialization-deserialization (SERDES) hardware. SERDES interconnects work well for scenarios in which high-speed signaling with low signal count are desirable. SERDES, however, can result in additional power consumption and longer latencies for multiplexing and demultiplexing, error detection or correction (e.g., using block level cyclic redundancy checking (CRC)), link-level retry, or forward error correction. However, when low latency or energy consumption is a primary concern for ultra-short reach, chiplet-to-chiplet interconnects, a parallel interface with clock rates that allow data transfer with minimal latency may be utilized. CPI includes elements to minimize both latency and energy consumption in these ultra-short reach chiplet interconnects.</p><p id="p-0028" num="0027">For flow control, CPI employs a credit-based technique. A recipient, such as the application chiplet <b>125</b>, provides a sender, such as the memory controller chiplet <b>140</b>, with credits that represent available buffers. In an example, a CPI recipient includes a buffer for each virtual channel for a given time-unit of transmission. Thus, if the CPI recipient supports five messages in time and a single virtual channel, the recipient has five buffers arranged in five rows (e.g., one row for each unit time). If four virtual channels are supported, then the recipient has twenty buffers arranged in five rows. Each buffer holds the payload of one CPI packet.</p><p id="p-0029" num="0028">When the sender transmits to the recipient, the sender decrements the available credits based on the transmission. Once all credits for the recipient are consumed, the sender stops sending packets to the recipient. This ensures that the recipient always has an available buffer to store the transmission.</p><p id="p-0030" num="0029">As the recipient processes received packets and frees buffers, the recipient communicates the available buffer space back to the sender. This credit return can then be used by the sender allow transmitting of additional information.</p><p id="p-0031" num="0030">Also illustrated is a chiplet mesh network <b>160</b> that uses a direct, chiplet-to-chiplet technique without the need for the NOC <b>130</b>. The chiplet mesh network <b>160</b> can be implemented in CPI, or another chiplet-to-chiplet protocol. The chiplet mesh network <b>160</b> generally enables a pipeline of chiplets where one chiplet serves as the interface to the pipeline while other chiplets in the pipeline interface only with themselves.</p><p id="p-0032" num="0031">Additionally, dedicated device interfaces, such as one or more industry standard memory interfaces <b>145</b> (such as, for example, synchronous memory interfaces, such as DDR5, DDR6), can also be used to interconnect chiplets. Connection of a chiplet system or individual chiplets to external devices (such as a larger system can be through a desired interface (for example, a PCIE interface). Such as external interface may be implemented, in an example, through a host interface chiplet <b>135</b>, which in the depicted example, provides a PCIE interface external to chiplet system <b>110</b>. Such dedicated interfaces <b>145</b> are generally employed when a convention or standard in the industry has converged on such an interface. The illustrated example of a Double Data Rate (DDR) interface <b>145</b> connecting the memory controller chiplet <b>140</b> to a dynamic random access memory (DRAM) memory device <b>150</b> is just such an industry convention.</p><p id="p-0033" num="0032">Of the variety of possible support chiplets, the memory controller chiplet <b>140</b> is likely present in the chiplet system <b>110</b> due to the near omnipresent use of storage for computer processing as well as sophisticated state-of-the-art for memory devices. Thus, using memory device chiplets <b>150</b> and memory controller chiplets <b>140</b> produced by others gives chiplet system designers access to robust products by sophisticated producers. Generally, the memory controller chiplet <b>140</b> provides a memory device specific interface to read, write, or erase data. Often, the memory controller chiplet <b>140</b> can provide additional features, such as error detection, error correction, maintenance operations, or atomic operation execution. For some types of memory, maintenance operations tend to be specific to the memory device <b>150</b>, such as garbage collection in NAND flash or storage class memories, temperature adjustments (e.g., cross temperature management) in NAND flash memories. In an example, the maintenance operations can include logical-to-physical (L2P) mapping or management to provide a level of indirection between the physical and logical representation of data. In other types of memory, for example DRAM, some memory operations, such as refresh may be controlled by a host processor or a memory controller at some times, and at other times controlled by the DRAM memory device, or by logic associated with one or more DRAM devices, such as an interface chip (in an example, a buffer).</p><p id="p-0034" num="0033">Atomic operations are a data manipulation that, for example, may be performed by the memory controller chiplet <b>140</b>. In other chiplet systems, the atomic operations may be performed by other chiplets. For example, an atomic operation of &#x201c;increment&#x201d; can be specified in a command by the application chiplet <b>125</b>, the command including a memory address and possibly an increment value. Upon receiving the command, the memory controller chiplet <b>140</b> retrieves a number from the specified memory address, increments the number by the amount specified in the command, and stores the result. Upon a successful completion, the memory controller chiplet <b>140</b> provides an indication of the command's success to the application chiplet <b>125</b>. Atomic operations avoid transmitting the data across the chiplet network <b>160</b>, resulting in lower latency execution of such commands.</p><p id="p-0035" num="0034">Atomic operations can be classified as built-in atomics or programmable (e.g., custom) atomics. Built-in atomics are a finite set of operations that are immutably implemented in hardware. Programmable atomics are small programs that can execute on a programmable atomic unit (PAU) (e.g., a custom atomic unit (CAU)) of the memory controller chiplet <b>140</b>. <figref idref="DRAWINGS">FIGS. <b>1</b>A and <b>1</b>B</figref> illustrate an example of a memory controller chiplet that discusses a PAU.</p><p id="p-0036" num="0035">The memory device chiplet <b>150</b> can be, or include any combination of, volatile memory devices or non-volatile memories. Examples of volatile memory devices include, but are not limited to, random access memory (RAM)&#x2014;such as DRAM, synchronous DRAM (SDRAM), graphics double data rate type 6 SDRAM (GDDR6 SDRAM), among others. Examples of non-volatile memory devices include, but are not limited to, negative-and-(NAND)-type flash memory, storage class memory (e.g., phase-change memory or memristor based technologies), ferroelectric RAM (FeRAM), among others. The illustrated example includes the memory device <b>150</b> as a chiplet, however, the memory device <b>150</b> can reside elsewhere, such as in a different package on the peripheral board <b>105</b>. For many applications, multiple memory device chiplets may be provided. In an example, these memory device chiplets may each implement one or multiple storage technologies. In an example, a memory chiplet may include, multiple stacked memory die of different technologies, for example one or more SRAM devices stacked or otherwise in communication with one or more DRAM devices. Memory controller <b>140</b> may also serve to coordinate operations between multiple memory chiplets in chiplet system <b>110</b>; for example, to utilize one or more memory chiplets in one or more levels of cache storage, and to use one or more additional memory chiplets as main memory. Chiplet system <b>110</b> may also include multiple memory controllers <b>140</b>, as may be used to provide memory control functionality for separate processors, sensors, networks, etc. A chiplet architecture, such as chiplet system <b>110</b> offers advantages in allowing adaptation to different memory storage technologies; and different memory interfaces, through updated chiplet configurations, without requiring redesign of the remainder of the system structure.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates components of an example of a memory controller chiplet <b>505</b>, according to an embodiment. The memory controller chiplet <b>505</b> includes a cache <b>510</b>, a cache controller <b>515</b>, an off-die memory controller <b>520</b> (e.g., to communicate with off-die memory <b>575</b>), a network communication interface <b>525</b> (e.g., to interface with a chiplet network <b>585</b> and communicate with other chiplets), and a set of atomic and merge units <b>550</b>. Members of this set can include, for example, a write merge unit <b>555</b>, a memory hazard unit <b>560</b>, built-in atomic unit <b>565</b>, or a PAU <b>570</b>. The various components are illustrated logically, and not as they necessarily would be implemented. For example, the built-in atomic unit <b>565</b> likely comprises different devices along a path to the off-die memory. For example, the built-in atomic unit <b>565</b> could be in an interface device/buffer on a memory chiplet, as discussed above. In contrast, the programmable atomic unit <b>570</b> could be implemented in a separate processor on the memory controller chiplet <b>505</b> (but in various examples may be implemented in other locations, for example on a memory chiplet).</p><p id="p-0038" num="0037">The off-die memory controller <b>520</b> is directly coupled to the off-die memory <b>575</b> (e.g., via a bus or other communication connection) to provide write operations and read operations to and from the one or more off-die memory devices, such as off-die memory <b>575</b> and off-die memory <b>580</b>. In the depicted example, the off-die memory controller <b>520</b> is also coupled for output to the atomic and merge unit <b>550</b>, and for input to the cache controller <b>515</b> (e.g., a memory side cache controller).</p><p id="p-0039" num="0038">In the example configuration, cache controller <b>515</b> is directly coupled to the cache <b>510</b>, and may be coupled to the network communication interface <b>525</b> for input (such as incoming read or write requests), and coupled for output to the off-die memory controller <b>520</b>.</p><p id="p-0040" num="0039">The network communication interface <b>525</b> includes a packet decoder <b>530</b>, network input queues <b>535</b>, a packet encoder <b>540</b>, and network output queues <b>545</b> to support a packet-based chiplet network <b>585</b>, such as CPI. The chiplet network <b>585</b> can provide packet routing between and among processors, memory controllers, hybrid threading processors, configurable processing circuits, or communication interfaces. In such a packet-based communication system, each packet typically includes destination and source addressing, along with any data payload or instruction. In an example, the chiplet network <b>585</b> can be implemented as a collection of crossbar switches having a folded Clos configuration, or a mesh network providing for additional connections, depending upon the configuration.</p><p id="p-0041" num="0040">In various examples, the chiplet network <b>585</b> can be part of an asynchronous switching fabric. Here, a data packet can be routed along any of various paths, such that the arrival of any selected data packet at an addressed destination can occur at any of multiple different times, depending upon the routing. Additionally, chiplet network <b>585</b> can be implemented at least in part as a synchronous communication network, such as a synchronous mesh communication network. Both configurations of communication networks are contemplated for use for examples in accordance with the present disclosure.</p><p id="p-0042" num="0041">The memory controller chiplet <b>505</b> can receive a packet having, for example, a source address, a read request, and a physical address. In response, the off-die memory controller <b>520</b> or the cache controller <b>515</b> will read the data from the specified physical address (which can be in the off-die memory <b>575</b> or in the cache <b>510</b>), and assemble a response packet to the source address containing the requested data. Similarly, the memory controller chiplet <b>505</b> can receive a packet having a source address, a write request, and a physical address. In response, the memory controller chiplet <b>505</b> will write the data to the specified physical address (which can be in the cache <b>510</b> or in the off-die memories <b>575</b> or <b>580</b>), and assemble a response packet to the source address containing an acknowledgement that the data was stored to a memory.</p><p id="p-0043" num="0042">Thus, the memory controller chiplet <b>505</b> can receive read and write requests via the chiplet network <b>585</b> and process the requests using the cache controller <b>515</b> interfacing with the cache <b>510</b>, if possible. If the request cannot be handled by the cache controller <b>515</b>, the off-die memory controller <b>520</b> handles the request by communication with the off-die memories <b>575</b> or <b>580</b>, the atomic and merge unit <b>550</b>, or both. As noted above, one or more levels of cache may also be implemented in off-die memories <b>275</b> or <b>280</b>; and in some such examples may be accessed directly by cache controller <b>215</b>. Data read by the off-die memory controller <b>520</b> can be cached in the cache <b>510</b> by the cache controller <b>515</b> for later use.</p><p id="p-0044" num="0043">The atomic and merge unit <b>250</b> are coupled to receive (as input) the output of the off-die memory controller <b>220</b>, and to provide output to the cache <b>210</b>, the network communication interface <b>225</b>, or directly to the chiplet network <b>285</b>. The memory hazard unit <b>560</b>, write merge unit <b>555</b> and the built-in (e.g., predetermined) atomic unit <b>565</b> can each be implemented as state machines with other combinational logic circuitry (such as adders, shifters, comparators, AND gates, OR gates, XOR gates, or any suitable combination thereof) or other logic circuitry. These components can also include one or more registers or buffers to store operand or other data. The PAU <b>570</b> can be implemented as one or more processor cores or control circuitry, and various state machines with other combinational logic circuitry or other logic circuitry, and can also include one or more registers, buffers, or memories to store addresses, executable instructions, operand and other data, or can be implemented as a processor.</p><p id="p-0045" num="0044">The write merge unit <b>555</b> receives read data and request data, and merges the request data and read data to create a single unit having the read data and the source address to be used in the response or return data packet). The write merge unit <b>555</b> provides the merged data to the write port of the cache <b>510</b> (or, equivalently, to the cache controller <b>515</b> to write to the cache <b>510</b>). Optionally, the write merge unit <b>555</b> provides the merged data to the network communication interface <b>525</b> to encode and prepare a response or return data packet for transmission on the chiplet network <b>585</b>.</p><p id="p-0046" num="0045">When the request data is for a built-in atomic operation, the built-in atomic unit <b>565</b> receives the request and reads data, either from the write merge unit <b>555</b> or directly from the off-die memory controller <b>520</b>. The atomic operation is performed, and using the write merge unit <b>555</b>, the resulting data is written to the cache <b>510</b>, or provided to the network communication interface <b>525</b> to encode and prepare a response or return data packet for transmission on the chiplet network <b>585</b>.</p><p id="p-0047" num="0046">The built-in atomic unit <b>565</b> handles predefined atomic operations such as fetch-and-increment or compare-and-swap. In an example, these operations perform a simple read-modify-write operation to a single memory location of 32-bytes or less in size. Atomic memory operations are initiated from a request packet transmitted over the chiplet network <b>585</b>. The request packet has a physical address, atomic operator type, operand size, and optionally up to 32-bytes of data. The atomic operation performs the read-modify-write to a cache memory line of the cache <b>510</b>, filling the cache memory if necessary. The atomic operator response can be a simple completion response, or a response with up to 32-bytes of data. Example atomic memory operators include fetch-and-AND, fetch-and-OR, fetch-and-XOR, fetch-and-add, fetch-and-subtract, fetch-and-increment, fetch-and-decrement, fetch-and-minimum, fetch-and-maximum, fetch-and-swap, and compare-and-swap. In various example embodiments, 32-bit and 64-bit operations are supported, along with operations on 16 or 32 bytes of data. Methods disclosed herein are also compatible with hardware supporting larger or smaller operations and more or less data.</p><p id="p-0048" num="0047">Built-in atomic operations can also involve requests for a &#x201c;standard&#x201d; atomic operation on the requested data, such as comparatively simple, single cycle, integer atomics&#x2014;such as fetch-and-increment or compare-and-swap&#x2014;which will occur with the same throughput as a regular memory read or write operation not involving an atomic operation. For these operations, the cache controller <b>515</b> may generally reserve a cache line in the cache <b>510</b> by setting a hazard bit (in hardware), so that the cache line cannot be read by another process while it is in transition. The data is obtained from either the off-die memory <b>575</b> or the cache <b>510</b>, and is provided to the built-in atomic operation unit <b>565</b> to perform the requested atomic operation. Following the atomic operation, in addition to providing the resulting data to the packet encoder <b>540</b> to encode outgoing data packets for transmission on the chiplet network <b>585</b>, the built-in atomic operation unit <b>565</b> provides the resulting data to the write merge unit <b>555</b>, which will also write the resulting data to the cache <b>510</b>. Following the writing of the resulting data to the cache <b>510</b>, any corresponding hazard bit which was set will be cleared by the memory hazard unit <b>560</b>.</p><p id="p-0049" num="0048">The PAU <b>570</b> enables high performance (high throughput and low latency) for programmable atomic operations (also referred to as &#x201c;custom atomic transactions&#x201d; or &#x201c;custom atomic operations&#x201d;), comparable to the performance of built-in atomic operations. Rather than executing multiple memory accesses, in response to an atomic operation request designating a programmable atomic operation and a memory address, circuitry in the memory controller chiplet <b>505</b> transfers the atomic operation request to PAU <b>570</b> and sets a hazard bit stored in a memory hazard register corresponding to the memory address of the memory line used in the atomic operation, to ensure that no other operation (read, write, or atomic) is performed on that memory line, which hazard bit is then cleared upon completion of the atomic operation. Additional, direct data paths provided for the PAU <b>570</b> executing the programmable atomic operations allow for additional write operations without any limitations imposed by the bandwidth of the communication networks and without increasing any congestion of the communication networks.</p><p id="p-0050" num="0049">The PAU <b>570</b> includes a multi-threaded processor, for example, such as a RISC-V ISA based multi-threaded processor, having one or more processor cores, and further having an extended instruction set for executing programmable atomic operations. When provided with the extended instruction set for executing programmable atomic operations, the PAU <b>570</b> can be embodied as one or more hybrid threading processors. In some example embodiments, the PAU <b>570</b> provides barrel-style, round-robin instantaneous thread switching to maintain a high instruction-per-clock rate.</p><p id="p-0051" num="0050">Programmable atomic operations can be performed by the PAU <b>570</b> involving requests for a programmable atomic operation on the requested data. A user can prepare programming code to provide such programmable atomic operations. For example, the programmable atomic operations can be comparatively simple, multi-cycle operations such as floating-point addition, or comparatively complex, multi-instruction operations such as a Bloom filter insert. The programmable atomic operations can be the same as or different than the built-in atomic operations, insofar as they are defined by the user rather than a system vendor. For these operations, the cache controller <b>515</b> can reserve a cache line in the cache <b>510</b>, by setting a hazard bit (in hardware), so that cache line cannot be read by another process while it is in transition. The data is obtained from either the cache <b>510</b> or the off-die memories <b>575</b> or <b>580</b>, and is provided to the PAU <b>570</b> to perform the requested programmable atomic operation. Following the atomic operation, the PAU <b>570</b> will provide the resulting data to the network communication interface <b>525</b> to directly encode outgoing data packets having the resulting data for transmission on the chiplet network <b>585</b>. In addition, the PAU <b>570</b> will provide the resulting data to the cache controller <b>515</b>, which will also write the resulting data to the cache <b>510</b>. Following the writing of the resulting data to the cache <b>510</b>, any corresponding hazard bit which was set will be cleared by the cache control circuit <b>515</b>.</p><p id="p-0052" num="0051">In selected examples, the approach taken for programmable atomic operations is to provide multiple, generic, custom atomic request types that can be sent through the chiplet network <b>585</b> to the memory controller chiplet <b>505</b> from an originating source such as a processor or other system component. The cache controllers <b>515</b> or off-die memory controller <b>520</b> identify the request as a custom atomic and forward the request to the PAU <b>570</b>. In a representative embodiment, the PAU <b>570</b>: (1) is a programmable processing element capable of efficiently performing a user defined atomic operation; (2) can perform load and stores to memory, arithmetic and logical operations and control flow decisions; and (3) leverages the RISC-V ISA with a set of new, specialized instructions to facilitate interacting with such controllers <b>515</b>, <b>520</b> to atomically perform the user-defined operation. In desirable examples, the RISC-V ISA contains a full set of instructions that support high level language operators and data types. The PAU <b>570</b> can leverage the RISC-V ISA, but will commonly support a more limited set of instructions and limited register file size to reduce the die size of the unit when included within the memory controller chiplet <b>505</b>.</p><p id="p-0053" num="0052">As mentioned above, prior to the writing of the read data to the cache <b>510</b>, the set hazard bit for the reserved cache line is to be cleared, by the memory hazard clear unit <b>560</b>. Accordingly, when the request and read data is received by the write merge unit <b>555</b>, a reset or clear signal can be transmitted by the memory hazard clear unit <b>560</b> to the cache <b>510</b> to reset the set memory hazard bit for the reserved cache line. Also, resetting this hazard bit will also release a pending read or write request involving the designated (or reserved) cache line, providing the pending read or write request to an inbound request multiplexer for selection and processing.</p><p id="p-0054" num="0053">The merge circuitry <b>290</b> is configured to merge various responses from the cache <b>210</b> and the off-die memory (e.g., off-die memory <b>275</b>) in response to a memory request (e.g., received from the packet decoder <b>230</b>) before delivery in a memory response (e.g., via packet encoder <b>240</b>). As illustrated, the merge circuitry <b>290</b> can have components in the cache controller <b>215</b>, the off-die memory controller <b>220</b>, or any other location in which memory requests (e.g., transactions) can be tracked and completed (e.g., merged).</p><p id="p-0055" num="0054">As noted above, the response times between the cache <b>210</b> and the off-die memory <b>275</b>, <b>280</b> can vary greatly, creating a challenge to track and reassemble responses for a memory request transaction. Although various parallel pipelines can exist in the memory controller <b>205</b>, an example of a two-path parallel pipeline includes memory retrievals from the cache <b>210</b> and an off-die memory. An example of a three-way parallel pipeline may include access to the cache <b>210</b>, a fast off-die memory (e.g., off-die memory <b>275</b> is DRAM), and a slow off-die memory (e.g., off-die memory <b>280</b> is flash).</p><p id="p-0056" num="0055">To track parallel operations in a transaction, a logging vector is used for each of the paths. Within each logging vector, the bit positions are represented by indexes. The index positions between each vector is shared such that a transaction associated with a given index in one vector is also associated with the same index in other vectors. The logging vectors of each path is then straightforward to use to determine whether a given transaction has completed all operations in each of the parallel paths by comparing the vector values of bits positioned at the index of the transaction.</p><p id="p-0057" num="0056">When an operation for a transaction is complete, the completion is logged in a logging vector associated with the pipeline at a position that corresponds to the transaction. In an embodiment, a controller associated with the pipeline (e.g., cache controller <b>215</b> or off-die memory controller <b>220</b>) logs the completion of the operation (e.g., a memory read completion). In another embodiment, the merge circuitry <b>290</b> is configured to log the completion in a logging vector for the pipeline.</p><p id="p-0058" num="0057">The logging vector is one of a set of logging vectors with each of the set of logging vectors uniquely assigned to a respective set of parallel pipelines. Thus, each parallel pipeline has its own logging vector in the set of logging vectors. Moreover, a given index in any vector corresponds to a transaction such that the same index in each vector corresponds to the same transaction. Generally, transaction 0 will be index 0 across all vectors of the set of vectors. Accordingly, if pipeline A completes transaction 0 and pipeline B has not, index 0 of pipeline A's vector will indicate that the transaction is complete and index 0 of pipeline B's vector will indicate that the transaction is not complete. This may be performed using logic one for complete and logic zero for incomplete. Although it is understood that the logic may be inverted in some implementations.</p><p id="p-0059" num="0058">Each logging vector may be a bit vector, such that each element of a logging vector holds a single bit. The bit vector can be represented with one or more words in registers of the merge circuitry <b>290</b>. Such a representation can be convenient to implement, both in storage of the vector as well as comparing vectors to one another to determine whether a given transaction is complete as described below. In an example, to mark an element in a bit vector, the merge circuitry <b>290</b> is configured to set a position of the bit vector to a logical one. Using the logical one to indicate completion and a logical zero to indicate that the transaction is not complete can be convenient when using standard bitwise comparison operations, such as a bitwise AND operation or a bitwise OR operation, to compare transaction status over several pipelines.</p><p id="p-0060" num="0059">The merge circuitry <b>290</b> is configured to compare corresponding elements from two or more logging vectors. The comparison may be performed based on an event. The event may be when an element is marked as being complete, an expiration of an interval, upon an interrupt from the cache controller <b>215</b> or the off-die memory controller <b>220</b>, or other triggering events. The comparison determines which transactions are complete. Thus, the merge circuitry <b>290</b> is configured to compare the transaction complete indications in a given index across the logging vectors of the parallel pipelines. For example, if index 1 of the vector for pipeline A and index 1 of the vector for pipeline B both indicate completion, then the transaction 1 that corresponds to index 1 is considered complete.</p><p id="p-0061" num="0060">In an example, when the vectors are bit vectors, the merge circuitry <b>290</b> is configured to compare elements in the members of the set of bit vectors by performing a bitwise operation upon entire members (e.g., upon all indices in the vectors). For example, given three 256-bit vectors, a logical AND operation is performed between all three vectors to produce a single 256-bit result vector. Such an operation can generally be implemented within a single clock cycle. In an example, the bitwise operation is an AND operation. In an example, the transaction is complete when the result of the AND operation that corresponds to the transaction index is a logical one. The AND operation, with transaction completions being marked with a logical one, is a convenient mechanism to determine that every vector is complete because a logical one in a given index of the result vector can only be obtained with a logical one at the same index in all of the parallel pipeline vectors.</p><p id="p-0062" num="0061">In some implementations, it is possible for a transaction to be complete if fewer than all pipelines complete. For example, if the transaction involves a single memory data unit, then either the cache <b>210</b> or the off-die memory satisfies the transaction. However, both locations can be checked in parallel to avoid, for example, latency associated with waiting for a cache miss before making the off-die memory inquiry. In these examples, the merge circuitry <b>290</b> can be configured to use a bitwise OR operation as the bitwise operation. In an example, the transaction is complete when the result of the OR operation that corresponds to the transaction index is a logical one. As long as any pipeline vector has a logical one at the transaction index, the transaction is complete. Because the implementation of a bitwise AND and a bitwise OR can consume little hardware area in the merge circuitry <b>290</b>, both can be included and performed on each clock cycle, for example. In this type of implementation, the merge circuitry has two result vectors. The merge circuitry <b>290</b> may consult the appropriate result vector based on metadata about each transaction. Thus, the AND result vector can be consulted for a transaction when all pipelines must complete for the transaction to be considered complete, and the OR vector can be consulted when only one pipeline must complete for the transaction to be considered complete.</p><p id="p-0063" num="0062">Using the result vector, the merge circuitry <b>290</b> is configured to release the corresponding transaction to the rest of the pipeline. This may include creation and delivery of a memory response over a network-on-chip (NOC), processing additional related memory requests, or the like.</p><p id="p-0064" num="0063">A round-robin arbiter in the merge circuitry <b>290</b> is used to ensure that a completed transaction is handled fairly. When the arbiter releases the transaction to the remaining pipeline, the corresponding bits are cleared in the logging vectors. To release the transaction to the remaining pipeline, the arbiter may write transaction data, metadata, or other information to a pipeline buffer. In an example, the merge circuitry <b>290</b> is configured to read completed transactions out of the result vector in a round-robin sequence.</p><p id="p-0065" num="0064">A round-robin arbiter may be used to provide this functionality. Various round-robin arbiter designs may be used. For instance, a mask vector may be used to mask completed indexes out of the result vector over successive cycles. The mask vector may be updated after each transaction is forwarded to service the next higher completed index. The mask may be updated until the entire request vector is masked, at which time the mask is reset and the lowest completed index in the result vector can be identified. As such, in an example, the arbiter in the merge circuitry <b>290</b> can identify the lowest index of completed transactions and forward the transaction associated with this index to the remaining pipeline. This implementation provide wraparound functionality and fair round-robin service.</p><p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates processing flow through electronic components, according to an embodiment. As illustrated, there is a request processor <b>305</b> (e.g., the packet decoder <b>230</b> from <figref idref="DRAWINGS">FIG. <b>2</b></figref>) that processing incoming transaction requests. Transaction requests may be memory requests. The request processor <b>305</b> can split a transaction and initiate a first request using a fast sequential access pipeline <b>310</b>A (e.g., memory access to cache <b>210</b>) and initiate a second request using a slow random access pipeline <b>310</b>B (e.g., memory access to off-die memory <b>280</b>). These sub-requests proceed independently and asynchronously. It is understood that more than two pipelines may be used.</p><p id="p-0067" num="0066">A merge circuitry <b>315</b> (e.g., merge circuitry <b>290</b>) merges results from the fast pipeline <b>310</b>A and the slow pipeline <b>310</b>B and provides the results to a response processor <b>310</b> (e.g., the packet encoder <b>240</b> from <figref idref="DRAWINGS">FIG. <b>2</b></figref>).</p><p id="p-0068" num="0067">The merge circuitry <b>315</b> accesses logging vectors <b>325</b>A, <b>325</b>B associated with the fast sequential access pipeline <b>310</b>A and the slow random access pipeline <b>310</b>B. The logging vectors are combined using logic to produce a result vector <b>330</b>. Round-robin arbiter <b>335</b> selects a completed transaction from the result vector <b>330</b> and forwards the transaction to the response processor <b>320</b>.</p><p id="p-0069" num="0068">The logging vectors <b>325</b>A, <b>325</b>B are used to capture and maintain status of the associated transactions. The transaction data may be stored in an associative memory. The memory may be implemented as registers and store relationships between a transaction index identifier and payload data (e.g., memory request results from fast or slow memory access pipelines). The merge circuitry <b>315</b> may access the associative memory to obtain the corresponding data and forward the data to the response processor <b>320</b>. Alternatively, the merge circuitry <b>315</b> may forward the index of the transaction to the response processor <b>320</b>, which then may use the index to lookup the transaction data. The transaction data may be a requested byte, word, or other addressable unit of data, requested from memory by the requestor. The transaction data may then be returned to the original requestor by the response processor <b>320</b>.</p><p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow chart of an example of a method <b>400</b> for asynchronous pipeline merging in a merge circuit, according to an embodiment. Operations of the method <b>400</b> are performed by computer hardware, such as that described with respect to <figref idref="DRAWINGS">FIGS. <b>1</b>A-<b>1</b>B</figref> (e.g., memory controller chiplet), <figref idref="DRAWINGS">FIG. <b>2</b></figref> (e.g., merge circuitry <b>290</b>), <figref idref="DRAWINGS">FIG. <b>3</b></figref>, or <figref idref="DRAWINGS">FIG. <b>5</b></figref> (e.g., processing circuitry). At <b>405</b>, a bitwise logical operation is performed on a first logging bit vector and a second logging bit vector to obtain a result vector. The first logging bit vector is associated with a first pipeline and the second logging bit vector is associated with a second pipeline. Bits in respective index positions of the first and second logging bit vectors represent transactions.</p><p id="p-0071" num="0070">In an embodiment, the first pipeline comprises a fast sequential access pipeline. In a related embodiment, the second pipeline comprises a slow random access pipeline.</p><p id="p-0072" num="0071">In an embodiment, the first logging bit vector and the second logging bit vector are of the same size. In a related embodiment, the first logging bit vector and the second logging bit vector are each 256 bits.</p><p id="p-0073" num="0072">At <b>410</b>, a completed transaction is selected from the result vector using a round-robin technique. In an embodiment, the first and second logging bit vectors store a logical one to indicate completion in the respective first and second pipeline. In a further embodiment, the bitwise logical operation is an AND operation, and wherein transactions that correspond to a logical one in the result vector are considered complete. In another embodiment, the bitwise logical operation is an OR operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</p><p id="p-0074" num="0073">In an embodiment, a controller associated with the first pipeline sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0075" num="0074">In an embodiment, the merge circuitry sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0076" num="0075">At <b>415</b>, the completed transaction from the set of completed transactions is forwarded to an output pipeline. The output pipeline may include the response processor <b>320</b>. In an embodiment, forwarding the completed transaction comprises transmitting an index of the result vector corresponding to the completed transaction. In another embodiment, forwarding the completed transaction includes using an index of the result vector corresponding to the completed transaction to obtain transaction data corresponding to the completed transaction and transmitting the transaction data to the output pipeline. In a further embodiment, the transaction data comprises data related to a memory request.</p><p id="p-0077" num="0076">In an embodiment, the method <b>400</b> includes clearing bits at an index of the first and second logging bit vectors that corresponds to the completed transaction.</p><p id="p-0078" num="0077">In an embodiment, the merge circuitry is included in a memory controller chiplet (e.g., memory controller chiplet <b>140</b>) in a chiplet system (e.g., chiplet system <b>110</b>). In a further embodiment, the merge circuitry is disposed on an output path of the memory controller chiplet, the output path being between the memory controller chiplet and memory managed by the memory controller chiplet. In a further embodiment, memory managed by the memory controller includes memory on the memory controller chiplet (e.g., cache <b>210</b>) and memory that is not on the memory controller chiplet (e.g., off-die memory <b>275</b> or off-die memory <b>280</b>).</p><p id="p-0079" num="0078"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a block diagram of an example machine <b>500</b> with which, in which, or by which any one or more of the techniques (e.g., methodologies) discussed herein can be implemented. Examples, as described herein, can include, or can operate by, logic or a number of components, or mechanisms in the machine <b>500</b>. Circuitry (e.g., processing circuitry) is a collection of circuits implemented in tangible entities of the machine <b>500</b> that include hardware (e.g., simple circuits, gates, logic, etc.). Circuitry membership can be flexible over time. Circuitries include members that can, alone or in combination, perform specified operations when operating; thus. processing circuitry in various instances, for example in various controllers as described in the specification, can include one or more processors, or cores of processors, or other instruction-executing devices. In an example, hardware of the circuitry can be immutably designed to carry out a specific operation (e.g., hardwired). In an example, the hardware of the circuitry can include variably connected physical components (e.g., execution units, transistors, simple circuits, etc.) including a machine readable medium physically modified (e.g., magnetically, electrically, moveable placement of invariant massed particles, etc.) to encode instructions of the specific operation. In connecting the physical components, the underlying electrical properties of a hardware constituent are changed, for example, from an insulator to a conductor or vice versa. The instructions enable embedded hardware (e.g., the execution units or a loading mechanism) to create members of the circuitry in hardware via the variable connections to carry out portions of the specific operation when in operation. Accordingly, in an example, the machine-readable medium elements are part of the circuitry or are communicatively coupled to the other components of the circuitry when the device is operating. In an example, any of the physical components can be used in more than one member of more than one circuitry. For example, under operation, execution units can be used in a first circuit of a first circuitry at one point in time and reused by a second circuit in the first circuitry, or by a third circuit in a second circuitry at a different time. Additional examples of these components with respect to the machine <b>500</b> follow.</p><p id="p-0080" num="0079">In alternative embodiments, the machine <b>500</b> can operate as a standalone device or can be connected (e.g., networked) to other machines. In a networked deployment, the machine <b>500</b> can operate in the capacity of a server machine, a client machine, or both in server-client network environments. In an example, the machine <b>500</b> can act as a peer machine in peer-to-peer (P2P) (or other distributed) network environment. The machine <b>500</b> can be a personal computer (PC), a tablet PC, a set-top box (STB), a personal digital assistant (PDA), a mobile telephone, a web appliance, a network router, switch or bridge, or any machine capable of executing instructions (sequential or otherwise) that specify actions to be taken by that machine. Further, while only a single machine is illustrated, the term &#x201c;machine&#x201d; shall also be taken to include any collection of machines that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein, such as cloud computing, software as a service (SaaS), other computer cluster configurations.</p><p id="p-0081" num="0080">The machine (e.g., computer system) <b>500</b> can include a hardware processor <b>502</b> (e.g., a central processing unit (CPU), a graphics processing unit (GPU), a hardware processor core, or any combination thereof), a main memory <b>504</b>, a static memory (e.g., memory or storage for firmware, microcode, a basic-input-output (BIOS), unified extensible firmware interface (UEFI), etc.) <b>506</b>, and mass storage <b>508</b> (e.g., hard drives, tape drives, flash storage, or other block devices) some or all of which can communicate with each other via an interlink (e.g., bus) <b>530</b>. The machine <b>500</b> can further include a display unit <b>510</b>, an alphanumeric input device <b>512</b> (e.g., a keyboard), and a user interface (UI) navigation device <b>514</b> (e.g., a mouse). In an example, the display unit <b>510</b>, input device <b>512</b> and UI navigation device <b>514</b> can be a touch screen display. The machine <b>500</b> can additionally include a storage device (e.g., drive unit) <b>508</b>, a signal generation device <b>518</b> (e.g., a speaker), a network interface device <b>520</b>, and one or more sensors <b>516</b>, such as a global positioning system (GPS) sensor, compass, accelerometer, or other sensor. The machine <b>500</b> can include an output controller <b>528</b>, such as a serial (e.g., universal serial bus (USB)), parallel, or other wired or wireless (e.g., infrared (IR), near field communication (NFC), etc.) connection to communicate or control one or more peripheral devices (e.g., a printer, card reader, etc.).</p><p id="p-0082" num="0081">Registers of the processor <b>502</b>, the main memory <b>504</b>, the static memory <b>506</b>, or the mass storage <b>508</b> can be, or include, a machine readable medium <b>522</b> on which is stored one or more sets of data structures or instructions <b>524</b> (e.g., software) embodying or utilized by any one or more of the techniques or functions described herein. The instructions <b>524</b> can also reside, completely or at least partially, within any of registers of the processor <b>502</b>, the main memory <b>504</b>, the static memory <b>506</b>, or the mass storage <b>508</b> during execution thereof by the machine <b>500</b>. In an example, one or any combination of the hardware processor <b>502</b>, the main memory <b>504</b>, the static memory <b>506</b>, or the mass storage <b>508</b> can constitute the machine readable media <b>522</b>. While the machine readable medium <b>522</b> is illustrated as a single medium, the term &#x201c;machine readable medium&#x201d; can include a single medium or multiple media (e.g., a centralized or distributed database, or associated caches and servers) configured to store the one or more instructions <b>524</b>.</p><p id="p-0083" num="0082">The term &#x201c;machine readable medium&#x201d; can include any medium that is capable of storing, encoding, or carrying instructions for execution by the machine <b>500</b> and that cause the machine <b>500</b> to perform any one or more of the techniques of the present disclosure, or that is capable of storing, encoding or carrying data structures used by or associated with such instructions. Non-limiting machine-readable medium examples can include solid-state memories, optical media, magnetic media, and signals (e.g., radio frequency signals, other photon-based signals, sound signals, etc.). In an example, a non-transitory machine-readable medium comprises a machine-readable medium with a plurality of particles having invariant (e.g., rest) mass, and thus are compositions of matter. Accordingly, non-transitory machine-readable media are machine readable media that do not include transitory propagating signals. Specific examples of non-transitory machine readable media can include: non-volatile memory, such as semiconductor memory devices (e.g., electrically programmable read-only memory (EPROM), electrically erasable programmable read-only memory (EEPROM)) and flash memory devices; magnetic disks, such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.</p><p id="p-0084" num="0083">In an example, information stored or otherwise provided on the machine readable medium <b>522</b> can be representative of the instructions <b>524</b>, such as instructions <b>524</b> themselves or a format from which the instructions <b>524</b> can be derived. This format from which the instructions <b>524</b> can be derived can include source code, encoded instructions (e.g., in compressed or encrypted form), packaged instructions (e.g., split into multiple packages), or the like. The information representative of the instructions <b>524</b> in the machine readable medium <b>522</b> can be processed by processing circuitry into the instructions to implement any of the operations discussed herein. For example, deriving the instructions <b>524</b> from the information (e.g., processing by the processing circuitry) can include: compiling (e.g., from source code, object code, etc.), interpreting, loading, organizing (e.g., dynamically or statically linking), encoding, decoding, encrypting, unencrypting, packaging, unpackaging, or otherwise manipulating the information into the instructions <b>524</b>.</p><p id="p-0085" num="0084">In an example, the derivation of the instructions <b>524</b> can include assembly, compilation, or interpretation of the information (e.g., by the processing circuitry) to create the instructions <b>524</b> from some intermediate or preprocessed format provided by the machine readable medium <b>522</b>. The information, when provided in multiple parts, can be combined, unpacked, and modified to create the instructions <b>524</b>. For example, the information can be in multiple compressed source code packages (or object code, or binary executable code, etc.) on one or several remote servers. The source code packages can be encrypted when in transit over a network and decrypted, uncompressed, assembled (e.g., linked) if necessary, and compiled or interpreted (e.g., into a library, stand-alone executable etc.) at a local machine, and executed by the local machine.</p><p id="p-0086" num="0085">The instructions <b>524</b> can be further transmitted or received over a communications network <b>526</b> using a transmission medium via the network interface device <b>520</b> utilizing any one of a number of transfer protocols (e.g., frame relay, internet protocol (IP), transmission control protocol (TCP), user datagram protocol (UDP), hypertext transfer protocol (HTTP), etc.). Example communication networks can include a local area network (LAN), a wide area network (WAN), a packet data network (e.g., the Internet), mobile telephone networks (e.g., cellular networks), plain old telephone (POTS) networks, and wireless data networks (e.g., Institute of Electrical and Electronics Engineers (IEEE) 802.11 family of standards known as Wi-Fi&#xae;, IEEE 802.16 family of standards known as WiMax&#xae;), IEEE 802.15.4 family of standards, peer-to-peer (P2P) networks, among others. In an example, the network interface device <b>520</b> can include one or more physical jacks (e.g., Ethernet, coaxial, or phone jacks) or one or more antennas to connect to the communications network <b>526</b>. In an example, the network interface device <b>520</b> can include a plurality of antennas to wirelessly communicate using at least one of single-input multiple-output (SIMO), multiple-input multiple-output (MIMO), or multiple-input single-output (MISO) techniques. The term &#x201c;transmission medium&#x201d; shall be taken to include any intangible medium that is capable of storing, encoding or carrying instructions for execution by the machine <b>500</b>, and includes digital or analog communications signals or other intangible medium to facilitate communication of such software. A transmission medium is a machine readable medium. To better illustrate the methods and apparatuses described herein, a non-limiting set of Example embodiments are set forth below as numerically identified Examples.</p><p id="p-0087" num="0086">Example 1 is an apparatus, comprising: memory configured as a cache; an interface couplable to off-die memory; and merge circuitry coupled to the interface and the memory configured as the cache, the merge circuitry configured to: perform a bitwise logical operation on a first logging bit vector and a second logging bit vector to obtain a result vector, wherein the first logging bit vector is associated with a first pipeline and the second logging bit vector is associated with a second pipeline, and wherein bits in respective index positions of the first and second logging bit vectors represent transactions; select a completed transaction from the result vector using a round-robin technique; and forward the completed transaction from the set of completed transactions to an output pipeline.</p><p id="p-0088" num="0087">In Example 2, the subject matter of Example 1 includes, wherein the first and second logging bit vectors store a logical one to indicate completion in the respective first and second pipeline.</p><p id="p-0089" num="0088">In Example 3, the subject matter of Example 2 includes, wherein the bitwise logical operation is an AND operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</p><p id="p-0090" num="0089">In Example 4, the subject matter of Examples 2-3 includes, wherein the bitwise logical operation is an OR operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</p><p id="p-0091" num="0090">In Example 5, the subject matter of Examples 1&#x2dc;4 includes, wherein a controller associated with the first pipeline sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0092" num="0091">In Example 6, the subject matter of Examples 1-5 includes, wherein the merge circuitry sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0093" num="0092">In Example 7, the subject matter of Examples 1-6 includes, wherein forwarding the completed transaction comprises transmitting an index of the result vector corresponding to the completed transaction.</p><p id="p-0094" num="0093">In Example 8, the subject matter of Examples 1-7 includes, wherein forwarding the completed transaction comprises: using an index of the result vector corresponding to the completed transaction to obtain transaction data corresponding to the completed transaction; and transmitting the transaction data to the output pipeline.</p><p id="p-0095" num="0094">In Example 9, the subject matter of Example 8 includes, wherein the transaction data comprises data related to a memory request.</p><p id="p-0096" num="0095">In Example 10, the subject matter of Examples 1-9 includes, wherein the memory controller is to perform operations including: clearing bits at an index of the first and second logging bit vectors that corresponds to the completed transaction.</p><p id="p-0097" num="0096">In Example 11, the subject matter of Examples 1-10 includes, wherein the first pipeline comprises a fast sequential access pipeline.</p><p id="p-0098" num="0097">In Example 12, the subject matter of Examples 1-11 includes, wherein the second pipeline comprises a slow random access pipeline.</p><p id="p-0099" num="0098">In Example 13, the subject matter of Examples 1-12 includes, wherein the first logging bit vector and the second logging bit vector are of the same size.</p><p id="p-0100" num="0099">In Example 14, the subject matter of Examples 1-13 includes, wherein the first logging bit vector and the second logging bit vector are each 256 bits.</p><p id="p-0101" num="0100">In Example 15, the subject matter of Examples 1-14 includes, wherein the merge circuitry is included in a memory controller chiplet in a chiplet system.</p><p id="p-0102" num="0101">In Example 16, the subject matter of Example 15 includes, wherein the merge circuitry is disposed on an output path of the memory controller chiplet, the output path being between the memory controller chiplet and memory managed by the memory controller chiplet.</p><p id="p-0103" num="0102">In Example 17, the subject matter of Example 16 includes, wherein memory managed by the memory controller includes memory on the memory controller chiplet and memory that is not on the memory controller chiplet.</p><p id="p-0104" num="0103">Example 18 is a method, comprising: performing, by a memory controller having merge circuitry, a bitwise logical operation on a first logging bit vector and a second logging bit vector to obtain a result vector, wherein the first logging bit vector is associated with a first pipeline and the second logging bit vector is associated with a second pipeline, and wherein bits in respective index positions of the first and second logging bit vectors represent transactions; selecting, by the memory controller having merge circuitry, a completed transaction from the result vector using a round-robin technique; and forwarding, by the memory controller having merge circuitry, the completed transaction from the set of completed transactions to an output pipeline.</p><p id="p-0105" num="0104">In Example 19, the subject matter of Example 18 includes, wherein the first and second logging bit vectors store a logical one to indicate completion in the respective first and second pipeline.</p><p id="p-0106" num="0105">In Example 20, the subject matter of Example 19 includes, wherein the bitwise logical operation is an AND operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</p><p id="p-0107" num="0106">In Example 21, the subject matter of Examples 19-20 includes, wherein the bitwise logical operation is an OR operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</p><p id="p-0108" num="0107">In Example 22, the subject matter of Examples 18-21 includes, wherein a controller associated with the first pipeline sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0109" num="0108">In Example 23, the subject matter of Examples 18-22 includes, wherein the merge circuitry sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0110" num="0109">In Example 24, the subject matter of Examples 18-23 includes, wherein forwarding the completed transaction comprises transmitting an index of the result vector corresponding to the completed transaction.</p><p id="p-0111" num="0110">In Example 25, the subject matter of Examples 18-24 includes, wherein forwarding the completed transaction comprises: using an index of the result vector corresponding to the completed transaction to obtain transaction data corresponding to the completed transaction; and transmitting the transaction data to the output pipeline.</p><p id="p-0112" num="0111">In Example 26, the subject matter of Example 25 includes, wherein the transaction data comprises data related to a memory request.</p><p id="p-0113" num="0112">In Example 27, the subject matter of Examples 18-26 includes, clearing bits at an index of the first and second logging bit vectors that corresponds to the completed transaction.</p><p id="p-0114" num="0113">In Example 28, the subject matter of Examples 18-27 includes, wherein the first pipeline comprises a fast sequential access pipeline.</p><p id="p-0115" num="0114">In Example 29, the subject matter of Examples 18-28 includes, wherein the second pipeline comprises a slow random access pipeline.</p><p id="p-0116" num="0115">In Example 30, the subject matter of Examples 18-29 includes, wherein the first logging bit vector and the second logging bit vector are of the same size.</p><p id="p-0117" num="0116">In Example 31, the subject matter of Examples 18-30 includes, wherein the first logging bit vector and the second logging bit vector are each 256 bits.</p><p id="p-0118" num="0117">In Example 32, the subject matter of Examples 18-31 includes, wherein the merge circuitry is included in a memory controller chiplet in a chiplet system.</p><p id="p-0119" num="0118">In Example 33, the subject matter of Example 32 includes, wherein the merge circuitry is disposed on an output path of the memory controller chiplet, the output path being between the memory controller chiplet and memory managed by the memory controller chiplet.</p><p id="p-0120" num="0119">In Example 34, the subject matter of Example 33 includes, wherein memory managed by the memory controller includes memory on the memory controller chiplet and memory that is not on the memory controller chiplet.</p><p id="p-0121" num="0120">Example 35 is a machine-readable medium including instructions, which when executed by a memory controller having merge circuitry, cause the memory controller to: perform a bitwise logical operation on a first logging bit vector and a second logging bit vector to obtain a result vector, wherein the first logging bit vector is associated with a first pipeline and the second logging bit vector is associated with a second pipeline, and wherein bits in respective index positions of the first and second logging bit vectors represent transactions; select a completed transaction from the result vector using a round-robin technique; and forward the completed transaction from the set of completed transactions to an output pipeline.</p><p id="p-0122" num="0121">In Example 36, the subject matter of Example 35 includes, wherein the first and second logging bit vectors store a logical one to indicate completion in the respective first and second pipeline.</p><p id="p-0123" num="0122">In Example 37, the subject matter of Example 36 includes, wherein the bitwise logical operation is an AND operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</p><p id="p-0124" num="0123">In Example 38, the subject matter of Examples 36-37 includes, wherein the bitwise logical operation is an OR operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</p><p id="p-0125" num="0124">In Example 39, the subject matter of Examples 35-38 includes, wherein a controller associated with the first pipeline sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0126" num="0125">In Example 40, the subject matter of Examples 35-39 includes, wherein the merge circuitry sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0127" num="0126">In Example 41, the subject matter of Examples 35-40 includes, wherein forwarding the completed transaction comprises transmitting an index of the result vector corresponding to the completed transaction.</p><p id="p-0128" num="0127">In Example 42, the subject matter of Examples 35-41 includes, wherein forwarding the completed transaction comprises: using an index of the result vector corresponding to the completed transaction to obtain transaction data corresponding to the completed transaction; and transmitting the transaction data to the output pipeline.</p><p id="p-0129" num="0128">In Example 43, the subject matter of Example 42 includes, wherein the transaction data comprises data related to a memory request.</p><p id="p-0130" num="0129">In Example 44, the subject matter of Examples 35-43 includes, wherein the memory controller is to perform operations including: clearing bits at an index of the first and second logging bit vectors that corresponds to the completed transaction.</p><p id="p-0131" num="0130">In Example 45, the subject matter of Examples 35-44 includes, wherein the first pipeline comprises a fast sequential access pipeline.</p><p id="p-0132" num="0131">In Example 46, the subject matter of Examples 35-45 includes, wherein the second pipeline comprises a slow random access pipeline.</p><p id="p-0133" num="0132">In Example 47, the subject matter of Examples 35-46 includes, wherein the first logging bit vector and the second logging bit vector are of the same size.</p><p id="p-0134" num="0133">In Example 48, the subject matter of Examples 35-47 includes, wherein the first logging bit vector and the second logging bit vector are each 256 bits.</p><p id="p-0135" num="0134">In Example 49, the subject matter of Examples 35-48 includes, wherein the merge circuitry is included in a memory controller chiplet in a chiplet system.</p><p id="p-0136" num="0135">In Example 50, the subject matter of Example 49 includes, wherein the merge circuitry is disposed on an output path of the memory controller chiplet, the output path being between the memory controller chiplet and memory managed by the memory controller chiplet.</p><p id="p-0137" num="0136">In Example 51, the subject matter of Example 50 includes, wherein memory managed by the memory controller includes memory on the memory controller chiplet and memory that is not on the memory controller chiplet.</p><p id="p-0138" num="0137">Example 52 is an apparatus, comprising: means for performing, by a memory controller having merge circuitry, a bitwise logical operation on a first logging bit vector and a second logging bit vector to obtain a result vector, wherein the first logging bit vector is associated with a first pipeline and the second logging bit vector is associated with a second pipeline, and wherein bits in respective index positions of the first and second logging bit vectors represent transactions; means for selecting, by the memory controller having merge circuitry, a completed transaction from the result vector using a round-robin technique; and means for forwarding, by the memory controller having merge circuitry, the completed transaction from the set of completed transactions to an output pipeline.</p><p id="p-0139" num="0138">In Example 53, the subject matter of Example 52 includes, wherein the first and second logging bit vectors store a logical one to indicate completion in the respective first and second pipeline.</p><p id="p-0140" num="0139">In Example 54, the subject matter of Example 53 includes, wherein the bitwise logical operation is an AND operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</p><p id="p-0141" num="0140">In Example 55, the subject matter of Examples 53-54 includes, wherein the bitwise logical operation is an OR operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</p><p id="p-0142" num="0141">In Example 56, the subject matter of Examples 52-55 includes, wherein a controller associated with the first pipeline sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0143" num="0142">In Example 57, the subject matter of Examples 52-56 includes, wherein the merge circuitry sets a bit the first logging bit vector for a transaction executing in the first pipeline, the bit representing a completion status of the transaction executing in the first pipeline.</p><p id="p-0144" num="0143">In Example 58, the subject matter of Examples 52-57 includes, wherein the means for forwarding the completed transaction comprise means for transmitting an index of the result vector corresponding to the completed transaction.</p><p id="p-0145" num="0144">In Example 59, the subject matter of Examples 52-58 includes, wherein the means for forwarding the completed transaction comprise: means for using an index of the result vector corresponding to the completed transaction to obtain transaction data corresponding to the completed transaction; and means for transmitting the transaction data to the output pipeline.</p><p id="p-0146" num="0145">In Example 60, the subject matter of Example 59 includes, wherein the transaction data comprises data related to a memory request.</p><p id="p-0147" num="0146">In Example 61, the subject matter of Examples 52-60 includes, means for clearing bits at an index of the first and second logging bit vectors that corresponds to the completed transaction.</p><p id="p-0148" num="0147">In Example 62, the subject matter of Examples 52-61 includes, wherein the first pipeline comprises a fast sequential access pipeline.</p><p id="p-0149" num="0148">In Example 63, the subject matter of Examples 52-62 includes, wherein the second pipeline comprises a slow random access pipeline.</p><p id="p-0150" num="0149">In Example 64, the subject matter of Examples 52-63 includes, wherein the first logging bit vector and the second logging bit vector are of the same size.</p><p id="p-0151" num="0150">In Example 65, the subject matter of Examples 52-64 includes, wherein the first logging bit vector and the second logging bit vector are each 256 bits.</p><p id="p-0152" num="0151">In Example 66, the subject matter of Examples 52-65 includes, wherein the merge circuitry is included in a memory controller chiplet in a chiplet system.</p><p id="p-0153" num="0152">In Example 67, the subject matter of Example 66 includes, wherein the merge circuitry is disposed on an output path of the memory controller chiplet, the output path being between the memory controller chiplet and memory managed by the memory controller chiplet.</p><p id="p-0154" num="0153">In Example 68, the subject matter of Example 67 includes, wherein memory managed by the memory controller includes memory on the memory controller chiplet and memory that is not on the memory controller chiplet.</p><p id="p-0155" num="0154">Example 69 is at least one machine-readable medium including instructions that, when executed by processing circuitry, cause the processing circuitry to perform operations to implement of any of Examples 1-68.</p><p id="p-0156" num="0155">Example 70 is an apparatus comprising means to implement of any of Examples 1-68.</p><p id="p-0157" num="0156">Example 71 is a system to implement of any of Examples 1-68.</p><p id="p-0158" num="0157">Example 72 is a method to implement of any of Examples 1-68.</p><p id="p-0159" num="0158">The above detailed description includes references to the accompanying drawings, which form a part of the detailed description. The drawings show, by way of illustration, specific embodiments in which the invention can be practiced. These embodiments are also referred to herein as &#x201c;examples&#x201d;. Such examples can include elements in addition to those shown or described. However, the present inventors also contemplate examples in which only those elements shown or described are provided. Moreover, the present inventors also contemplate examples using any combination or permutation of those elements shown or described (or one or more aspects thereof), either with respect to a particular example (or one or more aspects thereof), or with respect to other examples (or one or more aspects thereof) shown or described herein.</p><p id="p-0160" num="0159">In this document, the terms &#x201c;a&#x201d; or &#x201c;an&#x201d; are used, as is common in patent documents, to include one or more than one, independent of any other instances or usages of &#x201c;at least one&#x201d; or &#x201c;one or more.&#x201d; In this document, the term &#x201c;or&#x201d; is used to refer to a nonexclusive or, such that &#x201c;A or B&#x201d; can include &#x201c;A but not B,&#x201d; &#x201c;B but not A,&#x201d; and &#x201c;A and B,&#x201d; unless otherwise indicated. In the appended claims, the terms &#x201c;including&#x201d; and &#x201c;in which&#x201d; are used as the plain-English equivalents of the respective terms &#x201c;comprising&#x201d; and &#x201c;wherein&#x201d;. Also, in the following claims, the terms &#x201c;including&#x201d; and &#x201c;comprising&#x201d; are open-ended, that is, a system, device, article, or process that includes elements in addition to those listed after such a term in a claim are still deemed to fall within the scope of that claim. Moreover, in the following claims, the terms &#x201c;first,&#x201d; &#x201c;second,&#x201d; and &#x201c;third,&#x201d; etc. are used merely as labels, and are not intended to impose numerical requirements on their objects.</p><p id="p-0161" num="0160">The above description is intended to be illustrative, and not restrictive. For example, the above-described examples (or one or more aspects thereof) can be used in combination with each other. Other embodiments can be used, such as by one of ordinary skill in the art upon reviewing the above description. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. Also, in the above Detailed Description, various features can be grouped together to streamline the disclosure. This should not be interpreted as intending that an unclaimed disclosed feature is essential to any claim. Rather, inventive subject matter can lie in less than all features of a particular disclosed embodiment. Thus, the following claims are hereby incorporated into the Detailed Description, with each claim standing on its own as a separate embodiment, and it is contemplated that such embodiments can be combined with each other in various combinations or permutations. The scope of the invention should be determined with reference to the appended claims, along with the full scope of equivalents to which such claims are entitled.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. An apparatus, comprising:<claim-text>an interface couplable to off-die memory; and</claim-text><claim-text>merge circuitry coupled to the interface, the merge circuitry configured to:<claim-text>perform a bitwise logical operation on a first logging bit vector and a second logging bit vector to obtain a result vector, wherein the first logging bit vector is associated with a first pipeline and the second logging bit vector is associated with a second pipeline, and wherein bits in respective index positions of the first and second logging bit vectors represent transactions in the respective first and second pipelines;</claim-text><claim-text>select a completed transaction from the result vector; and</claim-text><claim-text>forward the completed transaction to an output pipeline.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein to select the completed transaction from the result vector, the merge circuitry is configured to select the completed transaction using a round-robin technique.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. A method, comprising:<claim-text>performing, by a memory controller having merge circuitry, a bitwise logical operation on a first logging bit vector and a second logging bit vector to obtain a result vector, wherein the first logging bit vector is associated with a first pipeline and the second logging bit vector is associated with a second pipeline, and wherein bits in respective index positions of the first and second logging bit vectors represent transactions in the respective first and second pipelines;</claim-text><claim-text>selecting, by the memory controller having merge circuitry, a completed transaction from the result vector; and</claim-text><claim-text>forwarding, by the memory controller having merge circuitry, the completed transaction to an output pipeline.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein selecting the completed transaction from the result vector comprises selecting the completed transaction using a round-robin technique.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the first and second logging bit vectors store a logical one to indicate completion in the respective first and second pipeline.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the bitwise logical operation is an OR operation, and wherein transactions that correspond to a logical one in the result vector are considered complete.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein a controller associated with the first pipeline sets a respective bit of the first logging bit vector for a transaction executing in the first pipeline, the respective bit representing a completion status of the transaction executing in the first pipeline.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the merge circuitry sets a respective bit of the first logging bit vector for a transaction executing in the first pipeline, the respective bit representing a completion status of the transaction executing in the first pipeline.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein forwarding the completed transaction comprises transmitting an index of the result vector corresponding to the completed transaction.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein forwarding the completed transaction comprises:<claim-text>using an index of the result vector corresponding to the completed transaction to obtain transaction data corresponding to the completed transaction; and</claim-text><claim-text>transmitting the transaction data to the output pipeline.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the transaction data comprises data related to a memory request.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, comprising:<claim-text>clearing bits at an index of the first and second logging bit vectors that corresponds to the completed transaction.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the first pipeline comprises a fast sequential access pipeline.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the second pipeline comprises a slow random access pipeline.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the first logging bit vector and the second logging bit vector are of a same size.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the first logging bit vector and the second logging bit vector are each 256 bits.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the merge circuitry is included in a memory controller chiplet in a chiplet system.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the merge circuitry is disposed on an output path of the memory controller chiplet, the output path being between the memory controller chiplet and memory managed by the memory controller chiplet.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein memory managed by the memory controller includes memory on the memory controller chiplet and memory that is not on the memory controller chiplet.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. A non-transitory machine-readable medium including instructions, which when executed by a memory controller having merge circuitry, cause the memory controller to perform operations comprising:<claim-text>performing a bitwise logical operation on a first logging bit vector and a second logging bit vector to obtain a result vector, wherein the first logging bit vector is associated with a first pipeline and the second logging bit vector is associated with a second pipeline, and wherein bits in respective index positions of the first and second logging bit vectors represent transactions in the respective first and second pipelines;</claim-text><claim-text>selecting a completed transaction from the result vector; and</claim-text></claim-text><claim-text>forwarding the completed transaction to an output pipeline.</claim-text></claim></claims></us-patent-application>