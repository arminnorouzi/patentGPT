<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007263A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007263</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17767705</doc-number><date>20201012</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>KR</country><doc-number>10-2019-0125140</doc-number><date>20191010</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>186</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>186</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">IMAGE ENCODING/DECODING METHOD AND APPARATUS, AND RECORDING MEDIUM STORING BITSTREAM</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Electronics and Telecommunications Research Institute</orgname><address><city>Daejeon</city><country>KR</country></address></addressbook><residence><country>KR</country></residence></us-applicant><us-applicant sequence="01" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>RESEARCH &#x26; BUSINESS FOUNDATION SUNGKYUNKWAN UNIVERSITY</orgname><address><city>Suwon-si, Gyeonggi-do</city><country>KR</country></address></addressbook><residence><country>KR</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>KANG</last-name><first-name>Jung Won</first-name><address><city>Daejeon</city><country>KR</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>LEE</last-name><first-name>Ha Hyun</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>LIM</last-name><first-name>Sung Chang</first-name><address><city>Daejeon</city><country>KR</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>LEE</last-name><first-name>Jin Ho</first-name><address><city>Daejeon</city><country>KR</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>JEON</last-name><first-name>Byeung Woo</first-name><address><city>Seongnam-si Gyeonggi-do</city><country>KR</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>PARK</last-name><first-name>Jee Yoon</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Electronics and Telecommunications Research Institute</orgname><role>03</role><address><city>Daejeon</city><country>KR</country></address></addressbook></assignee><assignee><addressbook><orgname>RESEARCH &#x26; BUSINESS FOUNDATION SUNGKYUNKWAN UNIVERSITY</orgname><role>03</role><address><city>Suwon-si Gyeonggi-do</city><country>KR</country></address></addressbook></assignee></assignees><pct-or-regional-filing-data><document-id><country>WO</country><doc-number>PCT/KR2020/013873</doc-number><date>20201012</date></document-id><us-371c12-date><date>20220408</date></us-371c12-date></pct-or-regional-filing-data></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Disclosed herein is a video decoding method. The video decoding method includes: obtaining a chroma residual joint flag of a current block indicating whether or not a chroma residual joint mode is applied to the current block; obtaining, from a bitstream, a transform skip mode flag for a luma component of the current block and a transform skip mode flag for a first chroma component; when the chroma residual joint flag indicates that a chroma residual joint mode is applied to the current block, determining whether or not a transform skip mode is applied to a second chroma component of the current block, according to the transform skip mode flag for the first chroma component; and, when the chroma residual joint flag indicates that a chroma residual joint mode is not applied to the current block, obtaining, from the bitstream, a transform skip mode flag for the second chroma component of the current block.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="116.59mm" wi="158.75mm" file="US20230007263A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="205.99mm" wi="159.77mm" orientation="landscape" file="US20230007263A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="221.83mm" wi="155.28mm" orientation="landscape" file="US20230007263A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="217.17mm" wi="148.34mm" orientation="landscape" file="US20230007263A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="194.06mm" wi="105.83mm" file="US20230007263A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="161.88mm" wi="155.53mm" file="US20230007263A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="139.78mm" wi="159.34mm" file="US20230007263A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="168.32mm" wi="122.00mm" file="US20230007263A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="150.96mm" wi="123.78mm" file="US20230007263A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">TECHNICAL FIELD</heading><p id="p-0002" num="0001">The present disclosure relates to a video encoding/decoding method and apparatus. More particularly, the present disclosure relates to an image encoding/decoding method and apparatus using transform skip.</p><heading id="h-0002" level="1">BACKGROUND ART</heading><p id="p-0003" num="0002">Recently, the demand for high resolution and quality images such as high definition (HD) or ultra-high definition (UHD) images has increased in various applications. As the resolution and quality of images are improved, the amount of data correspondingly increases. This is one of the causes of increase in transmission cost and storage cost when transmitting image data through existing transmission media such as wired or wireless broadband channels or when storing image data. In order to solve such problems with high resolution and quality image data, a high efficiency image encoding/decoding technique is required.</p><p id="p-0004" num="0003">There are various video compression techniques such as an inter prediction technique of predicting the values of pixels within a current picture from the values of pixels within a preceding picture or a subsequent picture, an intra prediction technique of predicting the values of pixels within a region of a current picture from the values of pixels within another region of the current picture, a transform and quantization technique of compressing the energy of a residual signal, and an entropy coding technique of allocating frequently occurring pixel values with shorter codes and less occurring pixel values with longer codes.</p><heading id="h-0003" level="1">DISCLOSURE</heading><heading id="h-0004" level="1">Technical Problem</heading><p id="p-0005" num="0004">The present disclosure is directed to provide an image encoding/decoding method and apparatus with enhanced compression efficiency and a recoding medium storing a bitstream that is generated by the video encoding/decoding method and apparatus of the present disclosure.</p><p id="p-0006" num="0005">The present disclosure is also directed to provide an image encoding/decoding method and apparatus, which improve compression efficiency by using a transform skip mode, and a recording medium for storing a bitstream.</p><heading id="h-0005" level="1">Technical Solution</heading><p id="p-0007" num="0006">The present disclosure provides a video decoding method including: obtaining a chroma residual joint flag of a current block indicating whether or not a chroma residual joint mode is applied to the current block; obtaining, from a bitstream, a transform skip mode flag for a luma component of the current block and a transform skip mode flag for a first chroma component; when the chroma residual joint flag indicates that a chroma residual joint mode is applied to the current block, determining whether or not a transform skip mode is applied to a second chroma component of the current block, according to the transform skip mode flag for the first chroma component; and, when the chroma residual joint flag indicates that a chroma residual joint mode is not applied to the current block, obtaining, from the bitstream, a transform skip mode flag for the second chroma component of the current block.</p><p id="p-0008" num="0007">According to an embodiment, the video decoding method may further include determining a residual sample for a second chroma component of a current block according to a residual sample of the first chroma component of the current block, when the chroma residual joint flag indicates that a chroma residual joint mode is applied to the current block.</p><p id="p-0009" num="0008">According to an embodiment, a size of a residual sample for the second chroma component may be determined based on a size of a residual sample for the first chroma component, and a sign of a residual sample for the second chroma component may be determined to be opposite to a sign of the residual sample for the first chroma component.</p><p id="p-0010" num="0009">According to an embodiment, the video decoding method may further include obtaining, from the bitstream, chroma residual joint sign information indicating a relation between a sign of a residual sample for the first chroma component and a sign of a residual sample for the second chroma component. The sign of the residual sample for the second chroma component may be determined based on the chroma residual joint sign information and the sign of the residual sample for the first chroma component.</p><p id="p-0011" num="0010">According to an embodiment, the obtaining of the transform skip mode flag for the luma component of the current block and the transform skip mode flag for the first chroma component may include: obtaining the transform skip mode flag for the luma component of the current block according to a size of the current block; and obtaining the transform skip mode flag for the first chroma component of the current block according to the size of the current block.</p><p id="p-0012" num="0011">According to an embodiment, the obtaining of the transform skip mode flag for the luma component of the current block according to the size of the current block may include obtaining the transform skip mode flag for the luma component of the current block, when a height of the current block is equal to or less than a maximum block height and a width of the current block is equal to or less than a maximum block width.</p><p id="p-0013" num="0012">According to an embodiment, the obtaining of the transform skip mode flag for the first chroma component of the current block according to the size of the current block may include obtaining the transform skip mode flag for the first chroma component of the current block according to the size of the current block and a color format.</p><p id="p-0014" num="0013">According to an embodiment, the video decoding method may further include obtaining, from the bitstream, a chroma residual joint enable flag indicating whether or not a chroma residual joint mode is enabled for an upper-level unit of the current block. The obtaining of the chroma residual joint flag of the current block may include obtaining the chroma residual joint flag of the current block, when the chroma residual joint enable flag indicates that the chroma residual joint mode is enabled for the upper-level unit of the current block.</p><p id="p-0015" num="0014">According to an embodiment, the upper-level unit may be at least one of a video, a coded video sequence (CVS), a picture, a sub-picture, a slice, a tile, and a coding tree unit.</p><p id="p-0016" num="0015">According to an embodiment, the first chroma component and the second chroma component may be a Cb component and a Cr component respectively, or a Cr component and a Cb component respectively.</p><p id="p-0017" num="0016">The present disclosure provides a video encoding method including: encoding a chroma residual joint flag of a current block indicating whether or not a chroma residual joint mode is applied to the current block; encoding a transform skip mode flag for a luma component of the current block and a transform skip mode flag for a first chroma component of the current block; skipping encoding of a transform skip mode flag for a second chroma component of the current block, when the chroma residual joint mode is applied to the current block; and encoding the transform skip mode flag for the second chroma component of the current block, when the chroma residual joint mode is not applied to the current block.</p><p id="p-0018" num="0017">According to an embodiment, the video encoding method may further include determining whether or not the chroma residual joint mode is applied to the current block, according to a residual sample for the first chroma component of the current block and a residual sample for the second chroma component of the current block.</p><p id="p-0019" num="0018">According to an embodiment, when the chroma residual joint mode is applied to the current block, the video encoding method may further include encoding chroma residual joint sign information indicating a relation between a sign of the residual sample for the first chroma component and a sign of the residual sample for the second chroma component according to the residual sample for the first chroma component of the current block and the residual sample for the second chroma component of the current block.</p><p id="p-0020" num="0019">According to an embodiment, the encoding of the transform skip mode flag for the luma component of the current block and the transform skip mode flag for the first chroma component of the current block may include: encoding the transform skip mode flag for the luma component of the current block according to a size of the current block; and encoding the transform skip mode flag for the first chroma component of the current block according to the size of the current block.</p><p id="p-0021" num="0020">According to an embodiment, the encoding of the transform skip mode flag for the luma component of the current block according to the size of the current block may include encoding the transform skip mode flag for the luma component of the current block, when a height of the current block is equal to or less than a maximum block height and a width of the current block is equal to or less than a maximum block width.</p><p id="p-0022" num="0021">According to an embodiment, the encoding of the transform skip mode flag for the first chroma component of the current block according to the size of the current block may include encoding the transform skip mode flag for the first chroma component of the current block according to the size and a color format of the current block.</p><p id="p-0023" num="0022">According to an embodiment, the video decoding method may further include encoding a chroma residual joint enable flag indicating whether or not a chroma residual joint mode is enabled for an upper-level unit of the current block. The encoding of the chroma residual joint flag of the current block may include encoding the chroma residual joint flag of the current block, when the chroma residual joint enable flag indicates that the chroma residual joint mode is enabled for the upper-level unit of the current block.</p><p id="p-0024" num="0023">According to an embodiment, the upper-level unit may be at least one of a video, a coded video sequence (CVS), a picture, a sub-picture, a slice, a tile, and a coding tree unit.</p><p id="p-0025" num="0024">According to an embodiment, the first chroma component and the second chroma component may be a Cb component and a Cr component respectively, or a Cr component and a Cb component respectively.</p><p id="p-0026" num="0025">The present disclosure provides a computer-readable recording medium for storing a bitstream including image data that are encoded according to a video encoding method. Herein, the bitstream includes: a chroma residual joint flag of a current block indicating whether or not a chroma residual joint mode is applied to the current block; a transform skip mode flag for a luma component of the current block; and a transform skip mode flag for a first chroma component of the current block. Herein, when the chroma residual joint flag indicates that the chroma residual joint mode is not applied to the current block, the bitstream further includes a transform skip mode flag for a second chroma component of the current block. When the chroma residual joint flag indicates that the chroma residual joint mode is applied to the current block, the transform skip mode flag for the second chroma component of the current block is skipped in the bitstream. Whether or not a transform skip mode is applied to the second chroma component of the current block is determined according to the transform skip mode flag for the first chroma component.</p><heading id="h-0006" level="1">Advantageous Effects</heading><p id="p-0027" num="0026">According to the present disclosure, an image encoding/decoding method and apparatus with enhanced compression efficiency and a recoding medium storing a bitstream that is generated by the video encoding/decoding method and apparatus of the present disclosure may be provided.</p><p id="p-0028" num="0027">According to the present disclosure, an image encoding/decoding method and apparatus, which improve compression efficiency by using a transform skip mode, and a recording medium for storing a bitstream may also be provided.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0007" level="1">DESCRIPTION OF DRAWINGS</heading><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram showing a configuration of an encoding apparatus according to an embodiment to which the present invention is applied.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram showing a configuration of a decoding apparatus according to an embodiment and to which the present invention is applied.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a view schematically showing a partition structure of an image when encoding and decoding the image.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a view showing an intra-prediction process.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a diagram illustrating an embodiment of an inter-picture prediction process.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a diagram illustrating a transform and quantization process.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a diagram illustrating reference samples capable of being used for intra prediction.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is view showing an encoding/decoding method according to an embodiment of the present disclosure.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates a video decoding method according to an embodiment of the present disclosure.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a video encoding method according to an embodiment of the present disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0008" level="1">BEST MODE</heading><p id="p-0039" num="0038">The present disclosure provides a video decoding method including: obtaining a chroma residual joint flag of a current block indicating whether or not a chroma residual joint mode is applied to the current block; obtaining, from a bitstream, a transform skip mode flag for a luma component of the current block and a transform skip mode flag for a first chroma component; when the chroma residual joint flag indicates that a chroma residual joint mode is applied to the current block, determining whether or not a transform skip mode is applied to a second chroma component of the current block, according to the transform skip mode flag for the first chroma component; and, when the chroma residual joint flag indicates that a chroma residual joint mode is not applied to the current block, obtaining, from the bitstream, a transform skip mode flag for the second chroma component of the current block.</p><heading id="h-0009" level="1">MODE FOR INVENTION</heading><p id="p-0040" num="0039">A variety of modifications may be made to the present invention and there are various embodiments of the present invention, examples of which will now be provided with reference to drawings and described in detail. However, the present invention is not limited thereto, although the exemplary embodiments can be construed as including all modifications, equivalents, or substitutes in a technical concept and a technical scope of the present invention. The similar reference numerals refer to the same or similar functions in various aspects. In the drawings, the shapes and dimensions of elements may be exaggerated for clarity. In the following detailed description of the present invention, references are made to the accompanying drawings that show, by way of illustration, specific embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to implement the present disclosure. It should be understood that various embodiments of the present disclosure, although different, are not necessarily mutually exclusive. For example, specific features, structures, and characteristics described herein, in connection with one embodiment, may be implemented within other embodiments without departing from the spirit and scope of the present disclosure. In addition, it should be understood that the location or arrangement of individual elements within each disclosed embodiment may be modified without departing from the spirit and scope of the present disclosure. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present disclosure is defined only by the appended claims, appropriately interpreted, along with the full range of equivalents to what the claims claim.</p><p id="p-0041" num="0040">Terms used in the specification, &#x2018;first&#x2019;, &#x2018;second&#x2019;, etc. can be used to describe various components, but the components are not to be construed as being limited to the terms. The terms are only used to differentiate one component from other components. For example, the &#x2018;first&#x2019; component may be named the &#x2018;second&#x2019; component without departing from the scope of the present invention, and the &#x2018;second&#x2019; component may also be similarly named the &#x2018;first&#x2019; component. The term &#x2018;and/or&#x2019; includes a combination of a plurality of items or any one of a plurality of terms.</p><p id="p-0042" num="0041">It will be understood that when an element is simply referred to as being &#x2018;connected to&#x2019; or &#x2018;coupled to&#x2019; another element without being &#x2018;directly connected to&#x2019; or &#x2018;directly coupled to&#x2019; another element in the present description, it may be &#x2018;directly connected to&#x2019; or &#x2018;directly coupled to&#x2019; another element or be connected to or coupled to another element, having the other element intervening therebetween. In contrast, it should be understood that when an element is referred to as being &#x201c;directly coupled&#x201d; or &#x201c;directly connected&#x201d; to another element, there are no intervening elements present.</p><p id="p-0043" num="0042">Furthermore, constitutional parts shown in the embodiments of the present invention are independently shown so as to represent characteristic functions different from each other. Thus, it does not mean that each constitutional part is constituted in a constitutional unit of separated hardware or software. In other words, each constitutional part includes each of enumerated constitutional parts for convenience. Thus, at least two constitutional parts of each constitutional part may be combined to form one constitutional part or one constitutional part may be divided into a plurality of constitutional parts to perform each function. The embodiment where each constitutional part is combined and the embodiment where one constitutional part is divided are also included in the scope of the present invention, if not departing from the essence of the present invention.</p><p id="p-0044" num="0043">The terms used in the present specification are merely used to describe particular embodiments, and are not intended to limit the present invention. An expression used in the singular encompasses the expression of the plural, unless it has a clearly different meaning in the context. In the present specification, it is to be understood that terms such as &#x201c;including&#x201d;, &#x201c;having&#x201d;, etc. are intended to indicate the existence of the features, numbers, steps, actions, elements, parts, or combinations thereof disclosed in the specification, and are not intended to preclude the possibility that one or more other features, numbers, steps, actions, elements, parts, or combinations thereof may exist or may be added. In other words, when a specific element is referred to as being &#x201c;included&#x201d;, elements other than the corresponding element are not excluded, but additional elements may be included in embodiments of the present invention or the scope of the present invention.</p><p id="p-0045" num="0044">In addition, some of constituents may not be indispensable constituents performing essential functions of the present invention but be selective constituents improving only performance thereof. The present invention may be implemented by including only the indispensable constitutional parts for implementing the essence of the present invention except the constituents used in improving performance. The structure including only the indispensable constituents except the selective constituents used in improving only performance is also included in the scope of the present invention.</p><p id="p-0046" num="0045">Hereinafter, embodiments of the present invention will be described in detail with reference to the accompanying drawings. In describing exemplary embodiments of the present invention, well-known functions or constructions will not be described in detail since they may unnecessarily obscure the understanding of the present invention. The same constituent elements in the drawings are denoted by the same reference numerals, and a repeated description of the same elements will be omitted.</p><p id="p-0047" num="0046">Hereinafter, an image may mean a picture configuring a video, or may mean the video itself. For example, &#x201c;encoding or decoding or both of an image&#x201d; may mean &#x201c;encoding or decoding or both of a moving picture&#x201d;, and may mean &#x201c;encoding or decoding or both of one image among images of a moving picture.&#x201d;</p><p id="p-0048" num="0047">Hereinafter, terms &#x201c;moving picture&#x201d; and &#x201c;video&#x201d; may be used as the same meaning and be replaced with each other.</p><p id="p-0049" num="0048">Hereinafter, a target image may be an encoding target image which is a target of encoding and/or a decoding target image which is a target of decoding. Also, a target image may be an input image inputted to an encoding apparatus, and an input image inputted to a decoding apparatus. Here, a target image may have the same meaning with the current image.</p><p id="p-0050" num="0049">Hereinafter, terms &#x201c;image&#x201d;, &#x201c;picture, &#x201c;frame&#x201d; and &#x201c;screen&#x201d; may be used as the same meaning and be replaced with each other.</p><p id="p-0051" num="0050">Hereinafter, a target block may be an encoding target block which is a target of encoding and/or a decoding target block which is a target of decoding. Also, a target block may be the current block which is a target of current encoding and/or decoding. For example, terms &#x201c;target block&#x201d; and &#x201c;current block&#x201d; may be used as the same meaning and be replaced with each other.</p><p id="p-0052" num="0051">Hereinafter, terms &#x201c;block&#x201d; and &#x201c;unit&#x201d; may be used as the same meaning and be replaced with each other. Or a &#x201c;block&#x201d; may represent a specific unit.</p><p id="p-0053" num="0052">Hereinafter, terms &#x201c;region&#x201d; and &#x201c;segment&#x201d; may be replaced with each other.</p><p id="p-0054" num="0053">Hereinafter, a specific signal may be a signal representing a specific block. For example, an original signal may be a signal representing a target block. A prediction signal may be a signal representing a prediction block. A residual signal may be a signal representing a residual block.</p><p id="p-0055" num="0054">In embodiments, each of specific information, data, flag, index, element and attribute, etc. may have a value. A value of information, data, flag, index, element and attribute equal to &#x201c;0&#x201d; may represent a logical false or the first predefined value. In other words, a value &#x201c;0&#x201d;, a false, a logical false and the first predefined value may be replaced with each other. A value of information, data, flag, index, element and attribute equal to &#x201c;1&#x201d; may represent a logical true or the second predefined value. In other words, a value &#x201c;1&#x201d;, a true, a logical true and the second predefined value may be replaced with each other.</p><p id="p-0056" num="0055">When a variable i or j is used for representing a column, a row or an index, a value of i may be an integer equal to or greater than 0, or equal to or greater than 1. That is, the column, the row, the index, etc. may be counted from 0 or may be counted from 1.</p><heading id="h-0010" level="1">Description of Terms</heading><p id="p-0057" num="0056">Encoder: means an apparatus performing encoding. That is, means an encoding apparatus.</p><p id="p-0058" num="0057">Decoder: means an apparatus performing decoding. That is, means a decoding apparatus.</p><p id="p-0059" num="0058">Block: is an M&#xd7;N array of a sample. Herein, M and N may mean positive integers, and the block may mean a sample array of a two-dimensional form. The block may refer to a unit. A current block my mean an encoding target block that becomes a target when encoding, or a decoding target block that becomes a target when decoding. In addition, the current block may be at least one of an encode block, a prediction block, a residual block, and a transform block.</p><p id="p-0060" num="0059">Sample: is a basic unit constituting a block. It may be expressed as a value from 0 to 2Bd&#x2212;1 according to a bit depth (Bd). In the present invention, the sample may be used as a meaning of a pixel. That is, a sample, a pel, a pixel may have the same meaning with each other.</p><p id="p-0061" num="0060">Unit: may refer to an encoding and decoding unit. When encoding and decoding an image, the unit may be a region generated by partitioning a single image. In addition, the unit may mean a subdivided unit when a single image is partitioned into subdivided units during encoding or decoding. That is, an image may be partitioned into a plurality of units. When encoding and decoding an image, a predetermined process for each unit may be performed. A single unit may be partitioned into sub-units that have sizes smaller than the size of the unit. Depending on functions, the unit may mean a block, a macroblock, a coding tree unit, a code tree block, a coding unit, a coding block), a prediction unit, a prediction block, a residual unit), a residual block, a transform unit, a transform block, etc. In addition, in order to distinguish a unit from a block, the unit may include a luma component block, a chroma component block associated with the luma component block, and a syntax element of each color component block. The unit may have various sizes and forms, and particularly, the form of the unit may be a two-dimensional geometrical figure such as a square shape, a rectangular shape, a trapezoid shape, a triangular shape, a pentagonal shape, etc. In addition, unit information may include at least one of a unit type indicating the coding unit, the prediction unit, the transform unit, etc., and a unit size, a unit depth, a sequence of encoding and decoding of a unit, etc.</p><p id="p-0062" num="0061">Coding Tree Unit: is configured with a single coding tree block of a luma component Y, and two coding tree blocks related to chroma components Cb and Cr. In addition, it may mean that including the blocks and a syntax element of each block. Each coding tree unit may be partitioned by using at least one of a quad-tree partitioning method, a binary-tree partitioning method and ternary-tree partitioning method to configure a lower unit such as coding unit, prediction unit, transform unit, etc. It may be used as a term for designating a sample block that becomes a process unit when encoding/decoding an image as an input image. Here, the quad-tree may mean a quarternary-tree.</p><p id="p-0063" num="0062">When the size of the coding block is within a predetermined range, the division is possible using only quad-tree partitioning. Here, the predetermined range may be defined as at least one of a maximum size and a minimum size of a coding block in which the division is possible using only quad-tree partitioning. Information indicating a maximum/minimum size of a coding block in which quad-tree partitioning is allowed may be signaled through a bitstream, and the information may be signaled in at least one unit of a sequence, a picture parameter, a tile group, or a slice (segment). Alternatively, the maximum/minimum size of the coding block may be a fixed size predetermined in the coder/decoder. For example, when the size of the coding block corresponds to 256&#xd7;256 to 64&#xd7;64, the division is possible only using quad-tree partitioning. Alternatively, when the size of the coding block is larger than the size of the maximum conversion block, the division is possible only using quad-tree partitioning. Herein, the block to be divided may be at least one of a coding block and a transform block. In this case, information indicating the division of the coded block (for example, split_flag) may be a flag indicating whether or not to perform the quad-tree partitioning. When the size of the coding block falls within a predetermined range, the division is possible only using binary tree or ternary tree partitioning. In this case, the above description of the quad-tree partitioning may be applied to binary tree partitioning or ternary tree partitioning in the same manner.</p><p id="p-0064" num="0063">Coding Tree Block: may be used as a term for designating any one of a Y coding tree block, Cb coding tree block, and Cr coding tree block.</p><p id="p-0065" num="0064">Neighbor Block: may mean a block adjacent to a current block. The block adjacent to the current block may mean a block that comes into contact with a boundary of the current block, or a block positioned within a predetermined distance from the current block. The neighbor block may mean a block adjacent to a vertex of the current block. Herein, the block adjacent to the vertex of the current block may mean a block vertically adjacent to a neighbor block that is horizontally adjacent to the current block, or a block horizontally adjacent to a neighbor block that is vertically adjacent to the current block.</p><p id="p-0066" num="0065">Reconstructed Neighbor block: may mean a neighbor block adjacent to a current block and which has been already spatially/temporally encoded or decoded. Herein, the reconstructed neighbor block may mean a reconstructed neighbor unit. A reconstructed spatial neighbor block may be a block within a current picture and which has been already reconstructed through encoding or decoding or both. A reconstructed temporal neighbor block is a block at a corresponding position as the current block of the current picture within a reference image, or a neighbor block thereof.</p><p id="p-0067" num="0066">Unit Depth: may mean a partitioned degree of a unit. In a tree structure, the highest node (Root Node) may correspond to the first unit which is not partitioned. Also, the highest node may have the least depth value. In this case, the highest node may have a depth of level 0. A node having a depth of level 1 may represent a unit generated by partitioning once the first unit. A node having a depth of level 2 may represent a unit generated by partitioning twice the first unit. A node having a depth of level n may represent a unit generated by partitioning n-times the first unit. A Leaf Node may be the lowest node and a node which cannot be partitioned further. A depth of a Leaf Node may be the maximum level. For example, a predefined value of the maximum level may be 3. A depth of a root node may be the lowest and a depth of a leaf node may be the deepest. In addition, when a unit is expressed as a tree structure, a level in which a unit is present may mean a unit depth.</p><p id="p-0068" num="0067">Bitstream: may mean a bitstream including encoding image information.</p><p id="p-0069" num="0068">Parameter Set: corresponds to header information among a configuration within a bitstream. At least one of a video parameter set, a sequence parameter set, a picture parameter set, and an adaptation parameter set may be included in a parameter set. In addition, a parameter set may include a slice header, a tile group header, and tile header information. The term &#x201c;tile group&#x201d; means a group of tiles and has the same meaning as a slice.</p><p id="p-0070" num="0069">An adaptation parameter set may mean a parameter set that can be shared by being referred to in different pictures, subpictures, slices, tile groups, tiles, or bricks. In addition, information in an adaptation parameter set may be used by referring to different adaptation parameter sets for a subpicture, a slice, a tile group, a tile, or a brick inside a picture.</p><p id="p-0071" num="0070">In addition, regarding the adaptation parameter set, different adaptation parameter sets may be referred to by using identifiers of different adaptation parameter sets for a subpicture, a slice, a tile group, a tile, or a brick inside a picture.</p><p id="p-0072" num="0071">In addition, regarding the adaptation parameter set, different adaptation parameter sets may be referred to by using identifiers of different adaptation parameter sets for a slice, a tile group, a tile, or a brick inside a subpicture.</p><p id="p-0073" num="0072">In addition, regarding the adaptation parameter set, different adaptation parameter sets may be referred to by using identifiers of different adaptation parameter sets for a tile or a brick inside a slice.</p><p id="p-0074" num="0073">In addition, regarding the adaptation parameter set, different adaptation parameter sets may be referred to by using identifiers of different adaptation parameter sets for a brick inside a tile.</p><p id="p-0075" num="0074">Information on an adaptation parameter set identifier may be included in a parameter set or a header of the subpicture, and an adaptation parameter set corresponding to the adaptation parameter set identifier may be used for the subpicture.</p><p id="p-0076" num="0075">The information on the adaptation parameter set identifier may be included in a parameter set or a header of the tile, and an adaptation parameter set corresponding to the adaptation parameter set identifier may be used for the tile.</p><p id="p-0077" num="0076">The information on the adaptation parameter set identifier may be included in a header of the brick, and an adaptation parameter set corresponding to the adaptation parameter set identifier may be used for the brick.</p><p id="p-0078" num="0077">The picture may be partitioned into one or more tile rows and one or more tile columns.</p><p id="p-0079" num="0078">The subpicture may be partitioned into one or more tile rows and one or more tile columns within a picture. The subpicture may be a region having the form of a rectangle/square within a picture and may include one or more CTUs. In addition, at least one or more tiles/bricks/slices may be included within one subpicture.</p><p id="p-0080" num="0079">The tile may be a region having the form of a rectangle/square within a picture and may include one or more CTUs. In addition, the tile may be partitioned into one or more bricks.</p><p id="p-0081" num="0080">The brick may mean one or more CTU rows within a tile. The tile may be partitioned into one or more bricks, and each brick may have at least one or more CTU rows. A tile that is not partitioned into two or more may mean a brick.</p><p id="p-0082" num="0081">The slice may include one or more tiles within a picture and may include one or more bricks within a tile.</p><p id="p-0083" num="0082">Parsing: may mean determination of a value of a syntax element by performing entropy decoding, or may mean the entropy decoding itself.</p><p id="p-0084" num="0083">Symbol: may mean at least one of a syntax element, a coding parameter, and a transform coefficient value of an encoding/decoding target unit. In addition, the symbol may mean an entropy encoding target or an entropy decoding result.</p><p id="p-0085" num="0084">Prediction Mode: may be information indicating a mode encoded/decoded with intra prediction or a mode encoded/decoded with inter prediction.</p><p id="p-0086" num="0085">Prediction Unit: may mean a basic unit when performing prediction such as inter-prediction, intra-prediction, inter-compensation, intra-compensation, and motion compensation. A single prediction unit may be partitioned into a plurality of partitions having a smaller size, or may be partitioned into a plurality of lower prediction units. A plurality of partitions may be a basic unit in performing prediction or compensation. A partition which is generated by dividing a prediction unit may also be a prediction unit.</p><p id="p-0087" num="0086">Prediction Unit Partition: may mean a form obtained by partitioning a prediction unit.</p><p id="p-0088" num="0087">Reference picture list may refer to a list including one or more reference pictures used for inter prediction or motion compensation. There are several types of usable reference picture lists, including LC (List combined), L0 (List 0), L1 (List 1), L2 (List 2), L3 (List 3).</p><p id="p-0089" num="0088">Inter prediction indicator may refer to a direction of inter prediction (unidirectional prediction, bidirectional prediction, etc.) of a current block. Alternatively, it may refer to the number of reference pictures used to generate a prediction block of a current block. Alternatively, it may refer to the number of prediction blocks used at the time of performing inter prediction or motion compensation on a current block.</p><p id="p-0090" num="0089">Prediction list utilization flag indicates whether a prediction block is generated using at least one reference picture in a specific reference picture list. An inter prediction indicator can be derived using a prediction list utilization flag, and conversely, a prediction list utilization flag can be derived using an inter prediction indicator. For example, when the prediction list utilization flag has a first value of zero (0), it means that a reference picture in a reference picture list is not used to generate a prediction block. On the other hand, when the prediction list utilization flag has a second value of one (1), it means that a reference picture list is used to generate a prediction block.</p><p id="p-0091" num="0090">Reference picture index may refer to an index indicating a specific reference picture in a reference picture list.</p><p id="p-0092" num="0091">Reference picture may mean a reference picture which is referred to by a specific block for the purposes of inter prediction or motion compensation of the specific block. Alternatively, the reference picture may be a picture including a reference block referred to by a current block for inter prediction or motion compensation. Hereinafter, the terms &#x201c;reference picture&#x201d; and &#x201c;reference image&#x201d; have the same meaning and can be interchangeably.</p><p id="p-0093" num="0092">Motion vector may be a two-dimensional vector used for inter prediction or motion compensation. The motion vector may mean an offset between an encoding/decoding target block and a reference block. For example, (mvX, mvY) may represent a motion vector. Here, mvX may represent a horizontal component and mvY may represent a vertical component.</p><p id="p-0094" num="0093">Search range may be a two-dimensional region which is searched to retrieve a motion vector during inter prediction. For example, the size of the search range may be M&#xd7;N. Here, M and N are both integers.</p><p id="p-0095" num="0094">Motion vector candidate may refer to a prediction candidate block or a motion vector of the prediction candidate block when predicting a motion vector. In addition, a motion vector candidate may be included in a motion vector candidate list.</p><p id="p-0096" num="0095">Motion vector candidate list may mean a list composed of one or more motion vector candidates.</p><p id="p-0097" num="0096">Motion vector candidate index may mean an indicator indicating a motion vector candidate in a motion vector candidate list. Alternatively, it may be an index of a motion vector predictor.</p><p id="p-0098" num="0097">Motion information may mean information including at least one of the items including a motion vector, a reference picture index, an inter prediction indicator, a prediction list utilization flag, reference picture list information, a reference picture, a motion vector candidate, a motion vector candidate index, a merge candidate, and a merge index.</p><p id="p-0099" num="0098">Merge candidate list may mean a list composed of one or more merge candidates.</p><p id="p-0100" num="0099">Merge candidate may mean a spatial merge candidate, a temporal merge candidate, a combined merge candidate, a combined bi-predictive merge candidate, or a zero merge candidate. The merge candidate may include motion information such as an inter prediction indicator, a reference picture index for each list, a motion vector, a prediction list utilization flag, and an inter prediction indicator.</p><p id="p-0101" num="0100">Merge index may mean an indicator indicating a merge candidate in a merge candidate list. Alternatively, the merge index may indicate a block from which a merge candidate has been derived, among reconstructed blocks spatially/temporally adjacent to a current block. Alternatively, the merge index may indicate at least one piece of motion information of a merge candidate.</p><p id="p-0102" num="0101">Transform Unit: may mean a basic unit when performing encoding/decoding such as transform, inverse-transform, quantization, dequantization, transform coefficient encoding/decoding of a residual signal. A single transform unit may be partitioned into a plurality of lower-level transform units having a smaller size. Here, transformation/inverse-transformation may comprise at least one among the first transformation/the first inverse-transformation and the second transformation/the second inverse-transformation.</p><p id="p-0103" num="0102">Scaling: may mean a process of multiplying a quantized level by a factor. A transform coefficient may be generated by scaling a quantized level. The scaling also may be referred to as dequantization.</p><p id="p-0104" num="0103">Quantization Parameter; may mean a value used when generating a quantized level using a transform coefficient during quantization. The quantization parameter also may mean a value used when generating a transform coefficient by scaling a quantized level during dequantization. The quantization parameter may be a value mapped on a quantization step size.</p><p id="p-0105" num="0104">Delta Quantization Parameter: may mean a difference value between a predicted quantization parameter and a quantization parameter of an encoding/decoding target unit.</p><p id="p-0106" num="0105">Scan: may mean a method of sequencing coefficients within a unit, a block or a matrix. For example, changing a two-dimensional matrix of coefficients into a one-dimensional matrix may be referred to as scanning, and changing a one-dimensional matrix of coefficients into a two-dimensional matrix may be referred to as scanning or inverse scanning.</p><p id="p-0107" num="0106">Transform Coefficient: may mean a coefficient value generated after transform is performed in an encoder. It may mean a coefficient value generated after at least one of entropy decoding and dequantization is performed in a decoder. A quantized level obtained by quantizing a transform coefficient or a residual signal, or a quantized transform coefficient level also may fall within the meaning of the transform coefficient.</p><p id="p-0108" num="0107">Quantized Level: may mean a value generated by quantizing a transform coefficient or a residual signal in an encoder. Alternatively, the quantized level may mean a value that is a dequantization target to undergo dequantization in a decoder. Similarly, a quantized transform coefficient level that is a result of transform and quantization also may fall within the meaning of the quantized level.</p><p id="p-0109" num="0108">Non-zero Transform Coefficient: may mean a transform coefficient having a value other than zero, or a transform coefficient level or a quantized level having a value other than zero.</p><p id="p-0110" num="0109">Quantization Matrix: may mean a matrix used in a quantization process or a dequantization process performed to improve subjective or objective image quality. The quantization matrix also may be referred to as a scaling list.</p><p id="p-0111" num="0110">Quantization Matrix Coefficient: may mean each element within a quantization matrix. The quantization matrix coefficient also may be referred to as a matrix coefficient.</p><p id="p-0112" num="0111">Default Matrix: may mean a predetermined quantization matrix preliminarily defined in an encoder or a decoder.</p><p id="p-0113" num="0112">Non-default Matrix: may mean a quantization matrix that is not preliminarily defined in an encoder or a decoder but is signaled by a user.</p><p id="p-0114" num="0113">Statistic Value: a statistic value for at least one among a variable, a coding parameter, a constant value, etc. which have a computable specific value may be one or more among an average value, a sum value, a weighted average value, a weighted sum value, the minimum value, the maximum value, the most frequent value, a median value, an interpolated value of the corresponding specific values.</p><p id="p-0115" num="0114"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram showing a configuration of an encoding apparatus according to an embodiment to which the present invention is applied.</p><p id="p-0116" num="0115">An encoding apparatus <b>100</b> may be an encoder, a video encoding apparatus, or an image encoding apparatus. A video may include at least one image. The encoding apparatus <b>100</b> may sequentially encode at least one image.</p><p id="p-0117" num="0116">Referring to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the encoding apparatus <b>100</b> may include a motion prediction unit <b>111</b>, a motion compensation unit <b>112</b>, an intra-prediction unit <b>120</b>, a switch <b>115</b>, a subtractor <b>125</b>, a transform unit <b>130</b>, a quantization unit <b>140</b>, an entropy encoding unit <b>150</b>, a dequantization unit <b>160</b>, an inverse-transform unit <b>170</b>, an adder <b>175</b>, a filter unit <b>180</b>, and a reference picture buffer <b>190</b>.</p><p id="p-0118" num="0117">The encoding apparatus <b>100</b> may perform encoding of an input image by using an intra mode or an inter mode or both. In addition, encoding apparatus <b>100</b> may generate a bitstream including encoded information through encoding the input image, and output the generated bitstream. The generated bitstream may be stored in a computer readable recording medium, or may be streamed through a wired/wireless transmission medium. When an intra mode is used as a prediction mode, the switch <b>115</b> may be switched to an intra. Alternatively, when an inter mode is used as a prediction mode, the switch <b>115</b> may be switched to an inter mode. Herein, the intra mode may mean an intra-prediction mode, and the inter mode may mean an inter-prediction mode. The encoding apparatus <b>100</b> may generate a prediction block for an input block of the input image. In addition, the encoding apparatus <b>100</b> may encode a residual block using a residual of the input block and the prediction block after the prediction block being generated. The input image may be called as a current image that is a current encoding target. The input block may be called as a current block that is current encoding target, or as an encoding target block.</p><p id="p-0119" num="0118">When a prediction mode is an intra mode, the intra-prediction unit <b>120</b> may use a sample of a block that has been already encoded/decoded and is adjacent to a current block as a reference sample. The intra-prediction unit <b>120</b> may perform spatial prediction for the current block by using a reference sample, or generate prediction samples of an input block by performing spatial prediction. Herein, the intra prediction may mean intra-prediction,</p><p id="p-0120" num="0119">When a prediction mode is an inter mode, the motion prediction unit <b>111</b> may retrieve a region that best matches with an input block from a reference image when performing motion prediction, and deduce a motion vector by using the retrieved region. In this case, a search region may be used as the region. The reference image may be stored in the reference picture buffer <b>190</b>. Here, when encoding/decoding for the reference image is performed, it may be stored in the reference picture buffer <b>190</b>.</p><p id="p-0121" num="0120">The motion compensation unit <b>112</b> may generate a prediction block by performing motion compensation for the current block using a motion vector. Herein, inter-prediction may mean inter-prediction or motion compensation.</p><p id="p-0122" num="0121">When the value of the motion vector is not an integer, the motion prediction unit <b>111</b> and the motion compensation unit <b>112</b> may generate the prediction block by applying an interpolation filter to a partial region of the reference picture. In order to perform inter-picture prediction or motion compensation on a coding unit, it may be determined that which mode among a skip mode, a merge mode, an advanced motion vector prediction (AMVP) mode, and a current picture referring mode is used for motion prediction and motion compensation of a prediction unit included in the corresponding coding unit. Then, inter-picture prediction or motion compensation may be differently performed depending on the determined mode.</p><p id="p-0123" num="0122">The subtractor <b>125</b> may generate a residual block by using a difference of an input block and a prediction block. The residual block may be called as a residual signal. The residual signal may mean a difference between an original signal and a prediction signal. In addition, the residual signal may be a signal generated by transforming or quantizing, or transforming and quantizing a difference between the original signal and the prediction signal. The residual block may be a residual signal of a block unit.</p><p id="p-0124" num="0123">The transform unit <b>130</b> may generate a transform coefficient by performing transform of a residual block, and output the generated transform coefficient. Herein, the transform coefficient may be a coefficient value generated by performing transform of the residual block. When a transform skip mode is applied, the transform unit <b>130</b> may skip transform of the residual block.</p><p id="p-0125" num="0124">A quantized level may be generated by applying quantization to the transform coefficient or to the residual signal. Hereinafter, the quantized level may be also called as a transform coefficient in embodiments.</p><p id="p-0126" num="0125">The quantization unit <b>140</b> may generate a quantized level by quantizing the transform coefficient or the residual signal according to a parameter, and output the generated quantized level. Herein, the quantization unit <b>140</b> may quantize the transform coefficient by using a quantization matrix.</p><p id="p-0127" num="0126">The entropy encoding unit <b>150</b> may generate a bitstream by performing entropy encoding according to a probability distribution on values calculated by the quantization unit <b>140</b> or on coding parameter values calculated when performing encoding, and output the generated bitstream. The entropy encoding unit <b>150</b> may perform entropy encoding of sample information of an image and information for decoding an image. For example, the information for decoding the image may include a syntax element.</p><p id="p-0128" num="0127">When entropy encoding is applied, symbols are represented so that a smaller number of bits are assigned to a symbol having a high chance of being generated and a larger number of bits are assigned to a symbol having a low chance of being generated, and thus, the size of bit stream for symbols to be encoded may be decreased. The entropy encoding unit <b>150</b> may use an encoding method for entropy encoding such as exponential Golomb, context-adaptive variable length coding (CAVLC), context-adaptive binary arithmetic coding (CABAC), etc. For example, the entropy encoding unit <b>150</b> may perform entropy encoding by using a variable length coding/code (VLC) table. In addition, the entropy encoding unit <b>150</b> may deduce a binarization method of a target symbol and a probability model of a target symbol/bin, and perform arithmetic coding by using the deduced binarization method, and a context model.</p><p id="p-0129" num="0128">In order to encode a transform coefficient level (quantized level), the entropy encoding unit <b>150</b> may change a two-dimensional block form coefficient into a one-dimensional vector form by using a transform coefficient scanning method.</p><p id="p-0130" num="0129">A coding parameter may include information (flag, index, etc.) such as syntax element that is encoded in an encoder and signaled to a decoder, and information derived when performing encoding or decoding. The coding parameter may mean information required when encoding or decoding an image. For example, at least one value or a combination form of a unit/block size, a unit/block depth, unit/block partition information, unit/block shape, unit/block partition structure, whether to partition of a quad-tree form, whether to partition of a binary-tree form, a partition direction of a binary-tree form (horizontal direction or vertical direction), a partition form of a binary-tree form (symmetric partition or asymmetric partition), whether or not a current coding unit is partitioned by ternary tree partitioning, direction (horizontal or vertical direction) of the ternary tree partitioning, type (symmetric or asymmetric type) of the ternary tree partitioning, whether a current coding unit is partitioned by multi-type tree partitioning, direction (horizontal or vertical direction) of the multi-type three partitioning, type (symmetric or asymmetric type) of the multi-type tree partitioning, and a tree (binary tree or ternary tree) structure of the multi-type tree partitioning, a prediction mode (intra prediction or inter prediction), a luma intra-prediction mode/direction, a chroma intra-prediction mode/direction, intra partition information, inter partition information, a coding block partition flag, a prediction block partition flag, a transform block partition flag, a reference sample filtering method, a reference sample filter tab, a reference sample filter coefficient, a prediction block filtering method, a prediction block filter tap, a prediction block filter coefficient, a prediction block boundary filtering method, a prediction block boundary filter tab, a prediction block boundary filter coefficient, an intra-prediction mode, an inter-prediction mode, motion information, a motion vector, a motion vector difference, a reference picture index, a inter-prediction angle, an inter-prediction indicator, a prediction list utilization flag, a reference picture list, a reference picture, a motion vector predictor index, a motion vector predictor candidate, a motion vector candidate list, whether to use a merge mode, a merge index, a merge candidate, a merge candidate list, whether to use a skip mode, an interpolation filter type, an interpolation filter tab, an interpolation filter coefficient, a motion vector size, a presentation accuracy of a motion vector, a transform type, a transform size, information of whether or not a primary (first) transform is used, information of whether or not a secondary transform is used, a primary transform index, a secondary transform index, information of whether or not a residual signal is present, a coded block pattern, a coded block flag (CBF), a quantization parameter, a quantization parameter residue, a quantization matrix, whether to apply an intra loop filter, an intra loop filter coefficient, an intra loop filter tab, an intra loop filter shape/form, whether to apply a deblocking filter, a deblocking filter coefficient, a deblocking filter tab, a deblocking filter strength, a deblocking filter shape/form, whether to apply an adaptive sample offset, an adaptive sample offset value, an adaptive sample offset category, an adaptive sample offset type, whether to apply an adaptive in-loop filter, an adaptive in-loop filter coefficient, an adaptive in-loop filter tab, an adaptive in-loop filter shape/form, a binarization/inverse-binarization method, a context model determining method, a context model updating method, whether to perform a regular mode, whether to perform a bypass mode, a context bin, a bypass bin, a significant coefficient flag, a last significant coefficient flag, a coded flag for a unit of a coefficient group, a position of the last significant coefficient, a flag for whether a value of a coefficient is larger than 1, a flag for whether a value of a coefficient is larger than 2, a flag for whether a value of a coefficient is larger than 3, information on a remaining coefficient value, a sign information, a reconstructed luma sample, a reconstructed chroma sample, a residual luma sample, a residual chroma sample, a luma transform coefficient, a chroma transform coefficient, a quantized luma level, a quantized chroma level, a transform coefficient level scanning method, a size of a motion vector search area at a decoder side, a shape of a motion vector search area at a decoder side, a number of time of a motion vector search at a decoder side, information on a CTU size, information on a minimum block size, information on a maximum block size, information on a maximum block depth, information on a minimum block depth, an image displaying/outputting sequence, slice identification information, a slice type, slice partition information, tile identification information, a tile type, tile partition information, tile group identification information, a tile group type, tile group partition information, a picture type, a bit depth of an input sample, a bit depth of a reconstruction sample, a bit depth of a residual sample, a bit depth of a transform coefficient, a bit depth of a quantized level, and information on a luma signal or information on a chroma signal may be included in the coding parameter.</p><p id="p-0131" num="0130">Herein, signaling the flag or index may mean that a corresponding flag or index is entropy encoded and included in a bitstream by an encoder, and may mean that the corresponding flag or index is entropy decoded from a bitstream by a decoder.</p><p id="p-0132" num="0131">When the encoding apparatus <b>100</b> performs encoding through inter-prediction, an encoded current image may be used as a reference image for another image that is processed afterwards. Accordingly, the encoding apparatus <b>100</b> may reconstruct or decode the encoded current image, or store the reconstructed or decoded image as a reference image in reference picture buffer <b>190</b>.</p><p id="p-0133" num="0132">A quantized level may be dequantized in the dequantization unit <b>160</b>, or may be inverse-transformed in the inverse-transform unit <b>170</b>. A dequantized or inverse-transformed coefficient or both may be added with a prediction block by the adder <b>175</b>. By adding the dequantized or inverse-transformed coefficient or both with the prediction block, a reconstructed block may be generated. Herein, the dequantized or inverse-transformed coefficient or both may mean a coefficient on which at least one of dequantization and inverse-transform is performed, and may mean a reconstructed residual block.</p><p id="p-0134" num="0133">A reconstructed block may pass through the filter unit <b>180</b>. The filter unit <b>180</b> may apply at least one of a deblocking filter, a sample adaptive offset (SAO), and an adaptive in-loop filter (ALF) to a reconstructed sample, a reconstructed block or a reconstructed image. The filter unit <b>180</b> may be called as an in-loop filter.</p><p id="p-0135" num="0134">The deblocking filter may remove block distortion generated in boundaries between blocks. In order to determine whether or not to apply a deblocking filter, whether or not to apply a deblocking filter to a current block may be determined based samples included in several rows or columns which are included in the block. When a deblocking filter is applied to a block, another filter may be applied according to a required deblocking filtering strength.</p><p id="p-0136" num="0135">In order to compensate an encoding error, a proper offset value may be added to a sample value by using a sample adaptive offset. The sample adaptive offset may correct an offset of a deblocked image from an original image by a sample unit. A method of partitioning samples of an image into a predetermined number of regions, determining a region to which an offset is applied, and applying the offset to the determined region, or a method of applying an offset in consideration of edge information on each sample may be used.</p><p id="p-0137" num="0136">The adaptive in-loop filter may perform filtering based on a comparison result of the filtered reconstructed image and the original image. Samples included in an image may be partitioned into predetermined groups, a filter to be applied to each group may be determined, and differential filtering may be performed for each group. Information of whether or not to apply the ALF may be signaled by coding units (CUs), and a form and coefficient of the ALF to be applied to each block may vary.</p><p id="p-0138" num="0137">The reconstructed block or the reconstructed image having passed through the filter unit <b>180</b> may be stored in the reference picture buffer <b>190</b>. A reconstructed block processed by the filter unit <b>180</b> may be a part of a reference image. That is, a reference image is a reconstructed image composed of reconstructed blocks processed by the filter unit <b>180</b>. The stored reference image may be used later in inter prediction or motion compensation.</p><p id="p-0139" num="0138"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram showing a configuration of a decoding apparatus according to an embodiment and to which the present invention is applied.</p><p id="p-0140" num="0139">A decoding apparatus <b>200</b> may a decoder, a video decoding apparatus, or an image decoding apparatus.</p><p id="p-0141" num="0140">Referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the decoding apparatus <b>200</b> may include an entropy decoding unit <b>210</b>, a dequantization unit <b>220</b>, an inverse-transform unit <b>230</b>, an intra-prediction unit <b>240</b>, a motion compensation unit <b>250</b>, an adder <b>255</b>, a filter unit <b>260</b>, and a reference picture buffer <b>270</b>.</p><p id="p-0142" num="0141">The decoding apparatus <b>200</b> may receive a bitstream output from the encoding apparatus <b>100</b>. The decoding apparatus <b>200</b> may receive a bitstream stored in a computer readable recording medium, or may receive a bitstream that is streamed through a wired/wireless transmission medium. The decoding apparatus <b>200</b> may decode the bitstream by using an intra mode or an inter mode. In addition, the decoding apparatus <b>200</b> may generate a reconstructed image generated through decoding or a decoded image, and output the reconstructed image or decoded image.</p><p id="p-0143" num="0142">When a prediction mode used when decoding is an intra mode, a switch may be switched to an intra. Alternatively, when a prediction mode used when decoding is an inter mode, a switch may be switched to an inter mode.</p><p id="p-0144" num="0143">The decoding apparatus <b>200</b> may obtain a reconstructed residual block by decoding the input bitstream, and generate a prediction block. When the reconstructed residual block and the prediction block are obtained, the decoding apparatus <b>200</b> may generate a reconstructed block that becomes a decoding target by adding the reconstructed residual block with the prediction block. The decoding target block may be called a current block.</p><p id="p-0145" num="0144">The entropy decoding unit <b>210</b> may generate symbols by entropy decoding the bitstream according to a probability distribution. The generated symbols may include a symbol of a quantized level form. Herein, an entropy decoding method may be an inverse-process of the entropy encoding method described above.</p><p id="p-0146" num="0145">In order to decode a transform coefficient level (quantized level), the entropy decoding unit <b>210</b> may change a one-directional vector form coefficient into a two-dimensional block form by using a transform coefficient scanning method.</p><p id="p-0147" num="0146">A quantized level may be dequantized in the dequantization unit <b>220</b>, or inverse-transformed in the inverse-transform unit <b>230</b>. The quantized level may be a result of dequantizing or inverse-transforming or both, and may be generated as a reconstructed residual block. Herein, the dequantization unit <b>220</b> may apply a quantization matrix to the quantized level.</p><p id="p-0148" num="0147">When an intra mode is used, the intra-prediction unit <b>240</b> may generate a prediction block by performing, for the current block, spatial prediction that uses a sample value of a block adjacent to a decoding target block and which has been already decoded.</p><p id="p-0149" num="0148">When an inter mode is used, the motion compensation unit <b>250</b> may generate a prediction block by performing, for the current block, motion compensation that uses a motion vector and a reference image stored in the reference picture buffer <b>270</b>.</p><p id="p-0150" num="0149">The adder <b>255</b> may generate a reconstructed block by adding the reconstructed residual block with the prediction block. The filter unit <b>260</b> may apply at least one of a deblocking filter, a sample adaptive offset, and an adaptive in-loop filter to the reconstructed block or reconstructed image. The filter unit <b>260</b> may output the reconstructed image. The reconstructed block or reconstructed image may be stored in the reference picture buffer <b>270</b> and used when performing inter-prediction. A reconstructed block processed by the filter unit <b>260</b> may be a part of a reference image. That is, a reference image is a reconstructed image composed of reconstructed blocks processed by the filter unit <b>260</b>. The stored reference image may be used later in inter prediction or motion compensation.</p><p id="p-0151" num="0150"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a view schematically showing a partition structure of an image when encoding and decoding the image. <figref idref="DRAWINGS">FIG. <b>3</b></figref> schematically shows an example of partitioning a single unit into a plurality of lower units.</p><p id="p-0152" num="0151">In order to efficiently partition an image, when encoding and decoding, a coding unit (CU) may be used. The coding unit may be used as a basic unit when encoding/decoding the image. In addition, the coding unit may be used as a unit for distinguishing an intra prediction mode and an inter prediction mode when encoding/decoding the image. The coding unit may be a basic unit used for prediction, transform, quantization, inverse-transform, dequantization, or an encoding/decoding process of a transform coefficient.</p><p id="p-0153" num="0152">Referring to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, an image <b>300</b> is sequentially partitioned in a largest coding unit (LCU), and a LCU unit is determined as a partition structure. Herein, the LCU may be used in the same meaning as a coding tree unit (CTU). A unit partitioning may mean partitioning a block associated with to the unit. In block partition information, information of a unit depth may be included. Depth information may represent a number of times or a degree or both in which a unit is partitioned. A single unit may be partitioned into a plurality of lower level units hierarchically associated with depth information based on a tree structure. In other words, a unit and a lower level unit generated by partitioning the unit may correspond to a node and a child node of the node, respectively. Each of partitioned lower unit may have depth information. Depth information may be information representing a size of a CU, and may be stored in each CU. Unit depth represents times and/or degrees related to partitioning a unit. Therefore, partitioning information of a lower-level unit may comprise information on a size of the lower-level unit.</p><p id="p-0154" num="0153">A partition structure may mean a distribution of a coding unit (CU) within an LCU <b>310</b>. Such a distribution may be determined according to whether or not to partition a single CU into a plurality (positive integer equal to or greater than 2 including 2, 4, 8, 16, etc.) of CUs. A horizontal size and a vertical size of the CU generated by partitioning may respectively be half of a horizontal size and a vertical size of the CU before partitioning, or may respectively have sizes smaller than a horizontal size and a vertical size before partitioning according to a number of times of partitioning. The CU may be recursively partitioned into a plurality of CUs. By the recursive partitioning, at least one among a height and a width of a CU after partitioning may decrease comparing with at least one among a height and a width of a CU before partitioning. Partitioning of the CU may be recursively performed until to a predefined depth or predefined size. For example, a depth of an LCU may be 0, and a depth of a smallest coding unit (SCU) may be a predefined maximum depth. Herein, the LCU may be a coding unit having a maximum coding unit size, and the SCU may be a coding unit having a minimum coding unit size as described above. Partitioning is started from the LCU <b>310</b>, a CU depth increases by 1 as a horizontal size or a vertical size or both of the CU decreases by partitioning. For example, for each depth, a CU which is not partitioned may have a size of 2N&#xd7;2N. Also, in case of a CU which is partitioned, a CU with a size of 2N&#xd7;2N may be partitioned into four CUs with a size of N&#xd7;N. A size of N may decrease to half as a depth increase by 1.</p><p id="p-0155" num="0154">In addition, information whether or not the CU is partitioned may be represented by using partition information of the CU. The partition information may be 1-bit information. All CUs, except for a SCU, may include partition information. For example, when a value of partition information is a first value, the CU may not be partitioned, when a value of partition information is a second value, the CU may be partitioned</p><p id="p-0156" num="0155">Referring to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, an LCU having a depth 0 may be a 64&#xd7;64 block. 0 may be a minimum depth. A SCU having a depth 3 may be an 8&#xd7;8 block. 3 may be a maximum depth. A CU of a 32&#xd7;32 block and a 16&#xd7;16 block may be respectively represented as a depth 1 and a depth 2.</p><p id="p-0157" num="0156">For example, when a single coding unit is partitioned into four coding units, a horizontal size and a vertical size of the four partitioned coding units may be a half size of a horizontal and vertical size of the CU before being partitioned. In one embodiment, when a coding unit having a 32&#xd7;32 size is partitioned into four coding units, each of the four partitioned coding units may have a 16&#xd7;16 size. When a single coding unit is partitioned into four coding units, it may be called that the coding unit may be partitioned into a quad-tree form.</p><p id="p-0158" num="0157">For example, when one coding unit is partitioned into two sub-coding units, the horizontal or vertical size (width or height) of each of the two sub-coding units may be half the horizontal or vertical size of the original coding unit. For example, when a coding unit having a size of 32&#xd7;32 is vertically partitioned into two sub-coding units, each of the two sub-coding units may have a size of 16&#xd7;32. For example, when a coding unit having a size of 8&#xd7;32 is horizontally partitioned into two sub-coding units, each of the two sub-coding units may have a size of 8&#xd7;16. When one coding unit is partitioned into two sub-coding units, it can be said that the coding unit is binary-partitioned or is partitioned by a binary tree partition structure.</p><p id="p-0159" num="0158">For example, when one coding unit is partitioned into three sub-coding units, the horizontal or vertical size of the coding unit can be partitioned with a ratio of 1:2:1, thereby producing three sub-coding units whose horizontal or vertical sizes are in a ratio of 1:2:1. For example, when a coding unit having a size of 16&#xd7;32 is horizontally partitioned into three sub-coding units, the three sub-coding units may have sizes of 16&#xd7;8, 16&#xd7;16, and 16&#xd7;8 respectively, in the order from the uppermost to the lowermost sub-coding unit. For example, when a coding unit having a size of 32&#xd7;32 is vertically split into three sub-coding units, the three sub-coding units may have sizes of 8&#xd7;32, 16&#xd7;32, and 8&#xd7;32, respectively in the order from the left to the right sub-coding unit. When one coding unit is partitioned into three sub-coding units, it can be said that the coding unit is ternary-partitioned or partitioned by a ternary tree partition structure.</p><p id="p-0160" num="0159">In <figref idref="DRAWINGS">FIG. <b>3</b></figref>, a coding tree unit (CTU) <b>320</b> is an example of a CTU to which a quad tree partition structure, a binary tree partition structure, and a ternary tree partition structure are all applied.</p><p id="p-0161" num="0160">As described above, in order to partition the CTU, at least one of a quad tree partition structure, a binary tree partition structure, and a ternary tree partition structure may be applied. Various tree partition structures may be sequentially applied to the CTU, according to a predetermined priority order. For example, the quad tree partition structure may be preferentially applied to the CTU. A coding unit that cannot be partitioned any longer using a quad tree partition structure may correspond to a leaf node of a quad tree. A coding unit corresponding to a leaf node of a quad tree may serve as a root node of a binary and/or ternary tree partition structure. That is, a coding unit corresponding to a leaf node of a quad tree may be further partitioned by a binary tree partition structure or a ternary tree partition structure, or may not be further partitioned. Therefore, by preventing a coding unit that results from binary tree partitioning or ternary tree partitioning of a coding unit corresponding to a leaf node of a quad tree from undergoing further quad tree partitioning, block partitioning and/or signaling of partition information can be effectively performed.</p><p id="p-0162" num="0161">The fact that a coding unit corresponding to a node of a quad tree is partitioned may be signaled using quad partition information. The quad partition information having a first value (e.g., &#x201c;1&#x201d;) may indicate that a current coding unit is partitioned by the quad tree partition structure. The quad partition information having a second value (e.g., &#x201c;0&#x201d;) may indicate that a current coding unit is not partitioned by the quad tree partition structure. The quad partition information may be a flag having a predetermined length (e.g., one bit).</p><p id="p-0163" num="0162">There may not be a priority between the binary tree partitioning and the ternary tree partitioning. That is, a coding unit corresponding to a leaf node of a quad tree may further undergo arbitrary partitioning among the binary tree partitioning and the ternary tree partitioning. In addition, a coding unit generated through the binary tree partitioning or the ternary tree partitioning may undergo a further binary tree partitioning or a further ternary tree partitioning, or may not be further partitioned.</p><p id="p-0164" num="0163">A tree structure in which there is no priority among the binary tree partitioning and the ternary tree partitioning is referred to as a multi-type tree structure. A coding unit corresponding to a leaf node of a quad tree may serve as a root node of a multi-type tree. Whether to partition a coding unit which corresponds to a node of a multi-type tree may be signaled using at least one of multi-type tree partition indication information, partition direction information, and partition tree information. For partitioning of a coding unit corresponding to a node of a multi-type tree, the multi-type tree partition indication information, the partition direction, and the partition tree information may be sequentially signaled.</p><p id="p-0165" num="0164">The multi-type tree partition indication information having a first value (e.g., &#x201c;1&#x201d;) may indicate that a current coding unit is to undergo a multi-type tree partitioning. The multi-type tree partition indication information having a second value (e.g., &#x201c;0&#x201d;) may indicate that a current coding unit is not to undergo a multi-type tree partitioning.</p><p id="p-0166" num="0165">When a coding unit corresponding to a node of a multi-type tree is further partitioned by a multi-type tree partition structure, the coding unit may include partition direction information. The partition direction information may indicate in which direction a current coding unit is to be partitioned for the multi-type tree partitioning. The partition direction information having a first value (e.g., &#x201c;1&#x201d;) may indicate that a current coding unit is to be vertically partitioned. The partition direction information having a second value (e.g., &#x201c;0&#x201d;) may indicate that a current coding unit is to be horizontally partitioned.</p><p id="p-0167" num="0166">When a coding unit corresponding to a node of a multi-type tree is further partitioned by a multi-type tree partition structure, the current coding unit may include partition tree information. The partition tree information may indicate a tree partition structure which is to be used for partitioning of a node of a multi-type tree. The partition tree information having a first value (e.g., &#x201c;1&#x201d;) may indicate that a current coding unit is to be partitioned by a binary tree partition structure. The partition tree information having a second value (e.g., &#x201c;0&#x201d;) may indicate that a current coding unit is to be partitioned by a ternary tree partition structure.</p><p id="p-0168" num="0167">The partition indication information, the partition tree information, and the partition direction information may each be a flag having a predetermined length (e.g., one bit).</p><p id="p-0169" num="0168">At least any one of the quadtree partition indication information, the multi-type tree partition indication information, the partition direction information, and the partition tree information may be entropy encoded/decoded. For the entropy-encoding/decoding of those types of information, information on a neighboring coding unit adjacent to the current coding unit may be used. For example, there is a high probability that the partition type (the partitioned or non-partitioned, the partition tree, and/or the partition direction) of a left neighboring coding unit and/or an upper neighboring coding unit of a current coding unit is similar to that of the current coding unit. Therefore, context information for entropy encoding/decoding of the information on the current coding unit may be derived from the information on the neighboring coding units. The information on the neighboring coding units may include at least any one of quad partition information, multi-type tree partition indication information, partition direction information, and partition tree information.</p><p id="p-0170" num="0169">As another example, among binary tree partitioning and ternary tree partitioning, binary tree partitioning may be preferentially performed. That is, a current coding unit may primarily undergo binary tree partitioning, and then a coding unit corresponding to a leaf node of a binary tree may be set as a root node for ternary tree partitioning. In this case, neither quad tree partitioning nor binary tree partitioning may not be performed on the coding unit corresponding to a node of a ternary tree.</p><p id="p-0171" num="0170">A coding unit that cannot be partitioned by a quad tree partition structure, a binary tree partition structure, and/or a ternary tree partition structure becomes a basic unit for coding, prediction and/or transformation. That is, the coding unit cannot be further partitioned for prediction and/or transformation. Therefore, the partition structure information and the partition information used for partitioning a coding unit into prediction units and/or transformation units may not be present in a bit stream.</p><p id="p-0172" num="0171">However, when the size of a coding unit (i.e., a basic unit for partitioning) is larger than the size of a maximum transformation block, the coding unit may be recursively partitioned until the size of the coding unit is reduced to be equal to or smaller than the size of the maximum transformation block. For example, when the size of a coding unit is 64&#xd7;64 and when the size of a maximum transformation block is 32&#xd7;32, the coding unit may be partitioned into four 32&#xd7;32 blocks for transformation. For example, when the size of a coding unit is 32&#xd7;64 and the size of a maximum transformation block is 32&#xd7;32, the coding unit may be partitioned into two 32&#xd7;32 blocks for the transformation. In this case, the partitioning of the coding unit for transformation is not signaled separately, and may be determined through comparison between the horizontal or vertical size of the coding unit and the horizontal or vertical size of the maximum transformation block. For example, when the horizontal size (width) of the coding unit is larger than the horizontal size (width) of the maximum transformation block, the coding unit may be vertically bisected. For example, when the vertical size (height) of the coding unit is larger than the vertical size (height) of the maximum transformation block, the coding unit may be horizontally bisected.</p><p id="p-0173" num="0172">Information of the maximum and/or minimum size of the coding unit and information of the maximum and/or minimum size of the transformation block may be signaled or determined at an upper level of the coding unit. The upper level may be, for example, a sequence level, a picture level, a slice level, a tile group level, a tile level, or the like. For example, the minimum size of the coding unit may be determined to be 4&#xd7;4. For example, the maximum size of the transformation block may be determined to be 64&#xd7;64. For example, the minimum size of the transformation block may be determined to be 4&#xd7;4.</p><p id="p-0174" num="0173">Information of the minimum size (quad tree minimum size) of a coding unit corresponding to a leaf node of a quad tree and/or information of the maximum depth (the maximum tree depth of a multi-type tree) from a root node to a leaf node of the multi-type tree may be signaled or determined at an upper level of the coding unit. For example, the upper level may be a sequence level, a picture level, a slice level, a tile group level, a tile level, or the like. Information of the minimum size of a quad tree and/or information of the maximum depth of a multi-type tree may be signaled or determined for each of an intra-picture slice and an inter-picture slice.</p><p id="p-0175" num="0174">Difference information between the size of a CTU and the maximum size of a transformation block may be signaled or determined at an upper level of the coding unit. For example, the upper level may be a sequence level, a picture level, a slice level, a tile group level, a tile level, or the like. Information of the maximum size of the coding units corresponding to the respective nodes of a binary tree (hereinafter, referred to as a maximum size of a binary tree) may be determined based on the size of the coding tree unit and the difference information. The maximum size of the coding units corresponding to the respective nodes of a ternary tree (hereinafter, referred to as a maximum size of a ternary tree) may vary depending on the type of slice. For example, for an intra-picture slice, the maximum size of a ternary tree may be 32&#xd7;32. For example, for an inter-picture slice, the maximum size of a ternary tree may be 128&#xd7;128. For example, the minimum size of the coding units corresponding to the respective nodes of a binary tree (hereinafter, referred to as a minimum size of a binary tree) and/or the minimum size of the coding units corresponding to the respective nodes of a ternary tree (hereinafter, referred to as a minimum size of a ternary tree) may be set as the minimum size of a coding block.</p><p id="p-0176" num="0175">As another example, the maximum size of a binary tree and/or the maximum size of a ternary tree may be signaled or determined at the slice level. Alternatively, the minimum size of the binary tree and/or the minimum size of the ternary tree may be signaled or determined at the slice level.</p><p id="p-0177" num="0176">Depending on size and depth information of the above-described various blocks, quad partition information, multi-type tree partition indication information, partition tree information and/or partition direction information may be included or may not be included in a bit stream.</p><p id="p-0178" num="0177">For example, when the size of the coding unit is not larger than the minimum size of a quad tree, the coding unit does not contain quad partition information. The quad partition information may be inferred to be a second value.</p><p id="p-0179" num="0178">For example, when the sizes (horizontal and vertical sizes) of a coding unit corresponding to a node of a multi-type tree are larger than the maximum sizes (horizontal and vertical sizes) of a binary tree and/or the maximum sizes (horizontal and vertical sizes) of a ternary tree, the coding unit may not be binary-partitioned or ternary-partitioned. Accordingly, the multi-type tree partition indication information may not be signaled but may be inferred to be a second value.</p><p id="p-0180" num="0179">Alternatively, when the sizes (horizontal and vertical sizes) of a coding unit corresponding to a node of a multi-type tree are the same as the maximum sizes (horizontal and vertical sizes) of a binary tree and/or are two times as large as the maximum sizes (horizontal and vertical sizes) of a ternary tree, the coding unit may not be further binary-partitioned or ternary-partitioned. Accordingly, the multi-type tree partition indication information may not be signaled but be derived from a second value. This is because when a coding unit is partitioned by a binary tree partition structure and/or a ternary tree partition structure, a coding unit smaller than the minimum size of a binary tree and/or the minimum size of a ternary tree is generated.</p><p id="p-0181" num="0180">Alternatively, the binary tree partitioning or the ternary tree partitioning may be limited on the basis of the size of a virtual pipeline data unit (hereinafter, a pipeline buffer size). For example, when the coding unit is divided into sub-coding units which do not fit the pipeline buffer size by the binary tree partitioning or the ternary tree partitioning, the corresponding binary tree partitioning or ternary tree partitioning may be limited. The pipeline buffer size may be the size of the maximum transform block (e.g., 64&#xd7;64). For example, when the pipeline buffer size is 64&#xd7;64, the division below may be limited.<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0181">N&#xd7;M (N and/or M is 128) Ternary tree partitioning for coding units</li>        <li id="ul0002-0002" num="0182">128&#xd7;N (N&#x3c;=64) Binary tree partitioning in horizontal direction for coding units</li>        <li id="ul0002-0003" num="0183">N&#xd7;128 (N&#x3c;=64) Binary tree partitioning in vertical direction for coding units</li>    </ul>    </li></ul></p><p id="p-0182" num="0184">Alternatively, when the depth of a coding unit corresponding to a node of a multi-type tree is equal to the maximum depth of the multi-type tree, the coding unit may not be further binary-partitioned and/or ternary-partitioned. Accordingly, the multi-type tree partition indication information may not be signaled but may be inferred to be a second value.</p><p id="p-0183" num="0185">Alternatively, only when at least one of vertical direction binary tree partitioning, horizontal direction binary tree partitioning, vertical direction ternary tree partitioning, and horizontal direction ternary tree partitioning is possible for a coding unit corresponding to a node of a multi-type tree, the multi-type tree partition indication information may be signaled. Otherwise, the coding unit may not be binary-partitioned and/or ternary-partitioned. Accordingly, the multi-type tree partition indication information may not be signaled but may be inferred to be a second value.</p><p id="p-0184" num="0186">Alternatively, only when both of the vertical direction binary tree partitioning and the horizontal direction binary tree partitioning or both of the vertical direction ternary tree partitioning and the horizontal direction ternary tree partitioning are possible for a coding unit corresponding to a node of a multi-type tree, the partition direction information may be signaled. Otherwise, the partition direction information may not be signaled but may be derived from a value indicating possible partitioning directions.</p><p id="p-0185" num="0187">Alternatively, only when both of the vertical direction binary tree partitioning and the vertical direction ternary tree partitioning or both of the horizontal direction binary tree partitioning and the horizontal direction ternary tree partitioning are possible for a coding tree corresponding to a node of a multi-type tree, the partition tree information may be signaled. Otherwise, the partition tree information may not be signaled but be inferred to be a value indicating a possible partitioning tree structure.</p><p id="p-0186" num="0188"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a view showing an intra-prediction process.</p><p id="p-0187" num="0189">Arrows from center to outside in <figref idref="DRAWINGS">FIG. <b>4</b></figref> may represent prediction directions of intra prediction modes.</p><p id="p-0188" num="0190">Intra encoding and/or decoding may be performed by using a reference sample of a neighbor block of the current block. A neighbor block may be a reconstructed neighbor block. For example, intra encoding and/or decoding may be performed by using a coding parameter or a value of a reference sample included in a reconstructed neighbor block.</p><p id="p-0189" num="0191">A prediction block may mean a block generated by performing intra prediction. A prediction block may correspond to at least one among CU. PU and TU. A unit of a prediction block may have a size of one among CU, PU and TU. A prediction block may be a square block having a size of 2&#xd7;2, 4&#xd7;4, 16&#xd7;16, 32&#xd7;32 or 64&#xd7;64 etc. or may be a rectangular block having a size of 2&#xd7;8, 4&#xd7;8, 2&#xd7;16, 4&#xd7;16 and 8&#xd7;16 etc.</p><p id="p-0190" num="0192">Intra prediction may be performed according to intra prediction mode for the current block. The number of intra prediction modes which the current block may have may be a fixed value and may be a value determined differently according to an attribute of a prediction block. For example, an attribute of a prediction block may comprise a size of a prediction block and a shape of a prediction block, etc.</p><p id="p-0191" num="0193">The number of intra-prediction modes may be fixed to N regardless of a block size. Or, the number of intra prediction modes may be 3, 5, 9, 17, 34, 35, 36, 65, or 67 etc. Alternatively, the number of intra-prediction modes may vary according to a block size or a color component type or both. For example, the number of intra prediction modes may vary according to whether the color component is a luma signal or a chroma signal. For example, as a block size becomes large, a number of intra-prediction modes may increase. Alternatively, a number of intra-prediction modes of a luma component block may be larger than a number of intra-prediction modes of a chroma component block.</p><p id="p-0192" num="0194">An intra-prediction mode may be a non-angular mode or an angular mode. The non-angular mode may be a DC mode or a planar mode, and the angular mode may be a prediction mode having a specific direction or angle. The intra-prediction mode may be expressed by at least one of a mode number, a mode value, a mode numeral, a mode angle, and mode direction. A number of intra-prediction modes may be M, which is larger than 1, including the non-angular and the angular mode. In order to intra-predict a current block, a step of determining whether or not samples included in a reconstructed neighbor block may be used as reference samples of the current block may be performed. When a sample that is not usable as a reference sample of the current block is present, a value obtained by duplicating or performing interpolation on at least one sample value among samples included in the reconstructed neighbor block or both may be used to replace with a non-usable sample value of a sample, thus the replaced sample value is used as a reference sample of the current block.</p><p id="p-0193" num="0195"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a diagram illustrating reference samples capable of being used for intra prediction.</p><p id="p-0194" num="0196">As shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, at least one of the reference sample line <b>0</b> to the reference sample line <b>3</b> may be used for intra prediction of the current block. In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the samples of a segment A and a segment F may be padded with the samples closest to a segment B and a segment E, respectively, instead of retrieving from the reconstructed neighboring block. Index information indicating the reference sample line to be used for intra prediction of the current block may be signaled. For example, in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, reference sample line indicators <b>0</b>, <b>1</b>, and <b>2</b> may be signaled as index information indicating reference sample lines <b>0</b>, <b>1</b> and <b>2</b>. When the upper boundary of the current block is the boundary of the CTU, only the reference sample line <b>0</b> may be available. Therefore, in this case, the index information may not be signaled. When a reference sample line other than the reference sample line <b>0</b> is used, filtering for a prediction block, which will be described later, may not be performed.</p><p id="p-0195" num="0197">When intra-predicting, a filter may be applied to at least one of a reference sample and a prediction sample based on an intra-prediction mode and a current block size.</p><p id="p-0196" num="0198">In case of a planar mode, when generating a prediction block of a current block, according to a position of a prediction target sample within a prediction block, a sample value of the prediction target sample may be generated by using a weighted sum of an upper and left side reference sample of a current block, and a right upper side and left lower side reference sample of the current block. In addition, in case of a DC mode, when generating a prediction block of a current block, an average value of upper side and left side reference samples of the current block may be used. In addition, in case of an angular mode, a prediction block may be generated by using an upper side, a left side, a right upper side, and/or a left lower side reference sample of the current block. In order to generate a prediction sample value, interpolation of a real number unit may be performed.</p><p id="p-0197" num="0199">In the case of intra prediction between color components, a prediction block for the current block of the second color component may be generated on the basis of the corresponding reconstructed block of the first color component. For example, the first color component may be a luma component, and the second color component may be a chroma component. For intra prediction between color components, the parameters of the linear model between the first color component and the second color component may be derived on the basis of the template. The template may include upper and/or left neighboring samples of the current block and upper and/or left neighboring samples of the reconstructed block of the first color component corresponding thereto. For example, the parameters of the linear model may be derived using a sample value of a first color component having a maximum value among samples in a template and a sample value of a second color component corresponding thereto, and a sample value of a first color component having a minimum value among samples in the template and a sample value of a second color component corresponding thereto. When the parameters of the linear model are derived, a corresponding reconstructed block may be applied to the linear model to generate a prediction block for the current block. According to a video format, subsampling may be performed on the neighboring samples of the reconstructed block of the first color component and the corresponding reconstructed block. For example, when one sample of the second color component corresponds to four samples of the first color component, four samples of the first color component may be sub-sampled to compute one corresponding sample. In this case, the parameter derivation of the linear model and intra prediction between color components may be performed on the basis of the corresponding sub-sampled samples. Whether or not to perform intra prediction between color components and/or the range of the template may be signaled as the intra prediction mode.</p><p id="p-0198" num="0200">The current block may be partitioned into two or four sub-blocks in the horizontal or vertical direction. The partitioned sub-blocks may be sequentially reconstructed. That is, the intra prediction may be performed on the sub-block to generate the sub-prediction block. In addition, dequantization and/or inverse transform may be performed on the sub-blocks to generate sub-residual blocks. A reconstructed sub-block may be generated by adding the sub-prediction block to the sub-residual block. The reconstructed sub-block may be used as a reference sample for intra prediction of the sub-sub-blocks. The sub-block may be a block including a predetermined number (for example, 16) or more samples. Accordingly, for example, when the current block is an 8&#xd7;4 block or a 4&#xd7;8 block, the current block may be partitioned into two sub-blocks. Also, when the current block is a 4&#xd7;4 block, the current block may not be partitioned into sub-blocks. When the current block has other sizes, the current block may be partitioned into four sub-blocks. Information on whether or not to perform the intra prediction based on the sub-blocks and/or the partitioning direction (horizontal or vertical) may be signaled. The intra prediction based on the sub-blocks may be limited to be performed only when reference sample line <b>0</b> is used. When the intra prediction based on the sub-block is performed, filtering for the prediction block, which will be described later, may not be performed.</p><p id="p-0199" num="0201">The final prediction block may be generated by performing filtering on the prediction block that is intra-predicted. The filtering may be performed by applying predetermined weights to the filtering target sample, the left reference sample, the upper reference sample, and/or the upper left reference sample. The weight and/or the reference sample (range, position, etc.) used for the filtering may be determined on the basis of at least one of a block size, an intra prediction mode, and a position of the filtering target sample in the prediction block. The filtering may be performed only in the case of a predetermined intra prediction mode (e.g., DC, planar, vertical, horizontal, diagonal, and/or adjacent diagonal modes). The adjacent diagonal mode may be a mode in which k is added to or subtracted from the diagonal mode. For example, k may be a positive integer of 8 or less.</p><p id="p-0200" num="0202">An intra-prediction mode of a current block may be entropy encoded/decoded by predicting an intra-prediction mode of a block present adjacent to the current block. When intra-prediction modes of the current block and the neighbor block are identical, information that the intra-prediction modes of the current block and the neighbor block are identical may be signaled by using predetermined flag information. In addition, indicator information of an intra-prediction mode that is identical to the intra-prediction mode of the current block among intra-prediction modes of a plurality of neighbor blocks may be signaled. When intra-prediction modes of the current block and the neighbor block are different, intra-prediction mode information of the current block may be entropy encoded/decoded by performing entropy encoding/decoding based on the intra-prediction mode of the neighbor block.</p><p id="p-0201" num="0203"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a diagram illustrating an embodiment of an inter-picture prediction process.</p><p id="p-0202" num="0204">In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, a rectangle may represent a picture. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, an arrow represents a prediction direction. Pictures may be categorized into intra pictures (I pictures), predictive pictures (P pictures), and Bi-predictive pictures (B pictures) according to the encoding type thereof.</p><p id="p-0203" num="0205">The I picture may be encoded through intra-prediction without requiring inter-picture prediction. The P picture may be encoded through inter-picture prediction by using a reference picture that is present in one direction (i.e., forward direction or backward direction) with respect to a current block. The B picture may be encoded through inter-picture prediction by using reference pictures that are preset in two directions (i.e., forward direction and backward direction) with respect to a current block. When the inter-picture prediction is used, the encoder may perform inter-picture prediction or motion compensation and the decoder may perform the corresponding motion compensation.</p><p id="p-0204" num="0206">Hereinbelow, an embodiment of the inter-picture prediction will be described in detail.</p><p id="p-0205" num="0207">The inter-picture prediction or motion compensation may be performed using a reference picture and motion information.</p><p id="p-0206" num="0208">Motion information of a current block may be derived during inter-picture prediction by each of the encoding apparatus <b>100</b> and the decoding apparatus <b>200</b>. The motion information of the current block may be derived by using motion information of a reconstructed neighboring block, motion information of a collocated block (also referred to as a col block or a co-located block), and/or a block adjacent to the co-located block. The co-located block may mean a block that is located spatially at the same position as the current block, within a previously reconstructed collocated picture (also referred to as a col picture or a co-located picture). The co-located picture may be one picture among one or more reference pictures included in a reference picture list.</p><p id="p-0207" num="0209">The derivation method of the motion information may be different depending on the prediction mode of the current block. For example, a prediction mode applied for inter prediction includes an AMVP mode, a merge mode, a skip mode, a merge mode with a motion vector difference, a subblock merge mode, a geometric partitioning mode, an combined inter intra prediction mode, affine mode, and the like. Herein, the merge mode may be referred to as a motion merge mode.</p><p id="p-0208" num="0210">For example, when the AMVP is used as the prediction mode, at least one of motion vectors of the reconstructed neighboring blocks, motion vectors of the co-located blocks, motion vectors of blocks adjacent to the co-located blocks, and a (0, 0) motion vector may be determined as motion vector candidates for the current block, and a motion vector candidate list is generated by using the emotion vector candidates. The motion vector candidate of the current block can be derived by using the generated motion vector candidate list. The motion information of the current block may be determined based on the derived motion vector candidate. The motion vectors of the collocated blocks or the motion vectors of the blocks adjacent to the collocated blocks may be referred to as temporal motion vector candidates, and the motion vectors of the reconstructed neighboring blocks may be referred to as spatial motion vector candidates.</p><p id="p-0209" num="0211">The encoding apparatus <b>100</b> may calculate a motion vector difference (MVD) between the motion vector of the current block and the motion vector candidate and may perform entropy encoding on the motion vector difference (MVD). In addition, the encoding apparatus <b>100</b> may perform entropy encoding on a motion vector candidate index and generate a bitstream. The motion vector candidate index may indicate an optimum motion vector candidate among the motion vector candidates included in the motion vector candidate list. The decoding apparatus may perform entropy decoding on the motion vector candidate index included in the bitstream and may select a motion vector candidate of a decoding target block from among the motion vector candidates included in the motion vector candidate list by using the entropy-decoded motion vector candidate index. In addition, the decoding apparatus <b>200</b> may add the entropy-decoded MVD and the motion vector candidate extracted through the entropy decoding, thereby deriving the motion vector of the decoding target block.</p><p id="p-0210" num="0212">Meanwhile, the coding apparatus <b>100</b> may perform entropy-coding on resolution information of the calculated MVD. The decoding apparatus <b>200</b> may adjust the resolution of the entropy-decoded MVD using the MVD resolution information.</p><p id="p-0211" num="0213">Meanwhile, the coding apparatus <b>100</b> calculates a motion vector difference (MVD) between a motion vector and a motion vector candidate in the current block on the basis of an affine model, and performs entropy-coding on the MVD. The decoding apparatus <b>200</b> derives a motion vector on a per sub-block basis by deriving an affine control motion vector of a decoding target block through the sum of the entropy-decoded MVD and an affine control motion vector candidate.</p><p id="p-0212" num="0214">The bitstream may include a reference picture index indicating a reference picture. The reference picture index may be entropy-encoded by the encoding apparatus <b>100</b> and then signaled as a bitstream to the decoding apparatus <b>200</b>. The decoding apparatus <b>200</b> may generate a prediction block of the decoding target block based on the derived motion vector and the reference picture index information.</p><p id="p-0213" num="0215">Another example of the method of deriving the motion information of the current may be the merge mode. The merge mode may mean a method of merging motion of a plurality of blocks. The merge mode may mean a mode of deriving the motion information of the current block from the motion information of the neighboring blocks. When the merge mode is applied, the merge candidate list may be generated using the motion information of the reconstructed neighboring blocks and/or the motion information of the collocated blocks. The motion information may include at least one of a motion vector, a reference picture index, and an inter-picture prediction indicator. The prediction indicator may indicate one-direction prediction (L0 prediction or L1 prediction) or two-direction predictions (L0 prediction and L1 prediction).</p><p id="p-0214" num="0216">The merge candidate list may be a list of motion information stored. The motion information included in the merge candidate list may be at least one of motion information (spatial merge candidate) of a neighboring block adjacent to the current block, motion information (temporal merge candidate) of the collocated block of the current block in the reference picture, new motion information generated by a combination of the motion information exiting in the merge candidate list, motion information (history-based merge candidate) of the block that is encoded/decoded before the current block, and zero merge candidate.</p><p id="p-0215" num="0217">The encoding apparatus <b>100</b> may generate a bitstream by performing entropy encoding on at least one of a merge flag and a merge index and may signal the bitstream to the decoding apparatus <b>200</b>. The merge flag may be information indicating whether or not to perform the merge mode for each block, and the merge index may be information indicating that which neighboring block, among the neighboring blocks of the current block, is a merge target block. For example, the neighboring blocks of the current block may include a left neighboring block on the left of the current block, an upper neighboring block disposed above the current block, and a temporal neighboring block temporally adjacent to the current block.</p><p id="p-0216" num="0218">Meanwhile, the coding apparatus <b>100</b> performs entropy-coding on the correction information for correcting the motion vector among the motion information of the merge candidate and signals the same to the decoding apparatus <b>200</b>. The decoding apparatus <b>200</b> can correct the motion vector of the merge candidate selected by the merge index on the basis of the correction information. Here, the correction information may include at least one of information on whether or not to perform the correction, correction direction information, and correction size information. As described above, the prediction mode that corrects the motion vector of the merge candidate on the basis of the signaled correction information may be referred to as a merge mode having the motion vector difference.</p><p id="p-0217" num="0219">The skip mode may be a mode in which the motion information of the neighboring block is applied to the current block as it is. When the skip mode is applied, the encoding apparatus <b>100</b> may perform entropy encoding on information of the fact that the motion information of which block is to be used as the motion information of the current block to generate a bit stream, and may signal the bitstream to the decoding apparatus <b>200</b>. The encoding apparatus <b>100</b> may not signal a syntax element regarding at least any one of the motion vector difference information, the encoding block flag, and the transform coefficient level to the decoding apparatus <b>200</b>.</p><p id="p-0218" num="0220">The subblock merge mode may mean a mode that derives the motion information in units of sub-blocks of a coding block (CU). When the subblock merge mode is applied, a subblock merge candidate list may be generated using motion information (sub-block based temporal merge candidate) of the sub-block collocated to the current sub-block in the reference image and/or an affine control point motion vector merge candidate.</p><p id="p-0219" num="0221">The geometric partitioning mode may mean a mode that derives motion information by partitioning the current block into the predefined directions, derives each prediction sample using each of the derived motion information, and derives the prediction sample of the current block by weighting each of the derived prediction samples.</p><p id="p-0220" num="0222">The inter-intra combined prediction mode may mean a mode that derives a prediction sample of the current block by weighting a prediction sample generated by inter prediction and a prediction sample generated by intra prediction.</p><p id="p-0221" num="0223">The decoding apparatus <b>200</b> may correct the derived motion information by itself. The decoding apparatus <b>200</b> may search the predetermined region on the basis of the reference block indicated by the derived motion information and derive the motion information having the minimum SAD as the corrected motion information.</p><p id="p-0222" num="0224">The decoding apparatus <b>200</b> may compensate a prediction sample derived via inter prediction using an optical flow.</p><p id="p-0223" num="0225"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a diagram illustrating a transform and quantization process.</p><p id="p-0224" num="0226">As illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, a transform and/or quantization process is performed on a residual signal to generate a quantized level signal. The residual signal is a difference between an original block and a prediction block (i.e., an intra prediction block or an inter prediction block). The prediction block is a block generated through intra prediction or inter prediction. The transform may be a primary transform, a secondary transform, or both. The primary transform of the residual signal results in transform coefficients, and the secondary transform of the transform coefficients results in secondary transform coefficients.</p><p id="p-0225" num="0227">At least one scheme selected from among various transform schemes which are preliminarily defined is used to perform the primary transform. For example, examples of the predefined transform schemes include discrete cosine transform (DCT), discrete sine transform (DST), and Karhunen-Lo&#xe9;ve transform (KLT). The transform coefficients generated through the primary transform may undergo the secondary transform. The transform schemes used for the primary transform and/or the secondary transform may be determined according to coding parameters of the current block and/or neighboring blocks of the current block. Alternatively, transform information indicating the transform scheme may be signaled. The DCT-based transform may include, for example, DCT-2, DCT-8, and the like. The DST-based transform may include, for example, DST-7.</p><p id="p-0226" num="0228">A quantized-level signal (quantization coefficients) may be generated by performing quantization on the residual signal or a result of performing the primary transform and/or the secondary transform. The quantized level signal may be scanned according to at least one of a diagonal up-right scan, a vertical scan, and a horizontal scan, depending on an intra prediction mode of a block or a block size/shape. For example, as the coefficients are scanned in a diagonal up-right scan, the coefficients in a block form change into a one-dimensional vector form. Aside from the diagonal up-right scan, the horizontal scan of horizontally scanning a two-dimensional block form of coefficients or the vertical scan of vertically scanning a two-dimensional block form of coefficients may be used depending on the intra prediction mode and/or the size of a transform block. The scanned quantized-level coefficients may be entropy-encoded to be inserted into a bitstream.</p><p id="p-0227" num="0229">A decoder entropy-decodes the bitstream to obtain the quantized-level coefficients. The quantized-level coefficients may be arranged in a two-dimensional block form through inverse scanning. For the inverse scanning, at least one of a diagonal up-right scan, a vertical scan, and a horizontal scan may be used.</p><p id="p-0228" num="0230">The quantized-level coefficients may then be dequantized, then be secondary-inverse-transformed as necessary, and finally be primary-inverse-transformed as necessary to generate a reconstructed residual signal.</p><p id="p-0229" num="0231">Inverse mapping in a dynamic range may be performed for a luma component reconstructed through intra prediction or inter prediction before in-loop filtering. The dynamic range may be divided into 16 equal pieces and the mapping function for each piece may be signaled. The mapping function may be signaled at a slice level or a tile group level. An inverse mapping function for performing the inverse mapping may be derived on the basis of the mapping function. In-loop filtering, reference picture storage, and motion compensation are performed in an inverse mapped region, and a prediction block generated through inter prediction is converted into a mapped region via mapping using the mapping function, and then used for generating the reconstructed block. However, since the intra prediction is performed in the mapped region, the prediction block generated via the intra prediction may be used for generating the reconstructed block without mapping/inverse mapping.</p><p id="p-0230" num="0232">When the current block is a residual block of a chroma component, the residual block may be converted into an inverse mapped region by performing scaling on the chroma component of the mapped region. The availability of the scaling may be signaled at the slice level or the tile group level. The scaling may be applied only when the mapping for the luma component is available and the division of the luma component and the division of the chroma component follow the same tree structure. The scaling may be performed on the basis of an average of sample values of a luma prediction block corresponding to the color difference block. In this case, when the current block uses inter prediction, the luma prediction block may mean a mapped luma prediction block. A value necessary for the scaling may be derived by referring to a lookup table using an index of a piece to which an average of sample values of a luma prediction block belongs. Finally, by scaling the residual block using the derived value, the residual block may be switched to the inverse mapped region. Then, chroma component block restoration, intra prediction, inter prediction, in-loop filtering, and reference picture storage may be performed in the inverse mapped area.</p><p id="p-0231" num="0233">Information indicating whether the mapping/inverse mapping of the luma component and chroma component is available may be signaled through a set of sequence parameters.</p><p id="p-0232" num="0234">The prediction block of the current block may be generated on the basis of a block vector indicating a displacement between the current block and the reference block in the current picture. In this way, a prediction mode for generating a prediction block with reference to the current picture is referred to as an intra block copy (IBC) mode. The IBC mode may be applied to M&#xd7;N (M&#x3c;=64, N&#x3c;=64) coding units. The IBC mode may include a skip mode, a merge mode, an AMVP mode, and the like. In the case of a skip mode or a merge mode, a merge candidate list is constructed, and the merge index is signaled so that one merge candidate may be specified. The block vector of the specified merge candidate may be used as a block vector of the current block. The merge candidate list may include at least one of a spatial candidate, a history-based candidate, a candidate based on an average of two candidates, and a zero-merge candidate. In the case of an AMVP mode, the difference block vector may be signaled. In addition, the prediction block vector may be derived from the left neighboring block and the upper neighboring block of the current block. The index on which neighboring block to use may be signaled. The prediction block in the IBC mode is included in the current CTU or the left CTU and limited to a block in the already reconstructed area. For example, a value of the block vector may be limited such that the prediction block of the current block is positioned in an area of three 64&#xd7;64 blocks preceding the 64&#xd7;64 block to which the current block belongs in the coding/decoding order. By limiting the value of the block vector in this way, memory consumption and device complexity according to the IBC mode implementation may be reduced.</p><p id="p-0233" num="0235">Hereinafter, an image encoding/decoding method according to embodiments of the present disclosure will be described.</p><p id="p-0234" num="0236">When encoding/decoding an image, block transform is generally performed. However, in some cases, not performing block transform may be advantageous. Here, not performing block transform is referred to as transform skip (TS). In addition, coding information indicating whether or not transform is skipped for a current block to be encoded (or decoded) is referred to as a transform skip flag (transform_skip_flag). A transform skip flag is transmitted from an encoder to a decoder by being marked in a bitstream. In addition, the decoder parses the transform skip flag in the bitstream, thereby deriving its value. When the transform skip flag indicates 0, block transform is performed. When the transform skip flag indicates 1, block transform is skipped.</p><p id="p-0235" num="0237"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a method of constructing a bitstream that transmits transform skip flag information only to a luma channel.</p><p id="p-0236" num="0238">Transmitting a transform skip flag to each YcbCr channel may be disadvantageous with respect to coding efficiency. Accordingly, transform skip may be applied to a luma channel but not to a chroma channel. Thus, a transform skip flag may be transmitted only for a luma channel.</p><p id="p-0237" num="0239">Herein, a spatial coordinate (x0, y0) is a coordinate indicating a top-left spatial position of a currently encoded (decoded) block, and transform skip flag information of a corresponding current luma block is indicated as transform_skip_flag[x0][y0]. According to the method of constructing a bitstream in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, an encoder transmits or parses only a transform skip flag (transform_skip_flag) for a luma channel. In addition, according to the method of constructing a bitstream in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, when parsing transform skip information from a bitstream, a decoder parses only a transform skip flag for a luma channel.</p><p id="p-0238" num="0240">According to the embodiment of <figref idref="DRAWINGS">FIG. <b>8</b></figref>, as a transform skip flag for a chroma channel is not transmitted, even when a transform skip mode is more advantageous for a chroma block, transform is always performed, which is a problem. In addition, when lossless coding is performed or in the case of screen content or other images made by a computer, transform skip may be advantageous for a chroma block as well as for a luma block.</p><p id="p-0239" num="0241">Generally, channel channels of an image have a considerable correlation. Accordingly, the present disclosure provides a method and apparatus for determining whether or not to skip transform for a chroma channel through minimum information by sharing or referring to transform skip flag information among multiple channels. According to the present disclosure, when a transform skip flag is transmitted and parsed only for one or two color channels, instead of being transmitted and parsed for each color channel, and the remaining channels refer to the transform skip flag, the problems of degraded compression and image quality may be solved.</p><p id="p-0240" num="0242">Although the present disclosure describes a transform skip flag below, this technique is not applied exclusively to a transform skip flag. According to the present disclosure, the method of sharing or referring to information among color channels may be applied not only to a transform skip flag but also to first or second transform selection (multiple transform selection, MTS) information, intra smoothing filtering information, position dependent intra prediction combination (PDPC) flag information, information required for deblocking filtering, information required for adaptive loop filtering (ALF), information required for sample adaptive offset (SAO) filtering, information for image quality improvement and information for improving compression efficiency. However, for the convenience of description, transform is used as a specific example to describe in detail an image encoding/decoding operation according to the present disclosure. The description may also be applied to the other examples of coding information listed above.</p><p id="p-0241" num="0243">For sharing coding information among channels for an embodiment of the present disclosure, one or more predetermined channels may be selected as a representative channel among color channels. In addition, coding information of the representative channel may be shared or referred to in the remaining channels. In other words, a decoder may parse only coding information of a representative channel from an encoder through a bitstream. The decoder may parse coding information of the remaining channels by referring to or sharing the coding information of the representative channel without separate signaling.</p><p id="p-0242" num="0244">For example, when a luma channel with the highest correlation to a luma signal in a YCbCr color space is selected as a representative channel, since there exists a correlation between a luma (Y) channel and a chroma (Cb and/or Cr) channel in an image, instead of transmitting (for encoding) and parsing (for decoding) coding information necessary for encoding and decoding the image in each color channel, coding information of a chroma channel may be transmitted and parsed by referring to coding information of a luma channel.</p><p id="p-0243" num="0245">According to the present disclosure, a detailed method and apparatus for transmitting and parsing a transform skip flag and using the flag for decoding may be implemented as follows.</p><heading id="h-0011" level="1">Embodiment A-1</heading><p id="p-0244" num="0246">Table 1 below shows a syntax structure according to Embodiment A-1.</p><p id="p-0245" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( sps_joint_cbcr_enabled_flag &#x26;&#x26; ( ( CuPredMode[ chType ][ x0 ][ y0 ] = = MODE_INTRA</entry></row><row><entry>&#x2003;&#x2002;&#x26;&#x26; ( tu_cbf_cb[ x0 ][ y0 ] || tu_cbf_cr[ x0 ][ y0 ] ) ) ||</entry></row><row><entry>&#x2003;( tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_cbf_cr[ x0 ][ y0 ] ) ) )</entry></row><row><entry>&#x2003;tu_joint_cbcr_residual_flag[ x0 ][ y0 ]</entry></row><row><entry>if( ( tbWidth &#x3c;= 32 ) &#x26;&#x26; ( tbHeight &#x3c;= 32 )</entry></row><row><entry>&#x2003;&#x2009;&#x26;&#x26; ( IntraSubPartitionsSplit[ x0 ][ y0 ] = = ISP_NO_SPLIT ) &#x26;&#x26; ( !cu_sbt_flag ) ) {</entry></row><row><entry>&#x2003;if( sps_transform_skip_enabled_flag &#x26;&#x26; !BdpcmFlag[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2009;tbWidth &#x3c;= MaxTsSize &#x26;&#x26; tbHeight &#x3c;= MaxTsSize ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_luma[ x0 ][ y0 ] {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;transform_skip_flag[ x0 ][ y0 ][0]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( ( ( CuPredMode[ chType ][ x0 ][ y0 ] = = MODE_INTER &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;sps_explicit_mts_inter_enabled_flag )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;|| ( CuPredMode[ chType ][ x0 ][ y0 ] = = MODE_INTRA &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;sps_explicit_mts_intra_enabled_flag ) ) &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( !transform_skip_flag[ x0 ][ y0 ] ) )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tu_mts_idx[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_cb[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag[ x0 ][ y0 ][1]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_cr[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;!(tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_joint_cbcr_residual_flag[ x0 ][ y0 ]))</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag[ x0 ][ y0 ][2]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>if( tu_cbf_luma[ x0 ][ y0 ] ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( !transform_skip_flag[ x0 ][ y0 ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( x0, y0, Log2( tbWidth ), Log2( tbHeight ), 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_ts_coding( x0, y0, Log2( tbWidth ), Log2( tbHeight ), 0 )</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>if( tu_cbf_cb[ x0 ][ y0 ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;residual_coding( xC, yC, Log2( wC ), Log2( hC ), 1 )</entry></row><row><entry>if( tu_cbf_cr[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;!( tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_joint_cbcr_residual_flag[ x0 ][ y0 ] )) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;residual_coding( xC, yC, Log2( wC ), Log2( hC ), 2 )</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0246" num="0247">Here, transform_skip_flag[x0][y0][cIdx] is a transform skip flag for a block corresponding to a channel indicated by cIdx and to the spatial coordinate (x0, y0). cIdx indicates a currently encoded (or decoded) channel. In other words, a luma channel corresponds to cIdx=0, and Cb and Cr channels correspond to cIdx=1 and cIdx=2 respectively. Accordingly, transform skip flag information of a current block of a currently encoded (decoded) channel may be generally indicated by transform skip_flag[x0][y0][cIdx]. However, in the operation description below, transform_skip_flag[x0]y0][cIdx] will be simply indicated as transform_skip_flag or transform_skip_flag[cIdx] with some information being excluded for the sake of convenience.</p><p id="p-0247" num="0248">According to Embodiment A-1, transform_skip_flag is transmitted (by an encoder) or parsed (by a decoder) for each of three channels (that is, cIdx=0, 1, 2 or Y, Cb, Cr). In this case, transform skip flag values transmitted or parsed may be transform_skip_flag[x0][y0][0], transform_skip_flag[x0][y0][1] and transform_skip_flag[x0][y0][2], which correspond to Y, Cb and Cr channels (that is, cIdx=0, 1, 2) respectively.</p><p id="p-0248" num="0249">Meanwhile, tu_joint_cbcr_residual may be applied which encodes (or decodes) only a Cb block and generates a Cr block by using a value of a decoded Cb block. Whether or not the technique is used may be determined according to tu_joint_cbcr_residual_flag. When tu_joint_cbcr_residual_flag has a value of 1, tu_joint_cbcr_residual technique is applied. In this case, instead of being transmitted or parsed for each of three channels (that is, cIdx=0, 1, 2 or Y, Cb, Cr) (here, a total of 3 bits of transform skip flag is required), transform_skip_flag is transmitted or parsed only for Y and Cb channels (here, a total of 2 bits of transform skip flag is required). In other words, as a transform skip flag for Cb channel replaces a transform skip flag for Cr channel, not only coding efficiency may be improved but also a transform skip mode for a chroma channel may be implemented.</p><p id="p-0249" num="0250">Unlike Embodiment A-1 above, as shown in Embodiment A-2 below, the order of operations for parsing a flag value and constructing a residual signal (or prediction error signal) may be modified.</p><heading id="h-0012" level="1">Embodiment A-2</heading><p id="p-0250" num="0251">Table 2 below shows a syntax structure according to Embodiment A-2. The operation description according to Embodiment A-2 is the same as the description according to Embodiment A-1.</p><p id="p-0251" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="294pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( sps_joint_cbcr_enabled_flag &#x26;&#x26; ( ( CuPredMode[ chType ][ x0 ][ y0 ] = = MODE_INTRA</entry></row><row><entry>&#x2003;&#x2003;&#x2002;&#x26;&#x26; ( tu_cbf_cb[ x0 ][ y0 ] || tu_cbf_cr[ x0 ][ y0 ] ) ) ||</entry></row><row><entry>&#x2003;&#x2003;( tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_cbf_cr[ x0 ][ y0 ] ) ) )</entry></row><row><entry>&#x2003;&#x2003;tu_joint_cbcr_residual_flag[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;if( ( tbWidth &#x3c;= 32 ) &#x26;&#x26; ( tbHeight &#x3c;= 32 )</entry></row><row><entry>&#x2003;&#x2003;&#x2009;&#x26;&#x26; ( IntraSubPartitionsSplit[ x0 ][ y0 ] = = ISP_NO_SPLIT ) &#x26;&#x26; ( !cu_sbt_flag ) ) {</entry></row><row><entry>&#x2003;&#x2003;if( sps_transform_skip_enabled_flag &#x26;&#x26; !BdpcmFlag[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tbWidth &#x3c;= MaxTsSize &#x26;&#x26; tbHeight &#x3c;= MaxTsSize ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;if( tu_cbf_luma[ x0 ][ y0 ]) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;transform_skip_flag[ x0 ][ y0 ][0]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( ( ( CuPredMode[ chType ][ x0 ][ y0 ] = = MODE_INTER &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;sps_explicit_mts_inter_enabled_flag )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;|| ( CuPredMode[ chType ][ x0 ][ y0 ] = = MODE_INTRA &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;sps_explicit_mts_intra_enabled_flag ) ) &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( !transform_skip_flag[ x0 ][ y0 ] ) )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tu_mts_idx[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( !transform_skip_flag[ x0 ][ y0 ][0] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( x0, y0, Log2( tbWidth ), Log2( tbHeight ), 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_ts_coding( x0, y0, Log2( tbWidth ), Log2( tbHeight ), 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;if( tu_cbf_cb[ x0 ][ y0 ]) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;transform_skip_flag[ x0 ][ y0 ][1]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( !transform_skip_flag[ x0 ][ y0 ][1] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( xC, yC, Log2( wC ), Log2( hC ), 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_ts_coding( xC, yC, Log2( wC ), Log2( hC ), 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;if( tu_cbf_cr[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;!(tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_joint_cbcr_residual_flag[ x0 ][ y0 ])) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;transform_skip_flag[ x0 ][ y0 ][2]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;if( !transform_skip_flag[ x0 ][ y0 ][2] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( xC, yC, Log2( wC ), Log2( hC ), 2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_ts_coding( xC, yC, Log2( wC ), Log2( hC ), 2 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0013" level="1">Embodiment B</heading><p id="p-0252" num="0252">According to an embodiment, another simple method may be implemented such that, when a transform skip technique is applied to Y, Cb and Cr channels respectively, a transform skip flag is transmitted (or parsed) for a luma block and the transform skip flag for the luma block is shared for a chroma block instead of a separate transform skip flag being transmitted (or parsed) for the chroma block. This embodiment is composed of the following two operations. First (Operation 1), a decoder parses only transform skip_flag indicating whether or not a transform skip technique is applied to a luma channel. However (Operation 2), the decoder shares the transform_skip_flag of the luma block (that is, uses a same value) without separately parsing transform_skip_flag for Cb and Cr blocks. A decoder according to this embodiment may be implemented to execute Operation 1 and Operation 2 described in Table 3.</p><p id="p-0253" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 3</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(Operation 1)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="147pt" align="left"/><colspec colname="2" colwidth="70pt" align="left"/><tbody valign="top"><row><entry>parse transform_skip_flag[ x0 ][ y0 ][ 0 ]</entry><entry>// Bitstream parsing</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><tbody valign="top"><row><entry>(Operation 2)</entry></row><row><entry>transform_skip_flag [ x0 ][ y0 ][ 1 ] = transform_skip_flag[ x0 ][ y0</entry></row><row><entry>][ 0 ]</entry></row><row><entry>transform_skip_flag [ x0 ][ y0 ][ 2 ] = transform_skip_flag[ x0 ][ y0</entry></row><row><entry>][ 0 ]</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0254" num="0253">According to an embodiment, irrespective of block partition tree structures like a single tree or a dual tree, which are set when encoding is performed, or prediction modes like intra prediction or inter prediction, a transform skip flag of a luma block corresponding to a chroma block may be implemented to be referred to or shared by the chroma block. Depending on embodiments, a parsing operation corresponding to Operation 1 of this embodiment may be implemented only when all or some of the conditions for parsing transform_skip_flag[x0][y0][0] of Embodiment A-1 or Embodiment A-2 are satisfied. Table 4 describes Operation 1 that applies the parsing conditions of Embodiment A-1 or Embodiment A-2 without alteration.</p><p id="p-0255" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 4</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;(Operation 1)</entry></row><row><entry>if( ( tbWidth &#x3c;= 32 ) &#x26;&#x26; ( tbHeight &#x3c;= 32 )</entry></row><row><entry>&#x2003;&#x2003;&#x2009;&#x26;&#x26; ( IntraSubPartitionsSplit[ x0 ][ y0 ] = = ISP_NO_SPLIT )</entry></row><row><entry>&#x2003;&#x2003;&#x2009;&#x26;&#x26; ( !cu_sbt_flag ) ) {</entry></row><row><entry>&#x2003;&#x2003;if( sps_transform_skip_enabled_flag &#x26;&#x26; !BdpcmFlag[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;&#x2003;&#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tbWidth &#x3c;= MaxTsSize &#x26;&#x26; tbHeight &#x3c;= MaxTsSize )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_luma[ x0 ][ y0 ]</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="147pt" align="left"/><colspec colname="2" colwidth="70pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag[ x0 ][ y0 ][0]</entry><entry>// Bitstream parsing</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0256" num="0254">Meanwhile, in another embodiment, instead of always sharing a transform skip flag of a luma block like in like Embodiment B, a configuration for sharing a transform skip flag of a luma block corresponding to a current chroma block only under a specific condition may be more advantageous. Herein, depending on conditions being used, various modifications may be described as follows. Such various modified configurations may be implemented such that Operation 1 of Embodiment B-1 is performed and then Operation 2 is modified under various conditions. Accordingly, in the description below about modified embodiments (Embodiment B-1, Embodiment B-2, . . . ) of Embodiment B, only Operation 2 is described. However, it should be understood that the embodiments below describe an additional operation performed after Operation 1 described above.</p><heading id="h-0014" level="1">Embodiment B-1</heading><p id="p-0257" num="0255">According to an embodiment, high-level syntax may define that transform skip is not permitted for a chroma block. Since it is defined beforehand that transform skip is not used for a chroma block, no operation is needed for indicating whether or not to use transform skip for a chroma block. That is, a transform skip flag is transmitted or parsed only for a luma block in this embodiment.</p><p id="p-0258" num="0256">In this embodiment, encoding performance of a chroma block may be a little degraded. On the other hand, encoding complexity may be decreased, which is an advantage. However, in some cases, as shown in Table 5, skipping a transform skip operation may be indicated through an operation of explicitly setting transform skip_flag [x0][y0][2]=transform_skip_flag[x0][y0][1]=0.</p><p id="p-0259" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="175pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 5</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>(Operation 2)</entry></row><row><entry/><entry>transform_skip_flag [ x0 ][ y0 ][ 1 ] = 0</entry></row><row><entry/><entry>transform_skip_flag [ x0 ][ y0 ][ 2 ] = 0</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0015" level="1">Embodiment B-2</heading><p id="p-0260" num="0257">According to an embodiment, when the condition that a current chroma block is a derived mode (DM), that is, an intra-prediction mode, is satisfied in Operation 2, a transform skip flag of a luma block corresponding to the current chroma block may be shared. As an intra-prediction mode of a chroma block, DM refers to an intra-prediction mode of a luma block that is used by being shared. CuPredMode[chType][x0][y0] indicates a prediction mode of a currently encoded block corresponding to the spatial coordinate (x0, y0). chType=0 indicates that a currently encoded block is a luma block. chType=1 or chType=2 indicates that a currently encoded block is a chroma block.</p><p id="p-0261" num="0258">intra_chroma_pred_mode indicates an intra-prediction mode of a current chroma block. intra_chroma_pred_mode=4 corresponds to a case in which an intra-prediction mode of a current chroma block is DM. A decoder according to this embodiment may be implemented to execute Operation 2 as shown in Table 6.</p><p id="p-0262" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 6</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(Operation 2)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="140pt" align="left"/><colspec colname="2" colwidth="77pt" align="left"/><tbody valign="top"><row><entry>if(CuPredMode[ chType ][ x0 ][ y0 ] = =</entry><entry>//&#x2003;is an intra-</entry></row><row><entry>MODE_INTRA)</entry></row><row><entry>prediction</entry><entry>&#x2003;mode,</entry></row><row><entry>&#x2003;if(intra_chroma_pred_mode = = 4 ) {</entry><entry>// is a DM (indicated</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><tbody valign="top"><row><entry>by 4),</entry></row><row><entry>&#x2003;&#x2003;transform_skip_flag [ x0 ][ y0 ][ 1 ] = transform_skip_flag[ x0 ][</entry></row><row><entry>&#x2003;&#x2003;y0 ][ 0 ]</entry></row><row><entry>&#x2003;&#x2003;transform_skip_flag [ x0 ][ y0 ][ 2 ] = transform_skip_flag[ x0 ][</entry></row><row><entry>&#x2003;&#x2003;y0 ][ 0 ]</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0016" level="1">Embodiment B-3</heading><p id="p-0263" num="0259">According to an embodiment, when the condition that a current chroma block is an inter-prediction mode (&#x201c;MODE_INTER&#x201d;) is satisfied in Operation 2, a transform skip flag of a luma block corresponding to the current chroma block may be shared. A decoder according to this embodiment may be implemented to execute Operation 2 as shown in Table 7.</p><p id="p-0264" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 7</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(Operation 2)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="196pt" align="left"/><colspec colname="2" colwidth="21pt" align="left"/><tbody valign="top"><row><entry>if(CuPredMode[ chType ][ x0 ][ y0 ] = = MODE_INTER) {</entry><entry>//</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><tbody valign="top"><row><entry>is inter prediction</entry></row><row><entry>&#x2003;transform_skip_flag [ x0 ][ y0 ][ 1 ] = transform_skip_flag[ x0 ][ y0</entry></row><row><entry>&#x2003;][ 0 ]</entry></row><row><entry>&#x2003;transform_skip_flag [ x0 ][ y0 ][ 2 ] = transform_skip_flag[ x0 ][ y0</entry></row><row><entry>&#x2003;][ 0 ]</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0017" level="1">Embodiment B-4</heading><p id="p-0265" num="0260">As Embodiment B-2 and Embodiment B-3 are applied to a case in which a current chroma block is an intra-prediction mode and a case in which the current chroma block is an inter-prediction mode, respectively, the two embodiments may be combined to implement the following operation of Table 8.</p><p id="p-0266" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 8</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(Operation 2)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="126pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>if(CuPredMode[ chType ][ x0 ][ y0 ]</entry><entry>&#x2003;&#x2003;//&#x2003;is an intra-prediction</entry></row><row><entry>= = MODE_INTRA)</entry><entry>&#x2003;&#x2003;mode,</entry></row><row><entry>&#x2003;if(intra_chroma_pred_mode = = 4) {</entry><entry>&#x2003;// the mode is a DM (4)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;transform_skip_flag [ x0 ][ y0 ][ 1 ] = transform_skip_flag[</entry></row><row><entry>&#x2003;&#x2003;x0 ][ y0 ][ 0 ]</entry></row><row><entry>&#x2003;&#x2003;transform_skip_flag [ x0 ][ y0 ][ 2 ] = transform_skip_flag[</entry></row><row><entry>&#x2003;&#x2003;x0 ][ y0 ][ 0 ]</entry></row><row><entry>&#x2003;}</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="126pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>else&#x2003;{</entry><entry>// is inter prediction</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><tbody valign="top"><row><entry>&#x2003;transform_skip_flag [ x0 ][ y0 ][ 1 ] = transform_skip_flag[ x0</entry></row><row><entry>&#x2003;][ y0 ][ 0 ]</entry></row><row><entry>&#x2003;transform_skip_flag [ x0 ][ y0 ][ 2 ] = transform_skip_flag[ x0</entry></row><row><entry>&#x2003;][ y0 ][ 0 ]</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0018" level="1">Embodiment B-5</heading><p id="p-0267" num="0261">In order to determine whether or not to skip transform for Y, Cb, Cr blocks respectively, a transform skip flag of Y block and a transform skip flag of Cb block may be transmitted (or parsed) respectively, and then Cr block may share the transform skip flag of Cb block. According to this embodiment, transform_skip_flag indicating whether or not to apply a transform skip mode is transmitted only for Y and Cb channels, and a decoder parses the transform_skip_flag in a bitstream only for Y and Cb channels. A decoder according to this embodiment may be implemented to execute Operation 2 as shown in Table 9.</p><p id="p-0268" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 9</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(Operation 2)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="140pt" align="left"/><colspec colname="2" colwidth="77pt" align="left"/><tbody valign="top"><row><entry>parse transform_skip_flag[ x0 ][ y0 ][ 1 ]</entry><entry>// Bitstream parsing</entry></row><row><entry/><entry>for Cb block</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><tbody valign="top"><row><entry>transform_skip_flag [ x0 ][ y0 ][ 2 ] = transform_skip_flag[ x0 ][</entry></row><row><entry>y0 ][ 1 ]</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0269" num="0262">Depending on embodiments, after a transform skip flag of Cr block is transmitted (or parsed), Cb block may share the transform skip flag of Cr block.</p><heading id="h-0019" level="1">Embodiment B-6</heading><p id="p-0270" num="0263">Generally, the signal features of a Cb channel and a Cr channel are similar except having opposite signs in many cases. Accordingly, instead of encoding a prediction error signal block (&#x201c;residual block&#x201d;) for Cb and Cr channels respectively, only a residual block of the Cb channel may be encoded, and a residual block of the Cr channel may not be encoded. In this case, it may be implemented such that the opposite sign of a residual block of a decoded Cr channel is used for a residual block of a Cb block. This technique is called &#x201c;tu_joint_cbcr_residual&#x201d; technique.</p><p id="p-0271" num="0264">The fact that Cb and Cr blocks are encoded through the above technique may be indicated using tu_joint_cbcr_flag. When tu_joint_cbcr_flag=1, a current block may be decoded according to tu_joint_cbcr_residual mode. When the condition for using tu_joint_cbcr_residual mode is satisfied, a residual block of a Cb channel may be decoded and then a residual block of a Cr channel may be decoded by reversing the sign of the block value of the Cb channel. When tu_joint_cbcr_flag=0, tu_joint_cbcr_residual mode is not applied to a current block. After parsing compressed residual data for a Cb block and a Cr block in a bitstream respectively, each block may be decoded.</p><p id="p-0272" num="0265">When tu_joint_cbcr_flag=1, a decoder may parse transform_skip_flag of a Cb block and use the transform skip flag of the Cb block for a Cr block with no parsing operation of transform_skip_flag of the Cr block. Or, on the contrary, when tu_joint_cbcr_flag=1, a decoder may parse transform_skip_flag of a Cr block and use the transform skip flag of the Cr block for a Cb block with no parsing operation of transform_skip_flag of the Cb block.</p><p id="p-0273" num="0266">When tu_joint_cbcr_flag=0, a decoder may decode a Cb block and a Cr block after parsing compressed residual data of the Cb and Cr blocks respectively in a bitstream. As shown in Table 10, a decoder according to this embodiment may be implemented to use one (a combination) of the operations (referred to as Operation 2) in Embodiment B or Embodiments B-1 to B-5</p><p id="p-0274" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="406pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 10</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(Operation 2)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="224pt" align="left"/><colspec colname="2" colwidth="182pt" align="left"/><tbody valign="top"><row><entry>if(tu_joint_cbcr_residual_flag[ x0 ][ y0 ]) {</entry><entry>&#x2003;&#x2003;// if joint_cbcr_residual is applied</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;parse transform_skip_flag[ x0 ][ y0 ][ 1 ]</entry><entry>&#x2003;// Bitstream parsing</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="406pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag [ x0 ][ y0 ][ 2 ] = transform_skip_flag[ x0 ][ y0 ][ 1 ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="224pt" align="left"/><colspec colname="2" colwidth="182pt" align="left"/><tbody valign="top"><row><entry>else&#x2003;{</entry><entry>// if joint_cbcr_residual is not applied</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="406pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;it Is implemented to use another one (or combination) of the Operations 2 in Embodiment B and Embodiment B-1 to Embodiment B-5</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0020" level="1">Embodiment B-7</heading><p id="p-0275" num="0267">According to an embodiment, Operation 2 is performed as follows. When tu_joint_cbcr_flag=1, a decoder may parse transform_skip_flag of a Cb block and use the transform skip flag of the Cb block for a Cr block as it is. In addition, when tu_joint_cbcr_flag=0, as shown in Table 11, a decoder may parse transform_skip_flag for a Cb block and a Cr block respectively.</p><p id="p-0276" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 11</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(Operation 2)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="147pt" align="left"/><colspec colname="2" colwidth="119pt" align="left"/><tbody valign="top"><row><entry>if(tu_joint_cbcr_residual_flag[ x0 ][ y0 ]) {</entry><entry>&#x2003;&#x2003;// if joint_cbcr_residual is applied</entry></row><row><entry>&#x2003;&#x2003;&#x2003;parse transform_skip_flag[ x0 ][ y0 ][ 1 ]</entry><entry>&#x2003;// Bitstream parsing</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2003;transform_skip_flag [ x0 ][ y0 ][ 2 ] = transform_skip_flag[ x0 ][ y0 ][ 1 ]</entry></row><row><entry>&#x2003;&#x2003;}</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="147pt" align="left"/><colspec colname="2" colwidth="119pt" align="left"/><tbody valign="top"><row><entry>else&#x2003;{</entry><entry>// if joint_cbcr_residual is not applied</entry></row><row><entry>&#x2003;&#x2003;&#x2003;parse transform_skip_flag[ x0 ][ y0 ][ 1 ]</entry><entry>&#x2003;// Bitstream parsing</entry></row><row><entry>&#x2003;&#x2003;&#x2003;parse transform_skip_flag[ x0 ][ y0 ][ 2 ]</entry><entry>&#x2003;// Bitstream parsing</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0021" level="1">Embodiment B-8</heading><p id="p-0277" num="0268">Operation 2 performed in Embodiment B-1 to Embodiment B-7 may be implemented to be limited according to a size or a shape of a current block, as shown in Table 12.</p><p id="p-0278" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 12</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(Operation 2)</entry></row><row><entry>if(Condition Check for Suggested Practice1) {</entry></row><row><entry>&#x2003;&#x2003;it is implemented to use one (or a combination) of the Operations 2 in</entry></row><row><entry>Embodiment B and Embodiment B-1 to Embodiment B-7}</entry></row><row><entry>}</entry></row><row><entry>else&#x2003;{</entry></row><row><entry>&#x2003;&#x2003;it Is implemented to use another one (or combination) of the</entry></row><row><entry>Operations 2 in Embodiment B and Embodiment B-1 to Embodiment B-7</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0279" num="0269">A condition according to an embodiment (that is, Condition Check for Suggested Practice 1) may be configured as follows according to application.</p><p id="p-0280" num="0270">a Condition Check for Suggested Practice1&#x2192;(tbWidth !=tbHeight)</p><p id="p-0281" num="0271">b Condition Check for Suggested Practice1&#x2192;(tbWidth==tbHeight)</p><p id="p-0282" num="0272">c Condition Check for Suggested Practice1&#x2192;(tbWidth&#x3e;=N*tbHeight)</p><p id="p-0283" num="0273">d Condition Check for Suggested Practice1&#x2192;(tbWidth&#x3e;=N*tbHeight)</p><p id="p-0284" num="0274">Here, tbWidth and tbHeight refer to the horizontal length and vertical height of a current coding unit respectively. In addition, the inequality sign &#x201c;=&#x3c;&#x201d; meaning that the left side is &#x201c;equal to or smaller than&#x201d; the right side may be replaced by &#x201c;&#x3c;&#x201d; meaning that &#x201c;the left side is smaller than the right side&#x201d; according to an embodiment. In addition, meaning a ratio of a width to a height (aspect ratio), N is calculated as width/height and may be at least one of 2, 4, 8, 16 and 32.</p><heading id="h-0022" level="1">Embodiment B-9</heading><p id="p-0285" num="0275">As shown in Table 13, a size of a block may be applied restrictively in all the cases of Embodiment B, Embodiment B-1 to Embodiment B-7.</p><p id="p-0286" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 13</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(Operation 2)</entry></row><row><entry>if(Condition Check for Suggested Practice2) {</entry></row><row><entry>&#x2003;&#x2003;it is implemented to use one (or a combination) of the Operations 2 in</entry></row><row><entry>Embodiment B and Embodiment B-1 to Embodiment B-7}</entry></row><row><entry>}</entry></row><row><entry>else&#x2003;{</entry></row><row><entry>&#x2003;&#x2003;it Is implemented to use another one (or combination) of the</entry></row><row><entry>Operations 2 in Embodiment B and Embodiment B-1 to Embodiment B-7</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0287" num="0276">A condition according to an embodiment (that is, Condition Check for Suggested Practice 2) may be configured as follows according to application.</p><p id="p-0288" num="0277">a Condition Check for Suggested Practice2&#x2192;((tbWidth&#x3c;N1) &#x26;&#x26; (cbHeight&#x3c;N2))</p><p id="p-0289" num="0278">b Condition Check for Suggested Practice2&#x2192;((tbWidth&#x3c;N1) OR (cbHeight&#x3c;N2))</p><p id="p-0290" num="0279">c Condition Check for Suggested Practice2&#x2192;(min(tbWidth, tbHeight)&#x3c;N3)</p><p id="p-0291" num="0280">d Condition Check for Suggested Practice2&#x2192;(max(tbWidth, tbHeight)&#x3c;N4)</p><p id="p-0292" num="0281">e Condition Check for Suggested Practice2&#x2192;(tbWidth*tbHeight&#x3c;N5)</p><p id="p-0293" num="0282">f Condition Check for Suggested Practice2&#x2192;(tbWidth+tbHeight&#x3c;N6)</p><p id="p-0294" num="0283">g Condition Check for Suggested Practice2&#x2192;(tbWidth==N7 &#x26;&#x26; tbHeight==N6)</p><p id="p-0295" num="0284">h Condition Check for Suggested Practice2&#x2192;(tbWidth==N7 &#x26;&#x26; tbHeight==N7)</p><p id="p-0296" num="0285">i Condition Check for Suggested Practice2&#x2192;(log(tbWidth)+log(tbHeight)&#x3c;N8)</p><p id="p-0297" num="0286">In the various embodiments above, the inequality sign &#x201c;&#x3c;&#x201d; meaning that the left side is &#x201c;smaller&#x201d; than the right side may be replaced by &#x201c;=&#x3c;&#x201d; meaning that &#x201c;the left side is equal to or smaller than the right side&#x201d;, according to application. In addition, N1 to N7 indicating a predetermined boundary condition value may be one of 2, 4, 8, 12, 16, 32, 64 and 128 respectively, and N8 may be one of 0, 1, 2, 3, 4, 5 and 6.</p><heading id="h-0023" level="1">Embodiment C</heading><p id="p-0298" num="0287">Depending on an embodiment, it may be necessary to enable or disable the use of a transform skip mode. For example, when transform skip is advantageous to a part of an image but disadvantageous to the remaining part, a transform skip mode may be globally enabled or disabled at an upper level of CU. In this regard, whether or not transform skip is possible may be set by setting transform_skip_enabled_flag and transform_skip_chroma_enabled_flag.</p><p id="p-0299" num="0288">transform_skip_enabled_flag, which indicates whether or not transform is enabled, is applied both to a luma block and a chroma block. That is, transform_skip_enabled_flag=0 may indicate that a transform skip mode is not to be used. In addition, transform_skip_enabled_flag=1 may indicate that a transform skip mode is to be used.</p><p id="p-0300" num="0289">transform_skip_chroma_enabled_flag indicates whether or not transform skip may be enabled for a chroma block. When transform_skip_enabled_flag=1 and transform_skip_chroma_enabled_flag=1, a transform skip mode may be enabled for a chroma block. When transform_skip_enabled_flag=1 and transform_skip_chroma_enabled_flag=0, a transform skip mode may be enabled for a luma block, but a transform skip mode may not be enabled for a chroma block.</p><p id="p-0301" num="0290">In the case of transform_skip_enabled_flag=0, transform skip may not be used both for a luma block and for a chroma block. Accordingly, in the case of transform_skip_enabled_flag=0, transform_skip_chroma_enabled_flag may not be included in a bitstream. Also, transform skip_chroma_enabled_flag may be determined as 0.</p><p id="p-0302" num="0291">transform_skip_enabled_flag and transform_skip_chroma_enabled_flag may be implemented as shown in Table 14 and be transmitted by being included in an upper level unit like SPS (Sequence Parameter Set).</p><p id="p-0303" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="133pt" align="left"/><colspec colname="2" colwidth="140pt" align="left"/><colspec colname="3" colwidth="21pt" align="left"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 14</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>seq_parameter_set_rbsp( ){</entry><entry/><entry/></row><row><entry>...</entry></row><row><entry>&#x2003;transform_skip_enabled_flag</entry><entry>&#x2009;//parse transform_skip_enabled_flag</entry></row><row><entry>&#x2003;if(transform_skip_enabled_flag ) {</entry></row><row><entry>&#x2003;&#x2003;transform_skip_chroma_enabled_flag</entry><entry>//parse transform_skip_chroma_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;sps_bdpcm_enabled_flag</entry><entry/><entry>u(1)</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0304" num="0292">However, in the case of an embodiment in which a natural video and a computer-generated video are frequently repeated, transform_skip_enabled_flag and transform_skip_chroma_enabled_flag may be transmitted by being included in a PPS (Picture Parameter Set), as shown in Table 15.</p><p id="p-0305" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="133pt" align="left"/><colspec colname="2" colwidth="140pt" align="left"/><colspec colname="3" colwidth="21pt" align="left"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 15</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>picture_parameter_set_rbsp( ){</entry><entry/><entry/></row><row><entry>...</entry></row><row><entry>&#x2003;transform_skip_enabled_flag</entry><entry>&#x2009;//parse transform_skip_enabled_flag</entry></row><row><entry>&#x2003;if(transform_skip_enabled_flag ) {</entry></row><row><entry>&#x2003;&#x2003;transform_skip_chroma_enabled_flag</entry><entry>//parse transform_skip_chroma_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;sps_bdpcm_enabled_flag</entry><entry/><entry>u(1)</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0306" num="0293">In another embodiment, transform_skip_enabled_flag and transform_skip_chroma_enabled_flag may be included both in a SPS and in a PPS.</p><p id="p-0307" num="0294">An embodiment that globally enables or disables a transform skip mode by using transform_skip_enabled_flag and transform skip_chroma_enabled_flag may be applied to all the embodiments described above.</p><p id="p-0308" num="0295">As shown in Table 16, the &#x3c;Embodiment A-1&#x3e; may be implemented by being modified to the &#x3c;Embodiment C-1&#x3e; below.</p><p id="p-0309" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="294pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 16</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( sps_joint_cbcr_enabled_flag &#x26;&#x26; ( ( CuPredMode[ chType ][ x0 ][ y0 ] = = MODE_INTR</entry></row><row><entry>A</entry></row><row><entry>&#x2003;&#x2003;&#x2002;&#x26;&#x26; ( tu_cbf_cb[ x0 ][ y0 ] | | tu_cbf_cr[ x0 ][ y0 ] ) ) | |</entry></row><row><entry>&#x2003;&#x2003;( tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_cbf_cr[ x0 ][ y0 ] ) ) )</entry></row><row><entry>&#x2003;&#x2003;tu_joint_cbcr_residual_flag[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;if( ( tbWidth &#x3c;= 32 ) &#x26;&#x26; ( tbHeight &#x3c;= 32 )</entry></row><row><entry>&#x2003;&#x2003;&#x2009;&#x26;&#x26; ( IntraSubPartitionsSplit[ x0 ][ y0 ] = = ISP_NO_SPLIT ) &#x26;&#x26; ( !cu_sbt_flag ) ) {</entry></row><row><entry>&#x2003;&#x2003;if(!BdpcmFlag[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2009;tbWidth &#x3c;= MaxTsSize &#x26;&#x26; tbHeight &#x3c;= MaxTsSize ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_luma[ x0 ][ y0 ] {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;if (transform_skip_enabled_flag)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag[ x0 ][ y0 ][0]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;if( ( ( CuPredMode[ chType ][ x0 ][ y0 ] = = MODE_INTER &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sps_explicit_mts_inter_enabled_flag ) | | ( CuPredMode[ chType ][ x0 ][ y0 ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;= = MODE_INTRA &#x26;&#x26; sps_explicit_mts_intra_enabled_flag ) ) &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( !transform_skip_flag[ x0 ][ y0 ] ) )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tu_mts_idx[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_cb[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;if (transform_skip_chroma_enabled_flag)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag[ x0 ][ y0 ][1]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_cr[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;!(tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_joint_cbcr_residual_flag[ x0 ][ y0 ]))</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;if (transform_skip_chroma_enabled_flag)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2009;transform_skip_flag[ x0 ][ y0 ][2]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;if( tu_cbf_luma[ x0 ][ y0 ] ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( !transform_skip_flag[ x0 ][ y0 ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( x0, y0, Log2( tbWidth ), Log2( tbHeight ), 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_ts_coding( x0, y0, Log2( tbWidth ), Log2( tbHeight ), 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;if( tu_cbf_cb[ x0 ][ y0 ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( xC, yC, Log2( wC ), Log2( hC ), 1 )</entry></row><row><entry>&#x2003;if( tu_cbf_cr[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;!( tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_joint_cbcr_residual_flag[ x0 ][ y0 ] )) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( xC, yC, Log2( wC ), Log2( hC ), 2 )</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0310" num="0296">As shown in Table 17, the &#x3c;Embodiment A-2&#x3e; may be implemented by being modified to the &#x3c;Embodiment C-2&#x3e; below.</p><heading id="h-0024" level="1">Embodiment C-2</heading><p id="p-0311" num="0297"></p><p id="p-0312" num="0000"><tables id="TABLE-US-00017" num="00017"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 17</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( sps_joint_cbcr_enabled_flag &#x26;&#x26; ( ( CuPredMode[ chType ][ x0</entry></row><row><entry>&#x2003;][ y0 ] = = MODE_INTRA</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26; ( tu_cbf_cb[ x0 ][ y0 ] | | tu_cbf_cr[ x0 ][ y0 ] ) ) | |</entry></row><row><entry>&#x2003;&#x2003;( tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_cbf_cr[ x0 ][ y0 ] ) ) )</entry></row><row><entry>&#x2003;&#x2003;tu_joint_cbcr_residual_flag[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;if( ( tbWidth &#x3c;= 32 ) &#x26;&#x26; ( tbHeight &#x3c;= 32 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26; ( IntraSubPartitionsSplit[ x0 ][ y0 ] = = ISP_NO_SPLIT )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26; ( !cu_sbt_flag ) ) {</entry></row><row><entry>&#x2003;&#x2003;if(!BdpcmFlag[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tbWidth &#x3c;= MaxTsSize &#x26;&#x26; tbHeight &#x3c;= MaxTsSize ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_luma[ x0 ][ y0 ]) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if (transform_skip_enabled_flag)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag[ x0 ][ y0 ][0]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( ( ( CuPredMode[ chType ][ x0 ][ y0 ] = =</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;MODE_INTER &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sps_explicit_mts_inter_enabled_flag )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;| | ( CuPredMode[ chType ][ x0 ][ y0 ] = =</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;MODE_INTRA &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sps_explicit_mts_intra_enabled_flag ) ) &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( !transform_skip_flag[ x0 ][ y0 ] ) )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tu_mts_idx[ x0 ][ y0 ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( !transform_skip_flag[ x0 ][ y0 ][0] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( x0, y0, Log2( tbWidth ),</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;Log2( tbHeight ), 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_ts_coding( x0, y0, Log2(</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tbWidth ), Log2( tbHeight ), 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_cb[ x0 ][ y0 ]) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if (transform_skip_chroma_enabled_flag)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag[ x0 ][ y0 ][1]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( !transform_skip_flag[ x0 ][ y0 ][1] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( xC, yC, Log2( wC ), Log2(</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003; hC ), 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_ts_coding( xC, yC, Log2( wC ),</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;Log2( hC ), 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( tu_cbf_cr[ x0 ][ y0 ] &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;!(tu_cbf_cb[ x0 ][ y0 ] &#x26;&#x26; tu_joint_cbcr_residual_flag[</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;x0 ][ y0 ])) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if (transform_skip_chroma_enabled_flag)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag[ x0 ][ y0 ][2]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( !transform_skip_flag[ x0 ][ y0 ][2] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_coding( xC, yC, Log2( wC ), Log2(</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;hC ), 2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;residual_ts_coding( xC, yC, Log2( wC ),</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;Log2( hC ), 2 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0313" num="0298">In the same way as implementing &#x3c;Embodiment C-1&#x3e; and &#x3c;Embodiment C-2&#x3e;, all the embodiments described above may be implemented to globally enable or disable a transform skip mode by using transform_skip_enabled_flag and transform_skip_chroma_enabled_flag.</p><p id="p-0314" num="0299"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates a video decoding method according to an embodiment of the present disclosure.</p><p id="p-0315" num="0300">In the step S<b>902</b>, a chroma residual joint flag of a current block may be obtained which indicates whether or not a chroma residual joint mode is applied to the current block.</p><p id="p-0316" num="0301">According to an embodiment, a video decoding method may further include obtaining a chroma residual joint enable flag, which indicates whether or not a chroma residual joint mode is enabled for an upper level unit of a current block, from a bitstream. In addition, when the chroma residual joint enable flag indicates that a chroma residual joint mode is enabled for the upper level unit of the current block, a chroma residual joint flag of the current block may be obtained.</p><p id="p-0317" num="0302">According to an embodiment, the upper-level unit may be at least one of a video, a coded video sequence (CVS), a picture, a sub-picture, a slice, a tile, and a coding tree unit.</p><p id="p-0318" num="0303">In the step S<b>904</b>, a transform skip mode flag for a luma component of a current block and a transform skip mode flag for a first chroma component may be obtained from a bitstream.</p><p id="p-0319" num="0304">According to an embodiment, a transform skip mode flag for a luma component of a current block may be obtained according to a size of the current block. In addition, a transform skip mode flag for a first chroma component of a current block may be obtained according to the size of the current block. In addition, a transform skip mode flag for a second chroma component of a current block may be obtained according to the size of the current block.</p><p id="p-0320" num="0305">According to an embodiment, a transform skip mode flag for a first chroma component of a current block may be obtained according to the size and color format of the current block.</p><p id="p-0321" num="0306">According to an embodiment, when a height of a current block is equal to or smaller than a maximum block height and a width of the current block is equal to or smaller than a maximum block width, a transform skip mode flag may be obtained for a luma component of the current block. In addition, when a height of a current block adjusted according to color format is equal to or smaller than a maximum block height and a width of the current block adjusted according to color format is equal to or smaller than a maximum block width, a transform skip mode flag may be obtained for a first chroma component of the current block.</p><p id="p-0322" num="0307">In the step S<b>906</b>, when the chroma residual joint flag indicates that a chroma residual joint mode is applied to a current block, whether or not a transform skip mode is applied to a second chroma component of the current block may be determined according to a transform skip mode flag for a first chroma component.</p><p id="p-0323" num="0308">In the step S<b>908</b>, when the chroma residual joint flag indicates that a chroma residual joint mode is not applied to a current block, a transform skip mode flag for a second chroma component of the current block may be obtained from a bitstream.</p><p id="p-0324" num="0309">According to an embodiment, a transform skip mode flag for a second chroma component of a current block may be obtained according to the size of the current block. In addition, a transform skip mode flag for a second chroma component of a current block may be obtained according to the size and color format of the current block.</p><p id="p-0325" num="0310">According to an embodiment, when a height of a current block adjusted according to color format is equal to or smaller than a maximum block height and a width of the current block adjusted according to color format is equal to or smaller than a maximum block width, a transform skip mode flag may be obtained for a second chroma component of the current block.</p><p id="p-0326" num="0311">According to an embodiment, a video decoding method may further include determining a residual sample for a second chroma component of a current block according to a residual sample of the first chroma component of the current block, when a chroma residual joint flag indicates that a chroma residual joint mode is applied to the current block.</p><p id="p-0327" num="0312">According to an embodiment, a size of a residual sample for a second chroma component may be determined based on a size of a residual sample for a first chroma component, and a sign of the residual sample for the second chroma component may be determined to be opposite to a sign of the residual sample for the first chroma component.</p><p id="p-0328" num="0313">According to an embodiment, a video decoding method may further include obtaining, from a bitstream. chroma residual joint sign information indicating a relation between a sign of a residual sample for a first chroma component and a sign of a residual sample for a second chroma component. Also, a sign of a residual sample for a second chroma component may be determined according to chroma residual joint sign information and a sign of a residual sample for a first chroma component.</p><p id="p-0329" num="0314"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a video encoding method according to an embodiment of the present disclosure.</p><p id="p-0330" num="0315">In the step S<b>1002</b>, a chroma residual joint flag of a current block is encoded which indicates whether or not a chroma residual joint mode is applied to the current block.</p><p id="p-0331" num="0316">According to an embodiment, whether or not a chroma residual joint mode is applied to a current block may be determined according to a residual sample for a first chroma component of the current block and a residual sample for a second chroma component of the current block.</p><p id="p-0332" num="0317">According to an embodiment, when a chroma residual joint mode is applied to a current block, chroma residual joint sign information indicating a relation between a sign of a residual sample for a first chroma component and a sign of a residual sample for a second chroma component may be encoded according to the residual sample for the first chroma component of the current block and the residual sample for the second chroma component of the current block.</p><p id="p-0333" num="0318">According to an embodiment, a video decoding method may further include encoding a chroma residual joint enable flag indicating whether or not a chroma residual joint mode is enabled for an upper level unit of a current block. In addition, when the chroma residual joint enable flag indicates that a chroma residual joint mode is enabled for the upper level unit of the current block, a chroma residual joint flag of the current block may be encoded.</p><p id="p-0334" num="0319">According to an embodiment, the upper-level unit may be at least one of a video, a coded video sequence (CVS), a picture, a sub-picture, a slice, a tile, and a coding tree unit.</p><p id="p-0335" num="0320">In the step S<b>1004</b>, a transform skip mode flag for a luma component of a current block and a transform skip mode flag for a first chroma component of the current block are encoded.</p><p id="p-0336" num="0321">According to an embodiment, a transform skip mode flag for a luma component of a current block may be encoded according to a size of the current block. In addition, a transform skip mode flag for a first chroma component of the current block may be encoded according to the size of the current block.</p><p id="p-0337" num="0322">According to an embodiment, a transform skip mode flag for a first chroma component of a current block may be encoded according to the size and color format of the current block.</p><p id="p-0338" num="0323">According to an embodiment, when a height of a current block is equal to or smaller than a maximum block height and a width of the current block is equal to or smaller than a maximum block width, a transform skip mode flag for a luma component of the current block may be encoded. In addition, when a height of a current block adjusted according to color format is equal to or smaller than a maximum block height and a width of the current block adjusted according to color format is equal to or smaller than a maximum block width, a transform skip mode flag for a first chroma component of the current block may be encoded.</p><p id="p-0339" num="0324">In the step S<b>1006</b>, when a chroma residual joint mode is applied to a current block, encoding of a transform skip mode flag for a second chroma component of the current block is skipped.</p><p id="p-0340" num="0325">In the step S<b>1008</b>, when a chroma residual joint mode is not applied to a current block, a transform skip mode flag for a second chroma component of the current block is encoded.</p><p id="p-0341" num="0326">According to an embodiment, a transform skip mode flag for a second chroma component of a current block may be encoded according to a size of the current block. Alternatively, a transform skip mode flag for a second chroma component of a current block may be encoded according to the size and color format of the current block.</p><p id="p-0342" num="0327">According to an embodiment, the first chroma component and the second chroma component in the video decoding method of <figref idref="DRAWINGS">FIG. <b>9</b></figref> and the video encoding method of <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be a Cb component and a Cr component respectively or a Cr component and a Cb component respectively.</p><p id="p-0343" num="0328">The embodiments of <figref idref="DRAWINGS">FIG. <b>9</b></figref> and <figref idref="DRAWINGS">FIG. <b>10</b></figref> are illustrative, and each step of <figref idref="DRAWINGS">FIG. <b>9</b></figref> and <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be readily modified by those skilled in the art. In addition, each configuration of <figref idref="DRAWINGS">FIG. <b>9</b></figref> and <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be omitted or replaced by other configuration. The video decoding method of <figref idref="DRAWINGS">FIG. <b>9</b></figref> may be performed in the decoder of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. In addition, the video encoding method of <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be performed in the encoder of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. Also, one or more processors may perform commands implementing each step of <figref idref="DRAWINGS">FIG. <b>9</b></figref> and <figref idref="DRAWINGS">FIG. <b>10</b></figref>. In addition, a program product including commands implementing each step of <figref idref="DRAWINGS">FIG. <b>9</b></figref> and <figref idref="DRAWINGS">FIG. <b>10</b></figref> may be stored in a memory device or be circulated online.</p><p id="p-0344" num="0329">The above embodiments may be performed in the same method in an encoder and a decoder.</p><p id="p-0345" num="0330">At least one or a combination of the above embodiments may be used to encode/decode a video.</p><p id="p-0346" num="0331">A sequence of applying to above embodiment may be different between an encoder and a decoder, or the sequence applying to above embodiment may be the same in the encoder and the decoder.</p><p id="p-0347" num="0332">The above embodiment may be performed on each luma signal and chroma signal, or the above embodiment may be identically performed on luma and chroma signals.</p><p id="p-0348" num="0333">A block form to which the above embodiments of the present invention are applied may have a square form or a non-square form.</p><p id="p-0349" num="0334">At least one of syntax elements (flags, indices, etc.) entropy-coded by the encoder and entropy-decoded by the decoder may use at least one of the following binarization/debinarization methods and entropy-coding/decoding methods.</p><p id="p-0350" num="0335">Signed 0-th order Exp_Golomb binarization/debinarization method (se(v))</p><p id="p-0351" num="0336">Signed k-th order Exp_Golomb binarization/debinarization method (sek(v))</p><p id="p-0352" num="0337">Unsigned 0-th order Exp_Golomb binarization/debinarization method (ue(v))</p><p id="p-0353" num="0338">Unsigned k-th order Exp_Golomb binarization/debinarization method (uek(v))</p><p id="p-0354" num="0339">Fixed-length binarization/debinarization method (f(n))</p><p id="p-0355" num="0340">Truncated Rice binarization/debinarization method or Truncated Unary binarization/debinarization method (tu(v))</p><p id="p-0356" num="0341">Truncated binary binarization/debinarization method (tb(v))</p><p id="p-0357" num="0342">Context-adaptive arithmetic encoding/decoding method (ae(v))</p><p id="p-0358" num="0343">Byte-unit bit string (b(8))</p><p id="p-0359" num="0344">Signed integer binarization/debinarization method (i(n))</p><p id="p-0360" num="0345">Unsigned integer binarization/debinarization method (u(n))</p><p id="p-0361" num="0346">Unary binarization/debinarization method</p><p id="p-0362" num="0347">The above embodiment of the present invention may be applied depending on a size of at least one of a coding block, a prediction block, a transform block, a block, a current block, a coding unit, a prediction unit, a transform unit, a unit, and a current unit. Herein, the size may be defined as a minimum size or maximum size or both so that the above embodiments are applied, or may be defined as a fixed size to which the above embodiment is applied. In addition, in the above embodiments, a first embodiment may be applied to a first size, and a second embodiment may be applied to a second size. In other words, the above embodiments may be applied in combination depending on a size. In addition, the above embodiments may be applied when a size is equal to or greater that a minimum size and equal to or smaller than a maximum size. In other words, the above embodiments may be applied when a block size is included within a certain range.</p><p id="p-0363" num="0348">For example, the above embodiments may be applied when a size of current block is 8&#xd7;8 or greater. For example, the above embodiments may be applied when a size of current block is 4&#xd7;4 only. For example, the above embodiments may be applied when a size of current block is 16&#xd7;16 or smaller. For example, the above embodiments may be applied when a size of current block is equal to or greater than 16&#xd7;16 and equal to or smaller than 64&#xd7;64.</p><p id="p-0364" num="0349">The above embodiments of the present invention may be applied depending on a temporal layer. In order to identify a temporal layer to which the above embodiments may be applied, a corresponding identifier may be signaled, and the above embodiments may be applied to a specified temporal layer identified by the corresponding identifier. Herein, the identifier may be defined as the lowest layer or the highest layer or both to which the above embodiment may be applied, or may be defined to indicate a specific layer to which the embodiment is applied. In addition, a fixed temporal layer to which the embodiment is applied may be defined.</p><p id="p-0365" num="0350">For example, the above embodiments may be applied when a temporal layer of a current image is the lowest layer. For example, the above embodiments may be applied when a temporal layer identifier of a current image is 1. For example, the above embodiments may be applied when a temporal layer of a current image is the highest layer.</p><p id="p-0366" num="0351">A slice type or a tile group type to which the above embodiments of the present invention are applied may be defined, and the above embodiments may be applied depending on the corresponding slice type or tile group type.</p><p id="p-0367" num="0352">In the above-described embodiments, the methods are described based on the flowcharts with a series of steps or units, but the present invention is not limited to the order of the steps, and rather, some steps may be performed simultaneously or in different order with other steps. In addition, it should be appreciated by one of ordinary skill in the art that the steps in the flowcharts do not exclude each other and that other steps may be added to the flowcharts or some of the steps may be deleted from the flowcharts without influencing the scope of the present invention.</p><p id="p-0368" num="0353">The embodiments include various aspects of examples. All possible combinations for various aspects may not be described, but those skilled in the art will be able to recognize different combinations. Accordingly, the present invention may include all replacements, modifications, and changes within the scope of the claims.</p><p id="p-0369" num="0354">The embodiments of the present invention may be implemented in a form of program instructions, which are executable by various computer components, and recorded in a computer-readable recording medium. The computer-readable recording medium may include stand-alone or a combination of program instructions, data files, data structures, etc. The program instructions recorded in the computer-readable recording medium may be specially designed and constructed for the present invention, or well-known to a person of ordinary skilled in computer software technology field. Examples of the computer-readable recording medium include magnetic recording media such as hard disks, floppy disks, and magnetic tapes; optical data storage media such as CD-ROMs or DVD-ROMs; magneto-optimum media such as floptical disks; and hardware devices, such as read-only memory (ROM), random-access memory (RAM), flash memory, etc., which are particularly structured to store and implement the program instruction. Examples of the program instructions include not only a mechanical language code formatted by a compiler but also a high-level language code that may be implemented by a computer using an interpreter. The hardware devices may be configured to be operated by one or more software modules or vice versa to conduct the processes according to the present invention.</p><p id="p-0370" num="0355">Although the present invention has been described in terms of specific items such as detailed elements as well as the limited embodiments and the drawings, they are only provided to help more general understanding of the invention, and the present invention is not limited to the above embodiments. It will be appreciated by those skilled in the art to which the present invention pertains that various modifications and changes may be made from the above description.</p><p id="p-0371" num="0356">Therefore, the spirit of the present invention shall not be limited to the above-described embodiments, and the entire scope of the appended claims and their equivalents will fall within the scope and spirit of the invention.</p><heading id="h-0025" level="1">INDUSTRIAL APPLICABILITY</heading><p id="p-0372" num="0357">The present invention may be used to encode or decode an image.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A video decoding method, the method comprising:<claim-text>obtaining a chroma residual joint flag of a current block indicating whether or not a chroma residual joint mode is applied to the current block;</claim-text><claim-text>obtaining, from a bitstream, a transform skip mode flag for a luma component of the current block and a transform skip mode flag for a first chroma component;</claim-text><claim-text>when the chroma residual joint flag indicates that a chroma residual joint mode is applied to the current block, determining whether or not a transform skip mode is applied to a second chroma component of the current block, according to the transform skip mode flag for the first chroma component; and</claim-text><claim-text>when the chroma residual joint flag indicates that a chroma residual joint mode is not applied to the current block, obtaining, from the bitstream, a transform skip mode flag for the second chroma component of the current block.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising<claim-text>determining a residual sample for the second chroma component of a current block according to a residual sample of the first chroma component of the current block, when the chroma residual joint flag indicates that a chroma residual joint mode is applied to the current block.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The video decoding method of <claim-ref idref="CLM-00002">claim 2</claim-ref>,<claim-text>wherein a size of the residual sample for the second chroma component is determined based on a size of the residual sample for the first chroma component, and</claim-text><claim-text>wherein a sign of the residual sample for the second chroma component is determined to be opposite to a sign of the residual sample for the first chroma component.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The video decoding method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising<claim-text>obtaining, from the bitstream, chroma residual joint sign information indicating a relation between the sign of the residual sample for the first chroma component and the sign of the residual sample for the second chroma component,</claim-text><claim-text>wherein the sign of the residual sample for the second chroma component is determined according to the chroma residual joint sign information and the sign of the residual sample for the first chroma component.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,<claim-text>wherein the obtaining of the transform skip mode flag for the luma component of the current block and the transform skip mode flag for the first chroma component comprises:</claim-text><claim-text>obtaining the transform skip mode flag for the luma component of the current block according to a size of the current block; and</claim-text><claim-text>obtaining the transform skip mode flag for the first chroma component of the current block according to the size of the current block.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The video decoding method of <claim-ref idref="CLM-00005">claim 5</claim-ref>,<claim-text>wherein the obtaining of the transform skip mode flag for the luma component of the current block according to the size of the current block comprises</claim-text><claim-text>obtaining the transform skip mode flag for the luma component of the current block, when a height of the current block is equal to or less than a maximum block height and a width of the current block is equal to or less than a maximum block width.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The video decoding method of <claim-ref idref="CLM-00005">claim 5</claim-ref>,<claim-text>wherein the obtaining of the transform skip mode flag for the first chroma component of the current block according to the size of the current block comprises</claim-text><claim-text>obtaining the transform skip mode flag for the first chroma component of the current block according to the size and a color format of the current block.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising<claim-text>obtaining, from the bitstream, a chroma residual joint enable flag indicating whether or not a chroma residual joint mode is enabled for an upper-level unit of the current block,</claim-text><claim-text>wherein the obtaining of the chroma residual joint flag of the current block comprises obtaining the chroma residual joint flag of the current block, when the chroma residual joint enable flag indicates that the chroma residual joint mode is enabled for the upper-level unit of the current block.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The video decoding method of <claim-ref idref="CLM-00008">claim 8</claim-ref>,<claim-text>wherein the upper-level unit is at least one of a video, a coded video sequence (CVS), a picture, a sub-picture, a slice, a tile, and a coding tree unit.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,<claim-text>wherein the first chroma component and the second chroma component are a Cb component and a Cr component respectively, or a Cr component and a Cb component respectively.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A video encoding method, the method comprising:<claim-text>encoding a chroma residual joint flag of a current block indicating whether or not a chroma residual joint mode is applied to the current block:</claim-text><claim-text>encoding a transform skip mode flag for a luma component of the current block and a transform skip mode flag for a first chroma component of the current block:</claim-text><claim-text>skipping encoding of a transform skip mode flag for a second chroma component of the current block, when the chroma residual joint mode is applied to the current block; and</claim-text><claim-text>encoding the transform skip mode flag for the second chroma component of the current block, when the chroma residual joint mode is not applied to the current block.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The video encoding method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising<claim-text>determining whether or not the chroma residual joint mode is applied to the current block, according to a residual sample for the first chroma component of the current block and a residual sample for the second chroma component of the current block.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The video encoding method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising<claim-text>encoding chroma residual joint sign information indicating a relation between a sign of the residual sample for the first chroma component and a sign of the residual sample for the second chroma component according to the residual sample for the first chroma component of the current block and the residual sample for the second chroma component of the current block.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The video encoding method of <claim-ref idref="CLM-00011">claim 11</claim-ref>,<claim-text>wherein the encoding of the transform skip mode flag for the luma component of the current block and the transform skip mode flag for the first chroma component of the current block comprises:</claim-text><claim-text>encoding the transform skip mode flag for the luma component of the current block according to a size of the current block; and</claim-text><claim-text>encoding the transform skip mode flag for the first chroma component of the current block according to the size of the current block.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The video encoding method of <claim-ref idref="CLM-00014">claim 14</claim-ref>,<claim-text>wherein the encoding of the transform skip mode flag for the luma component of the current block according to the size of the current block comprises</claim-text><claim-text>encoding the transform skip mode flag for the luma component of the current block, when a height of the current block is equal to or less than a maximum block height and a width of the current block is equal to or less than a maximum block width.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The video encoding method of <claim-ref idref="CLM-00014">claim 14</claim-ref>,<claim-text>wherein the encoding of the transform skip mode flag for the first chroma component of the current block according to the size of the current block comprises</claim-text><claim-text>encoding the transform skip mode flag for the first chroma component of the current block according to the size and a color format of the current block.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The video encoding method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising<claim-text>encoding a chroma residual joint enable flag indicating whether or not a chroma residual joint mode is enabled for an upper-level unit of the current block,</claim-text><claim-text>wherein the encoding of the chroma residual joint flag of the current block comprises encoding the chroma residual joint flag of the current block, when the chroma residual joint enable flag indicates that the chroma residual joint mode is enabled for the upper-level unit of the current block.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The video encoding method of <claim-ref idref="CLM-00017">claim 17</claim-ref>,<claim-text>wherein the upper-level unit is at least one of a video, a coded video sequence (CVS), a picture, a sub-picture, a slice, a tile, and a coding tree unit.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The video encoding method of <claim-ref idref="CLM-00011">claim 11</claim-ref>,<claim-text>wherein the first chroma component and the second chroma component are a Cb component and a Cr component respectively, or a Cr component and a Cb component respectively.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. A computer-readable recording medium for storing a bitstream comprising video data that are encoded according to a video encoding method,<claim-text>wherein the bitstream comprises:</claim-text><claim-text>a chroma residual joint flag of a current block indicating whether or not a chroma residual joint mode is applied to the current block;</claim-text><claim-text>a transform skip mode flag for a luma component of the current block; and</claim-text><claim-text>a transform skip mode flag for a first chroma component of the current block,</claim-text><claim-text>wherein, when the chroma residual joint flag indicates that the chroma residual joint mode is not applied to the current block, the bitstream further comprises a transform skip mode flag for a second chroma component of the current block, and</claim-text><claim-text>wherein, when the chroma residual joint flag indicates that the chroma residual joint mode is applied to the current block, the transform skip mode flag for the second chroma component of the current block is skipped in the bitstream, and whether or not a transform skip mode is applied to the second chroma component of the current block is determined according to the transform skip mode flag for the first chroma component.</claim-text></claim-text></claim></claims></us-patent-application>