<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004564A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004564</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17364808</doc-number><date>20210630</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2455</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2453</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>28</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>24552</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>24539</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>24568</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>283</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>285</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">MAKING DECISIONS FOR PLACING DATA IN A MULTI-TENANT CACHE</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Amazon Technologies, Inc.</orgname><address><city>Seattle</city><state>WA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Rochel</last-name><first-name>Steffen</first-name><address><city>Burlingame</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Januschowski</last-name><first-name>Tim</first-name><address><city>Berlin</city><country>DE</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Mallidi</last-name><first-name>Sainath Chowdary</first-name><address><city>Seattle</city><state>WA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Caldwell</last-name><first-name>Andrew Edward</first-name><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Atta</last-name><first-name>Islam Mohamed Hatem A</first-name><address><city>Redmond</city><state>WA</state><country>US</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Flunkert</last-name><first-name>Valentin</first-name><address><city>Berlin</city><country>DE</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>Ashok</last-name><first-name>Arjun</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Amazon Technologies, Inc.</orgname><role>02</role><address><city>Seattle</city><state>WA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Placement decisions may be made to place data in a multi-tenant cache. Usage of multi-tenant cache nodes for performing access requests may be obtained. Usage prediction techniques may be applied to the usage to determine placement decisions for data amongst the multi-tenant cache nodes. Placement actions for the data amongst at the multi-tenant cache nodes may be performed according to the placement decisions.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="129.12mm" wi="158.75mm" file="US20230004564A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="216.24mm" wi="161.04mm" orientation="landscape" file="US20230004564A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="161.71mm" wi="162.48mm" file="US20230004564A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="234.19mm" wi="162.90mm" file="US20230004564A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="253.92mm" wi="164.42mm" file="US20230004564A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="251.21mm" wi="150.28mm" file="US20230004564A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="250.70mm" wi="160.44mm" orientation="landscape" file="US20230004564A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="180.09mm" wi="111.51mm" file="US20230004564A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="180.85mm" wi="89.32mm" file="US20230004564A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="130.05mm" wi="89.24mm" file="US20230004564A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="171.87mm" wi="159.77mm" file="US20230004564A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">As the technological capacity for organizations to create, track, and retain information continues to grow, a variety of different technologies for accessing data with increasing speed and efficiency continue to be developed. Computational storage, for example may be utilized by various applications to perform some of the data processing work prior to returning requested data to the application, such as database system.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0003" num="0002"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a logical block diagram of making decisions for placing data for in a multi-tenant cache, according to some embodiments.</p><p id="p-0004" num="0003"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a logical block diagram illustrating a provider network offering data processing services that utilize a query acceleration service, according to some embodiments.</p><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a logical block diagram of a data warehouse service that uses a query acceleration service to perform data analytics operations using a multi-tenant cache, according to some embodiments.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a logical block diagram illustrating an example processing cluster of a data warehouse service using a query acceleration service to perform a query, according to some embodiments.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a logical block diagram illustrating a query acceleration service that implements making decisions for placing data for query acceleration, according to some embodiments.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a logical block diagram of data placement management that applies usage prediction techniques to train models for making placement decisions for query acceleration, according to some embodiments.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a high-level flowchart illustrating methods and techniques to implement making decisions for placing data in a multi-tenant cache, according to some embodiments.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a high-level flowchart illustrating methods and techniques to implement time series prediction for making placement decisions, according to some embodiments.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a high-level flowchart illustrating methods and techniques to implement reinforcement learning for making placement decisions, according to some embodiments.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates an example system that implements the various methods, techniques, and systems described herein, according to some embodiments.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0013" num="0012">While embodiments are described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that embodiments are not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit embodiments to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word &#x201c;may&#x201d; is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words &#x201c;include,&#x201d; &#x201c;including,&#x201d; and &#x201c;includes&#x201d; mean including, but not limited to.</p><p id="p-0014" num="0013">It will also be understood that, although the terms first, second, etc. may be used herein to describe various elements, these elements should not be limited by these terms. These terms are only used to distinguish one element from another. For example, a first contact could be termed a second contact, and, similarly, a second contact could be termed a first contact, without departing from the scope of the present invention. The first contact and the second contact are both contacts, but they are not the same contact.</p><heading id="h-0003" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading><p id="p-0015" num="0014">Various techniques for making decisions for placing data in a multi-tenant cache are described herein. Multi-tenant caches may improve the performance of various client systems, services, or application, such as the data warehouse service discussed below. A multi-tenant cache may distribute data across multiple different multi-tenant cache nodes, which may then respond to client application requests to provide data. A multi-tenant cache may implement a multi-tenant model for sharing the resources of an individual multi-tenant node across different users, entities, application, services, or other organizations. One multi-tenant node may, for example, store data for different tenants (e.g., users, entities, application, services, or other organizations) on the same node (e.g., in different ranges of memory or different storage devices implemented on the same node). A multi-tenant cache may still guarantee the privacy of data for tenants, preventing one tenant's data from being modified, returned, read, or otherwise accessed by another tenant.</p><p id="p-0016" num="0015">Because a multi-tenant cache may support the distribution of data across multiple different multi-tenant cache nodes, the performance of various requests to obtain data (as well as different data processing operations) can be improved as the work to return data (and/or perform data processing operations on the data prior to the data being returned) can be distributed across a large number of nodes. Further performance improvements, however, can be gained by placing data preemptively into the multi-tenant cache so that it is present when likely to be used (e.g., so that the data does not have to be moved into the cache after a request to access the data is received at the multi-tenant cache). Because a multi-tenant cache may store data for multiple different tenants, usage patterns of data may vary. Therefore, techniques that for making decisions for placing data in a multi-tenant cache can account for varying usage, improving the performance of the multi-tenant cache and clients that dependent upon the multi-tenant cache to provide data, as discussed in detail below.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a logical block diagram of making decisions for placing data in a multi-tenant cache, according to some embodiments. Multi-tenant cache nodes, such as multi-tenant cache nodes <b>120</b><i>a</i>, <b>120</b><i>b</i>, <b>120</b><i>c</i>, and <b>120</b><i>d</i>, may provide a multi-tenant cache <b>100</b> for data <b>132</b>, storing data <b>122</b><i>a</i>, <b>122</b><i>b</i>, <b>122</b><i>c</i>, and <b>122</b><i>d </i>in order to provide requested data <b>106</b> to access requests <b>104</b> received from clients <b>110</b>. Multi-tenant cache nodes <b>120</b> may provide cache storage to speed the return of data <b>132</b> from other storage systems, such as separate storage system(s) <b>130</b> (which may not be able to return or otherwise provide requested data as quickly as a multi-tenant cache). In some embodiments, multi-tenant cache nodes <b>120</b> may implement additional data processing features to accelerate or otherwise improve data processing before returning data, such as by taking advantage of various hardware or other acceleration techniques, as discussed in detail below with regard to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>5</b></figref>.</p><p id="p-0018" num="0017">Data may be placed among multi-tenant cache nodes <b>120</b> in order to improve performance of multi-tenant cache nodes <b>120</b> and client(s) <b>110</b>. For example, if an access request is received at multi-tenant cache node <b>120</b><i>a </i>that accesses data not present on that node (or any other multi-tenant cache node in multi-tenant cache <b>100</b>), then added latency/costs to obtain the data <b>122</b><i>a </i>from data <b>132</b> in separate storage system(s) <b>130</b> may be incurred. If, however, a placement decision <b>102</b> were made to proactively store data <b>122</b><i>a </i>on multi-tenant cache node <b>120</b><i>a </i>before an access request for that data was received, then significant performance savings can be achieved (as the data would not have be fetched in order to perform the query).</p><p id="p-0019" num="0018">Placement decisions <b>102</b> may indicate when to place data and where to place data, in some embodiments, so that the data may be present in the multi-tenant cache <b>100</b> at one or more multi-tenant cache nodes <b>120</b> when needed. Placement decisions can also be used to distribute data processing workloads (e.g., for providing query results) as data for multiple tenants can be efficiently co-located without exceeding the capacities of a given multi-tenant cache node <b>120</b> by storing or removing different tenant data from multi-tenant cache nodes. As discussed in detail below with regard to <figref idref="DRAWINGS">FIGS. <b>6</b>-<b>9</b></figref>, placement decisions <b>102</b> can be made based on the application of usage prediction techniques to usage information in order to make placement decisions based on the likelihood of data access. In this way, placement decisions can anticipate and improve the performance of a multi-tenant cache beyond the hardware or software techniques implemented on multi-tenant cache nodes alone by placing data in the best place at the best time.</p><p id="p-0020" num="0019">Please note that the previous description of making decisions for placing data in a multi-tenant cache is a logical illustration and thus is not to be construed as limiting as to the implementation of clients, multi-tenant cache nodes, or storage systems.</p><p id="p-0021" num="0020">This specification begins with a general description of a provider network that implements multiple different services, including data processing services and a query acceleration service which may implement making decisions for placing in a multi-tenant cache. Then various examples of multiple data processors, such as a data warehouse service and a query acceleration service, including different components/modules, or arrangements of components/module that may be employed as part of implementing the data processors are discussed. A number of different methods and techniques to implement making decisions for placing data in a multi-tenant cache are then discussed, some of which are illustrated in accompanying flowcharts. Finally, a description of an example computing system upon which the various components, modules, systems, devices, and/or nodes may be implemented is provided. Various examples are provided throughout the specification.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a logical block diagram illustrating a provider network offering data processing services that utilize a query acceleration service, according to some embodiments. Provider network <b>200</b> may be a private or closed system or may be set up by an entity such as a company or a public sector organization to provide one or more services (such as various types of cloud-based storage) accessible via the Internet and/or other networks to clients <b>250</b>. Provider network <b>200</b> may be implemented in a single location or may include numerous data centers hosting various resource pools, such as collections of physical and/or virtualized computer servers, storage devices, networking equipment and the like (e.g., computing system <b>1000</b> described below with regard to <figref idref="DRAWINGS">FIG. <b>10</b></figref>), needed to implement and distribute the infrastructure and storage services offered by the provider network <b>200</b>. In some embodiments, provider network <b>200</b> may implement various computing resources or services, such as data processing service(s) <b>210</b>, (e.g., a map reduce service, a data warehouse service, and other large scale data processing services or database services), query acceleration service <b>220</b>, and other services <b>230</b> that may be any other type of network based services (which may include a virtual compute service and various other types of storage, processing, analysis, communication, event handling, visualization, and security services).</p><p id="p-0023" num="0022">In various embodiments, the components illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be implemented directly within computer hardware, as instructions directly or indirectly executable by computer hardware (e.g., a microprocessor or computer system), dedicated circuitry, or using a combination of these techniques. For example, the components of <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be implemented by a system that includes a number of computing nodes (or simply, nodes), each of which may be similar to the computer system embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>10</b></figref> and described below. In various embodiments, the functionality of a given system or service component (e.g., a component of data processing service <b>210</b>, query acceleration service <b>220</b>, or other service <b>230</b>) may be implemented by a particular node or may be distributed across several nodes. In some embodiments, a given node may implement the functionality of more than one service system component (e.g., more than one data store component).</p><p id="p-0024" num="0023">Data processing services <b>210</b> may be various types of data processing services that perform general or specialized data processing functions (e.g., anomaly detection, machine learning, data mining, big data querying, or any other type of data processing operation). For example, in at least some embodiments, data processing services <b>210</b> may include a map reduce service that creates clusters of processing nodes that implement map reduce functionality over data stored in the map reduce cluster as well as data stored in a data storage service (e.g. one of other service <b>230</b>).</p><p id="p-0025" num="0024">In another example, data processing service(s) <b>210</b> may include various types of database services (both relational and non-relational) for storing, querying, and updating data. Such services may be enterprise-class database systems that are highly scalable and extensible. Queries may be directed to these database services that are distributed across multiple physical resources, and the database may be scaled up or down on an as needed basis. The database may work effectively with database schemas of various types and/or organizations, in different embodiments. In some embodiments, clients/subscribers may submit queries in a number of ways, e.g., interactively via an SQL interface to the database system. In some embodiments, external applications and programs may submit queries using Open Database Connectivity (ODBC) and/or Java Database Connectivity (JDBC) driver interfaces to the database system. For instance, data processing service(s) <b>210</b> may implement, in some embodiments, a data warehouse service, such as discussed below with regard to <figref idref="DRAWINGS">FIG. <b>3</b></figref> that utilizes another data processing service, such as query acceleration service <b>220</b>, to execute portions of queries or other access requests with respect to data (which may be stored in query acceleration service <b>220</b> or in a remote data store, such as a provider network <b>200</b> data storage service (or a data store external to provider network <b>200</b>).</p><p id="p-0026" num="0025">Query acceleration service <b>220</b>, as discussed in more detail below with regard to <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>6</b></figref>, may provide a service supporting many data analytics operations implemented on dedicated circuitry, such as Field Programmable Gate Arrays (FPGAs), system-on-a-chip (SoC) or Application Specific Integrated Circuits (ASICs), in some embodiments.</p><p id="p-0027" num="0026">Query acceleration service <b>220</b> may perform requested operations, such as scan operations that filter out data results according to string or numeric value comparisons, aggregation operations that aggregate data values and provide partial or complete aggregation results, or other operations that organize or reduce the determined data results retrieved from storage using circuitry dedicated to and optimized for the performance such operations. For example, query acceleration service <b>220</b> may execute different operations that are part of a larger query plan generated at a data processing service <b>210</b> (such as discussed below with regard to <figref idref="DRAWINGS">FIG. <b>4</b></figref> and provide results to the data processing service <b>210</b> by relying upon requests from data processing service(s) <b>210</b> to determine the different operations to perform. In this way, query acceleration service <b>220</b> may be implemented as a dynamically scalable and stateless analytics processing service that is fault tolerant without the need to support complex query planning and execution for multiple different analytics operations that can be performed faster and using less resources with hardware implementations of the analytics operations. Instead, query acceleration service <b>220</b> may offer a set of data processing capabilities to filter or otherwise retrieve data.</p><p id="p-0028" num="0027">In some embodiments, other service(s) <b>230</b> may implement different types of data stores for storing, accessing, and managing data on behalf of clients <b>250</b> as a network-based service that enables clients <b>250</b> to operate a data storage system in a cloud or network computing environment. Data storage service(s) may also include various kinds of object or file data stores for putting, updating, and getting data objects or files.</p><p id="p-0029" num="0028">For example, one data storage service may be an object-based data store that allows for different data objects of different formats or types of data, such as structured data (e.g., database data stored in different database schemas), unstructured data (e.g., different types of documents or media content), or semi-structured data (e.g., different log files, human-readable data in different formats like JavaScript Object Notation (JSON) or Extensible Markup Language (XML)) to be stored and managed according to a key value or other unique identifier that identifies the object. In at least some embodiments, such data storage service(s) may be treated as a data lake. For example, an organization may generate many different kinds of data, stored in one or multiple collections of data objects in a data storage service. The data objects in the collection may include related or homogenous data objects, such as database partitions of sales data, as well as unrelated or heterogeneous data objects, such as audio files and web site log files. Data storage service(s) may be accessed via programmatic interfaces (e.g., APIs) or graphical user interfaces. For example, query acceleration service <b>220</b> may access data objects stored in data storage services via the programmatic interfaces.</p><p id="p-0030" num="0029">Generally speaking, clients <b>250</b> may encompass any type of client that can submit network-based requests to provider network <b>200</b> via network <b>260</b>, including requests for storage services (e.g., a request to query a data processing service <b>210</b>, or a request to create, read, write, obtain, or modify data in data storage service(s), etc.). For example, a given client <b>250</b> may include a suitable version of a web browser, or may include a plug-in module or other type of code module that can execute as an extension to or within an execution environment provided by a web browser. Alternatively, a client <b>250</b> may encompass an application such as a database application (or user interface thereof), a media application, an office application or any other application that may make use of data processing service(s) <b>210</b>, query acceleration service <b>220</b>, or storage resources in other service(s) <b>230</b> to store and/or access the data to implement various applications. In some embodiments, such an application may include sufficient protocol support (e.g., for a suitable version of Hypertext Transfer Protocol (HTTP)) for generating and processing network-based services requests without necessarily implementing full browser support for all types of network-based data. That is, client <b>250</b> may be an application that can interact directly with provider network <b>200</b>. In some embodiments, client <b>250</b> may generate network-based services requests according to a Representational State Transfer (REST)-style network-based services architecture, a document- or message-based network-based services architecture, or another suitable network-based services architecture.</p><p id="p-0031" num="0030">In some embodiments, a client <b>250</b> may provide access to provider network <b>200</b> to other applications in a manner that is transparent to those applications. For example, client <b>250</b> may integrate with an operating system or file system to provide storage on one of data storage service(s) <b>230</b> (e.g., a block-based storage service). However, the operating system or file system may present a different storage interface to applications, such as a conventional file system hierarchy of files, directories and/or folders. In such an embodiment, applications may not need to be modified to make use of the storage system service model. Instead, the details of interfacing to the data storage service(s) <b>230</b> may be coordinated by client <b>250</b> and the operating system or file system on behalf of applications executing within the operating system environment. Similarly, a client <b>250</b> may be an analytics application that relies upon data processing service(s) <b>210</b> to execute various queries for data already ingested or stored in the data processing service (e.g., such as data maintained in a data warehouse service, like data warehouse service <b>300</b> in <figref idref="DRAWINGS">FIG. <b>3</b></figref> below) or data stored in a data lake hosted in data storage service(s) by performing federated data processing between the data processing service <b>210</b> and query acceleration service <b>220</b> (as discussed below with regard to <figref idref="DRAWINGS">FIG. <b>5</b></figref>). In some embodiments, clients of data processing services <b>210</b>, query acceleration service <b>220</b>, and/or other service(s) <b>230</b> may be implemented within provider network <b>200</b> (e.g., an application hosted on a virtual computing resource that utilizes a data processing service <b>210</b> to perform database queries) to implement various application features or functions and thus various features of client(s) <b>250</b> discussed above may be applicable to such internal clients as well.</p><p id="p-0032" num="0031">Clients <b>250</b> may convey network-based services requests (e.g., access requests to read or write data may be directed to data in data storage service(s) <b>230</b>, operations, tasks, or jobs, being performed as part of data processing service(s) <b>220</b>, or to interact with data catalog service <b>210</b>) to and receive responses from provider network <b>200</b> via network <b>260</b>. In various embodiments, network <b>260</b> may encompass any suitable combination of networking hardware and protocols necessary to establish network-based-based communications between clients <b>250</b> and provider network <b>200</b>. For example, network <b>260</b> may generally encompass the various telecommunications networks and service providers that collectively implement the Internet. Network <b>260</b> may also include private networks such as local area networks (LANs) or wide area networks (WANs) as well as public or private wireless networks. For example, both a given client <b>250</b> and provider network <b>200</b> may be respectively provisioned within enterprises having their own internal networks. In such an embodiment, network <b>260</b> may include the hardware (e.g., modems, routers, switches, load balancers, proxy servers, etc.) and software (e.g., protocol stacks, accounting software, firewall/security software, etc.) necessary to establish a networking link between given client <b>250</b> and the Internet as well as between the Internet and provider network <b>200</b>. It is noted that in some embodiments, clients <b>250</b> may communicate with provider network <b>200</b> using a private network rather than the public Internet.</p><p id="p-0033" num="0032">In at least some embodiments, one of data processing service(s) <b>220</b> may be a data warehouse service. <figref idref="DRAWINGS">FIG. <b>3</b></figref> is a logical block diagram of a data warehouse service that uses a query acceleration service to perform data analytics operations, according to some embodiments. A data warehouse service, such as data warehouse service <b>300</b>, may offer clients a variety of different data management services, according to their various needs. In some cases, clients may wish to store and maintain large of amounts data, such as sales records marketing, management reporting, business process management, budget forecasting, financial reporting, website analytics, or many other types or kinds of data. A client's use for the data may also affect the configuration of the data management system used to store the data. For instance, for certain types of data analysis and other operations, such as those that aggregate large sets of data from small numbers of columns within each row, a columnar database table may provide more efficient performance. In other words, column information from database tables may be stored into data blocks on disk, rather than storing entire rows of columns in each data block (as in traditional database schemes). The following discussion describes various embodiments of a relational columnar database system. However, various versions of the components discussed below as may be equally adapted to implement embodiments for various other types of database systems, such as row-oriented database systems. Therefore, the following examples are not intended to be limiting as to various other types or formats of database systems.</p><p id="p-0034" num="0033">In some embodiments, storing table data in such a columnar fashion may reduce the overall disk I/O requirements for various queries and may improve analytic query performance. For example, storing database table information in a columnar fashion may reduce the number of disk I/O requests performed when retrieving data into memory to perform database operations as part of processing a query (e.g., when retrieving all of the column field values for all of the rows in a table) and may reduce the amount of data that needs to be loaded from disk when processing a query. Conversely, for a given number of disk requests, more column field values for rows may be retrieved than is necessary when processing a query if each data block stored entire table rows. In some embodiments, the disk requirements may be further reduced using compression methods that are matched to the columnar storage data type. For example, since each block contains uniform data (i.e., column field values that are all of the same data type), disk storage and retrieval requirements may be further reduced by applying a compression method that is best suited to the particular column data type. In some embodiments, the savings in space for storing data blocks containing only field values of a single column on disk may translate into savings in space when retrieving and then storing that data in system memory (e.g., when analyzing or otherwise processing the retrieved data).</p><p id="p-0035" num="0034">Data warehouse service <b>300</b> may be implemented by a large collection of computing devices, such as customized or off-the-shelf computing systems, servers, or any other combination of computing systems or devices, such as the various types of systems <b>1000</b> described below with regard to <figref idref="DRAWINGS">FIG. <b>10</b></figref>. Different subsets of these computing devices may be controlled by control plane <b>310</b>. Control plane <b>310</b>, for example, may provide a cluster control interface to clients or users who wish to interact with the processing clusters <b>320</b> managed by control plane <b>310</b>. For example, control plane <b>310</b> may generate one or more graphical user interfaces (GUIs) for storage clients, which may then be utilized to select various control functions offered by the control interface for the processing clusters <b>320</b> hosted in the data warehouse service <b>300</b>.</p><p id="p-0036" num="0035">As discussed above, various clients (or customers, organizations, entities, or users) may wish to store and manage data using a data management service. Processing clusters may respond to various requests, including write/update/store requests (e.g., to write data into storage) or queries for data (e.g., such as a Server Query Language request (SQL) for particular data), as discussed below with regard to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, along with many other data management or storage services. Multiple users or clients may access a processing cluster to obtain data warehouse services. In at least some embodiments, a data warehouse service <b>300</b> may provide network endpoints to the clusters which allow the clients to send requests and other messages directly to a particular cluster. Network endpoints, for example may be a particular network address, such as a URL, which points to a particular cluster. For instance, a client may be given the network endpoint &#x201c;http://mycluster.com&#x201d; to send various request messages to. Multiple clients (or users of a particular client) may be given a network endpoint for a particular cluster. Various security features may be implemented to prevent unauthorized users from accessing the clusters. Conversely, a client may be given network endpoints for multiple clusters.</p><p id="p-0037" num="0036">Processing clusters, such as processing clusters <b>320</b><i>a</i>, <b>320</b><i>b</i>, through <b>320</b><i>n</i>, hosted by the data warehouse service <b>300</b> may provide an enterprise-class database query and management system that allows users to send data processing requests to be executed by the clusters <b>320</b>, such as by sending a query to a cluster control interface implemented by the network-based service. Processing clusters <b>320</b> may perform data processing <b>322</b> operations with respect to data stored locally in a processing cluster, as well as remotely stored data. For example, another service, like query acceleration service <b>220</b> may implement multi-tenant cache <b>342</b>, which may store data for different users, accounts, or other entities of data warehouse service <b>300</b> as different tenants in order provide back data from multi-tenant cache <b>342</b> for performing queries or other data processing requests. Query acceleration service <b>220</b> may have access to stored data <b>332</b> in storage service <b>310</b> (e.g., an object storage service, other database service, etc.), which may be accessed to move data into multi-tenant cache <b>342</b> before being sent to a processing cluster <b>320</b>. For example, queries sent to a processing cluster <b>320</b> may be directed to local data stored in the processing cluster and/or remotely stored data <b>332</b>. Therefore, processing clusters may implement data processing, such as data processing <b>322</b><i>a</i>, <b>322</b><i>b</i>, and <b>322</b><i>c </i>to plan and execute the performance of queries with respect to local data in the processing cluster, as well as acting as a remote data processing client to direct execution of different operations determined as part of the query plan generated at the processing cluster that are assigned to query acceleration service <b>220</b> with respect to processing remote data <b>332</b>. In at least some embodiments, data processing <b>322</b> may support some analytics operations by relying upon query acceleration service <b>220</b> to perform operations, such as a query with a regular expression as a predicate, with respect to data <b>332</b>.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a logical block diagram illustrating an example processing cluster of a data warehouse service using a query acceleration service to perform a query, according to some embodiments. Processing cluster <b>400</b> may be data warehouse service cluster, like processing clusters <b>320</b> discussed above with regard to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, or another processing cluster that distributes execution of a query among multiple processing nodes. As illustrated in this example, a processing cluster <b>400</b> may include a leader node <b>410</b> and compute nodes <b>420</b><i>a</i>, <b>420</b><i>b</i>, and <b>420</b><i>n</i>, which may communicate with each other over an interconnect (not illustrated). Leader node <b>410</b> may implement query planning <b>412</b> to generate query plan(s) and instructions <b>414</b> for executing queries on processing cluster <b>400</b> that perform local and/or remote query operations, including operations to performing matching on regular expressions as discussed in further detail below. As described herein, each node in a processing cluster <b>400</b> may include attached storage, such as attached storage <b>422</b><i>a</i>, <b>422</b><i>b</i>, and <b>422</b><i>n</i>, on which a database (or portions thereof) may be stored on behalf of clients (e.g., users, client applications, and/or storage service subscribers). In other embodiments, compute nodes <b>420</b> may not implement attached storage <b>422</b>, but instead may rely upon query acceleration service to retrieve and send data (e.g., unfiltered as stored on disk or with various operations/filters applied) in order to perform query <b>402</b>.</p><p id="p-0039" num="0038">Note that in at least some embodiments, query processing capability may be separated from compute nodes, and thus in some embodiments, additional components may be implemented for processing queries. Additionally, it may be that in some embodiments, no one node in processing cluster <b>400</b> is a leader node as illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, but rather different nodes of the nodes in processing cluster <b>400</b> may act as a leader node or otherwise direct processing of queries to data stored in processing cluster <b>400</b>. While nodes of processing cluster may be implemented on separate systems or devices, in at least some embodiments, some or all of processing cluster may be implemented as separate virtual nodes or instance on the same underlying hardware system (e.g., on a same server).</p><p id="p-0040" num="0039">In at least some embodiments, processing cluster <b>400</b> may be implemented as part of a data warehouse service, as discussed above with regard to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, or another one of data processing service(s) <b>210</b>. Leader node <b>410</b> may manage communications with clients, such as clients <b>250</b> (or internal provider network clients) as discussed above with regard to <figref idref="DRAWINGS">FIG. <b>2</b></figref>. For example, leader node <b>410</b> may be a server that receives a query <b>402</b> from various client programs (e.g., applications) and/or subscribers (users), then parses them and develops an execution plan (e.g., query plan(s)) to carry out the associated database operation(s)). More specifically, leader node <b>410</b> may develop the series of steps necessary to obtain results for the query. Query <b>402</b> may be directed to data that is stored locally within processing cluster <b>400</b> (e.g., at one or more of compute nodes <b>420</b>), remotely in query acceleration service <b>220</b> or another storage service or data store accessible to query acceleration service <b>220</b>.</p><p id="p-0041" num="0040">Leader node <b>410</b> may also manage the communications among compute nodes <b>420</b> instructed to carry out database operations for data stored in the processing cluster <b>400</b>. For example, node-specific query instructions <b>414</b> may be generated or compiled code that is distributed by leader node <b>410</b> to various ones of the compute nodes <b>420</b> to carry out the steps needed to perform query <b>402</b>, including executing the code to generate intermediate results of query <b>402</b> at individual compute nodes may be sent back to the leader node <b>410</b>. Leader node <b>410</b> may receive data and query responses or results from compute nodes <b>420</b> in order to determine a final result for query <b>402</b>. A database schema, data format and/or other metadata information for the data stored among the compute nodes, such as the data tables stored in the cluster, may be managed and stored by leader node <b>410</b>. Query planning <b>412</b> may account for remotely stored data by generating node-specific query instructions that include remote operations to be directed by individual compute node(s) <b>420</b>.</p><p id="p-0042" num="0041">Processing cluster <b>400</b> may also include compute nodes, such as compute nodes <b>420</b><i>a</i>, <b>420</b><i>b</i>, and <b>420</b><i>n</i>. Compute nodes <b>420</b>, may for example, be implemented on servers or other computing devices, such as those described below with regard to computer system <b>1000</b> in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, and each may include individual query processing &#x201c;slices&#x201d; defined, for example, for each core of a server's multi-core processor, one or more query processing engine(s), such as query engine(s) <b>424</b><i>a</i>, <b>424</b><i>b</i>, and <b>424</b><i>n</i>, to execute the instructions <b>414</b> or otherwise perform the portions of the query plan assigned to the compute node. Query engine(s) <b>424</b> may access a certain memory and disk space in order to process a portion of the workload for a query (or other database operation) that is sent to one or more of the compute nodes <b>420</b>. Query engine <b>424</b> may access attached storage, such as <b>422</b><i>a</i>, <b>422</b><i>b</i>, and <b>422</b><i>n</i>, to perform local operation(s), such as local operations <b>418</b><i>a</i>, <b>418</b><i>b</i>, and <b>418</b><i>n</i>. For example, query engine <b>424</b> may scan data in attached storage <b>422</b>, access indexes, perform joins, semi joins, aggregations, or any other processing operation assigned to the compute node <b>420</b>.</p><p id="p-0043" num="0042">Query engine <b>424</b><i>a </i>may also direct the execution of remote data processing operations, by providing remote operation(s), such as remote operations <b>416</b><i>a</i>, <b>416</b><i>b</i>, and <b>416</b><i>n</i>, to remote data processing clients, such as remote data processing client <b>426</b><i>a</i>, <b>426</b><i>b</i>, and <b>426</b><i>n</i>. Remote data processing clients <b>426</b> may be implemented by a client library, plugin, driver or other component that sends request operations, such as request operation(s) <b>432</b><i>a</i>, <b>432</b><i>b</i>, and <b>432</b><i>n </i>to query acceleration service <b>220</b>. In some embodiments, query acceleration service <b>220</b> may implement a common network endpoint to which request operation(s) <b>432</b> are directed, and then may dispatch the requests to respective acceleration nodes, such as acceleration nodes <b>440</b><i>a</i>, <b>440</b><i>b</i>, and <b>440</b><i>n</i>. Acceleration nodes <b>440</b> may store data as a node in a respective portion of a multi-tenant cache (e.g., multi-tenant cache portions <b>441</b><i>a</i>, <b>441</b><i>b</i>, and <b>441</b><i>n</i>) according to placement decisions, or if data is not present in the acceleration node may request/obtain data from the separate storage service, as indicated at <b>442</b><i>a</i>, <b>442</b><i>b</i>, and <b>442</b><i>n </i>respectively.</p><p id="p-0044" num="0043">Remote data processing clients <b>426</b> may read, process, or otherwise obtain results from acceleration nodes, including partial results of different operations (e.g., a stream of filtered tuples) and may provide operation result(s), including result(s) <b>434</b><i>a</i>, <b>434</b><i>b</i>, and <b>434</b><i>c</i>, back to query engine(s) <b>424</b>, which may further process, combine, and/or include them with results of local operations <b>418</b>, or further finalizing processing of the query if no local operations <b>418</b> are invoked for query <b>402</b>.</p><p id="p-0045" num="0044">Compute nodes <b>420</b> may send intermediate results from queries back to leader node <b>410</b> for final result generation (e.g., combining, aggregating, modifying, joining, etc.). Remote data processing clients <b>426</b> may retry operation request(s) <b>432</b> that do not return within a retry threshold.</p><p id="p-0046" num="0045">Attached storage, such as attached storage <b>422</b><i>a</i>, <b>422</b><i>b</i>, and <b>422</b><i>n </i>may be implemented as one or more of any type of storage devices and/or storage system suitable for storing data accessible to the compute nodes, including, but not limited to: redundant array of inexpensive disks (RAID) devices, disk drives (e.g., hard disk drives or solid state drives) or arrays of disk drives such as Just a Bunch Of Disks (JBOD), (used to refer to disks that are not implemented according to RAID), optical storage devices, tape drives, RAM disks, Storage Area Network (SAN), Network Access Storage (NAS), or combinations thereof. In various embodiments, disks may be formatted to store database tables (e.g., in column oriented data formats or other data formats).</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a logical block diagram illustrating a query acceleration service that implements making decisions for placing data for query acceleration, according to some embodiments. As noted above in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, query acceleration service <b>220</b> may receive requests to perform processing operations with respect to data stored <b>532</b> stored in a data storage service. Processing requests may be received from a client, such as remote data analytics client(s) <b>502</b> (which may another data processing service <b>210</b>, like data warehouse service <b>300</b> or another data processing client, such as a database engine/cluster or map reduce cluster implemented outside of provider network <b>200</b> and communicating with query acceleration service <b>220</b> in order to process queries with respect to data stored within provider network <b>200</b> or to process data stored outside of provider network <b>200</b> (when the data is made accessible to query acceleration service <b>220</b>).</p><p id="p-0048" num="0047">Query acceleration service <b>220</b> may implement a control plane <b>510</b> and multiple acceleration node(s) <b>520</b> to execute processing requests received from remote data processing client(s) <b>502</b>. Control plane <b>510</b> may arbitrate, balance, select, or dispatch requests to different processing node(s) <b>520</b> in various embodiments, such as dispatching requests to those acceleration node(s) <b>520</b> that store different portions of data for a received request, according to a placement decision. Control plane <b>510</b> may implement interface <b>512</b> which may be a programmatic interface, such as an application programming interface (API), that allows for requests to be formatted according to the interface <b>512</b> to programmatically invoke operations. In some embodiments, the API may be defined to allow operation requests defined as objects of code generated at and sent from remote data processing client(s) <b>502</b> (based on a query plan generated at remote data processing client(s) <b>502</b>) to be compiled or executed in order to perform the assigned operations at query acceleration service <b>220</b>.</p><p id="p-0049" num="0048">In some embodiments, query acceleration service <b>220</b> may implement request routing as part of data placement management <b>518</b> to distribute remote processing requests across different acceleration node(s) <b>520</b> according to placement decisions made, as discussed below with regard to <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0050" num="0049">Query acceleration service <b>220</b> may also implement resource scaling <b>514</b>. Resource scaling <b>514</b> may detect when the current request rate or workload upon a current number of acceleration node(s) <b>520</b> exceeds or falls below over-utilization or under-utilization thresholds for processing nodes. In response to detecting that the request rate or workload exceeds an over-utilized threshold, for example, then resources scaling <b>514</b> may provision, spin up, activate, repurpose, reallocate, or otherwise obtain additional acceleration node(s) <b>520</b> to perform received remote data processing requests. Similarly, the number of acceleration node(s) <b>520</b> could be reduced by resource scaling <b>514</b> in the event that the request rate or workload of acceleration node(s) falls below the under-utilization threshold.</p><p id="p-0051" num="0050">Query acceleration service <b>220</b> may also implement failure management <b>516</b> to monitor acceleration node(s) <b>520</b> and other components of query acceleration service <b>220</b> for failure or other health or performance states that may need to be repaired or replaced. For example, failure management <b>516</b> may detect when an acceleration node fails or becomes unavailable (e.g., due to a network partition) by polling processing node(s) <b>520</b> to obtain health or performance status information. Failure management may initiate shutdown or halting of processing at failing acceleration node(s) <b>520</b> and provision replacement acceleration node(s) <b>520</b>.</p><p id="p-0052" num="0051">Acceleration node(s) <b>520</b> may be implemented as separate computing nodes, servers, or devices, such as computing systems <b>1000</b> in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, to perform data processing operations on behalf of remote data processing client(s) <b>502</b>. Acceleration node(s) <b>520</b> may implement stateless, in-memory processing to execute operations, in some embodiments. In this way, processing node(s) <b>520</b> may have fast data processing rates. Acceleration node(s) <b>520</b> may implement client authentication/identification <b>521</b> to determine whether a remote data processing client <b>502</b> has the right to access data <b>532</b>. For example, client authentication/identification <b>521</b> may evaluate access credentials, such as a username and password, token, or other identity indicator by attempting to connect with storage device <b>530</b>. If the credentials are not valid, then the data processing node <b>502</b> may send an error indication to remote data analytics client <b>502</b>.</p><p id="p-0053" num="0052">Acceleration node(s) <b>520</b> may implement operation processing <b>522</b> which may perform multiple different processing operations to perform various analytics operations upon data <b>532</b> before returning operation results and/or retrieve data without modification or analysis. In some embodiments, data <b>532</b> may be stored in encrypted or compressed format. Processing node(s) <b>520</b> may implement compression engine(s) <b>524</b> to decompress data <b>532</b> according to a compression technique identified for data <b>532</b>, such as lossless compression techniques like run-length encoding, Lempel-Ziv based encoding, or bzip based encoding. Processing node(s) <b>520</b> may implement encryption engine(s) <b>526</b> to decrypt data <b>532</b> according to an encryption technique and/or encryption credential, such as a key, identified for data <b>532</b>, such as symmetric key or public-private key encryption techniques.</p><p id="p-0054" num="0053">In some embodiments, acceleration node(s) <b>530</b> may be directly attached to one or more storage devices <b>530</b>, which may store multi-tenant cache data <b>532</b>. For example, storage devices <b>530</b> may include, but not be limited to: non-volatile memories or storage technologies, such as redundant array of inexpensive disks (RAID) devices, disk drives (e.g., hard disk drives or solid state drives) or arrays of disk drives such as Just a Bunch Of Disks (JBOD), (used to refer to disks that are not implemented according to RAID), optical storage devices, tape drives, RAM disks, Storage Area Network (SAN), Network Access Storage (NAS), or volatile storage technologies, such as such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), or any other type of memory, or combinations thereof.</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a logical block diagram of data placement management that applies usage prediction techniques to train models for making placement decisions for query acceleration, according to some embodiments. Data placement management <b>518</b> make placement decisions and direct placement among acceleration nodes <b>670</b>, in various embodiments. Usage metrics <b>602</b> may be captured, recorded, or otherwise obtained by acceleration node usage capture <b>610</b>. For example, usage metrics may include the identity of data files, objects, or other data structures that are utilized to perform a query, the time at which the data is accessed, the client, account, or other indicator of the requesting tenant for that data, the costs of node resources (e.g., computational resources such as processor or other hardware devices utilized to perform operations), among other possible usage metrics. The time period over which usage occurs may vary, including such long time periods (e.g., weeks or months) or may be captured for smaller time periods (e.g., days or hours). Usage metrics may include various granularity of usage, such as the duration of data processing in minutes, seconds, or other time measures, the amount of data accessed, such as large data sizes in gigabytes or terabytes, or in smaller data sizes, such as megabytes or bytes.</p><p id="p-0056" num="0055">Usage metrics may be continually captured, in some embodiments, and stored in usage store <b>620</b>, which may be, for example, a time series database. In various embodiments, techniques to ensure efficient storage of metrics, such as hierarchical data structures and purging of irrelevant data (e.g., usage indicative of non-repetitive usage patterns) may be used, among others.</p><p id="p-0057" num="0056">Placement model building <b>630</b> may utilize different usage prediction techniques <b>632</b>. For example, usage prediction techniques may include various statistical analyses or evaluations, that weight the collected usage metrics for a particular user, client, or other tenant to produce a model for predicting usage or may rely upon various machine learning techniques to train a model, such as time series prediction technique (discussed in detail below with regard to <figref idref="DRAWINGS">FIG. <b>8</b></figref>) and/or reinforcement learning agent technique (discussed in detail below with regard to <figref idref="DRAWINGS">FIG. <b>9</b></figref>) in order to train or re-train to update models, responsive to building/events <b>612</b>. For example, a re-building event may occur after a lapse in a period of time since a model was built (or rebuilt), or may occur when a threshold amount of new usage data is received, or may occur when a change is detected in usage information (e.g., change in usage frequency).</p><p id="p-0058" num="0057">Model <b>614</b> may be provided to placement decision engine <b>640</b>. Placement decision engine <b>640</b> may make placement decisions in various ways based on the models, as well as other information, such as the state indicated in prior placement decisions and/or other placement state <b>663</b>. For example, data placement management <b>518</b> may implement data placement state tracking <b>660</b>, which may track placement decisions (e.g., decisions to store or evict data from the multi-tenant cache). Data placement management <b>660</b> may also obtain other state changes <b>662</b>, such as the failure of acceleration nodes (which may trigger a need to replace data that is no longer in a cache) or state changes to reduce the number of acceleration nodes, triggering a re-evaluation of data currently in the multi-tenant cache given a smaller number of acceleration nodes. As discussed below, a time series prediction model may be used, in some embodiments, to implement a cost minimization approach given a prediction of usage by a model <b>614</b>. For a reinforcement learning agent approach, state information, policies, and/or other input data for a reinforcement learning agent may be maintained or updated as part of placement decision engine <b>640</b>.</p><p id="p-0059" num="0058">Placement decisions <b>616</b> may include schedules or other indications of the timing to add or remove data from a multi-tenant cache (including timings that are &#x201c;as soon as possible&#x201d;), as well as particular placement locations (e.g., in order to ensure that the capacity of an individual placement node is not exceeded). For example, placement decisions <b>616</b> may instruct that data for different tenants be co-located on a same acceleration node. Placement decisions may be provided to data movement <b>650</b>, which may send out data movement instructions <b>618</b> according to placement decisions, in various embodiments. For example, data movement instructions <b>618</b> may orchestrate the addition or removal of data from one (or multiple) acceleration nodes <b>670</b> in accordance with a determine placement schedule.</p><p id="p-0060" num="0059">Although <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>6</b></figref> have been described and illustrated in the context of a provider network implementing different data processing services, like a data warehousing service, that utilizes a query acceleration service, the various components illustrated and described in <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>6</b></figref> may be easily applied to other data processing systems that implement different multi-tenant caches that move data from storage to multi-tenant cache nodes. As such, <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>6</b></figref> are not intended to be limiting as to other embodiments of making decisions for placing data in a multi-tenant cache. <figref idref="DRAWINGS">FIG. <b>7</b></figref> is a high-level flowchart illustrating methods and techniques to implement making decisions for placing data in a multi-tenant cache, according to some embodiments.</p><p id="p-0061" num="0060">Various different systems and devices may implement the various methods and techniques described below, either singly or working together. Different combinations of services implemented in different provider networks operated by different entities may implement some or all of the methods (e.g., a data warehouse cluster in a service of a first provider network and a query acceleration service in a second provider network). Alternatively, various other combinations of different systems and devices located within or without provider networks may implement the below techniques. Therefore, the above examples and or any other systems or devices referenced as performing the illustrated method, are not intended to be limiting as to other different components, modules, systems, or devices.</p><p id="p-0062" num="0061">As indicated at <b>710</b>, usage of multi-tenant cache nodes for client access requests may be obtained, in various embodiments. For example, usage information may be collected directly from multi-tenant cache nodes (e.g., reporting what data is accessed, such as the data objects accessed, the amount of data accessed, such as the size of the data objects accessed, what hardware is utilized to access, process, and/or return the data, and how much the hardware is utilized (e.g., is specialized hardware utilized), the tenant (e.g., client, account, entity, application, etc.) that made the access request, and so on). Usage information may also be collected from clients, in some embodiments. For instance, if a client is database system or data warehouse, as discussed above, then query execution statistics or other historical information may be sent or shared with a multi-tenant cache as usage information. As discussed above with regard to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, usage information may be continually captured by recording which data has to be stored to multi-tenant cache nodes and by recording duration, device, component, unit, operation, or other multi-tenant cache node features that can be utilized (e.g., FPGA usage per client id, usage per second, etc.).</p><p id="p-0063" num="0062">As indicated at <b>720</b>, a usage prediction technique may be applied to the usage of the multi-tenant cache nodes to make respective placement decisions for different data according to a likelihood of the different data to be accessed as part of performing subsequent client access requests at the multi-tenant cache nodes, in some embodiments. For example, as discussed in detail below with regard to <figref idref="DRAWINGS">FIGS. <b>8</b> and <b>9</b></figref>, different machine learning techniques, such as regression analysis, time series evaluation, or reinforcement learning techniques may be used to train, generate, or build models that can be used to make placement decisions. Other usage prediction techniques may also be used that do not rely upon training techniques based on historical data but provide criteria to weight, analyze, or otherwise evaluate the obtained usage information to make a prediction of the likelihood of the data to be accessed for subsequent client access. As discussed above with regard to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, other information, such as the state indicated in prior placement decisions and/or other placement state such as the failure of multi-tenant cache nodes may be used to make a placement decision. In one example, ensuring co-location of data for different tenants on a same multi-tenant cache node to ensure that the right amount of data is placed on a given multi-tenant cache node may rely upon the knowledge of tenant data already placed on a particular multi-tenant cache node to determine where to place a different tenant's data. For example, such other placement state may also concern scenarios in which a failure of a multi-tenant cache node may trigger a need to replace data that is no longer in the multi-tenant cache or state changes to reduce the number of multi-tenant cache nodes, triggering a re-evaluation of data currently in the multi-tenant cache given a smaller number of multi-tenant cache nodes.</p><p id="p-0064" num="0063">As indicated at <b>730</b>, placement decisions may be made with respect to the different data at the multi-tenant cache nodes according to the respective placement decisions, in some embodiments. For example, such placement actions may include obtaining data from separate storage system(s) and storing the data at particular multi-tenant cache nodes <b>732</b>. Placement actions may also include removing data from multi-tenant cache nodes (e.g., instructing a multi-tenant cache node to evict data).</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a high-level flowchart illustrating methods and techniques to implement time series prediction for making placement decisions, according to some embodiments. As indicated at <b>810</b>, usage of multi-tenant cache nodes for client access requests may be recorded as a time series. For example, the time series may be stored or written to a time series database.</p><p id="p-0066" num="0065">As indicated at <b>820</b>, the time series may be evaluated to build a time series prediction model for future usage of the multi-tenant cache nodes, in some embodiments. Various different time series prediction machine learning techniques may be applied to generate the time series prediction model. For example, training-based time series prediction techniques that use a Convolutional Neural Network (CNN), such as ones that use perform quantile regression using a causal CNN and Recurrent Neural Network (RNN) based technique that uses a RNN to provide a prediction model, and non-training prediction techniques, such as additive model-based prediction techniques where non-linear trends are fit with different time periods of seasonality (e.g., yearly, weekly, and daily), scalable, probabilistic baseline forecaster to handle time series data which may be sparse or intermittent (e.g., including different various for different types of features, such as seasonal, climatological, and a combination of seasonal and climatological), Autoregressive Integrated Moving Average (AMNIA), and Exponential Smoothing (ETS) (e.g., computing a weighted average over all observations in the time series dataset as its prediction, with exponentially decreasing weights over time).</p><p id="p-0067" num="0066">As indicated at <b>830</b>, the time series prediction model may be used to make a usage prediction for the multi-tenant cache nodes, in some embodiments. For example, a prediction horizon (e.g., 1 hour, 1 day, 1 week), may be used to return a prediction using the time series prediction model that predicts usage up to the prediction horizon (e.g., for the next hour, day, or week). In various embodiments, probabilities or confidences associated with a prediction may be provided. As indicated at <b>840</b>, placement of data at different ones of the multi-tenant cache nodes may be scheduled according to the usage prediction, in various embodiments. For example, as discussed above with regard to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, placement decisions may indicate when to move data to a multi-tenant cache node, when to remove data from a multi-tenant cache node, which particular multi-tenant cache node to move data to (e.g., in order to co-locate data that have compatible workloads), among other placement decisions. In some embodiments, cost minimization techniques may be used to minimize the expected cost of scenarios where data used for an access request is not presently stored in a multi-tenant cache node or the combination of data for different clients on a multi-tenant cache node leads to a workload overburdening or beyond the capacities of the multi-tenant cache node to perform the workload.</p><p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a high-level flowchart illustrating methods and techniques to implement reinforcement learning for making placement decisions, according to some embodiments. As indicated at <b>910</b>, a reinforcement learning agent may be trained to make placement decisions based on usage of multi-tenant cache nodes performing client access requests. For example, bin-packing or other online reinforcement learning techniques can be used to train the reinforcement learning agent by modeling the environment of placement decisions, agent placement decisions, transition probability, and a reward function for making placement decisions that store data in multi-tenant cache nodes that is likely to be accessed, as well as placing data together in multi-tenant cache nodes that have combined workloads that does not cause a multi-tenant cache node to be overloaded. In embodiments where a bin packing technique is utilized, a buffer or other safety margin may be enforced for multi-tenant cache nodes to prevent an unpredictable workload from exceeding a predicted usage.</p><p id="p-0069" num="0068">As indicated at <b>920</b>, a placement event may be detected for the multi-tenant cache nodes, in some embodiments. For example, a placement event may occur periodically (e.g., after the lapse of a time period) and/or upon other triggering events, such as the removal of data, the addition or removal of multi-tenant cache nodes, among others. As indicated at <b>930</b>, the reinforcement learning agent may be used to determine a placement decision for data to place the data on one of the multi-tenant cache nodes, in some embodiments. For example, when a placement event occurs, the reinforcement learning agent may identify what data, when to place the data, and/or where to place the data (e.g., on what multi-tenant cache node).</p><p id="p-0070" num="0069">The methods described herein may in various embodiments be implemented by any combination of hardware and software. For example, in one embodiment, the methods may be implemented by a computer system (e.g., a computer system as in <figref idref="DRAWINGS">FIG. <b>10</b></figref>) that includes one or more processors executing program instructions stored on a computer-readable storage medium coupled to the processors. The program instructions may implement the functionality described herein (e.g., the functionality of various servers and other components that implement the network-based virtual computing resource provider described herein). The various methods as illustrated in the figures and described herein represent example embodiments of methods. The order of any method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.</p><p id="p-0071" num="0070">Embodiments of making decisions for placing data in a multi-tenant cache as described herein may be executed on one or more computer systems, which may interact with various other devices. One such computer system is illustrated by <figref idref="DRAWINGS">FIG. <b>10</b></figref>. In different embodiments, computer system <b>1000</b> may be any of various types of devices, including, but not limited to, a personal computer system, desktop computer, laptop, notebook, or netbook computer, mainframe computer system, handheld computer, workstation, network computer, a camera, a set top box, a mobile device, a consumer device, video game console, handheld video game device, application server, storage device, a peripheral device such as a switch, modem, router, or in general any type of computing node, compute node, computing device, compute device, or electronic device.</p><p id="p-0072" num="0071">In the illustrated embodiment, computer system <b>1000</b> includes one or more processors <b>1010</b> coupled to a system memory <b>1020</b> via an input/output (I/O) interface <b>1030</b>. Computer system <b>1000</b> further includes a network interface <b>1040</b> coupled to I/O interface <b>1030</b>, and one or more input/output devices <b>1050</b>, such as cursor control device <b>1060</b>, keyboard <b>1070</b>, and display(s) <b>1080</b>. Display(s) <b>1080</b> may include standard computer monitor(s) and/or other display systems, technologies or devices. In at least some implementations, the input/output devices <b>1050</b> may also include a touch- or multi-touch enabled device such as a pad or tablet via which a user enters input via a stylus-type device and/or one or more digits. In some embodiments, it is contemplated that embodiments may be implemented using a single instance of computer system <b>1000</b>, while in other embodiments multiple such systems, or multiple nodes making up computer system <b>1000</b>, may host different portions or instances of embodiments. For example, in one embodiment some elements may be implemented via one or more nodes of computer system <b>1000</b> that are distinct from those nodes implementing other elements.</p><p id="p-0073" num="0072">In various embodiments, computer system <b>1000</b> may be a uniprocessor system including one processor <b>1010</b>, or a multiprocessor system including several processors <b>1010</b> (e.g., two, four, eight, or another suitable number). Processors <b>1010</b> may be any suitable processor capable of executing instructions. For example, in various embodiments, processors <b>1010</b> may be general-purpose or embedded processors implementing any of a variety of instruction set architectures (ISAs), such as the x86, PowerPC, SPARC, or MIPS ISAs, or any other suitable ISA. In multiprocessor systems, each of processors <b>1010</b> may commonly, but not necessarily, implement the same ISA.</p><p id="p-0074" num="0073">In some embodiments, at least one processor <b>1010</b> may be a graphics processing unit. A graphics processing unit or GPU may be considered a dedicated graphics-rendering device for a personal computer, workstation, game console or other computing or electronic device. Modern GPUs may be very efficient at manipulating and displaying computer graphics, and their highly parallel structure may make them more effective than typical CPUs for a range of complex graphical algorithms. For example, a graphics processor may implement a number of graphics primitive operations in a way that makes executing them much faster than drawing directly to the screen with a host central processing unit (CPU). In various embodiments, graphics rendering may, at least in part, be implemented by program instructions that execute on one of, or parallel execution on two or more of, such GPUs. The GPU(s) may implement one or more application programmer interfaces (APIs) that permit programmers to invoke the functionality of the GPU(s). Suitable GPUs may be commercially available from vendors such as NVIDIA Corporation, ATI Technologies (AMD), and others.</p><p id="p-0075" num="0074">System memory <b>1020</b> may store program instructions and/or data accessible by processor <b>1010</b>. In various embodiments, system memory <b>1020</b> may be implemented using any suitable memory technology, such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), nonvolatile/Flash-type memory, or any other type of memory. In the illustrated embodiment, program instructions and data implementing desired functions, such as those described above are shown stored within system memory <b>1020</b> as program instructions <b>1025</b> and data storage <b>1035</b>, respectively.</p><p id="p-0076" num="0075">In other embodiments, program instructions and/or data may be received, sent or stored upon different types of computer-accessible media or on similar media separate from system memory <b>1020</b> or computer system <b>1000</b>. Generally speaking, a non-transitory, computer-readable storage medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD/DVD-ROM coupled to computer system <b>1000</b> via I/O interface <b>1030</b>. Program instructions and data stored via a computer-readable medium may be transmitted by transmission media or signals such as electrical, electromagnetic, or digital signals, which may be conveyed via a communication medium such as a network and/or a wireless link, such as may be implemented via network interface <b>1040</b>.</p><p id="p-0077" num="0076">In one embodiment, I/O interface <b>1030</b> may coordinate I/O traffic between processor <b>1010</b>, system memory <b>1020</b>, and any peripheral devices in the device, including network interface <b>1040</b> or other peripheral interfaces, such as input/output devices <b>1050</b>. In some embodiments, I/O interface <b>1030</b> may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory <b>1020</b>) into a format suitable for use by another component (e.g., processor <b>1010</b>). In some embodiments, I/O interface <b>1030</b> may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I/O interface <b>1030</b> may be split into two or more separate components, such as a north bridge and a south bridge, for example. In addition, in some embodiments some or all of the functionality of I/O interface <b>1030</b>, such as an interface to system memory <b>1020</b>, may be incorporated directly into processor <b>1010</b>.</p><p id="p-0078" num="0077">Network interface <b>1040</b> may allow data to be exchanged between computer system <b>1000</b> and other devices attached to a network, such as other computer systems, or between nodes of computer system <b>1000</b>. In various embodiments, network interface <b>1040</b> may support communication via wired or wireless general data networks, such as any suitable type of Ethernet network, for example; via telecommunications/telephony networks such as analog voice networks or digital fiber communications networks; via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and/or protocol.</p><p id="p-0079" num="0078">Input/output devices <b>1050</b> may, in some embodiments, include one or more display terminals, keyboards, keypads, touchpads, scanning devices, voice or optical recognition devices, or any other devices suitable for entering or retrieving data by one or more computer system <b>1000</b>. Multiple input/output devices <b>1050</b> may be present in computer system <b>1000</b> or may be distributed on various nodes of computer system <b>1000</b>. In some embodiments, similar input/output devices may be separate from computer system <b>1000</b> and may interact with one or more nodes of computer system <b>1000</b> through a wired or wireless connection, such as over network interface <b>1040</b>.</p><p id="p-0080" num="0079">As shown in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, memory <b>1020</b> may include program instructions <b>1025</b>, that implement the various methods and techniques as described herein, and data storage <b>1035</b>, comprising various data accessible by program instructions <b>1025</b>. In one embodiment, program instructions <b>1025</b> may include software elements of embodiments as described herein and as illustrated in the Figures. Data storage <b>1035</b> may include data that may be used in embodiments. In other embodiments, other or different software elements and data may be included.</p><p id="p-0081" num="0080">Those skilled in the art will appreciate that computer system <b>1000</b> is merely illustrative and is not intended to limit the scope of the techniques as described herein. In particular, the computer system and devices may include any combination of hardware or software that can perform the indicated functions, including a computer, personal computer system, desktop computer, laptop, notebook, or netbook computer, mainframe computer system, handheld computer, workstation, network computer, a camera, a set top box, a mobile device, network device, internet appliance, PDA, wireless phones, pagers, a consumer device, video game console, handheld video game device, application server, storage device, a peripheral device such as a switch, modem, router, or in general any type of computing or electronic device. Computer system <b>1000</b> may also be connected to other devices that are not illustrated, or instead may operate as a stand-alone system. In addition, the functionality provided by the illustrated components may in some embodiments be combined in fewer components or distributed in additional components. Similarly, in some embodiments, the functionality of some of the illustrated components may not be provided and/or other additional functionality may be available.</p><p id="p-0082" num="0081">Those skilled in the art will also appreciate that, while various items are illustrated as being stored in memory or on storage while being used, these items or portions of them may be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively, in other embodiments some or all of the software components may execute in memory on another device and communicate with the illustrated computer system via inter-computer communication. Some or all of the system components or data structures may also be stored (e.g., as instructions or structured data) on a computer-accessible medium or a portable article to be read by an appropriate drive, various examples of which are described above. In some embodiments, instructions stored on a non-transitory, computer-accessible medium separate from computer system <b>1000</b> may be transmitted to computer system <b>1000</b> via transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a network and/or a wireless link. Various embodiments may further include receiving, sending or storing instructions and/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Accordingly, the present invention may be practiced with other computer system configurations.</p><p id="p-0083" num="0082">It is noted that any of the distributed system embodiments described herein, or any of their components, may be implemented as one or more web services. In some embodiments, a network-based service may be implemented by a software and/or hardware system designed to support interoperable machine-to-machine interaction over a network. A network-based service may have an interface described in a machine-processable format, such as the Web Services Description Language (WSDL). Other systems may interact with the web service in a manner prescribed by the description of the network-based service's interface. For example, the network-based service may define various operations that other systems may invoke, and may define a particular application programming interface (API) to which other systems may be expected to conform when requesting the various operations.</p><p id="p-0084" num="0083">In various embodiments, a network-based service may be requested or invoked through the use of a message that includes parameters and/or data associated with the network-based services request. Such a message may be formatted according to a particular markup language such as Extensible Markup Language (XML), and/or may be encapsulated using a protocol such as Simple Object Access Protocol (SOAP). To perform a web services request, a network-based services client may assemble a message including the request and convey the message to an addressable endpoint (e.g., a Uniform Resource Locator (URL)) corresponding to the web service, using an Internet-based application layer transfer protocol such as Hypertext Transfer Protocol (HTTP).</p><p id="p-0085" num="0084">In some embodiments, web services may be implemented using Representational State Transfer (&#x201c;RESTful&#x201d;) techniques rather than message-based techniques. For example, a web service implemented according to a RESTful technique may be invoked through parameters included within an HTTP method such as PUT, GET, or DELETE, rather than encapsulated within a SOAP message.</p><p id="p-0086" num="0085">The various methods as illustrated in the FIGS. and described herein represent example embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.</p><p id="p-0087" num="0086">Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A system, comprising:<claim-text>a plurality of computing devices, respectively comprising a processor and a memory, the plurality of computing devices configured to implement a query acceleration service;</claim-text><claim-text>wherein the query acceleration service comprises a plurality of acceleration nodes; and</claim-text><claim-text>wherein the query acceleration service is configured to:<claim-text>perform a plurality of queries received from one or more clients of the query acceleration service at the plurality of acceleration nodes;</claim-text><claim-text>record usage of the plurality of acceleration nodes for the performance of the plurality of queries;</claim-text><claim-text>apply a usage prediction technique to the usage of the plurality of acceleration nodes to make respective placement decisions for different data according to a likelihood of the different data to be accessed as part of performing subsequent client queries at the plurality of acceleration nodes;</claim-text><claim-text>send requests to one or more separate storage systems to obtain the different data; and</claim-text><claim-text>store the different data at the plurality of acceleration nodes according to the respective placement decisions to make the different data available for performing the subsequent queries at the plurality of acceleration nodes when the subsequent queries are received.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the usage of the plurality of acceleration nodes is recorded as a time series, and wherein to apply the usage prediction technique to the usage of the plurality of acceleration nodes to make respective placement decisions, the query acceleration service is configured to:<claim-text>evaluate the time series to build a time series prediction model for future usage of the plurality of acceleration nodes;</claim-text><claim-text>use the time series prediction model to make a usage prediction for the plurality of acceleration nodes; and</claim-text><claim-text>schedule placement of the different data at different ones of the plurality of acceleration nodes according to the usage prediction.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the query acceleration service is further configured to:<claim-text>after recording further usage of the plurality of acceleration nodes for the performance of additional queries, update the time series prediction model based on the further usage of plurality of acceleration nodes.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The system of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the query acceleration service is implemented as part of a provider network, wherein the one or more clients of the query acceleration service are respective processing clusters of a data warehouse service implemented as part of the provider network, and wherein the one or more separate storages systems is a storage service different from the data warehouse service and implemented as part of the provider network.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. A method, comprising:<claim-text>obtaining usage of a plurality of multi-tenant cache nodes for a plurality of client access requests;</claim-text><claim-text>applying a usage prediction technique to the usage of the plurality of multi-tenant cache nodes to make respective placement decisions for different data according to a likelihood of the different data to be accessed as part of performing subsequent client access requests at the plurality of multi-tenant cache nodes; and</claim-text><claim-text>performing placement actions with respect to the different data at the plurality of multi-tenant cache nodes according to the respective placement decisions, the different data being obtained from one or more separate storage systems.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein performing placement actions with respect to the different data comprises obtaining and storing the different data at the plurality of multi-tenant cache nodes.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein obtaining the usage of the plurality of multi-tenant cache nodes for the plurality of client access requests comprises obtaining the usage from the plurality of multi-tenant cache nodes.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein obtaining the usage of the plurality of multi-tenant cache nodes for the plurality of client access requests comprises obtaining at least some of the usage from one or more clients that submitted the client access requests.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the usage of the plurality of multi-tenant cache nodes is recorded as a time series, and wherein applying the usage prediction technique to the usage of the plurality of multi-tenant cache nodes to make respective placement decisions comprises:<claim-text>evaluating the time series to build a time series prediction model for future usage of the plurality of multi-tenant cache nodes;</claim-text><claim-text>using the time series prediction model to make a usage prediction for the plurality of multi-tenant cache nodes; and</claim-text><claim-text>scheduling placement of the different data at different ones of the plurality of multi-tenant cache nodes according to the usage prediction.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising:<claim-text>after obtaining further usage of the plurality of multi-tenant cache nodes for the performance of additional access requests, updating the time series prediction model based on the further usage of plurality of multi-tenant cache nodes.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein updating the time series prediction model is performed responsive to detecting a usage change for the plurality of multi-tenant cache nodes based on the further usage of the plurality of multi-tenant cache nodes.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein applying the usage prediction technique to the usage of the plurality of multi-tenant cache nodes to make respective placement decisions comprises:<claim-text>training a reinforcement learning agent to make placement decisions based on the usage of the plurality of multi-tenant cache nodes; and</claim-text><claim-text>using the reinforcement learning agent to determine the respective placement decisions.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein performing placement actions with respect to the different data comprises removing at least a portion of data at one of the plurality of multi-tenant cache nodes.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. One or more non-transitory, computer-readable storage media, storing program instructions that when executed on or across one or more computing devices cause the one or more computing devices to implement:<claim-text>recording usage of a plurality of multi-tenant cache nodes for a plurality of client access requests;</claim-text><claim-text>applying a machine learning technique to the usage of the plurality of multi-tenant cache nodes to make respective placement decisions according to a likelihood of different data to be accessed as part of performing subsequent client access requests at the plurality of multi-tenant cache nodes; and</claim-text><claim-text>causing performance of placement actions with respect to the different data at the plurality of multi-tenant cache nodes according to the respective placement decisions, the different data being obtained from one or more separate storage systems.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the respective placement decisions indicate which portions of the different data to co-locate on a same one of the plurality of multi-tenant cache nodes.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein in causing performance of placement actions with respect to the different data, the program instructions cause the one or more computing devices to implement removing at least a portion of data at one of the plurality of multi-tenant cache nodes as one of the placement actions.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the usage of the plurality of multi-tenant cache nodes is recorded as a time series, and wherein, in applying the usage prediction technique to the usage of the plurality of multi-tenant cache nodes to make respective placement decisions, the program instructions cause the one or more computing devices to implement:<claim-text>evaluating the time series to build a time series prediction model for future usage of the plurality of multi-tenant cache nodes;</claim-text><claim-text>using the time series prediction model to make a usage prediction for the plurality of multi-tenant cache nodes; and</claim-text><claim-text>scheduling placement of the different data at different ones of the plurality of multi-tenant cache nodes according to the usage prediction.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00017">claim 17</claim-ref>, storing further instructions that when executed on or across the one or more computing devices, causes the one or more computing devices to implement:<claim-text>after recording further usage of the plurality of multi-tenant cache nodes for the performance of additional access requests, updating the time series prediction model based on the further usage of plurality of multi-tenant cache nodes.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein updating the time series prediction model is performed responsive to exceeding a period of time since a last update of the time series prediction model.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein, in applying the usage prediction technique to the usage of the plurality of multi-tenant cache nodes to make respective placement decisions, the program instructions cause the one or more computing devices to implement:<claim-text>training a reinforcement learning agent to make placement decisions based on the usage of the plurality of multi-tenant cache nodes; and</claim-text><claim-text>using the reinforcement learning agent to determine the respective placement decisions.</claim-text></claim-text></claim></claims></us-patent-application>