<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004502A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004502</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17943739</doc-number><date>20220913</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20160101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>10</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20220101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>67</main-group><subgroup>1097</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20090101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>W</subclass><main-group>84</main-group><subgroup>04</subgroup><symbol-position>L</symbol-position><classification-value>N</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>10</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>67</main-group><subgroup>1097</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>154</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>657</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>W</subclass><main-group>84</main-group><subgroup>042</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">Distributed Computing based on Memory as a Service</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17319002</doc-number><date>20210512</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11481334</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17943739</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16424424</doc-number><date>20190528</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11061819</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17319002</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Micron Technology, Inc.</orgname><address><city>Boise</city><state>ID</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Akel</last-name><first-name>Ameen D.</first-name><address><city>Rancho Cordova</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Bradshaw</last-name><first-name>Samuel E.</first-name><address><city>Sacramento</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Curewitz</last-name><first-name>Kenneth Marion</first-name><address><city>Cameron Park</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Eilert</last-name><first-name>Sean Stephen</first-name><address><city>Penryn</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Yudanov</last-name><first-name>Dmitri</first-name><address><city>Rancho Cordova</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Systems, methods and apparatuses of distributed computing based on memory as a service are described. For example, a set of networked computing devices can each be configured to execute an application that accesses memory using a virtual memory address region. Each respective device can map the virtual memory address region to the local memory for a first period of time during which the application is being executed in the respective device, map the virtual memory address region to a local memory of a remote device in the group for a second period of time after starting the application in the respective device and before terminating the application in the respective device, and request the remote device to process data in the virtual memory address region during at least the second period of time.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="198.37mm" wi="122.51mm" file="US20230004502A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="220.05mm" wi="124.54mm" file="US20230004502A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="219.03mm" wi="156.29mm" file="US20230004502A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="228.35mm" wi="141.99mm" file="US20230004502A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="187.03mm" wi="137.24mm" file="US20230004502A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="187.03mm" wi="137.24mm" file="US20230004502A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="200.91mm" wi="137.16mm" file="US20230004502A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="193.38mm" wi="99.06mm" file="US20230004502A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="210.23mm" wi="147.15mm" file="US20230004502A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="152.15mm" wi="89.58mm" file="US20230004502A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="219.71mm" wi="164.25mm" file="US20230004502A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="218.78mm" wi="99.06mm" file="US20230004502A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="235.63mm" wi="169.50mm" file="US20230004502A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="235.63mm" wi="169.50mm" file="US20230004502A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="235.63mm" wi="169.50mm" file="US20230004502A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="202.95mm" wi="156.29mm" file="US20230004502A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="228.35mm" wi="156.29mm" file="US20230004502A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="190.25mm" wi="153.08mm" file="US20230004502A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="199.14mm" wi="134.62mm" file="US20230004502A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="220.39mm" wi="135.64mm" file="US20230004502A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="219.03mm" wi="156.29mm" file="US20230004502A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="219.03mm" wi="156.29mm" file="US20230004502A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00022" num="00022"><img id="EMI-D00022" he="219.03mm" wi="156.29mm" file="US20230004502A1-20230105-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00023" num="00023"><img id="EMI-D00023" he="219.03mm" wi="156.29mm" file="US20230004502A1-20230105-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00024" num="00024"><img id="EMI-D00024" he="209.30mm" wi="99.06mm" file="US20230004502A1-20230105-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00025" num="00025"><img id="EMI-D00025" he="227.75mm" wi="166.29mm" file="US20230004502A1-20230105-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00026" num="00026"><img id="EMI-D00026" he="227.75mm" wi="166.29mm" file="US20230004502A1-20230105-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00027" num="00027"><img id="EMI-D00027" he="227.75mm" wi="166.29mm" file="US20230004502A1-20230105-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00028" num="00028"><img id="EMI-D00028" he="227.75mm" wi="166.29mm" file="US20230004502A1-20230105-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00029" num="00029"><img id="EMI-D00029" he="227.75mm" wi="166.29mm" file="US20230004502A1-20230105-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00030" num="00030"><img id="EMI-D00030" he="227.75mm" wi="165.44mm" file="US20230004502A1-20230105-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00031" num="00031"><img id="EMI-D00031" he="209.30mm" wi="165.78mm" file="US20230004502A1-20230105-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">RELATED APPLICATIONS</heading><p id="p-0002" num="0001">The present application is a continuation application of U.S. patent application Ser. No. 17/319,002 filed May 12, 2021, which is a continuation application of U.S. patent application Ser. No. 16/424,424 filed May 28, 2019 and issued as U.S. Pat. No. 11,061,819 on Jul. 13, 2021, the entire disclosures of which applications are hereby incorporated herein by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">At least some embodiments disclosed herein relate to memory services provided by operating systems.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">In some computer systems, an operating system allows an application program to use virtual addresses of memory to store data in, or retrieve data from, memory components of one or more memory sub-systems of the computer system. The operating system defines the mapping between the virtual memory addresses and the physical memory addresses of one or more memory sub-systems connected to the central processing unit (CPU) and/or a graphics processing unit (GPU) and/or system-on-a-chip (SoC) of the computer system. Such mapping can be defined through the use of page tables. A page table entry specifies the mapping between a set of virtual memory addresses of a virtual memory page and a corresponding set of physical memory addresses of a physical memory page. The page tables can be used to implement the memory accesses requested for virtual memory addresses by translation of the virtual memory addresses into corresponding physical memory addresses of the memory sub-systems.</p><p id="p-0005" num="0004">A computer processor can have a memory management unit (MMU) configured to perform the translation of virtual memory addresses into physical memory addresses according to page tables defined by the operating system. The memory management unit (MMU) can have a translation lookaside buffer (TLB) that is configured to cache the recently used page table entries. The memory management unit (MMU) may perform other memory related tasks, such as cache control and/or memory protection.</p><p id="p-0006" num="0005">In general, a virtual address space for memory in a computer can be divided into pages of a predetermined size. A page of virtual memory is represented by the collection of the virtual memory addresses; the virtual memory addresses can be mapped to the physical memory addresses of a page of physical memory in the memory sub-systems; page table entries define the address mapping between the page of virtual memory and the page of physical memory.</p><p id="p-0007" num="0006">In some computer systems, an operating system can use a paging technique to access a page of data in a storage or memory device via a page of memory in a memory module. At different time instances, the same page of memory in a memory module can be used as proxy to access different pages of memory in the storage or memory device or another storage or memory device in the computer system.</p><p id="p-0008" num="0007">Remote direct memory access (RDMA) is a technique that allows direct memory access from one computer into another, without involving any of the operating systems of the computers involved (e.g., after the operating systems are executed to negotiate and set up the memory resources for RDMA operations). Prior to an RDMA operation (e.g., read or write), commands are executed to establish a memory mapping between the two computers via one or more networking devices. When an application running on a computer performs an RDMA operation, the application data is delivered directly across the computer network, reducing latency and enabling fast data transfer. RDMA uses a network adapter to transfer data to or from application memory, eliminating the need to copy data between application memory and the data buffers in the operating system.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0009" num="0008">The embodiments are illustrated by way of example and not limitation in the figures of the accompanying drawings in which like references indicate similar elements.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a system in which a computing device or a server computer can borrow memory from and/or lend memory to another computing device and/or another server computer.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a borrower device and a lender device implementing inter operating system memory services over communication network connections according to one embodiment.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a technique to use borrowed memory according to one embodiment.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates the use of a physical memory region to facilitate access to different borrowed memory regions according to one embodiment.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates another use of a physical memory region to facilitate access to different borrowed memory regions according to one embodiment.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a borrower-lender memory hierarchy in a computing system.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows a method to implement inter operating system memory services over communication network connections.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a method to service a page of borrowed memory according to one embodiment.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows a borrower device having memory regions of different criticality levels based on which network traffics for memory as a service can be throttled.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates tagging criticality levels of memory regions in a memory map according to one embodiment.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates a method to identify the criticality level of a memory region according to one embodiment.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows a method to throttle network communications for memory as a service according to one embodiment.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIGS. <b>13</b>-<b>15</b></figref> illustrate hardware accelerated configurations to access borrowed memory according to some embodiments.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIGS. <b>16</b> and <b>17</b></figref> illustrate hardware accelerated configurations to provide access to loaned memory according to some embodiments.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>18</b></figref> shows a method to accelerate access to borrowed memory via a memory management unit according to one embodiment.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIGS. <b>19</b> and <b>20</b></figref> illustrate a borrower device and a lender device configured to perform intelligent content migration according to some embodiments.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIGS. <b>21</b>-<b>24</b></figref> illustrate content movements according to some embodiments.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>25</b></figref> shows a method to migrate content in a computing system having borrowed memory according to some embodiments.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIGS. <b>26</b> and <b>27</b></figref> illustrate distributed computing based on selectively hosting a virtual address region on local memory of different computers.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIGS. <b>28</b> and <b>29</b></figref> illustrate selectively running an application on different computers at different stages of the execution of the application.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIGS. <b>30</b> and <b>31</b></figref> illustrate running an application in virtual machines hosted on different computers.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>32</b></figref> shows a method of distributed computing based on memory as a service (MaaS).</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0032" num="0031">At least some embodiments disclosed herein provide techniques of inter operating system memory services over communication network connections, such that a borrower device can expand its memory capacity by using a communication link and the memory of a lender device. Operating systems of the borrower device and/or the lender device can be configured to seamlessly bridge the gap over the communication link, such that application programs running on the borrower device can use its local memory and the borrowed memory without distinction. The local memory is physically installed in the borrower device; and the borrowed memory is physically installed in a lender device that is connected to the borrower device via a communication connection.</p><p id="p-0033" num="0032">Optionally, a portion of the borrowed memory and/or the local memory in the borrower device can be loaned to another device over a computer network. A borrower device can have multiple lender devices. Thus, a borrower-lender device hierarchy can be formed on a hierarchy of communication links among the devices.</p><p id="p-0034" num="0033">The operating system of the borrower device can use a virtual to physical memory map to bridge the differences in the local memory and the borrowed memory. For example, the operating system of the borrower device can manipulate page table entry (PTE), in response to a miss in the translation lookaside buffer (TLB) of the borrower device that can lead to a determination of a page fault, to use a portion of the local memory of the borrower device as aperture, proxy, and/or cache in accessing the borrowed memory over a communication link. Cache coherency between the lender device and borrower device can be relaxed for improved bandwidth usage. Since the differences between the local memory and the borrowed memory area are shielded by the operating system of the borrower device from applications running on the borrower device, an application running on the borrower device can byte-access the borrowed memory in a same way as accessing the local random access memory configured in the borrower device.</p><p id="p-0035" num="0034">The memory services of the operating systems can be used to construct a multi-level byte-addressable memory in a computer system under a unified address space shared by multiple operating systems over non-coherent communication links. For example, a wearable computing device can borrow memory from a mobile computing device over a personal area network or a local area network. The wearable computing device can be a smart watch, a motion tracking device, or a smart glass, and the mobile computing device can be a smart phone, a touch pad computer, or a notebook computer, etc. The wearable computing device and/or the mobile computing device can borrow memory from a computing appliance over a local area network. For example, the computing appliance can be a mini-server, a desktop computer, a memory appliance, or a storage appliance, etc. The mobile computing device and/or the computing appliance can borrow memory from a server computer or a server farm over the internet and/or via cloud computing.</p><p id="p-0036" num="0035">In a multi-level hierarchy of lender-borrower of memory resources, each subsequent higher level device (e.g., a mobile computing device, a computing appliance, a server computer or farm) can use their memory capacity to boost on demand the memory capacity of lower level devices (e.g., a wearable computing device, a mobile computing device, a computing appliance), and/or devices in the same level. IoT devices will constitute environment, such as construction materials (concreate walls, roads and so on). It could be that low dense, but highly bulky cheap memory technologies will allow to integrate low-density memory (and compute) in construction at very low cost. Thus, we'll have sort of &#x2018;memory matter&#x2019; (or may be compute matter) as a part of the environment that any device can use.</p><p id="p-0037" num="0036">Optionally, some levels in the hierarchy can be skipped, depending on the availability of certain devices and/or network connections. For example, a wearable computing device can borrow memory from a computing appliance without going through a mobile computing device; and a mobile computing device can borrow memory from a server computer or a server farm over the internet without going through a computing appliance in a local area network.</p><p id="p-0038" num="0037">At the appliance and cloud levels, memory resources can be provisioned as a utility with memory as a service (MaaS). Such an arrangement can provide low level computing devices, such as wearable computing devices, mobile computing devices, and/or computing devices of internet of things, with enormous persistent memory capacity and storage resource on demand. Applications running on the low level computing devices can use the memory services provided by the operating systems to use the borrowed memory in a transparent way, as if the borrowed memory were part of the local memory of the borrower devices. As a result, no special programming is required in the applications to use the borrowed memory.</p><p id="p-0039" num="0038">The applications running on the borrower devices can use the borrowed memory to store data persistently and thus eliminate or reduce the need for operations to store data via a file system. For example, a lender appliance/server can provide a persistent random access memory, or a storage capacity, to offer memory resources to borrower devices and manage the persistence and/or redundancy of the data stored in the offered memory resources such that the borrowed memory can be treated as virtual non-volatile random access memory in the borrower devices.</p><p id="p-0040" num="0039">Optionally, memory provided as a service can include semantics for memory page sharing among clients/borrowers, locking mechanisms, time out mechanisms, etc.</p><p id="p-0041" num="0040">As an example, a phone can obtain, as a borrower device, 8 terabyte (TB) of observable memory over a wireless local area network (WLAN) (e.g., facilitated via a home Wi-Fi access point) from a memory appliance functioning as a lender device. The 8 TB of memory is observable to applications running under the operating system of the phone, in a way same as applications running on a phone having 8 TB of local memory. Alternatively, the phone can obtain 8 TB of observable memory over a cellular communications network from a server or the cloud computing infrastructure that is configured as a lender device. Optionally, the phone can borrow part of the <b>8</b> TB of observable memory from the memory appliance and part of the 8 TB of observable memory from the server or the cloud computing infrastructure. The 8 TB of observable memory can be virtually made available on the phone by the operating system of the phone such that applications running on the phone can use the virtual/remote memory, even though the phone may have only 8 megabyte (MB) of physical local memory. The 8 TB of borrowed memory expends the memory capability of the phone to over 8 TB; and to applications running on the phone with borrowed memory, the memory capacity of the phone appears to be the same as a phone having more than 8 TB of local random access memory.</p><p id="p-0042" num="0041">Since the borrower devices typically do not use borrowed memory at once at the time of borrowing the memory, the lender devices do not have to block-allocate the memory loaned to the borrower device upon the borrowing of the memory. The lender devices can implement thin provision of memory (e.g., thinly provision memory) and incrementally allocate the memory in response to the borrower device using an increasing amount of the borrowed memory.</p><p id="p-0043" num="0042">The applications running under the operating system of a borrower device can read and write on demand memory pages that are borrowed from the lender device(s). Physical page allocation in a lender device and/or a corresponding allocation in a borrower device can be configured to be performed in response to a write operation on the page. A part of local memory of the borrower device can be configured as cache, proxy, and/or aperture in accessing a borrowed page. When an application running on the borrower device accesses a virtual page, the operating system of the borrower device can migrate the content of the accessed virtual page to the local memory. When a local memory page has not been accessed for a certain period of time and/or is to be used for hosting the content of another page, the operating system of the borrower device can evict or migrate the content of the virtual page in the local memory to the borrowed memory on the lender device. Optionally, the operating system of the borrower device can use a portion of the local random access memory of the borrower device as a fast buffer for critical data, and use the borrowed memory physically residing in the remote lender device to hold less critical data. Less critical data and/or less frequently used data can be migrated to the local random access memory of the borrower device when needed.</p><p id="p-0044" num="0043">In general, a lender device for a lower level device in the hierarchy can be itself a borrower device in a higher level in the borrower-lender device hierarchy. For example, a phone, as a borrower device, may borrow 8 TB of memory from a memory appliance as a lender device. The memory appliance, as a borrower device, may borrow 4 TB of memory from a server and combine the 4 TB of memory borrowed from the server and 4 TB of its local memory into the 8 TB of memory loaned to the phone. In some implementations, the 4 TB of memory borrowed from the server can be identified to the phone such that when the connection between the phone and the appliance is not available, the phone can use an alternative connection to the server to continue using the 4 TB memory without going through the memory appliance. However, the alternative connection may be slower than the one to the memory appliance, since the appliance could be in closer proximity to the phone than the remote server.</p><p id="p-0045" num="0044">The operating system of a lender device and the operating system of a borrower device can communicate with each other to facilitate seamless memory access across the communication link between the lender device and the borrower device. Thus, it is not necessary to pre-allocate physical memory in the lender device before applications running on the borrower device start using memory. The page eviction traffic and lender device memory availability determine the size of the usage of borrowed memory as the footprint of the applications running on the borrower device grows. Elimination of the requirements for pre-allocation of the physical memory in the lender device for an application (e.g., as required in case of RDMA protocols) removes a necessity for special programming (e.g., message passing interface (MPI) over RDMA) and allows an application program to function in devices of varying configurations in their original code yet utilizing all benefits of scale-out application capacity as they would in the case of RDMA and alike.</p><p id="p-0046" num="0045">In general, a lender device can be configured to operate in a passive mode or an active mode for a particular borrower device. The lender device can operate in different modes for different borrower devices.</p><p id="p-0047" num="0046">In the passive mode, the operating system of the lender device observes memory pages that are cached or migrated by the operating system of the borrower device over the link and modifies its own page table entries, which correspond to these pages, accordingly. Observation that the lender operating system performs on page movement can be done for example by the bus snooping or hardware monitoring.</p><p id="p-0048" num="0047">The operating system of a borrower device is configured to maintain page tables for local memory of the borrower device and the borrowed memory that physically resides in the lender device. In general, when a page of borrowed memory is being accessed by an application running on the borrower device, the content of the page may or may not be currently stored in a page of local memory of the borrower device.</p><p id="p-0049" num="0048">When the borrower device accesses a page that does not exist in the local memory of the borrower device a page fault happens. For our purpose we consider a page fault happening in two cases: 1) an accessed page does not exist at all; and 2) the accessed page exists but not in local memory.</p><p id="p-0050" num="0049">If the page does not exist, it was never written or read. There is no page table entry (PTE) for that page. It is first time the page is being accessed. If a read operation is performed on such a page, it is not necessary to allocate actual page. Some operating systems (e.g., Linux) can provide a fake page filled with zeros, because the page has never written and thus contains no data. Hence, a read operation performed on such a page gets zero as a result. In this case the OS executes handler for this page fault: TLB miss causes page walk, which determines that a read operation is performed on a page without PTE. As a result, a mapping to zero page is returned.</p><p id="p-0051" num="0050">If a write operation is performed on a page for the first time, it is a true fault. The true fault results in a new PTE and page allocation in local memory. An example of page fault handler for this case: the TLB miss causes page walk, which determines that a write operation is performed on a page without PTE. As a result, the operating system allocates new page, generates the PTE and installs the PTE in the page table. After the PTE is cached in TLB, the fault is resolved.</p><p id="p-0052" num="0051">When a page fault occurs in accessing the borrowed page and the content of the page is not currently in the local memory of the borrower device (e.g., after the content of the borrowed page has been migrated/evicted to the lender device), the operating system of the borrower device can communicate with the lender device over the communication link between the borrower device and the lender device to retrieve or migrate the content of the borrowed page.</p><p id="p-0053" num="0052">Caching operations can be performed in connection with the processing in the above discussed two cases. For example, the lender device can keep a page copy. The copy can be useful if the borrower device does not further modify the page (e.g., performs only read operations on the page). In such a situation, no eviction is needed because true copy of the page already exists on the lender device. Similarly, the borrower device can perform speculative eviction of a page, when the communication link between the borrower device and the lender device is free to use.</p><p id="p-0054" num="0053">Optionally, the lender device and/or the borrower device can be configured with firmware/hardware that accelerates the operations of migrating the content between the lender device and the borrower device.</p><p id="p-0055" num="0054">Optionally, the operating system of the lender device can be configured to maintain and operate its own set of page tables and associated resources, such as page table walker, translation lookaside buffer (TLB), content-addressable memory (CAM), lookup tables etc.</p><p id="p-0056" num="0055">The operating system of the lender device monitors memory access requests from any of the borrower devices that borrow memory from the lender device. It can be configured to provide semantics for page sharing among the borrower devices (e.g., atomics, locks, semaphores, flags, timeouts, etc.). As a result, the address space of borrowed memory is unified among the borrower devices according to the page tables in the lender device. Distributed applications can take advantage of the unified address space by sharing borrowed memory, via the lender device, with different instances applications running on different borrower devices.</p><p id="p-0057" num="0056">Optionally, the lender device can be configured to accept requests from borrower devices to produce computation results on certain regions of memory loaned to the borrower devices. Thus, the lender device provides not only the memory resource but also the computing power for processing data in the memory loaned to the borrower devices.</p><p id="p-0058" num="0057">The memory services offered by the operating systems of borrower devices and lender devices allow an application running on a borrower device to address borrowed memory at byte granularity with fault resolved at page granularity.</p><p id="p-0059" num="0058">The operating system of the borrower device can evict or migrate a page from local memory to the lender device over the communication link between the borrower device and the lender device. The operating system of the borrower device can identify a page for eviction or migration from the local random access memory of the borrower device to its borrowed memory based on the infrequent use of the page and/or based on the page being used less recently than other pages or based on criticality or any other possible measurable system parameter. The operating system of the borrower device can decide to evict or migrate a borrowed page to free local memory for other uses, such as new local page allocations or for migration of a page from the lender device. As a result of this method the current page owner (borrower or lender) owns true copy of the page. Other devices may still cache it just in case if page is still not modified after the owner releases it. For example, when borrower gets the page from the lender the lender does not have that page any more. However, the lender may not delete page copy but keep it: in case if page will be non-modified upon eviction there will be no need to transfer it over the link back to the lender. What if lender also wants to modify it or provide it to other borrowers? In this case all writes would have to happen on the lender so to merge these write request from different borrowers.</p><p id="p-0060" num="0059">To evict or migrate a page, the operating system of the borrower device communicates the content of the page to the lender device, causing the lender device to store the page in the memory of the lender device. The operating system of the borrower device can then update a page table to indicate that the page is now in the lender device and not in the local memory of the borrower device.</p><p id="p-0061" num="0060">In active mode, the operating system of the lender device can be configured to monitor page tables on the borrower device, identify unused pages, and repurpose the unused pages for other memory users.</p><p id="p-0062" num="0061">The interactions between the lender device and the borrower device can be implemented via virtualization, which allows the lender device to monitor page table usages in the borrower device.</p><p id="p-0063" num="0062">For example, the operating system of the borrower device can be partially virtualized for operations in the operating system of the lender device. Some of the memory management code/subroutines of the operating system of the borrower device can be configured via virtualization to run on the lender device and/or as part of the operating system of the lender device. In such an implementation, the operating system of the borrower device can extend memory access request to the operating system of the lender device to execute such subroutines, which may be hardware/firmware-accelerated at the level of the operating system of the lender device.</p><p id="p-0064" num="0063">For example, the operating system of the lender device can create a virtual memory device and offer the virtual memory device to the borrower device. The borrower device can request the virtual memory device on demand and make available the virtual memory device for servicing the memory resource needs of applications running on the borrower device.</p><p id="p-0065" num="0064">In some instances, if an application running on the borrower device can tolerate or accept the latency caused by the communication link between the borrower device and the lender device, access to the borrowed page can be made directly over the communication link without migrating the entire page to the lender. In other implementations, the content migration can be configured at a sub-page level; and only the portion of the page that is being accessed and/or predicted to be accessed is migrated. Optionally, the operating system may use a remote direct memory access (RDMA) technique in implementing the direct memory access. Optionally, such direct memory access can be implemented at the memory controller and/or memory management unit and thus avoid the standard RDMA protocol and its overhead.</p><p id="p-0066" num="0065">In some implementations, the operating system of the borrower device is configured to dynamically adjust physical location of virtual memory pages. A page of virtual memory is specified by the virtual memory addresses of the page. The virtual memory page can be initially located in the local memory of the borrower device, subsequently moved to the memory loaned by a lender device to the borrower device, and subsequently moved to another local page of the borrower device.</p><p id="p-0067" num="0066">To migrate a virtual page from the lender device to the borrower device, the borrower device fetches the content of the page from the lender device, stores the content in its local memory, and updates relevant page tables to establish the mapping between the local physical page and the virtual page. Once the virtual page is migrated to the borrower device, the lender device can free the physical memory that was previously used for the virtual page and/or erase the data stored there. Optionally, the operating system of the lender device can reserve the page previously used for the virtual page and keep its content as a backup copy of the virtual page.</p><p id="p-0068" num="0067">In the reverse direction, the operating system of the borrower device can migrate the virtual page from the borrower device to the lender device. For example, the operating system of the borrower device can request the allocation of a borrowed page in the lender device, and transmit the content of the virtual page for storing it in the borrowed memory on the lender device. Once the content of the virtual page is stored on the lender device, the operating system of the borrower device can update its page tables for the virtual page to identify the mapping between the virtual page and its physical location in the borrowed memory to complete the migration of the page to the lender device. After the migration of the virtual page, the local memory previously used to host the virtual page can be used for hosting another virtual page. In such an implementation, it is not necessary to statically map a predetermined portion of the virtual memory or virtual memory address space to the borrowed memory in the lender device(s).</p><p id="p-0069" num="0068">Furthermore, a virtual page does not have to be hosted in a predetermined lender device. For example, the operating system of the borrower device can migrate a virtual page from a first lender device to the borrower device, and then migrate the virtual page from the borrower device to a second lender device. In some instances, the operating system of the borrower device can request the migration of a virtual page from a first lender device to a second lender device without downloading the content of the page to the borrower device and then uploading this content to the second lender device.</p><p id="p-0070" num="0069">Using the techniques of memory as a service (MaaS), mobile device vendors can market mobile devices having terabytes of memory capacities at the operating system level, which is to be backed by emerging memories on the lender devices including cloud computing infrastructure. For example, applications in a smart phone configured with 128 MB local memory can access 64 TB of random access memory when the phone is connected to a computer network or the internet or local memory appliance or any other device that implements concepts of MaaS described herein.</p><p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a system in which a computing device or a server computer can borrow memory from and/or lend memory to another computing device and/or another server computer.</p><p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates computing devices (<b>101</b> and <b>103</b>) and server computers (<b>105</b> and <b>107</b>) as examples of borrower devices and lender devices connected via computer networks and/or the internet (<b>109</b>), which can include a cellular communications network, such as a fifth generation cellular network.</p><p id="p-0073" num="0072">Each of the computing devices (<b>101</b> and <b>103</b>) and server computers (<b>105</b> and <b>107</b>) can borrow memory from another device and/or lend memory to another device. Each of the computing devices (<b>101</b> and <b>103</b>) and server computers (<b>105</b> and <b>107</b>) can have one or more communication devices (e.g., <b>117</b>, <b>137</b>, <b>157</b>, and <b>177</b>) to establish one or more communication links with each other or another computing devices or server computers in the system. Each of the computing devices (<b>101</b> and <b>103</b>) and server computers (<b>105</b> and <b>107</b>) can have one or more processor(s) (e.g., <b>115</b>, <b>135</b>, <b>155</b>, and <b>175</b>) configured to execute instructions, such as instructions of operating systems (e.g., <b>113</b>, <b>133</b>, <b>153</b>, and <b>173</b>) and applications or programs running under the operating systems.</p><p id="p-0074" num="0073">Each of the computing devices (<b>101</b> and <b>103</b>) and server computers (<b>105</b> and <b>107</b>) can have local random access memory (e.g., <b>111</b>, <b>131</b>, <b>151</b>, and <b>171</b>) coupled (e.g., via memory buses) to respective processors (e.g., <b>115</b>, <b>135</b>, <b>155</b>, and <b>175</b>).</p><p id="p-0075" num="0074">In some examples, the device A (<b>101</b>) or device B (<b>103</b>) can be a wearable computing device, a computing device of internet of things, a mobile computing device, etc.</p><p id="p-0076" num="0075">In some examples, the server P (<b>105</b>) or server Q (<b>107</b>) can be a mini-server, a personal computer, a memory appliance, a storage appliance, a network storage device, a server computer, a server farm, etc.</p><p id="p-0077" num="0076">In one example, the device A (<b>101</b>) can be connected to the device B (<b>103</b>), the server P (<b>105</b>), and/or the server Q (<b>107</b>) using a wired connection, a wireless personal area network (WPAN), a wireless local area network (WLAN), and/or a wireless wide area network (WWAN).</p><p id="p-0078" num="0077">In another example, the device B (<b>103</b>) can be connected to the server P (<b>105</b>), and/or the server Q (<b>107</b>) using a wired connection, a wireless local area network (WLAN), and/or a wireless wide area network (WWAN).</p><p id="p-0079" num="0078">In another example, the server P (<b>105</b>) can be connected to the server Q (<b>107</b>) using a wired connection, a local area network, a wireless local area network (WLAN), a wireless wide area network (WWAN), and/or the internet.</p><p id="p-0080" num="0079">The server P (<b>105</b>) can borrow memory from the server Q (<b>107</b>) and lend borrowed memory and/or local memory to the devices (<b>101</b> and <b>103</b>) (and/or similar devices). The device B (<b>103</b>) can borrow memory from the server P (<b>105</b>) and/or server Q (<b>107</b>) and lend borrowed memory and/or local memory to the device A (<b>101</b>) (and/or similar devices).</p><p id="p-0081" num="0080">In general, a computing device can loan memory to one or more borrower devices and borrow memory from one or more lender devices.</p><p id="p-0082" num="0081">The operating systems (<b>113</b>, <b>133</b>, <b>153</b>, and <b>173</b>) are configured to provide memory services to applications and programs such that the applications and programs can use virtual memory without awareness of its physical allocation, such that this virtual memory may be partially allocated in borrowed memory and partially allocated in local memory (<b>111</b>, <b>131</b>, <b>151</b>, and <b>171</b>) . The operating systems and supporting hardware takes the burden from applications and programs to manage virtual memory allocations, which provides convenience for applications and programs not to have special code sections or designated instructions designed to handle the differences in local memory and borrowed memory allocations.</p><p id="p-0083" num="0082">In one example, a portion of the local memory (<b>171</b>) of the server Q (<b>107</b>) is loaned to the server P (<b>105</b>). The server P (<b>105</b>) loans a portion of the borrowed memory and/or a portion of its local memory (<b>151</b>) to the device B (<b>103</b>), which in turn loans a portion of its borrowed memory and/or a portion of its local memory (<b>131</b>) to the device A (<b>101</b>). Thus, the virtual memory allocated by the operating system (<b>113</b>) to an application running on the processors (<b>115</b>) of device A (<b>101</b>) may partially reside in the local memory (<b>111</b>) of the device A (<b>101</b>), partially in the local memory (<b>131</b>) of the device B (<b>103</b>), partially in the local memory (<b>151</b>) of the server P (<b>105</b>), and/or partially in the local memory (<b>171</b>) of the server Q (<b>107</b>). The operating systems (<b>113</b>, <b>133</b>, <b>153</b>, and <b>173</b>) are configured to cooperate with each other to provide the memory services and/or the physical allocation of the virtual memory used by the application among the local memories of various devices (e.g., <b>111</b>, <b>131</b>, <b>151</b>, and/or <b>171</b>) such that the application programmed to run on the device A and its local memory (<b>111</b>) can also run without modification with its virtual memory partly allocated in the borrowed memory (<b>131</b>, <b>151</b> and/or <b>171</b>) loaned to the device A (<b>101</b>) by the device B (<b>103</b>), the server P (<b>105</b>) and/or the server Q (<b>107</b>).</p><p id="p-0084" num="0083"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a borrower device (<b>201</b>) and a lender device (<b>203</b>) implementing inter operating system memory services over communication network connections, such as a wired or wireless connection (<b>205</b>) over a local area network, a wide area network, and/or a cellular communications network such as a fifth generation cellular network.</p><p id="p-0085" num="0084">In <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the borrower device (<b>201</b>) borrows memory from the lender device (<b>203</b>); and the lender device (<b>203</b>) loans the memory (<b>202</b>) to the borrower device (<b>201</b>). For example, the borrower device (<b>201</b>) can be the device A (<b>101</b>), the device B (<b>103</b>), or the server P (<b>105</b>) in the system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>; and the lender device (<b>203</b>) can be the device B (<b>103</b>), or the server P (<b>105</b>) in the system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. Further, lender device functionalities can be implemented in the borrower device (<b>201</b>), enabling it to loan memory to another device. Similarly, borrower device functionalities can be implemented in the lender device (<b>203</b>), enabling it to borrow memory from another device.</p><p id="p-0086" num="0085">In <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the borrower device (<b>201</b>) has a communication device (<b>217</b>), one or more processors (<b>215</b>) with a memory management unit (MMU) (<b>216</b>), and local random access memory (<b>211</b>). The processor(s) (<b>215</b>) and the local memory (<b>211</b>) can be in separate computer chips and/or formed on separate integrated circuit dies in some embodiments, and can be packaged in a same computer chip and/or formed on a same integrated circuit die in other embodiments (e.g., in a system-on-a-chip (SoC)).</p><p id="p-0087" num="0086">The operating system (<b>213</b>) of the borrower device (<b>201</b>) includes a memory service module (<b>209</b>) configured to maintain a memory map (<b>207</b>). The memory map (<b>207</b>) identifies the mapping between virtual memory and physical memory, where the physical memory can be partially in the local memory (<b>211</b>) in the borrower device (<b>201</b>) and partially in the loaned memory (<b>202</b>) in the lender device (<b>203</b>). The operating system (<b>213</b>) services virtual memory to one or more applications (e.g., <b>212</b>) running on the borrower device (<b>201</b>). The processor(s) (<b>215</b>) can run the application (<b>212</b>) by executing the instructions of the application code (<b>212</b>). The application memory read and write instructions can use the virtual memory. The memory management unit (MMU) (<b>216</b>) translates the virtual memory addresses into physical memory addresses according to the memory map (<b>207</b>).</p><p id="p-0088" num="0087">When the borrower device (<b>201</b>) borrows memory from the lender device (<b>203</b>), the borrowed memory (<b>204</b>) is virtually in the borrower device (<b>201</b>) and physically it is in the lender device (<b>203</b>) as the loaned memory (<b>202</b>) in the local random access memory (<b>231</b>). Optionally, the lender device (<b>203</b>) can configure a portion of the loaned memory (<b>202</b>), or its entirety, in a storage device (<b>232</b>) that is coupled to the processor(s) (<b>235</b>) of the lender device (<b>203</b>) via a peripheral bus and/or a device controller. For example, the operating system (<b>233</b>) of the lender device (<b>203</b>) can allocate a portion of its memory resources as virtual memory to the operating system (<b>213</b>) of the borrower device (<b>201</b>) in a way similar to allocating memory resources as virtual memory to an application (e.g., <b>234</b>) running on the lender device (<b>203</b>). Thus, the borrowed memory (<b>204</b>) used by the operating system (<b>213</b>) of the borrower device (<b>201</b>) can be in the unified virtual memory address space as the virtual memory used by the application (<b>234</b>) and/or borrowed memory used by other borrowers of the lender device (<b>203</b>). Alternatively, the operating system (<b>233</b>) of the lender device (<b>203</b>) can create virtual memory components for the borrowed memory (<b>204</b>); and operating system (<b>213</b>) of the borrower device (<b>201</b>) can make accessible the virtual memory component in the borrower device (<b>201</b>). A virtual memory controller for the virtual memory component can be implemented in the operating system (<b>213</b>) to access virtual memory components accessible to the borrower device (<b>201</b>). Memory management unit (MMU) <b>216</b> can implement hardware blocks to accelerate virtual memory controllers, and by doing so, improve speed of virtual memory component access.</p><p id="p-0089" num="0088">In some examples the borrowed memory (<b>204</b>) is implicit, such that it is indistinguishable from the rest of virtual memory of applications running on borrower device <b>201</b>. The distinction comes only when translating virtual page addresses to physical addresses by reading memory map <b>207</b>, and upon that translation the physical addresses appear to be in the loaned memory <b>202</b>. In other examples, the operating system (<b>213</b>) stores explicit identification for parts of virtual memory if it belongs to the borrowed memory (<b>204</b>) as provided by the lender device (<b>203</b>). In all cases the operating system <b>213</b> configures the memory map (<b>207</b>) to access the lender device (<b>203</b>) to read from and write to the virtual memory as being the borrowed memory (<b>204</b>) that is physically in the loaned memory (<b>202</b>) in the lender device (<b>203</b>) or in the borrower device (<b>201</b>) after migration to that device.</p><p id="p-0090" num="0089">The memory map (<b>207</b>) can be implemented via page tables. A portion of the page tables are cached in the memory management unit (MMU) (<b>216</b>) such that when instructions executed in the processor(s) (<b>215</b>) access virtual addresses defined in the portion of page tables cached in the memory management unit (MMU) (<b>216</b>), the memory management unit (MMU) (<b>216</b>) translates the virtual addresses into physical addresses. The successful address translation allows the processor(s) (<b>215</b>) to proceed with memory accesses without the need to execute the code of operating system (<b>213</b>).</p><p id="p-0091" num="0090">When the memory management unit (MMU) (<b>216</b>) cannot successfully translate a virtual memory address using the page tables cached in the memory management unit (MMU) (<b>216</b>), a page table entry cache miss is generated, which causes the processor (<b>215</b>) to execute the instructions of the memory service (<b>209</b>) of the operating system (<b>213</b>) to resolve this cache miss. In some implementations MMU contains a hardware IP architected to resolve page table entry cache miss in the cache of memory management unit (MMU) <b>216</b>. This IP, being a part of MMU, extracts required page table entries from page tables stored in the physical memory <b>211</b>. If a required entry does not exist or it exists but it translates virtual page address to address in physical loaned memory <b>202</b> then a page fault is generated for this page. This fault can be resolved by the memory management unit (MMU) <b>216</b> and communication device <b>217</b> directly in hardware. Alternatively, this fault can be resolved by the operating system <b>213</b> and memory service <b>209</b> in software assisted by hardware blocks: memory management unit (MMU) <b>216</b>, processors <b>215</b>, communication device <b>217</b>.</p><p id="p-0092" num="0091">When the memory service (<b>209</b>) of the operating system (<b>213</b>) or memory management unit (MMU) <b>216</b> determines that the virtual memory address being accessed is in the borrowed memory (<b>204</b>), the memory service (<b>209</b>) or memory management unit (MMU) <b>216</b> can allocate a physical page of the local physical memory <b>211</b>, communicate with the lender device (<b>203</b>) via communication devices <b>217</b> and <b>237</b> and computer network connection <b>205</b> to migrate the page of the borrowed memory (<b>204</b>) from the physical loaned memory <b>202</b> into the physical local memory <b>211</b>, generate a page table entry mapping the virtual page to the allocated local physical page, and load the page table entry into the memory management unit (MMU) (<b>216</b>). Thus, before the page fault, the virtual page of the borrowed memory (<b>204</b>) is physically located in the loaned memory (<b>202</b>) in the lender device (<b>203</b>). After the processing of the page fault, the virtual page is located in the local memory (<b>211</b>). The content of the page in loaned memory <b>202</b> of the lender device <b>203</b> may still be saved for future use and other purposes.</p><p id="p-0093" num="0092">When there is no free local page available for the migration, the memory service (<b>209</b>) can evict a selected virtual page that is currently in the local memory (<b>211</b>) to the loaned memory (<b>202</b>). When evicting the selected virtual page to the lender device (<b>203</b>), the memory service (<b>209</b>) communicates with the lender device (<b>203</b>) to transmit the content of the virtual page from the local memory (<b>211</b>) to the loaned memory (<b>202</b>) and updates the memory map (<b>207</b>). After evicting the virtual page from the local memory (<b>211</b>), the space in local memory (<b>211</b>) that was used for the evicted virtual page can be freed.</p><p id="p-0094" num="0093">For example, the memory service (<b>209</b>) can be configured to evict the least frequently used virtual page or the least recently used virtual page.</p><p id="p-0095" num="0094">In <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the lender device (<b>203</b>) has a communication device (<b>237</b>), one or more processors (<b>235</b>) with a memory management unit (MMU) (<b>236</b>), and local random access memory (<b>231</b>). Optionally, the lender device (<b>203</b>) includes one or more storage devices (<b>232</b>) that are connected to the processor(s) (<b>235</b>) via a peripheral bus and/or a computer network. For example, the storage device (<b>232</b>) can be a solid state drive (SSD) or a hard drive (HD).</p><p id="p-0096" num="0095">The operating system (<b>233</b>) of the lender device (<b>203</b>) includes a memory service module (<b>229</b>) configured to maintain a memory map (<b>227</b>). The memory map (<b>227</b>) identifies the mapping between virtual memory and physical memory. The memory map can be stored in the memory <b>231</b> or dedicated for its memory such as content-addressable memory or special cache. The operating system (<b>233</b>) services virtual memory to one or more applications (<b>234</b>) running on the lender device (<b>203</b>) in a way similar to the borrower device (<b>201</b>) servicing its application (<b>212</b>).</p><p id="p-0097" num="0096">Optionally, the lender device (<b>203</b>) provisions loaned memory (<b>202</b>) to the borrower device (<b>201</b>) in a unified virtual memory space. The memory service (<b>209</b>) of the borrower device (<b>201</b>) uses the borrowed memory (<b>204</b>) in the same way as the application (<b>234</b>) using virtual memory provisioned by the memory service (<b>229</b>). For example, the memory service (<b>229</b>) of the lender device (<b>203</b>) can allocate virtual memory to the application (<b>234</b>) running on the lender device (<b>203</b>) and allocate virtual memory as the borrowed memory (<b>204</b>) used by the memory service (<b>209</b>) of the borrower device (<b>201</b>), as if the memory service (<b>209</b>) were an application running on the lender device. Thus, the application (<b>234</b>) running on the lender device (<b>203</b>) and the borrower device (<b>201</b>) (and other devices that borrow memory from the lender device (<b>203</b>)) can operate in a unified virtual address space. Cooperative computations can be configured based on the unified virtual address space. Further, when the lender device (<b>203</b>) borrows memory from another device/server (e.g., <b>105</b> or <b>107</b>), the borrowed memory can also be provisioned in the unified virtual address space. The unified address space can facilitate data sharing and collaborative computation among the computing devices.</p><p id="p-0098" num="0097">The memory service (<b>229</b>) of the lender device (<b>203</b>) can maintain a memory map (<b>227</b>), including the mapping between the virtual addresses of the loaned memory (<b>202</b>), which corresponds to the borrowed memory (<b>204</b>) accessed by the borrower device (<b>201</b>), and the physical addresses of the loaned memory (<b>202</b>). For example, a page table entry of the virtual page identified by the borrower device (<b>201</b>) in accessing a borrowed page can be loaded into the memory management unit (MMU) (<b>236</b>) to facilitate the translation between the addresses of the virtual page and the physical address of the loaned memory (<b>202</b>) for the processor(s) of the lender device (<b>203</b>) to perform computations on behalf of the borrower device (<b>201</b>). Optionally, the lender device (<b>203</b>) can include a hardware similar to the memory management unit (<b>236</b>) to facilitate optimized and/or accelerated data transfer between the lender device (<b>203</b>) and the borrower device (<b>201</b>) using the memory map (<b>227</b>) that identifies the mapping between the borrowed memory (<b>204</b>) as known to the borrower device (<b>201</b>) and the loaned memory (<b>202</b>) physically accessible in the lender device (<b>203</b>).</p><p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a technique to implement borrowed memory according to one embodiment. For example, the technique of <figref idref="DRAWINGS">FIG. <b>3</b></figref> can be implemented in the borrower device (<b>201</b>) illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0100" num="0099"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates memory (<b>211</b>), a memory management unit (MMU) (<b>216</b>) configured to access the memory (<b>211</b>) using physical addresses (e.g., <b>257</b>), and a memory map (<b>207</b>) that defines mapping between virtual address regions (e.g., <b>261</b>, <b>263</b>, <b>265</b>, . . . ) and address regions where the virtual memory regions are mapped to, such as physical address regions (e.g., <b>281</b>, <b>283</b>, . . . ) and borrowed memory regions (e.g., <b>273</b>, <b>275</b>, . . . ).</p><p id="p-0101" num="0100">For example, the borrowed memory address regions (e.g., <b>273</b>, . . . , <b>275</b>) can be configured to identify the virtual address regions allocated by the lender device (<b>203</b>) as the memory provisioned/loaned to the borrower device (<b>201</b>).</p><p id="p-0102" num="0101">For example, a virtual address region A (<b>261</b>) is associated with a physical address region (<b>281</b>) in the memory map (<b>207</b>) to indicate that the region of virtual memory is currently directly mapped to the corresponding region of local physical memory (<b>211</b>).</p><p id="p-0103" num="0102">For example, a virtual address region B (<b>263</b>) is associated in the memory map (<b>207</b>) with a borrowed memory address region X (<b>273</b>) and a physical address region S (<b>283</b>) to indicate that the virtual address region B (<b>263</b>) is mapped to the borrowed memory address region X (<b>273</b>) and physically resides in the physical address region S (<b>283</b>). Thus, access to the virtual address region B (<b>263</b>) can be fulfilled through accessing the physical address region S (<b>283</b>) in the local memory (<b>211</b>). Virtual address region C (<b>265</b>) is associated in the memory map (<b>207</b>) with a borrowed memory address region Y (<b>275</b>) and is not associated with any physical address region in the memory map (<b>207</b>). Thus, for accessing the virtual address region C (<b>265</b>) the borrower device needs to communicate with the lender device.</p><p id="p-0104" num="0103">The content in the physical address region S (<b>283</b>) can be evicted to the lender device to free the physical address region S (<b>283</b>). Once the physical address region S (<b>283</b>) is freed, it can be used for physical placement of another borrowed memory address region, such as the borrowed memory address region Y (<b>275</b>). Once the content of the borrowed memory address region Y (<b>275</b>) is migrated from the lender device to the borrower device to the physical address region S (<b>283</b>), the physical address region S (<b>283</b>) can be used to provide access to the virtual address region C (<b>265</b>) mapped to the borrowed memory address region Y (<b>275</b>) of the unified address space and physically located in the physical address region S (<b>283</b>) of the borrower device, as illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0105" num="0104">In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the memory management unit (MMU) (e.g., similar to <b>216</b> illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>) has a translation lookaside buffer (TLB) (e.g., similar to <b>251</b> illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>) that can store a virtual to physical memory map (<b>253</b>) (e.g., a portion of the memory map (<b>207</b>) maintained by the operating system (<b>213</b>) of the borrower device (<b>201</b>)). When a processor (<b>215</b>) of the borrower device (<b>201</b>) executes an instruction that uses a virtual address (<b>255</b>), the TLB (<b>251</b>) uses the virtual to physical memory map (<b>253</b>) to translate the virtual address (<b>255</b>) into a physical address (<b>257</b>); and the memory management unit (MMU) (<b>216</b>) can use the physical address (<b>257</b>) to access the memory page (<b>259</b>) in the memory (<b>211</b>) (e.g., through a memory bus).</p><p id="p-0106" num="0105">The virtual to physical memory map (<b>253</b>) loaded in the TLB (<b>251</b>) is typically a portion of the memory map (<b>207</b>) managed by the operating system (<b>213</b>) of the borrower device (<b>201</b>). When the processor (<b>215</b>) of the borrower device (<b>201</b>) executes an instruction that uses a virtual address that is not covered in the virtual to physical memory map (<b>253</b>) in the TLB (<b>251</b>), the memory management unit (MMU) (<b>216</b>) can cause the processor (<b>215</b>) to execute the operating system (<b>213</b>), which is programmed to replace a portion of the virtual to physical memory map (<b>253</b>) in the TLB (<b>251</b>), such that the updated virtual to physical memory map (<b>253</b>) in the TLB (<b>251</b>) includes the data for the translation of the virtual address (e.g., <b>255</b>) to a physical address (e.g., <b>257</b>).</p><p id="p-0107" num="0106">The memory management unit (MMU) (<b>216</b>) is typically configured to access the memory (<b>211</b>) via a memory bus coupled between the memory management unit (MMU) (<b>216</b>) of the borrower device (<b>201</b>) and the local memory (<b>211</b>) of the borrower device (<b>201</b>). When the virtual address (<b>255</b>) is initially in a virtual address region (e.g., <b>265</b>) mapped to a borrowed memory address region (e.g., <b>275</b>), the operating system (<b>213</b>) can migrate the content of this region from loaned memory of the lender device to a physical address region (e.g., <b>283</b>) in the memory (<b>211</b>) and update the virtual to physical memory map (<b>253</b>) in the TLB (<b>251</b>) to allow the translation of the virtual address (<b>255</b>) into a physical address (<b>257</b>) corresponding to the virtual address (<b>255</b>) directly without translating it to the borrowed memory address region (e.g., <b>275</b>).</p><p id="p-0108" num="0107">In some embodiments, the memory management unit (MMU) (<b>216</b>) is further configured to access borrowed memory (<b>204</b>) using the communication device (<b>217</b>) over a computer network connection (e.g., <b>205</b>) without explicit migration. In such a situation, it is not necessary for the operating system (<b>213</b>) to migrate the content of a virtual address region (e.g., <b>265</b>). The physical address (<b>257</b>) of the borrowed memory (<b>204</b>) can include information for the communication device (<b>217</b>) to access the memory page (<b>260</b>) in the loaned memory (<b>202</b>) in the lender device (<b>203</b>). The memory access request made using the physical address (<b>257</b>) and via the communication device (<b>217</b>) can be processed in the lender device (<b>203</b>) via its operating system (<b>233</b>). Alternatively, the communication device (<b>237</b>) and/or the memory management unit (MMU) (<b>236</b>) can be configured to process such an access request to the loaned memory (<b>202</b>) (e.g., for read or write) without executing the operating system (<b>233</b>) (e.g., based on a virtual to physical memory map cached in the TLB of the memory management unit (MMU) (<b>236</b>) of the lender device (<b>203</b>) or a hardware acceleration component configured in the lender device (<b>203</b>) to perform similar operations).</p><p id="p-0109" num="0108">The virtual to physical memory map (<b>253</b>) can be implemented in the form of page table entries.</p><p id="p-0110" num="0109"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a borrower-lender memory hierarchy in a computing system.</p><p id="p-0111" num="0110">In <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the lender device (<b>203</b>) can borrow memory from one or more lender servers (<b>245</b>) in a way similar to the borrower device (<b>201</b>) borrows memory from the lender device (<b>203</b>) in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. The lender device (<b>203</b>) pools at least some of its local physical memory (e.g., <b>231</b> illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>) and/or some of its memory borrowed from the lender servers (e.g., <b>245</b>) as available memory (<b>293</b>) for loaning to borrower devices (<b>201</b>). One or more borrower devices (<b>201</b>) can borrow memory from the lender device (<b>203</b>).</p><p id="p-0112" num="0111">A typical borrowed memory (<b>204</b>) can have multiple borrowed memory regions (<b>295</b>, <b>297</b>, . . . , <b>299</b>) and multiple local memory regions (<b>291</b>, <b>293</b>, . . . ). The borrowed memory regions (<b>295</b>, <b>297</b>, . . . , <b>299</b>) in the borrower device (<b>201</b>) can be accessed via migration from the loaned memory of the lender device to the local memory regions (<b>291</b>, <b>293</b>, . . . ) of the borrower device (<b>201</b>). When the borrowed memory regions (<b>295</b>, <b>297</b>, . . . , <b>299</b>) are not used in the borrower device (<b>201</b>), they can be evicted back to the lender device (<b>203</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref> and <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0113" num="0112">Similarly, the lender device (<b>203</b>) may host a region (e.g., <b>299</b>) loaned to the borrower device (<b>201</b>) in its local memory, or the local memory borrowed from the lender server (<b>245</b>).</p><p id="p-0114" num="0113">In general, more than one lender devices (<b>203</b>) can be used to provide memory services to a borrower device (<b>201</b>); and more than one lender server (<b>245</b>) can be configured in the hierarchy.</p><p id="p-0115" num="0114">Optionally, the memory (e.g., <b>295</b>, <b>297</b>, . . . , <b>299</b>) provided as a service in the hierarchy is configured in a unified virtual address space. Thus, the borrower devices (<b>201</b>), the lender device(s) (<b>203</b>), and the lender server(s) (<b>245</b>) can collaborate in processing data in the memory by referencing the virtual addresses in the unified virtual address space.</p><p id="p-0116" num="0115">For example, the borrower device (<b>201</b>) in <figref idref="DRAWINGS">FIG. <b>6</b></figref> can be the device A (<b>101</b>) or device B (<b>103</b>) in the system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0117" num="0116">For example, the lender device (<b>203</b>) in <figref idref="DRAWINGS">FIG. <b>6</b></figref> can be the device B (<b>103</b>) or server P (<b>105</b>) in the system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0118" num="0117">For example, the lender server (<b>245</b>) in <figref idref="DRAWINGS">FIG. <b>6</b></figref> can be the server P (<b>105</b>) or Q (<b>107</b>) in the system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0119" num="0118"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows a method to implement inter operating system memory services over communication network connections. For example, the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref> can be implemented in the system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, with a borrower-lender configuration illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, and/or a borrower-lender memory hierarchy illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0120" num="0119">At block <b>301</b>, a communication connection (<b>205</b>) is established from a borrower device (<b>201</b>) to a lender device (<b>203</b>).</p><p id="p-0121" num="0120">At block <b>303</b>, the borrower device (<b>201</b>) communicates with the lender device (<b>203</b>) to borrow an amount of memory from the lender device (<b>203</b>). The lender device (<b>203</b>) can allocate loaned memory (<b>202</b>) that is borrowed by the borrower device (<b>201</b>) as the borrowed memory (<b>204</b>) usable by the borrowed memory (<b>204</b>) as virtual memory. By borrowing/loaning memory, the devices (<b>201</b> and <b>203</b>) establish a configuration where the processor(s) of the borrower device (<b>201</b>) can read and/or write into the borrowed memory (<b>204</b>)/loaned memory (<b>202</b>). In some instances, the loaned memory (<b>202</b>) is itself a memory borrowed from another lender device (e.g., <b>245</b>).</p><p id="p-0122" num="0121">At block <b>305</b>, the operating system (<b>213</b>) of the borrower device (<b>201</b>) extends a virtual/logical address space of the borrower device (<b>201</b>) to cover the borrowed memory (<b>204</b>). The applications (e.g., <b>212</b>) running on the processor(s) (<b>215</b>) of the borrower device (<b>201</b>) can use the virtual addresses in the space without distinction between borrowed memory (<b>204</b>) and local memory (<b>211</b>).</p><p id="p-0123" num="0122">At block <b>307</b>, the operating system (<b>213</b>) of the borrower device (<b>201</b>) generates a memory map (<b>207</b>) (e.g., in the form of page tables) that maps the extended portion of the logical address space to the borrowed memory (<b>204</b>).</p><p id="p-0124" num="0123">At block <b>309</b>, the operating system (<b>213</b>) of the borrower device (<b>201</b>) allocates the extended portion of logical address space to applications (<b>212</b>).</p><p id="p-0125" num="0124">At block <b>311</b>, the operating system (<b>213</b>) of the borrower device (<b>201</b>) services access to the borrowed memory (<b>204</b>) via access to a portion of physical memory (<b>211</b>) of the borrower device (<b>201</b>).</p><p id="p-0126" num="0125"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a method to service a page of borrowed memory according to one embodiment. For example, the method of <figref idref="DRAWINGS">FIG. <b>8</b></figref> can be implemented in the system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, with a borrower-lender configuration illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, and/or a borrower-lender memory hierarchy illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. For example, the method of <figref idref="DRAWINGS">FIG. <b>8</b></figref> can be used to implement the block <b>311</b> of the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0127" num="0126">At block <b>331</b>, a borrower device (<b>201</b>) reserves a page of physical memory (<b>211</b>) of the borrower device (<b>201</b>) for borrowed memory page (<b>204</b>).</p><p id="p-0128" num="0127">At block <b>333</b>, a processor of the borrower device (<b>201</b>) accesses a virtual memory address (<b>255</b>) that corresponds to a memory page (<b>260</b>) in the borrowed memory (<b>204</b>). A borrowed memory page (<b>204</b>) can be physically in the loaned memory (<b>202</b>) of a lender device (<b>203</b>).</p><p id="p-0129" num="0128">At block <b>335</b>, the memory management unit (MMU) (<b>216</b>) of the borrower device (<b>201</b>) determines that there is no page table entry available in a translation lookaside buffer (TLB) (<b>251</b>) to translate the virtual memory address (<b>255</b>) to local physical memory address. Such a determination (e.g., TLB miss) causes the borrower device (<b>201</b>) to run its operating system (<b>213</b>) to search for page table entry in the memory map.</p><p id="p-0130" num="0129">At block <b>337</b>, the operating system (<b>213</b>) running on the borrower device (<b>201</b>) identifies a page table entry in the memory map that translates the virtual memory address of the page to the borrowed memory address of the page.</p><p id="p-0131" num="0130">At block <b>339</b>, the operating system (<b>213</b>) running on the borrower device (<b>201</b>) communicates with the lender device and migrates the physical content of the borrowed page with borrowed memory address to the local memory and places that content at available physical address of the local memory. Borrowed page eviction of a different borrowed page from borrower device to lender device may need to be performed when there is not enough local memory for the page migration of the borrowed page from lender device to borrower device.</p><p id="p-0132" num="0131">At block <b>341</b>, the operating system (<b>213</b>) running on the borrower device (<b>201</b>) generates a page table entry mapping virtual addresses (e.g., <b>255</b>) of the borrowed page to the physical addresses (<b>257</b>) in the local memory.</p><p id="p-0133" num="0132">At block <b>343</b>, the operating system (<b>213</b>) running on the borrower device (<b>201</b>) loads the page table entry into the translation lookaside buffer (TLB) (<b>251</b>), which allows the processor to continue accessing the virtual memory address (<b>255</b>) using the translated physical memory address (<b>257</b>).</p><p id="p-0134" num="0133">In some situations, the computer network connection (<b>205</b>) between the borrower device (<b>201</b>) and the lender device (<b>203</b>) have a limited and/or degrading communication bandwidth. The borrower device (<b>201</b>) can throttle the network traffic/bandwidth allocated to different memory regions based on the criticality of the memory regions.</p><p id="p-0135" num="0134">For example, pages of borrowed memory (<b>204</b>) can be tagged with criticality indicators based on the category of the content stored in the memory, the priority ranks of applications using the borrowed memory, and/or the data criticality levels suggested by the applications. When the connectivity bandwidth between the borrower device (<b>201</b>) and the lender device (<b>203</b>) degrades, the least critical pages can be configured to be less accessible, by allocating less communication bandwidth for fetching, retiring, eviction, and/or migration of such pages. Access to the least critical pages can be slowed and/or temporarily cut off, in view of the degradation in the connectivity bandwidth between the borrower device (<b>201</b>) and the lender device (<b>203</b>).</p><p id="p-0136" num="0135">The operation of cessation memory can be prepared via quiescing or suspending an application that attempts a demand load from that memory. The application may not make forward progress during that time. It is possible to perform a graceful degradation when an application is cut off from accessing borrowed memory. An application can be made aware that a load or store operation could result in being suspended; and a vastly different programming paradigm can be used. For example, each memory access can be wrapped in a try-catch exception wrapper. However, such an approach has significant cost. Further, the application can be handled to gracefully handling such exception. For example, the application can hold some context open, and manage that context, relating to the aborted load/store operation, informing the data movement infrastructure whether that load/store still needs to be serviced eventually.</p><p id="p-0137" num="0136">When the borrowed memory pages are throttled according to criticality, applications running on the borrowed memory (<b>204</b>) can still gracefully degrade without catastrophic failure, and proceed with reduced functionality with less reachable/usable content.</p><p id="p-0138" num="0137">For example, a media library can prioritize its content based on usage frequency, usage history, and/or predicted usage. The priority can be used in the determination of the criticality of the borrowed memory pages in which the contents are stored. Thus, access to the less critical contents in the borrowed memory can be restricted and/or cut off with reduced impact on the usability of the media library.</p><p id="p-0139" num="0138"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows a borrower device (<b>201</b>) having memory regions of different criticality levels (or priority levels) based on which network traffics for memory as a service can be throttled. For example, the borrower device (<b>201</b>) can be implemented in a way illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref> and/or can borrow memory in a hierarchy illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, or in a system illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0140" num="0139">In <figref idref="DRAWINGS">FIG. <b>9</b></figref>, the memory regions (<b>295</b>, <b>297</b>, . . . , <b>299</b>) in the borrowed memory (<b>204</b>) can be labeled with criticality levels (<b>401</b>, <b>403</b>, . . . , <b>405</b>) respectively. The criticality levels (<b>401</b>, <b>403</b>, . . . , <b>405</b>) rank the relative priorities among the memory regions (<b>295</b>, <b>297</b>, . . . <b>299</b>). Network bandwidth used for the communications between the borrower device (<b>201</b>) and its lender device(s) (e.g., <b>203</b>) can be allocated according to the criticality levels (<b>401</b>, <b>403</b>, . . . , <b>405</b>).</p><p id="p-0141" num="0140">For example, when multiple regions (e.g., <b>295</b>, <b>297</b>) need to be migrated from the lender device (<b>203</b>) to the borrower device (<b>201</b>), the regions (e.g., <b>295</b>, <b>297</b>) can be migrated in an order according to their criticality levels (e.g., <b>401</b>, <b>403</b>). In such an arrangement, repeated requests to memory regions of high criticality levels may indefinitely delay the access to memory regions of low criticality.</p><p id="p-0142" num="0141">Alternatively, the bandwidth may be shared among the multiple regions (e.g., <b>295</b>, <b>297</b>) of different criticality levels. For example, the amounts of data communications over the network connection (<b>205</b>) allowed for different regions within a given time period can be allocated according to a ratio determined based on the criticality levels of the memory regions. Thus, fetching the content of a memory page of a low criticality level will take a longer time than fetching the content of a memory page of a high criticality level. However, the fetching of the low criticality page is not going to be completely blocked by the fetching of the high criticality page. Further, the ratio can be adjusted based on the overall available bandwidth such that the performance of accessing a high criticality page can degrade less severely than the low criticality page when the overall available bandwidth degrades. Thus, the user experience with the applications running in the borrower device can be optimized via selectively degrading the access speeds of less critical aspects.</p><p id="p-0143" num="0142">In <figref idref="DRAWINGS">FIG. <b>9</b></figref>, the contents in the memory regions (e.g., <b>291</b>, . . . , <b>293</b>) in the local memory (<b>211</b>) can also be labeled with criticality levels (e.g., <b>407</b>, . . . , <b>409</b>). The criticality levels (e.g., <b>407</b>, . . . , <b>409</b>) can be used to arrange predictive eviction or migration of less critical contents to the borrowed memory (<b>204</b>) in anticipation of significant degradation in overall available bandwidth.</p><p id="p-0144" num="0143">For example, in a particular model of bandwidth sharing at sub-page granularity, a link level bandwidth management capability or a forced chunking on the link can be used. Such an implementation may be lead to potentially inefficient non-throttle scenarios. Alternatively, when the granularity of management is the page (instead of sub-page), the rate of pages fetched may be slow, not the actual time it takes for a single page to be fetched. With certain implementations, fetching the content of a memory page of a low criticality level can take a longer time than fetching the content of a memory page of high criticality level. In other implementations, the duration of time taken to fetch a low criticality page can substantially stay constant but the rate at which groups of low criticality pages can be fetched can slow relative to groups of high criticality pages.</p><p id="p-0145" num="0144">For example, in some instances, a borrower device (<b>201</b>) borrows memory from several lender devices (e.g., <b>103</b>, <b>105</b>, and/or <b>107</b>). For example, the borrower device (<b>201</b>) can instruct one lender (e.g., <b>105</b> or <b>107</b>) to transfer or copy a memory page loaned to the borrower device (<b>201</b>) to another lender (e.g., <b>103</b> or <b>105</b>) directly. Alternatively, the borrower device (<b>201</b>) can migrate the memory page from one lender (e.g., <b>105</b> or <b>107</b>) to the local memory, and then evict the page to another lender (e.g., <b>103</b> or <b>105</b>).</p><p id="p-0146" num="0145"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates tagging criticality levels (or priority levels) of memory regions in a memory map according to one embodiment. For example, the memory map of <figref idref="DRAWINGS">FIG. <b>10</b></figref> can be used to implement the criticality labeling in <figref idref="DRAWINGS">FIG. <b>9</b></figref>.</p><p id="p-0147" num="0146">In <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the virtual memory address regions (<b>261</b>, <b>263</b>, <b>265</b>, . . . ) can be mapped to physical address regions (<b>281</b>, <b>283</b>) and borrowed memory address regions (<b>273</b>, <b>275</b>, . . . ), in a way similar to that in <figref idref="DRAWINGS">FIG. <b>3</b>, <b>4</b></figref>, or <b>5</b>. For example, the memory map (<b>207</b>) can be specified in the form of page tables.</p><p id="p-0148" num="0147">Further, for each of the virtual address regions (<b>261</b>, <b>263</b>, <b>265</b>, . . . ), the memory map (<b>207</b>) can include a criticality level (e.g., <b>411</b>, <b>413</b>, or <b>415</b>). The criticality level (e.g., <b>411</b>, <b>413</b>, or <b>415</b>) can be used to determine the share of bandwidth the virtual address region (e.g., <b>261</b>, <b>263</b>, or <b>265</b>) can use to communicate data between the borrower device (<b>201</b>) and the lender device (<b>203</b>).</p><p id="p-0149" num="0148"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates a method to identify the criticality level/priority level of a memory region according to one embodiment. For example, the method of <figref idref="DRAWINGS">FIG. <b>11</b></figref> can be used to determine any of the criticality levels (e.g., <b>401</b> to <b>415</b>) in <figref idref="DRAWINGS">FIGS. <b>9</b> and <b>10</b></figref>.</p><p id="p-0150" num="0149">In <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the criticality level (<b>421</b>) of the content of a memory region can be determined based on the content category (<b>431</b>), the priority (<b>433</b>) of the application (e.g., <b>212</b>) in control of the content, and/or the priority requested by the application (e.g., <b>212</b>) for the content.</p><p id="p-0151" num="0150">Different content categories can have predetermined weights. When an application allocates a memory page for storing data, the application can identify the content category (<b>431</b>) of the memory page, such as application state, historical/log data, media, sensor data, etc. The operating system (<b>213</b>) can assign predetermined weights for the criticality based on the content category (<b>431</b>).</p><p id="p-0152" num="0151">Different applications can have predetermined weights for their criticality. A user of a user device may value the experience with one application (<b>212</b>) more than the experience with another application and thus customize the weight assignments to different applications. In some instances, different applications may have inter-dependency. Thus, an application that provides important services to other applications can be assigned a higher priority (<b>433</b>).</p><p id="p-0153" num="0152">Different subsets of data of a same application and of a same content category (<b>431</b>) may have different priorities (<b>435</b>). When the application (<b>212</b>) is programmed to request a customized priority (<b>435</b>), the application (<b>212</b>) can make improved predictions (e.g., <b>439</b>) based on information that may not be available to the operating system (<b>213</b>). When the application (<b>212</b>) does not request a customized priority (<b>435</b>), the operating system (<b>213</b>) can track the memory usage of the application (<b>212</b>) and request usage-based priority (<b>435</b>) for the content.</p><p id="p-0154" num="0153">A predetermined function can be used to combine the content category (<b>431</b>), the application priority (<b>433</b>), . . . , and/or the requested priority (<b>435</b>) to generate the criticality level (<b>421</b>). For example, weights can be calculated for the content category (<b>431</b>), the application priority (<b>433</b>), . . . , the requested priority (<b>435</b>) and summed up to obtain a total weight as the criticality level (<b>421</b>). For example, the priorities (<b>433</b>, . . . , <b>435</b>) can be summed to generate a weight that is applied to increase or decrease the weight of content category (<b>431</b>) through multiplication.</p><p id="p-0155" num="0154"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows a method to throttle network communications for memory as a service according to one embodiment. For example, the method of <figref idref="DRAWINGS">FIG. <b>12</b></figref> can be implemented in the borrower device (<b>201</b>) illustrated in <figref idref="DRAWINGS">FIG. <b>2</b>, <b>6</b></figref>, or <b>9</b>. For example, the method of <figref idref="DRAWINGS">FIG. <b>12</b></figref> can be implemented as the device A (<b>101</b>), the device B (<b>103</b>), or the server P (<b>105</b>) of <figref idref="DRAWINGS">FIG. <b>1</b></figref> in borrowing memory.</p><p id="p-0156" num="0155">At block <b>451</b>, a communication connection (e.g., <b>205</b>) is established between a borrower device (<b>201</b>) and a lender device (<b>203</b>). For example, the connection (<b>205</b>) can be over the networks and/or internet (<b>109</b>) illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0157" num="0156">At block <b>453</b>, the borrower device (<b>201</b>) communicates with the lender device (<b>203</b>) to obtain permission for the borrower device (<b>201</b>) to use an amount of memory (<b>202</b>) loaned by the lender device (<b>203</b>) for access by the borrower device (<b>201</b>) over the communication connection (<b>205</b>).</p><p id="p-0158" num="0157">At block <b>455</b>, the operating system of the borrower device (<b>201</b>) allocates virtual memory to applications (e.g., <b>212</b>) running in the borrower device (<b>201</b>).</p><p id="p-0159" num="0158">At block <b>457</b>, the operating system of the borrower device (<b>201</b>) configures the virtual memory to be hosted at least in part on the amount of memory (<b>202</b>) loaned by the lender device (<b>203</b>) to the borrower device (<b>201</b>).</p><p id="p-0160" num="0159">At block <b>459</b>, the borrower device (<b>201</b>) determines criticality levels (e.g., <b>401</b> to <b>415</b>) of contents in memory regions (e.g., <b>291</b> to <b>299</b>, <b>261</b> to <b>265</b>, <b>273</b> to <b>275</b>, and <b>281</b> to <b>283</b>) used by the applications (e.g., <b>212</b>).</p><p id="p-0161" num="0160">At block <b>461</b>, the borrower device (<b>201</b>) allocates network bandwidth of the communication connection (<b>205</b>), based on the criticality levels, to data communications used by the memory regions in accessing the amount of memory (<b>202</b>) loaned by the lender device (<b>203</b>) over the communication connection (<b>205</b>) to the borrower device (<b>201</b>).</p><p id="p-0162" num="0161">The memory loaned by the lender device (<b>203</b>) can be in part borrowed by the lender device (<b>203</b>) from another device (e.g., <b>245</b>).</p><p id="p-0163" num="0162">The criticality levels (e.g., <b>401</b> to <b>415</b>, <b>421</b>) can be identified based at least in part on categories (<b>431</b>) of the contents, priorities (<b>433</b>) of the applications (e.g., <b>212</b>) controlling the contents, or priorities (<b>435</b>) requested for the contents by the applications (e.g., <b>212</b>), or any combination thereof.</p><p id="p-0164" num="0163">For example, the applications (e.g., <b>212</b>) can request the priorities (<b>435</b>) for the contents stored in the memory regions based on usage histories of the contents, predicted usages (e.g., <b>439</b>) of the contents in a subsequent period of time, or usage frequencies (e.g., <b>437</b>) of the contents, or any combination thereof. In some instances, the operating system (<b>213</b>) can collect the usage histories, determine predicted usages (e.g., <b>439</b>) and/or usage frequency (e.g., <b>437</b>), and/or calculate the requested priority (<b>435</b>) on behalf of an application (e.g., <b>212</b>).</p><p id="p-0165" num="0164">To allocate the network bandwidth, the operating system (<b>213</b>) of the borrower device (<b>201</b>) or the communication device (<b>217</b>) of the borrower device (<b>201</b>), can throttle/control the amounts of data communications used in a period of time for the memory regions over the communication connection in accessing the amount of memory (<b>202</b>), loaned by the lender device (<b>203</b>) to the borrower device (<b>201</b>), according to a ratio corresponding to the criticality levels of the contents in the memory regions. Thus, during the period of time, the communications used for the memory regions can be seen as being allowed according to the ratio; and the average speeds of the data communications for the different memory regions can be controlled to be proportional to the ratio.</p><p id="p-0166" num="0165">In some instances, the borrower device (<b>201</b>) can predict the degradation in the network bandwidth of the communication connection in a subsequent period of time. In response, the operating system (<b>213</b>) can adjust hosting of virtual memory between local memory (<b>211</b>) of the borrower device and the amount of memory (<b>202</b>) loaned by the lender device (<b>203</b>) to the borrower device (<b>201</b>), according to the criticality levels of contents in the memory regions.</p><p id="p-0167" num="0166">For example, the operating system (<b>213</b>) of the borrower device (<b>201</b>) can identify a first memory region having a criticality level lower than a second memory region. The operating system (<b>213</b>) can reconfigure the hosting of virtual memory such that a virtual memory region associated with the first memory region is migrated from being hosted or cached in the local memory (<b>211</b>) to being hosted in the amount of memory (<b>202</b>) loaned by the lender device (<b>203</b>) to the borrower device (<b>201</b>); and a virtual memory region associated with the second memory region can be migrated from being hosted in the amount of memory (<b>202</b>) loaned by the lender device (<b>203</b>) to the borrower device (<b>201</b>) to being hosted or cached in the local memory (<b>211</b>) of the borrower device (<b>201</b>).</p><p id="p-0168" num="0167">In some embodiments, the memory management units (MMU) of computing devices are configured to accelerate the access to borrowed memory over a network connection.</p><p id="p-0169" num="0168">For example, a memory management unit (MMU) (<b>216</b>) of a borrower device (<b>201</b>) can be configured not only to access the local random access memory (<b>211</b>) of the borrower device (<b>201</b>) over a memory bus, but also to use a communication device (<b>217</b>) to access borrowed memory (<b>204</b>) that is hosted in the loaned memory (<b>202</b>) of a lender device (<b>203</b>) over a network connection (<b>205</b>). The memory management units (MMU) (<b>216</b>) can access the loaned memory (<b>202</b>) in the lender device (<b>203</b>) using the communication device (<b>217</b>) in accordance with a physical address (<b>257</b>) translated from a virtual address (<b>255</b>) by the memory management units (MMU) (<b>216</b>), without a need to cause the processor(s) (<b>215</b>) of the borrower device (<b>201</b>) to execute instructions of its operating system (<b>213</b>).</p><p id="p-0170" num="0169">For example, some routine operations performed by an operating system (<b>213</b>) in accessing the loaned memory (<b>202</b>) can be implemented in the memory management unit (MMU) (<b>216</b>), such that the routine operations can be performed without the processor(s) (<b>215</b>) executing instructions in their execution units. Such MMU implementation/support can improve the efficiency of the processor(s) (<b>215</b>) in accessing borrowed memory (<b>204</b>) that is physically in the loaned memory (<b>202</b>) of the lender devices (<b>203</b>).</p><p id="p-0171" num="0170">In general, an operating system (<b>213</b>) can be programmed to handle more situations than what the memory management unit (MMU) (<b>216</b>) can handle. For example, when communications to access the loaned memory (<b>202</b>) over a network connection (<b>205</b>) encounter exceptional conditions that are beyond processing capability of the memory management unit (MMU) (<b>216</b>), the operating system (<b>213</b>) can be executed to handle such situations.</p><p id="p-0172" num="0171"><figref idref="DRAWINGS">FIGS. <b>13</b>-<b>15</b></figref> illustrate hardware accelerated configurations to access borrowed memory according to some embodiments. For example, the techniques of <figref idref="DRAWINGS">FIGS. <b>13</b>-<b>15</b></figref> can be implemented in the system of <figref idref="DRAWINGS">FIG. <b>1</b> or <b>6</b></figref>, with the memory service techniques of <figref idref="DRAWINGS">FIG. <b>2</b></figref> and the memory mapping techniques of <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0173" num="0172">In <figref idref="DRAWINGS">FIG. <b>13</b></figref>, the memory management unit (MMU) (<b>216</b>) of the borrower device (<b>201</b>) is configured to have a connection to the local random access memory (<b>211</b>) and a connection to the communication device (<b>217</b>) of the borrower device (<b>201</b>). In some instances, the communication device (<b>217</b>) is part of the memory management unit (MMU) (<b>216</b>).</p><p id="p-0174" num="0173">A virtual to physical memory map (<b>253</b>) cached in the translation lookaside buffer (TLB) (<b>251</b>) contains information to translate a virtual address (<b>255</b>) to a physical address (<b>257</b>).</p><p id="p-0175" num="0174">When an instruction is executed in the execution units (<b>215</b>) of the borrower device (<b>201</b>), a virtual address (<b>255</b>) stored in one of the registers (<b>501</b>) and/or generated by the execution units can be used to load an instruction, retrieve an operand, and/or store a computation result. In such a situation, the borrower device (<b>201</b>) accesses the virtual memory identified by the virtual address (<b>255</b>).</p><p id="p-0176" num="0175">When the virtual memory identified by the virtual address (<b>255</b>) is hosted in a memory page (<b>259</b>) in the local memory (<b>211</b>), the physical address (<b>257</b>) is configured to be sufficient for the memory management unit (<b>216</b>) to address the memory page (<b>259</b>) for a memory operation (e.g., read or write).</p><p id="p-0177" num="0176">When the virtual memory identified by the virtual address (<b>255</b>) is hosted in a memory page (<b>260</b>) in the loaned memory (<b>202</b>) that is physically inside the lender device (<b>203</b>), the physical address (<b>257</b>) is configured to include sufficient information for the communication device (<b>217</b>) to transmit the access request to the lender device (<b>203</b>) over the computer network connection (<b>205</b>).</p><p id="p-0178" num="0177">For example, when the virtual memory identified by the virtual address (<b>255</b>) is hosted in a memory page (<b>260</b>) in the loaned memory (<b>202</b>), the physical address (<b>257</b>) can include a network address of the lender device (<b>203</b>) and a virtual memory address in a virtual memory space serviced by the operating system of the lender device (<b>203</b>). The memory management unit (MMU) (<b>216</b>) requests the communication device (<b>217</b>) to transmit an access request to the lender device (<b>203</b>) using the network address; and the access request includes the virtual address that identifies the memory page (<b>260</b>) in the lender device (<b>203</b>).</p><p id="p-0179" num="0178">When the communication device (<b>237</b>) receives the access request, the communication device (<b>237</b>) can be configured to instruct the memory management unit (MMU) (<b>236</b>) to access the memory page (<b>260</b>) identified by the virtual address included in the access request from the borrower device (<b>201</b>), in a way similar to the processor(s) (<b>235</b>) instructing the memory management unit (MMU) (<b>236</b>) to access a virtual address. In some instances, the communication device (<b>237</b>) is part of the memory management unit (MMU) (<b>236</b>).</p><p id="p-0180" num="0179">For example, when the virtual address is translated into a physical address of the memory page (<b>260</b>) using a virtual to physical memory map of the lender device (<b>203</b>), the memory management unit (MMU) (<b>236</b>) performs the address translation and uses the physical memory address to access the memory page (<b>260</b>). When the virtual to physical memory map for the translation of the virtual address is not already in the memory management unit (MMU) (<b>236</b>) of the lender device (<b>203</b>), the operating system (<b>233</b>) of the lender device (<b>203</b>) can be executed to load a relevant portion of the virtual to physical memory map into the memory management unit (MMU) (<b>236</b>) of the lender device (<b>203</b>) such that the memory management unit (MMU) (<b>236</b>) can perform the address translation to access the memory page (<b>260</b>).</p><p id="p-0181" num="0180">In some instances, the lender device (<b>203</b>) can host the virtual address used by the borrower device (<b>201</b>) in the storage device (<b>232</b>). In response to a failure/page fault in the memory management unit (MMU) (<b>236</b>) to translate the virtual address, the memory management unit (MMU) (<b>236</b>) causes the processor(s) (<b>235</b>) to execute the operating system (<b>233</b>), which loads the data content from the storage device (<b>232</b>) into the loaned memory (<b>202</b>), updates the translation lookaside buffer (TLB) of the memory management unit (MMU) (<b>236</b>) to facilitate the access. Alternatively, the operating system (<b>233</b>) may service the access request directly from the storage device, without caching or buffering or re-hosting it in the local memory (<b>231</b>) of the lender device (<b>203</b>).</p><p id="p-0182" num="0181">In some instances, the lender device (<b>203</b>) can host the virtual address used by the borrower device (<b>201</b>) in another lender device (e.g., <b>245</b>). In such a situation, the lender device (<b>203</b>) can access its lender (e.g., <b>245</b>) in a way similar to the borrower device (<b>201</b>) accessing the lender device (<b>203</b>).</p><p id="p-0183" num="0182">Optionally, when the virtual address (<b>255</b>) being accessed in the one of the execution units (<b>215</b>) of the borrower device (<b>201</b>) is translated into the physical address (<b>257</b>) for access via the communication device (<b>217</b>), the communication device (<b>217</b>) can migrate a virtual address region from the lender device (<b>203</b>) into the buffer (<b>505</b>) of the communication device (<b>217</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>14</b></figref>.</p><p id="p-0184" num="0183">For example, when a virtual address (<b>255</b>) in a page of virtual memory is being accessed, the communication device (<b>217</b>) can migrate the entire page (or a portion of it) into the buffer (<b>505</b>) of the communication device (<b>217</b>) in anticipation of further accesses to the page.</p><p id="p-0185" num="0184">Alternatively, the memory management unit (MMU) (<b>216</b>) of the borrower device (<b>201</b>) can be configured to reserve a portion of the local random access memory (<b>211</b>) as a buffer for caching a portion of the loaned memory (<b>202</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>15</b></figref>.</p><p id="p-0186" num="0185">Optionally, the memory management unit (MMU) (<b>216</b>) of the borrower device (<b>201</b>) can be further configured to manage the adjustment of hosting of virtual memory regions identified in the virtual to physical memory map (<b>253</b>) in a way similar to that illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0187" num="0186">For example, when the memory management unit (MMU) (<b>216</b>) determines that a virtual region hosted in the loaned memory (<b>202</b>) of the lender device (<b>203</b>) is accessed more frequently and/or recently than a virtual region hosted in the local memory (<b>211</b>), the memory management unit (MMU) (<b>216</b>) can use the communication device (<b>217</b>) to migrate the more frequently and/or recently accessed virtual region into being hosted in the local memory (<b>211</b>) and evict the less frequently and/or recently accessed virtual region into being hosted in the loaned memory (<b>202</b>). Thus, the memory management unit (MMU) (<b>216</b>) can optimize the hosting of virtual memory regions identified in the virtual to physical memory map (<b>253</b>) cached in the translation lookaside buffer (TLB) (<b>251</b>) and update the virtual to physical memory map (<b>253</b>) cached in the translation lookaside buffer (TLB) (<b>251</b>) according to the adjustments. The operating system (<b>213</b>) of the borrower device (<b>201</b>) can be used to further adjust hosting of other virtual memory regions.</p><p id="p-0188" num="0187"><figref idref="DRAWINGS">FIGS. <b>16</b> and <b>17</b></figref> illustrate hardware accelerated configurations to provide access to loaned memory according to some embodiments. For example, the configuration of the lender device (<b>203</b>) illustrated in <figref idref="DRAWINGS">FIG. <b>13</b>, <b>14</b> or <b>15</b></figref> can be replaced with the configuration of <figref idref="DRAWINGS">FIG. <b>16</b> or <b>17</b></figref>.</p><p id="p-0189" num="0188">In <figref idref="DRAWINGS">FIG. <b>16</b></figref>, the lender device (<b>203</b>) has a peripheral bus (<b>511</b>) and a memory bus (<b>513</b>).</p><p id="p-0190" num="0189">A communication device (<b>237</b>) and a storage device (<b>232</b>) of the lender device (<b>203</b>) are connected to the processor(s) (<b>235</b>) of the lender device (<b>203</b>) via the peripheral bus (<b>511</b>). Local random access memory (<b>231</b>) of the lender device (<b>203</b>) is connected to the processor(s) via the memory bus (<b>513</b>).</p><p id="p-0191" num="0190">The operating system (<b>233</b>) can be initially stored in the storage device (<b>232</b>) and subsequently loaded into the random access memory (<b>231</b>) for execution.</p><p id="p-0192" num="0191">When the communication device (<b>237</b>) receives a memory access request (<b>507</b>) that identifies a virtual memory address (<b>509</b>) allocated by the operating system (<b>233</b>) for the borrowed memory (<b>204</b>) used by the borrower device (<b>201</b>), the communication device (<b>237</b>) is configured to request the processor (<b>235</b>) to process according to the memory access request (<b>507</b>).</p><p id="p-0193" num="0192">At the time of the communication device (<b>237</b>) receiving the access request (<b>507</b>), the operating system (<b>233</b>) running in the lender device (<b>203</b>) may host the virtual address (<b>509</b>) in the storage device (<b>232</b>) or in the random access memory (<b>231</b>) (e.g., via the configuration of the memory map (<b>227</b>)).</p><p id="p-0194" num="0193">If the virtual address (<b>509</b>) is hosted in the memory (<b>231</b>) and the memory management unit (MMU) (<b>236</b>) has a cached portion of the memory map (<b>227</b>) to translate the virtual address (<b>509</b>), the processor(s) (<b>235</b>) can process the access request (<b>507</b>) by accessing a physical address of the memory page (<b>260</b>) determined from the cached portion of the memory map (<b>227</b>).</p><p id="p-0195" num="0194">If the virtual address (<b>509</b>) is hosted in the memory (<b>231</b>) and the memory management unit (MMU) (<b>236</b>) does not have a cached portion of the memory map (<b>227</b>) to translate the virtual address (<b>509</b>), the processor(s) (<b>235</b>) can execute the operating system (<b>233</b>) to update the cached portion of the memory map (<b>227</b>) such that the memory management unit (MMU) (<b>236</b>) can translate the virtual address (<b>509</b>) into the physical address of the memory page (<b>260</b>).</p><p id="p-0196" num="0195">If the virtual address (<b>509</b>) is hosted in the storage device (<b>232</b>), such as a hard drive or a solid state drive, the memory management unit (MMU) (<b>236</b>) does not have a cached portion of the memory map (<b>227</b>) to translate the virtual address (<b>509</b>) (e.g., by generating a page fault). In response, the memory management unit (MMU) (<b>236</b>) causes the processor(s) (<b>235</b>) to execute the operating system (<b>233</b>), which can be configured to implement the access request (<b>507</b>) through accessing the storage device (<b>232</b>) and/or migrate a virtual memory region (e.g., a virtual memory page) into the random access memory (<b>231</b>).</p><p id="p-0197" num="0196">If the virtual address (<b>509</b>) is hosted in another lender device (e.g., <b>245</b>), the lender device (<b>203</b>) translates the virtual address (<b>509</b>) into a physical address that identifies a network address of its lender device (e.g., <b>245</b>) and a virtual address assigned by its lender device (e.g., <b>245</b>) (which can be optionally configured to be the same as the virtual address (<b>509</b>) in a unified address space). Then, the lender device (<b>203</b>) can access its lender device (e.g., <b>245</b>) in a way similar to the borrower device (<b>201</b>) accessing the lender device (<b>203</b>).</p><p id="p-0198" num="0197">The access request (<b>507</b>) can be configured in a form corresponding to the memory access requested during the instruction execution in the processor(s) (<b>215</b>) of the borrower device (<b>201</b>). For example, when a processor (<b>215</b>) of the borrower device (<b>201</b>) requests the loading of the instruction from a virtual address (<b>255</b>), the access request (<b>507</b>) is configured to request the retrieval of an instruction from the virtual address (<b>509</b>) (which can be optionally configured to be the same as the virtual address (<b>255</b>) in a unified address space).</p><p id="p-0199" num="0198">For example, when a processor (<b>215</b>) of the borrower device (<b>201</b>) requests the loading of an operand from a virtual address (<b>255</b>), the access request (<b>507</b>) is configured to request the retrieval of the operand from the virtual address (<b>509</b>); and when a processor (<b>215</b>) of the borrower device (<b>201</b>) requests the storing of a computation result at a virtual address (<b>255</b>), the access request (<b>507</b>) is configured to request the retrieval of the operand from the virtual address (<b>509</b>).</p><p id="p-0200" num="0199">Optionally, the access request (<b>507</b>) can be configured to implement migration of virtual address regions. For example, when the virtual address (<b>509</b>) is accessed, the communication device (<b>237</b>) is configured to automatically facilitate the migration of a virtual memory region between the lender device (<b>203</b>) and the borrower device (<b>201</b>).</p><p id="p-0201" num="0200">Optionally, the communication device (<b>237</b>) is implemented as part of the memory management unit (MMU) (<b>236</b>) of the lender device (<b>203</b>).</p><p id="p-0202" num="0201">Optionally, the memory management unit (MMU) (<b>236</b>) is configured to include a network controller (<b>523</b>) to operate the communication device (<b>237</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>17</b></figref>.</p><p id="p-0203" num="0202">In <figref idref="DRAWINGS">FIG. <b>17</b></figref>, the memory management unit (MMU) (<b>236</b>) has a memory controller (<b>521</b>) configured to access the memory page (<b>260</b>) using a physical address for the memory (<b>231</b>). Further, the memory management unit (MMU) (<b>236</b>) has a network controller (<b>523</b>) configured to process network based memory access requests (e.g., <b>507</b>). Such a network based memory access request (<b>507</b>) can be a request from its borrower device (e.g., <b>201</b>), or its lender device (e.g., <b>245</b>).</p><p id="p-0204" num="0203"><figref idref="DRAWINGS">FIG. <b>18</b></figref> shows a method to accelerate access to borrowed memory via a memory management unit according to one embodiment. For example, the method of <figref idref="DRAWINGS">FIG. <b>18</b></figref> can be implemented in a device A (<b>101</b>) or device B (<b>103</b>), or a server P (<b>105</b>) illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. For example, the method of <figref idref="DRAWINGS">FIG. <b>18</b></figref> can be implemented in a borrower device (<b>201</b>) illustrated in <figref idref="DRAWINGS">FIG. <b>2</b>, <b>6</b>, <b>9</b>, <b>13</b>, <b>14</b> or <b>15</b></figref>. For example, the method of <figref idref="DRAWINGS">FIG. <b>18</b></figref> can be implemented in a memory management unit (<b>216</b>) or a memory management unit (<b>236</b>) illustrated in <figref idref="DRAWINGS">FIGS. <b>2</b>, <b>3</b></figref>, or <b>13</b> to <b>17</b>.</p><p id="p-0205" num="0204">At block <b>531</b> in <figref idref="DRAWINGS">FIG. <b>18</b></figref>, a memory management unit (e.g., <b>216</b> or <b>236</b>) caches a virtual to physical memory map (e.g., <b>253</b>) in a translation lookaside buffer (e.g., <b>251</b>) of the memory management unit (e.g., <b>216</b> or <b>236</b>).</p><p id="p-0206" num="0205">For example, the virtual to physical memory map (e.g., <b>253</b>) can be a portion of page tables managed by the operating system (e.g., <b>213</b> or <b>233</b>) of the computing device (e.g., <b>201</b> or <b>203</b>) in which the memory management unit (e.g., <b>216</b> or <b>236</b>) is configured.</p><p id="p-0207" num="0206">At block <b>533</b>, the memory management unit (e.g., <b>216</b> or <b>236</b>) receives a request to access a virtual memory address (e.g., <b>255</b> or <b>509</b>) for the execution of an instruction in a microprocessor (e.g., <b>215</b> or <b>235</b>).</p><p id="p-0208" num="0207">For example, the virtual memory address (<b>255</b>) can be stored in the registers (<b>501</b>) for the execution of the instruction in the processor (<b>215</b>). The virtual memory address (<b>255</b>) can be used to load the instruction from virtual memory address (<b>255</b>), to load an operand of the instruction from the virtual memory address (<b>255</b>), or to store a computing result generated by the execution units (<b>503</b>) after the execution of the instruction.</p><p id="p-0209" num="0208">In some instances, the virtual memory address (<b>509</b>) is received in a communication device (<b>237</b>) in a memory access request from a network connection to a borrower device (e.g., <b>201</b>); and the communication device (<b>237</b>) is configured to request the memory management unit (<b>236</b>) to process the access request (<b>507</b>).</p><p id="p-0210" num="0209">At block <b>535</b>, the memory management unit (e.g., <b>216</b> or <b>236</b>) translates the virtual memory address (e.g., <b>255</b>) into a physical memory address (e.g., <b>257</b>) using the virtual to physical memory map (e.g., <b>253</b>) cached in the translation lookaside buffer (e.g., <b>251</b>).</p><p id="p-0211" num="0210">At block <b>537</b>, it is determined whether or not the physical memory address (e.g., <b>257</b>) is for local memory (e.g., <b>211</b> or <b>231</b>).</p><p id="p-0212" num="0211">For example, the memory management unit (e.g., <b>216</b> or <b>236</b>) can have connections to both a memory bus (e.g., <b>511</b>) via a memory controller (e.g., <b>521</b>) and a computer network (e.g., <b>109</b>) via a network controller (<b>523</b>).</p><p id="p-0213" num="0212">At block <b>539</b>, if the physical memory address (e.g., <b>257</b>) is determined (<b>537</b>) to be for the local memory (e.g., <b>211</b> or <b>231</b>) (e.g., of a first memory type), the memory management unit (e.g., <b>216</b> or <b>236</b>) instructs a memory controller (<b>521</b>) connected to a memory bus (<b>513</b>) to access a memory page (<b>259</b>) at the physical address (<b>257</b>).</p><p id="p-0214" num="0213">At block <b>541</b>, if the physical memory address (e.g., <b>257</b>) is determined (<b>537</b>) not to be for the local memory (e.g., <b>211</b> or <b>231</b>) (e.g., of a second memory type), the memory management unit (e.g., <b>216</b> or <b>236</b>) instructs a network controller (<b>523</b>) connected to a computer network connection (<b>205</b>) to access a memory page (<b>260</b>) according to the physical address (<b>257</b>).</p><p id="p-0215" num="0214">A memory management unit (MMU) (<b>216</b> or <b>236</b>) configured to perform the method of <figref idref="DRAWINGS">FIG. <b>18</b></figref> can be used in a microprocessor (<b>215</b> or <b>235</b>) of a borrower device (<b>201</b>) or a lender device (<b>203</b>) that borrows memory for another device (e.g., <b>245</b>).</p><p id="p-0216" num="0215">A communication device (e.g., <b>201</b> or <b>203</b>) having such a memory management unit (MMU) (<b>216</b> or <b>236</b>) can have a memory bus coupled to local random access memory (e.g., <b>211</b> or <b>231</b>), and at least one microprocessor (e.g., <b>215</b> or <b>235</b>). The microprocessor (e.g., <b>215</b>) can further have registers (e.g., <b>501</b>), and execution units (e.g., <b>503</b>).</p><p id="p-0217" num="0216">The computing device (e.g., <b>201</b> or <b>203</b>) has an operating system (e.g., <b>213</b> or <b>233</b>), including instructions, which when executed by the at least one microprocessor (e.g., <b>215</b> or <b>235</b>), cause the computing device to borrow an amount of memory from a lender device (e.g., <b>203</b> or <b>245</b>) over a network connection (<b>205</b>) using a communication device (e.g., <b>217</b> or <b>237</b>).</p><p id="p-0218" num="0217">The execution units (<b>503</b>) are configured to execute instructions using at least virtual memory addresses mapped to the amount of memory borrowed from the lender device (e.g., <b>203</b> or <b>245</b>).</p><p id="p-0219" num="0218">For example, after retrieving a first virtual memory address (<b>255</b>) from the registers (<b>501</b>) for the execution of an instruction in the execution units (<b>503</b>), the memory management unit (MMU) (<b>216</b>) translates the first virtual memory address (<b>255</b>) into a first physical address (<b>257</b>) that identifies the lender device (e.g., <b>203</b> or <b>245</b>) over the network connection (<b>205</b>) and a second virtual memory address (<b>509</b>). The memory management unit (MMU) (<b>216</b>) instructs the communication device (<b>217</b>) to access, using the second virtual memory address, the memory (<b>260</b>) loaned by the lender device (<b>203</b>) to the computing device (<b>201</b>) over the network connection (<b>205</b>).</p><p id="p-0220" num="0219">For example, the first physical address (<b>257</b>) can include a computer network address of the lender device (<b>203</b>).</p><p id="p-0221" num="0220">The execution of the instruction in the execution units (<b>503</b>) can generate a memory operation to read or write at the first virtual memory address (<b>255</b>); and the memory management unit (<b>216</b>) is configured to generate a request (<b>507</b>) for the memory operation at the second virtual memory address (<b>509</b>) and instruct the communication device (<b>217</b>) to transmit the request (<b>507</b>) to the lender device (<b>203</b>) over the communication connection (<b>205</b>).</p><p id="p-0222" num="0221">Operationally, the second virtual memory address (<b>509</b>) can be equal to the first virtual memory address (<b>255</b>) such that the lender device (<b>203</b>) and the borrower device (<b>201</b>) can use a unified virtual address space. For example, the operating system can be configured to receive the identification of the amount of borrowed memory (<b>204</b>) based on virtual memory addresses specified by the lender device (<b>203</b>) in the unified virtual address space; and the operating system can be configured to allocate virtual memory to applications directly from the virtual memory addresses in the unified virtual address space.</p><p id="p-0223" num="0222">Optionally, the memory management unit (<b>216</b>) includes a buffer (<b>505</b>); and the memory management unit (<b>216</b>) is further configured to instruct the communication device (<b>217</b>) to communicate with the lender device (<b>203</b>) to establish a cache, in the buffer (<b>505</b>), for a portion of the amount of the memory (<b>202</b>) loaned by the lender device (<b>203</b>) to the borrower device (<b>201</b>), in response to the first virtual memory address (<b>255</b>) being received from the registers (<b>501</b>). For example, the communication device (<b>217</b>) can cache a page of memory according to a page table when the virtual address (<b>255</b>) in the page table is used.</p><p id="p-0224" num="0223">Optionally, the memory management unit (<b>216</b>) is further configured to dynamically change from memory mappings between virtual memory and physical memory. For example, virtual memory identified by a set of virtual memory addresses can be initially mapped (e.g., in the translation lookaside buffer (TLB) (<b>251</b>)) to the memory (<b>202</b>) loaned by the lender device (<b>203</b>) to the borrower device; and the mapping can be changed to re-map the virtual memory to a portion of the local random access memory (<b>211</b>).</p><p id="p-0225" num="0224">For example, the memory management unit (<b>216</b>) can swap the mapping of two virtual memory regions identified in the virtual to physical memory map (<b>253</b>) cached in the translation lookaside buffer (TLB) (<b>251</b>) such that a first virtual memory region initially mapped onto a region in the local memory (<b>211</b>) is re-mapped to a region in the loaned memory (<b>202</b>) in the lender device (<b>203</b>), and the second virtual memory region initially mapped onto the region (or another region) in the loaned memory (<b>202</b>) in the lender device (<b>203</b>) is re-mapped to the region (or another region) in the local memory (<b>211</b>).</p><p id="p-0226" num="0225">For example, the memory management unit (<b>216</b>) can be further configured to identify the first virtual memory region and the second memory region for swapping based on a memory usage history in a past period of time or a predicted memory usage in a subsequent period of time. For example, a least recently used and/or least frequently used virtual memory page can be swapped from the local memory (<b>211</b>) to the loaned memory (<b>202</b>); and a most recently used and/or most frequently used virtual memory page can be swapped to the local memory (<b>211</b>) from the loaned memory (<b>202</b>).</p><p id="p-0227" num="0226">An artificial intelligent (AI) agent can be configured on a borrower device and/or a lender device to predict the degradation of the network connectivity for memory as a service (MaaS). In response to the prediction and in a time period before the occurrence of the degradation of the network connectivity, the operating systems of the borrower device and/or the lender device can identify content that may have a need to be migrated over the network connection in the time period of the network degradation or outage, and start the content migration before the network degradation or outage such that relevant content can be accessed locally during the network degradation or outage, and such that important data can be backed up at a safe location.</p><p id="p-0228" num="0227">For example, data predicted to be used in a borrower device during the network degradation or outage can be prefetched to the borrower device based on the predicted usage and/or the criticality of the data.</p><p id="p-0229" num="0228">For example, certain data that may be lost in a borrower device and/or predicted to have a need to be backed up in the lender device during the network degradation or outage (e.g., due to power loss in the borrower device or a hazardous condition that may be experienced by the borrower device) can be copied to the lender device to minimize the potential of data loss.</p><p id="p-0230" num="0229">For example, when a phone detects that the user will be driving through a mountain area with unreliable cellular data connectivity, the AI agent running in the phone can prefetch to the local memory or storage of the borrower device maps and/or other critical data for services in the mountain area. Data predicted to be unused during the time period can be copied into, or swapped into, the memory loaned by a lender device/server to the borrower device to make room in the phone for the prefetched content.</p><p id="p-0231" num="0230">For example, a drone can be scheduled to depart for a mission-critical task; and based on the scheduled task/operation, the drone can prefetch data that will be used in that specific task/operation (e.g., feature extraction library and/or artificial neural network models to detect certain objects, such as tanks).</p><p id="p-0232" num="0231">For example, a phone or a wearable device can detect that battery is dropping below a threshold level (e.g., 50%); and in response to a predicted power outage that may occur during the time period of network degradation or outage (e.g., determined based on power usage history and/or location history/schedule), the device can push certain important data to its memory borrowed from a lender device or server to avoid data loss.</p><p id="p-0233" num="0232"><figref idref="DRAWINGS">FIGS. <b>19</b> and <b>20</b></figref> illustrate a borrower device and a lender device configured to perform intelligent content migration according to some embodiments.</p><p id="p-0234" num="0233">For example, the techniques of <figref idref="DRAWINGS">FIGS. <b>19</b>-<b>20</b></figref> can be implemented in the system of <figref idref="DRAWINGS">FIG. <b>1</b> or <b>6</b></figref>, with the memory service techniques of <figref idref="DRAWINGS">FIG. <b>2</b></figref> and the memory mapping techniques of <figref idref="DRAWINGS">FIG. <b>3</b></figref>. The content migration can be accelerated via the memory management units (<b>216</b> and <b>236</b>) discussed in connection with <figref idref="DRAWINGS">FIGS. <b>13</b>-<b>18</b></figref>.</p><p id="p-0235" num="0234">In <figref idref="DRAWINGS">FIG. <b>19</b></figref>, the borrower device (<b>201</b>) has an artificial intelligent (AI) agent (<b>571</b>) that is optionally configured as part of the operating system (<b>213</b>). The AI agent (<b>571</b>) is configured to generate content migration decisions (<b>580</b>) based on various information collected by the operating system (<b>213</b>), such as a memory usage history (<b>573</b>), a location history (<b>575</b>), scheduled operations (<b>577</b>), battery power level (<b>579</b>) (e.g., when the borrower device (<b>201</b>) is power via battery), battery usage history, etc.</p><p id="p-0236" num="0235">The AI agent (<b>571</b>) can be configured to rank the likelihood of different memory regions being used in a time period of predicted network degradation/outage, based on the information (<b>573</b>, <b>575</b>, <b>577</b>, . . . , and/or <b>579</b>) collected by the operating system (<b>213</b>). For example, an artificial neural network can be trained to generate scores ranking the likelihood of different memory regions (e.g., <b>263</b>, <b>265</b>, . . . illustrated in <figref idref="DRAWINGS">FIG. <b>10</b></figref>) being used in the network based on the timing of the information (<b>573</b>, <b>575</b>, <b>577</b>, . . . , and/or <b>579</b>).</p><p id="p-0237" num="0236">Based on the likelihood of different memory regions being used in a subsequent period of time and/or the criticality (e.g., <b>421</b> illustrated in <figref idref="DRAWINGS">FIG. <b>11</b></figref>) of the content of the memory regions, the AI agent (<b>571</b>) can generate the migration decisions (<b>580</b>) to change the physical memory regions on which virtual memory regions are hosted.</p><p id="p-0238" num="0237">For example, virtual memory regions that are likely to be used during the network degradation or outage can be migrated from being hosted on the borrowed memory (<b>204</b>) that is physically in another device (e.g., <b>103</b>, <b>105</b>, <b>107</b>) to being hosted on the local random access memory (<b>211</b>) or a local storage device (<b>232</b>) of the borrower device (<b>201</b>). For example, the local storage device (<b>232</b>) can be a flash drive/memory, a solid state drive, a hard drive, etc.</p><p id="p-0239" num="0238">For example, virtual memory regions that are not likely to be used in the borrower device (<b>201</b>) until after the network degradation or outage can be migrated in the opposite direction, from being hosted on the local random access memory (<b>211</b>) or a local storage device (<b>232</b>) of the borrower device (<b>201</b>) to being hosted on the borrowed memory (<b>204</b>) that is physically in another device (e.g., <b>103</b>, <b>105</b>, <b>107</b>, or <b>203</b>). Migration from local memory/storage to borrowed/loaned memory can also be used as a way to save or backup important data to a location (e.g., a lender device or server) that is more reliable than the borrower device (<b>201</b>) in preserving the data.</p><p id="p-0240" num="0239">The AI agent (<b>571</b>) can be configured to score virtual memory regions for migration based on not only the likelihood of the virtual memory regions being used, but also the criticality (<b>421</b>) of the virtual memory regions for the desired functionality associated with the virtual memory regions, and the performance level of the network connection during the time period of the predicted network degradation or outage. The benefit scored for migrating the virtual memory regions can be measured against the cost of proactively migrating the virtual memory regions, which can degrade the performance for the time period of prefetching/migration and/or can incur unnecessary cost when the migrated data is eventually not used. When the benefit score is higher than the cost score for migrating a virtual memory region, the AI agent (<b>571</b>) can decide to migrate the virtual memory region to one or more lender devices (e.g., <b>103</b>, <b>105</b>, <b>107</b>, or <b>203</b>).</p><p id="p-0241" num="0240">Optionally, the AI agent (<b>571</b>) can be implemented at least in part in a lender device (e.g., <b>103</b>, <b>105</b>, <b>107</b>, or <b>203</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>20</b></figref>.</p><p id="p-0242" num="0241">For example, the lender device (e.g., <b>203</b>) can include an AI agent (<b>572</b>) that monitors the usage of loaned memory (<b>202</b>) used by the borrower device (e.g., <b>201</b>). The operating system (<b>233</b>) of the lender device (e.g., <b>203</b>) can track the memory usage history (<b>573</b>) of the borrower device (<b>201</b>), the location history (<b>575</b>) of the borrower device (<b>201</b>), the scheduled operations (<b>577</b>) of the borrower device (<b>201</b>), etc. The borrower device (<b>201</b>) can provide certain information related to the status of the borrower device (<b>201</b>), such as the battery power level (<b>579</b>) of the borrower device (<b>201</b>), the current location of the borrower device (<b>201</b>), scheduled operations (<b>577</b>) of the borrower device (<b>201</b>).</p><p id="p-0243" num="0242">For example, the borrower device (<b>201</b>) can share information (e.g., <b>573</b> to <b>579</b>) about its operations by storing the information (e.g., <b>573</b> to <b>579</b>) in the borrowed memory (<b>204</b>) that is loaned by the lender device (<b>203</b>) to the borrower device (<b>201</b>). Thus, the lender device (<b>203</b>) and the borrower device (<b>201</b>) can share the information (e.g., <b>573</b> to <b>579</b>) through memory as a service (MaaS).</p><p id="p-0244" num="0243">Further, the AI agent(s) (<b>571</b> and/or <b>572</b>) can be configured to run in the loaned memory (<b>202</b>)/borrowed memory (<b>204</b>). Thus, the lender device (<b>203</b>) and the borrower device (<b>201</b>) can run the AI agent(s) (<b>571</b> and/or <b>572</b>) in a collaborative way.</p><p id="p-0245" num="0244">For example, the borrower device (<b>201</b>) can execute the AI agent (<b>571</b>) to provide and/or update information about the borrower device (<b>201</b>), such as the location history (<b>575</b>) and the battery power level (<b>579</b>), and then request the lender device (<b>201</b>) to execute the AI agent (<b>571</b>/<b>572</b>) to make migration decisions (<b>580</b>).</p><p id="p-0246" num="0245">For example, the borrower device (<b>201</b>) can allocate a virtual memory region for running the AI agent (<b>571</b>). The virtual memory region can be initially hosted (or cached) in the local memory (<b>211</b>) of the borrower device (<b>201</b>) to provide and/or update the information (e.g., <b>573</b>, <b>575</b>, <b>577</b>, . . . , and/or <b>579</b>), which can also be stored in the virtual memory region. Subsequently, the borrower device (<b>201</b>) can migrate the virtual memory region to the borrowed memory (<b>204</b>); and the content of the virtual memory region is stored in the loaned memory (<b>202</b>) of the lender device (<b>203</b>). The lender device (<b>203</b>) can continue the execution of the AI agent (<b>571</b>) (e.g., as the AI agent (<b>572</b>)) to make the migration decisions (<b>580</b>). The borrower device (<b>201</b>) may further run the AI agent (<b>571</b>) to provide additional information and/or update status for future migration decisions (<b>580</b>). Thus, the borrower device (<b>201</b>) can provide the data used by the AI agent (<b>571</b>/<b>572</b>); and the lender device (<b>203</b>) can provide the computing power to process the data.</p><p id="p-0247" num="0246">In some embodiments, the computing devices (e.g., <b>201</b> and <b>203</b>, or <b>101</b> to <b>107</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>) are configured with memory as a service that allow the migration of the hosting of a virtual memory region freely between/among the computing devices. When the virtual memory region is hosted on one of the devices, the device currently hosting the virtual memory region functions as a lender providing its memory resources to the other computing device(s) for the virtual memory region. When the hosting of the virtual memory region is migrated to another device, that device functions as a lender providing its memory resources to the other computing device(s) for the virtual memory region. A given computing device can function as a lender for a set of virtual memory regions and a borrower for another set of virtual memory regions; and the role of the computing device as a borrower or a lender can change dynamically from time to time for a specific virtual memory region. A computing device having large local memory resources can host more virtual memory regions than other computing device(s). The computing devices can share their local memory resources via memory as a service (MaaS). When the network connection (e.g., <b>205</b>) is available, the virtual memory regions can migrate freely from one device to another device (e.g., in a system illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>).</p><p id="p-0248" num="0247"><figref idref="DRAWINGS">FIGS. <b>21</b>-<b>24</b></figref> illustrate content movements according to some embodiments.</p><p id="p-0249" num="0248"><figref idref="DRAWINGS">FIG. <b>21</b></figref> illustrates a borrower device (<b>201</b>) borrowing the memory resources of the lender device (<b>203</b>) for a virtual address region (<b>581</b>). The borrower device (<b>201</b>) stores a memory map (<b>207</b>) that associates the virtual address region (<b>581</b>) with the lender device identifier (<b>583</b>).</p><p id="p-0250" num="0249">For example, the lender device identifier (<b>583</b>) can be an internet protocol (IP) address of the lender device, a host name of the lender device (<b>203</b>), a uniform resource locator (URL) of the lender device (<b>203</b>), a universally unique identifier (UUID), etc.</p><p id="p-0251" num="0250">Based on the lender device identifier (<b>583</b>), the borrower device (<b>201</b>) can access the physical memory region (<b>586</b>) in the lender device (<b>203</b>). For example, the memory management unit (MMU) <b>216</b> of the borrower device (<b>201</b>), or the operating system (<b>213</b>) of the borrower device (<b>201</b>) running in the processor(s) (<b>215</b>) of the borrower device (<b>201</b>), can generate a memory access request (<b>507</b>) illustrated in <figref idref="DRAWINGS">FIG. <b>17</b></figref>. The request (<b>507</b>) to store data in, or load data from, a virtual address (<b>509</b>) in the virtual address region (<b>581</b>) is transmitted over the network connection (<b>205</b>) in accordance with the lender device identifier (<b>583</b>). The lender device (<b>201</b>) receiving the request (<b>507</b>) can store data in, or load data from, a memory page (e.g., <b>260</b> illustrated in <figref idref="DRAWINGS">FIG. <b>17</b></figref>) in the memory region (<b>586</b>) identified by the memory map (<b>227</b>) maintained by the operating system (<b>233</b>) of the lender device (<b>203</b>).</p><p id="p-0252" num="0251">In <figref idref="DRAWINGS">FIG. <b>21</b></figref>, the memory map (<b>227</b>) of the lender device (<b>203</b>) associates the virtual address region (<b>581</b>) with the lender device identifier (<b>583</b>), which indicates that the virtual address region (<b>581</b>) is hosted in the lender device (<b>203</b>). The memory map (<b>227</b>) of the lender device (<b>203</b>) maps the virtual address region (<b>581</b>) to a physical address region (<b>586</b>), which allows the memory management unit (MMU) <b>236</b> of the lender device (<b>203</b>) to translate a virtual address (<b>509</b>) in the virtual address region (<b>581</b>) into a physical address in the physical address region (<b>585</b>). The physical address region (<b>585</b>) can identify a memory region (<b>586</b>) in the local memory (<b>593</b> or <b>231</b>) of the lender device (<b>203</b>). The physical address in the physical address region (<b>585</b>) can be used to access a memory page (<b>260</b>) in the memory region (<b>586</b>).</p><p id="p-0253" num="0252"><figref idref="DRAWINGS">FIG. <b>22</b></figref> illustrates the result of migrating the hosting of the virtual address region from the lender device (<b>203</b>) to the borrower device (<b>201</b>). After copying the content from the memory region (<b>586</b>) in the local memory (<b>593</b> or <b>231</b>) of the lender device (<b>203</b>) to a memory region (<b>588</b>) in the local memory (<b>591</b> or <b>211</b>) of the borrower device (<b>201</b>), the borrower device (<b>201</b>) can update its memory map (<b>207</b>) to associate the virtual address region (<b>581</b>) with the borrower device identifier (<b>582</b>), which indicates that the virtual address region (<b>581</b>) is hosted in the borrower device (<b>201</b>). Further, the memory map (<b>207</b>) maps the virtual address region (<b>581</b>) into a physical address region (<b>587</b>). Thus, a virtual address (<b>255</b>) in the virtual address region (<b>581</b>) can be translated into a physical address (<b>257</b>) in the physical address region (<b>587</b>) (e.g., as illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>).</p><p id="p-0254" num="0253">In <figref idref="DRAWINGS">FIG. <b>22</b></figref>, the lender device (<b>203</b>) updates its memory map (<b>227</b>) to associate the borrower device identifier (<b>582</b>), which indicates that the virtual address region (<b>581</b>) is hosted in the borrower device (<b>201</b>). Further, the virtual address region (<b>581</b>) is no longer mapped to a physical address region (<b>585</b>) of the memory region (<b>586</b>). Thus, the memory region (<b>586</b>) previously used to host the virtual address region (<b>581</b>) can be freed and can be used to host another virtual address region.</p><p id="p-0255" num="0254">The configuration of <figref idref="DRAWINGS">FIG. <b>22</b></figref> reflects the borrowing of the memory region (<b>588</b>) by the lender device (<b>203</b>) for the virtual address region (<b>581</b>). When the lender device (<b>203</b>) accesses a virtual address in the virtual address region (<b>581</b>), the lender device (<b>203</b>) can access the memory (<b>588</b>) loaned by the borrower device (<b>201</b>) to the lender device (<b>203</b>), in a way similar to the borrower device (<b>201</b>) accessing the memory (<b>586</b>) loaned by the lender device (<b>203</b>) to the borrower device (<b>201</b>) with the configuration of <figref idref="DRAWINGS">FIG. <b>21</b></figref>. Thus, the lender/borrower roles can be reversed through migrating the hosting of the virtual address region (<b>581</b>); and a given device can have different lender/borrower roles with respect to different virtual address regions that are hosted in location memory of different devices.</p><p id="p-0256" num="0255"><figref idref="DRAWINGS">FIG. <b>23</b></figref> illustrates a configuration where the virtual address region (<b>581</b>) is associated with the borrower device identifier (<b>582</b>) and thus hosted in the memory region (<b>588</b>) in the local memory (<b>591</b> or <b>211</b>) of the borrower device (<b>201</b>). However, the memory map (<b>227</b>) of the lender device (<b>203</b>) further associates the virtual address region (<b>581</b>) with the physical address region (<b>585</b>) of the memory region (<b>586</b>) in the local memory (<b>593</b> or <b>231</b>) of the lender device (<b>203</b>). Thus, the content in the memory region (<b>586</b>) of the lender device (<b>203</b>) can be used as a backup copy, a cache copy, or a mirror copy, of the content in the memory region (<b>588</b>) in the borrower device (<b>201</b>), in which the virtual address region (<b>581</b>) is officially hosted.</p><p id="p-0257" num="0256">Similarly, <figref idref="DRAWINGS">FIG. <b>24</b></figref> illustrates a configuration where the virtual address region (<b>581</b>) is associated with the lender device identifier (<b>583</b>) and thus hosted in the memory region (<b>586</b>) in the local memory (<b>593</b> or <b>231</b>) of the lender device (<b>203</b>). However, the memory map (<b>207</b>) of the borrower device (<b>201</b>) further associates the virtual address region (<b>581</b>) with the physical address region (<b>587</b>) of the memory region (<b>588</b>) in the local memory (<b>591</b> or <b>211</b>) of the borrower device (<b>201</b>). Thus, the content in the memory region (<b>588</b>) of the borrower device (<b>203</b>) can be used as a backup copy, a cache copy, or a mirror copy, of the content in the memory region (<b>586</b>) in the lender device (<b>203</b>), in which the virtual address region (<b>581</b>) is officially hosted.</p><p id="p-0258" num="0257">Optionally, the devices (<b>201</b> and <b>203</b>) can also be configured to host, backup, cache, or mirror the contents in a local storage device (e.g., <b>232</b>).</p><p id="p-0259" num="0258">Using the techniques of <figref idref="DRAWINGS">FIGS. <b>21</b>-<b>24</b></figref>, contents of a virtual address region (<b>581</b>) can be migrated, mirrored, backed up, or cached in different devices (e.g., <b>201</b> and <b>203</b>) according to the migration decisions (<b>580</b>).</p><p id="p-0260" num="0259"><figref idref="DRAWINGS">FIG. <b>25</b></figref> shows a method to migrate content in a computing system having borrowed memory according to some embodiments.</p><p id="p-0261" num="0260">For example, the method of <figref idref="DRAWINGS">FIG. <b>25</b></figref> can be implemented in a computing system illustrated in <figref idref="DRAWINGS">FIG. <b>1</b>, <b>2</b>, <b>13</b>, <b>14</b>, <b>21</b>, <b>22</b>, <b>23</b></figref>, or <b>24</b>.</p><p id="p-0262" num="0261">At block <b>601</b>, a first computing device (e.g., <b>201</b>) and a second computing device (e.g., <b>203</b>) are connected via a computer network (e.g., <b>109</b>).</p><p id="p-0263" num="0262">At block <b>603</b>, the first and second computing devices (e.g., <b>201</b> and <b>203</b>) provision memory resources for access through virtual memory addresses across the computer network (e.g., <b>109</b>).</p><p id="p-0264" num="0263">For example, the first computing device (e.g., <b>201</b>) can borrow memory from the second computing device (e.g., <b>203</b>) (e.g., as illustrated in <figref idref="DRAWINGS">FIG. <b>21</b> or <b>24</b></figref>); and the second computing device (e.g., <b>203</b>) can borrow memory from the first computing device (e.g., <b>201</b>) (e.g., as illustrated in <figref idref="DRAWINGS">FIG. <b>22</b> or <b>23</b></figref>).</p><p id="p-0265" num="0264">At block <b>605</b>, the first and second computing devices (e.g., <b>201</b> and <b>203</b>) map a first portion (e.g., <b>263</b>) of the virtual memory addresses into the first computing device (<b>201</b>) (e.g., region <b>283</b>, memory <b>211</b>, unit <b>259</b> illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>) and a second portion of the virtual memory addresses (e.g., <b>265</b>) into the second computing device (<b>203</b>) (e.g., region <b>275</b>, memory <b>202</b>, unit <b>260</b> illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>).</p><p id="p-0266" num="0265">At block <b>607</b>, the first and second computing devices (e.g., <b>201</b> and <b>203</b>) predict a time period during which the network connection (e.g., <b>205</b>) between the first and second computing devices (e.g., <b>201</b> and <b>203</b>) degrades.</p><p id="p-0267" num="0266">At block <b>609</b>, the first and second computing devices (e.g., <b>201</b> and <b>203</b>) make a migration decision (<b>580</b>) for content of a first virtual memory address region (<b>581</b>) based on the prediction of the time period.</p><p id="p-0268" num="0267">At block <b>611</b>, the first and second computing devices (e.g., <b>201</b> and <b>203</b>) communicate the content of the virtual memory address region (<b>581</b>) between the first and second computing devices (e.g., <b>201</b> and <b>203</b>), prior to the time period and in response to the migration decision.</p><p id="p-0269" num="0268">For example, an AI agent (<b>571</b>/<b>572</b>) configured in the first and second computing devices (e.g., <b>201</b> and <b>203</b>) can make the migration decision (<b>580</b>) based on a memory usage history (<b>573</b>), a location history (<b>575</b>), scheduled operations (<b>577</b>), a battery power level (<b>579</b>), a battery usage history, etc.</p><p id="p-0270" num="0269">For example, the AI agent (<b>571</b>/<b>572</b>) can predict a usage of the virtual memory address region (<b>581</b>); and the usage is predicted to occur in the first computing device (e.g., <b>201</b>) during the time period of network degradation. When the virtual memory address region (<b>581</b>) is currently being mapped to the local memory (or storage) (<b>593</b>) of the second computing device (<b>203</b>), a migration decision (<b>580</b>) can be made to make the content available in the local memory (or storage) (<b>591</b>) such that the content is accessible even when the network connection (<b>205</b>) is not available during the predicted time period of network degradation.</p><p id="p-0271" num="0270">In another example, the AI agent (<b>571</b>/<b>572</b>) can predict that the content of a virtual memory address region (<b>581</b>) may be lost during the time period (e.g., due to the lack of battery power, or a hazardous condition). When the virtual memory address region (<b>581</b>) is currently being mapped to the local memory (or storage) (<b>591</b>) of the first computing device (<b>201</b>), a migration decision (<b>580</b>) can be made to make the content available in the local memory (or storage) (<b>593</b>) such that the content is preserved even when the network connection (<b>205</b>) is not available during the predicted time period to back up the content.</p><p id="p-0272" num="0271">In response to the migration decision (<b>580</b>) and after storing the migrated content of the virtual address region (<b>581</b>) into the local memory (or storage) (<b>591</b>) of the first computing device (e.g., <b>201</b>), the memory mapping of the virtual memory address region (<b>581</b>) can be changed by mapping the virtual memory address region (<b>581</b>) into the local memory (or storage) (<b>591</b>) of the first computing device (e.g., <b>201</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>22</b> or <b>23</b></figref>.</p><p id="p-0273" num="0272">Similarly, in response to the migration decision (<b>580</b>) and after storing the migrated content of the virtual address region (<b>581</b>) into the local memory (or storage) (<b>593</b>) of the second computing device (e.g., <b>203</b>), the memory mapping of the virtual memory address region (<b>581</b>) can be changed by mapping the virtual memory address region (<b>581</b>) into the local memory (or storage) (<b>593</b>) of the second computing device (e.g., <b>203</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>21</b> or <b>24</b></figref>.</p><p id="p-0274" num="0273">When the virtual memory address region (<b>581</b>) is mapped onto the local memory (or storage) (<b>591</b>) of the first computing device (<b>201</b>), the virtual memory address region (<b>581</b>) is associated in a memory map (<b>227</b>) of the second computing device (<b>203</b>) with an identifier (<b>582</b>) of the first computing device (<b>201</b>), as illustrated in <figref idref="DRAWINGS">FIGS. <b>22</b> and <b>23</b></figref>; and when the virtual memory address region (<b>581</b>) is mapped onto the local memory (or storage) (<b>593</b>) of the second computing device (<b>203</b>), the virtual memory address region (<b>581</b>) is associated in a memory map (<b>207</b>) of the first computing device (<b>201</b>) with an identifier (<b>583</b>) of the second computing device (<b>203</b>), as illustrated in <figref idref="DRAWINGS">FIGS. <b>21</b> and <b>24</b></figref>.</p><p id="p-0275" num="0274">Optionally, the virtual memory address region (<b>581</b>) is mapped into the local memory (or storage) (<b>591</b>) of the first computing device (<b>201</b>), the virtual memory address region (<b>581</b>) is further associated in the memory map (<b>207</b>) of the first computing device (<b>201</b>) with the identifier (<b>582</b>) of the first computing device (<b>201</b>), as illustrated in <figref idref="DRAWINGS">FIGS. <b>22</b> and <b>23</b></figref>; and when the virtual memory address region (<b>581</b>) is mapped onto the local memory (or storage) (<b>593</b>) of the second computing device (<b>203</b>), the virtual memory address region (<b>581</b>) is further associated in the memory map (<b>227</b>) of the second computing device (<b>203</b>) with the identifier (<b>583</b>) of the second computing device (<b>203</b>), as illustrated in <figref idref="DRAWINGS">FIGS. <b>21</b> and <b>24</b></figref>.</p><p id="p-0276" num="0275">When the virtual memory address region (<b>581</b>) is mapped onto the local memory (or storage) (<b>591</b>) of the first computing device (<b>201</b>), the memory map (<b>207</b>) of the first computing device (<b>201</b>) maps the virtual memory address region (<b>581</b>) to a physical memory address region (<b>587</b>/<b>588</b>) in the local memory (or storage) (<b>591</b>) of the first computing device (<b>201</b>), as illustrated in <figref idref="DRAWINGS">FIGS. <b>22</b> and <b>23</b></figref>; and when the virtual memory address region (<b>581</b>) is mapped onto the local memory (or storage) (<b>593</b>) of the second computing device (<b>203</b>), the memory map (<b>227</b>) of the second computing device (<b>203</b>) maps the virtual memory address region (<b>581</b>) to a physical memory address region (<b>585</b>/<b>586</b>) in the local memory (or storage) (<b>593</b>) of the second computing device (<b>203</b>), as illustrated in <figref idref="DRAWINGS">FIGS. <b>21</b> and <b>24</b></figref>. The content migration is performed by copying the content between the physical memory address region (<b>587</b>/<b>588</b>) of the first computing device (<b>201</b>) and the physical memory address region (<b>585</b>/<b>586</b>) of the second computing device (<b>203</b>).</p><p id="p-0277" num="0276">Optionally, after the virtual memory address region (<b>581</b>) is mapped onto the local memory (or storage) (<b>591</b>) of the first computing device (<b>201</b>), the second computing device (<b>203</b>) can configure the physical memory address region (<b>585</b>/<b>586</b>) in the second computing device (<b>203</b>) to store a cache, mirror, or backup copy of the content of the virtual memory address region (<b>581</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>23</b></figref>.</p><p id="p-0278" num="0277">Similarly, after the virtual memory address region (<b>581</b>) is mapped onto the local memory (or storage) (<b>593</b>) of the second computing device (<b>203</b>), the first computing device (<b>201</b>) can configure the physical memory address region (<b>587</b>/<b>588</b>) in the first computing device (<b>201</b>) to store a cache, mirror, or backup copy of the content of the virtual memory address region (<b>581</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>24</b></figref>.</p><p id="p-0279" num="0278">The migration decision (<b>580</b>) can be made based on a predicted location of the first computing device, a scheduled operation of the first computing device (<b>201</b>), an identification of the software/data to be used for the scheduled operation, a predicted operation of the first computing device (<b>201</b>) identified from repeated operations in the past, a battery usage history of the first computing device, etc.</p><p id="p-0280" num="0279">For example, the migration decision (<b>580</b>) can be made based at least in part on an artificial neural network stored in a portion of virtual memory addresses. The AI agent (<b>571</b>) running in the first computing device (<b>201</b>) can use the portion of the virtual memory addresses to provide data for the artificial neural network; and the AI agent (<b>572</b>) running in the second computing device (<b>201</b>) can use the portion of the virtual memory addresses to perform computation for the migration decision (<b>580</b>).</p><p id="p-0281" num="0280">Memory as a service (MaaS) supports a memory centric computing model. For example, MaaS allows the hosting of virtual memory to flow among networked computers. As a result, the content of the virtual memory can flow seamlessly among the processors of the computers. Therefore, the computers in the network can contribute computing resources, data, and/or computing results through sharing memory resources.</p><p id="p-0282" num="0281">For example, a thin client can borrow memory from an appliance or server. By loaning the memory to the client, the processor(s) of the appliance or server can readily access the content in the memory borrowed by the client and perform computation on behalf of the client in response to a request for the client.</p><p id="p-0283" num="0282">For example, the client can set up the computation in the borrowed memory and request the appliance or server to take over further computations. The borrowed memory can store the data and/or code for processing the data; and the appliance or server can operate on the data and/or execute the code, as if the computation were initially set up on the appliance or server. For example, the client can set up the computing task to provide data specific to the client; and the appliance or server can perform a processing intensive portion of the task for the client.</p><p id="p-0284" num="0283">For example, the client can initially host a virtual memory region in the local memory of the client. Subsequently, the client may re-host the virtual memory region in the memory loaned by the appliance or server to the client. The client can request the appliance or server to continue execution of a routine or a set of instructions in the virtual memory region; and the appliance or server can optionally take control of the memory loaned to the client and execute the routine or instructions that can further process the data in the memory loaned to the client. After the completion of the request, the appliance or server can provide a notification to the client, causing the client to retrieve the computation results of the appliance or server and/or continue execution of routines or instructions in the virtual memory region. In some instances, an application is configured to run from the virtual memory region; and the execution of the application can be performed on the client at some stages and transferred to the appliance or server at other stages. Thus, the client and the appliance or server can share computation resources via sharing memory.</p><p id="p-0285" num="0284">Similarly, an appliance or server can set up a task in memory, lend the memory to a client (e.g., an edge computing device), request the client to perform local computing on data of the client, and obtain the result back in the memory.</p><p id="p-0286" num="0285">Further, the appliance or server can set up the tasks in multiple memory regions that are loaned to multiple clients. The clients can provide inputs to the appliance or server by running the tasks in their respective borrowed memory regions. Thus, memory as a service (MaaS) can enable new memory centric computing models.</p><p id="p-0287" num="0286"><figref idref="DRAWINGS">FIGS. <b>26</b> and <b>27</b></figref> illustrate distributed computing based on selectively hosting a virtual address region on local memory of different computers, such as a device (<b>621</b>) and an appliance/server (<b>623</b>).</p><p id="p-0288" num="0287">In general, the device (<b>621</b>) can be a device (<b>101</b> or <b>103</b>) or server (<b>105</b>) in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, or a borrower device (<b>201</b>) in <figref idref="DRAWINGS">FIGS. <b>2</b>, <b>6</b>, <b>9</b>, <b>13</b>-<b>15</b>, <b>19</b></figref>, and/or <b>21</b>-<b>24</b>.</p><p id="p-0289" num="0288">In general, the appliance/server (<b>623</b>) can be a device (<b>103</b>) or server (<b>105</b> or <b>107</b>) in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, or a lender device (<b>203</b>) in <figref idref="DRAWINGS">FIGS. <b>2</b>, <b>6</b>, <b>13</b>-<b>17</b>, <b>20</b></figref>, and/or <b>21</b>-<b>24</b>.</p><p id="p-0290" num="0289">In <figref idref="DRAWINGS">FIG. <b>26</b></figref>, the device (<b>621</b>) allocates a virtual address region (<b>581</b>) for an application (<b>212</b>). The virtual address region (<b>581</b>) can be hosted in the local memory (<b>211</b>) of the device (<b>621</b>) for a time period in which the application (<b>212</b>) is being executed in the device (<b>621</b>).</p><p id="p-0291" num="0290">For example, the virtual memory address region (<b>581</b>) is associated with the device identifier A (<b>582</b>) of the device (<b>621</b>) in both the memory map (<b>207</b>) of the device (<b>621</b>) and the memory map (<b>227</b>) of the appliance/server (<b>623</b>). The memory map (<b>207</b>) of the device (<b>621</b>) further associates the virtual memory address region (<b>581</b>) with a physical address region (<b>587</b>). Thus, the memory map (<b>207</b>) can be used by the processor(s) (<b>215</b>) running the application (<b>212</b>) to translate virtual addresses in the virtual address region (<b>581</b>) into corresponding physical addresses in the physical address region (<b>587</b>). The physical addresses can be used to access memory pages in the memory region (<b>588</b>) in the local memory (<b>211</b>) of the device (<b>621</b>).</p><p id="p-0292" num="0291">For example, the application (<b>212</b>) running in the device (<b>621</b>) can use the virtual address region (<b>581</b>) to read data (<b>625</b>) in the memory region (<b>588</b>), operate on the data (<b>625</b>), and/or store the data (<b>625</b>) in the memory region (<b>588</b>).</p><p id="p-0293" num="0292">The virtual address region (<b>581</b>) can be re-hosted in the local memory (<b>231</b>) of the appliance/server (<b>623</b>), as illustrated in <figref idref="DRAWINGS">FIG. <b>27</b></figref>. After transmitting the content of the memory region (<b>588</b>) in the local memory (<b>211</b>) to the appliance/server (<b>623</b>) and storing the content in the memory region (<b>586</b>) in the local memory (<b>231</b>) of the appliance/server (<b>623</b>), the virtual address region (<b>581</b>) is associated with the device identifier B (<b>583</b>) of the appliance/server (<b>623</b>) in both the memory map (<b>227</b>) of the device (<b>623</b>) and the memory map (<b>227</b>) of the appliance/server (<b>623</b>). Further, the memory map (<b>227</b>) of the device (<b>621</b>) associates the virtual memory address region (<b>581</b>) with a physical address region (<b>585</b>). Thus, the memory map (<b>207</b>) can be used by the processor(s) (<b>235</b>) of the appliance/server (<b>623</b>) running a corresponding application (<b>234</b>) to translate virtual addresses in the virtual address region (<b>581</b>) into corresponding physical addresses in the physical address region (<b>585</b>). The physical addresses can be used to access memory pages in the memory region (<b>586</b>) in the local memory (<b>231</b>) of the appliance/server (<b>623</b>).</p><p id="p-0294" num="0293">For example, the application (<b>234</b>) running in the appliance/server (<b>623</b>) can use the virtual address region (<b>581</b>) to read data (<b>625</b>) in the memory region (<b>586</b>), operate on the data (<b>625</b>), and/or store the data (<b>625</b>) in the memory region (<b>586</b>).</p><p id="p-0295" num="0294">The application (<b>212</b>) in the device (<b>621</b>) and the application (<b>234</b>) in the appliance/server (<b>623</b>) can be configured to use the same virtual address region (<b>581</b>) to share data, processing resource, and/or computation results.</p><p id="p-0296" num="0295">In some instances, when the virtual address region (<b>581</b>) is re-hosted in the local memory (<b>231</b>) of the appliance/server (<b>623</b>), the device (<b>621</b>) can keep the memory region (<b>588</b>) for the virtual address region (<b>581</b>) as a backup, mirror, or cache copy of the content in the local memory (<b>231</b>) of the appliance/server (<b>623</b>). Optionally, the application (<b>212</b>) in the device (<b>621</b>) and the application (<b>234</b>) in the appliance/server (<b>623</b>) can run concurrently in the memory regions (<b>588</b> and <b>586</b>); and the applications (<b>212</b> and <b>234</b>) can communicate with each other with inter-process calls to coordinate processing tasks and data synchronization.</p><p id="p-0297" num="0296">Optionally, applications (<b>212</b> and <b>234</b>) are a set of instructions executed as different processes in the device (<b>621</b>) and the appliance/server (<b>623</b>).</p><p id="p-0298" num="0297"><figref idref="DRAWINGS">FIGS. <b>28</b> and <b>29</b></figref> illustrate selectively running an application (<b>627</b>) on different computers at different stages of the execution of the application (<b>627</b>). In <figref idref="DRAWINGS">FIGS. <b>28</b> and <b>29</b></figref>, the application (<b>627</b>) (or a portion of it) is configured to reside in the virtual address region (<b>581</b>). The processor(s) (<b>215</b>) can load the application (<b>627</b>) from the virtual address region (<b>581</b>) for execution and for reading, processing, and/or storing data (<b>625</b>).</p><p id="p-0299" num="0298">When the virtual address region (<b>581</b>) is hosted or cached in the local memory (<b>211</b>) of the device (<b>621</b>), the device (<b>621</b>) can execute the application (<b>627</b>). When the virtual address region (<b>581</b>) is hosted or cached in the local memory (<b>231</b>) of the appliance/server (<b>623</b>), the appliance/server (<b>623</b>) can execute the application (<b>627</b>).</p><p id="p-0300" num="0299">Thus, the device (<b>621</b>) and the appliance/server (<b>623</b>) can coordinate with each other to run different stages of the execution of the application (<b>627</b>). For example, the device (<b>621</b>) can run the application (<b>627</b>) to set up data (<b>625</b>) for further processing (e.g., for a computational and/or resource intensive tasks). The appliance/server (<b>623</b>) can continue the execution of the application (<b>627</b>) for the further processing. After the further processing by the appliance/server (<b>623</b>), the device (<b>621</b>) can continue running the application (<b>627</b>) to use the computation results provided by the appliance/server (<b>623</b>).</p><p id="p-0301" num="0300">In general, multiple virtual address regions (e.g., <b>581</b>) can be used for the application (<b>627</b>) and its data (<b>625</b>). Some of the virtual address regions (e.g., <b>581</b>) can be hosted on the device (<b>621</b>); and the other virtual address regions (e.g., <b>581</b>) can be hosted on the appliance/server (<b>623</b>) (and/or another device).</p><p id="p-0302" num="0301"><figref idref="DRAWINGS">FIGS. <b>30</b> and <b>31</b></figref> illustrate running an application (<b>627</b>) in virtual machines (<b>629</b>) hosted on different computers (<b>621</b> and <b>623</b>).</p><p id="p-0303" num="0302">For example, the processor(s) (<b>215</b>) of the device (<b>621</b>) and the processor(s) (<b>235</b>) of the appliance/server (<b>623</b>) can have different instruction sets. Thus, instructions of an application (<b>627</b>) may not be compatible for execution in both the processor(s) (<b>215</b>) of the device (<b>621</b>) and the processor(s) (<b>235</b>) of the appliance/server (<b>623</b>).</p><p id="p-0304" num="0303">In <figref idref="DRAWINGS">FIGS. <b>30</b> and <b>31</b></figref>, the device (<b>621</b>) runs a virtual machine (<b>629</b>). The application (<b>627</b>) is configured to run within the virtual machine (<b>629</b>) that is compatible with the virtual machine (<b>629</b>) hosted in the appliance/server (<b>623</b>). Thus, when the virtual address region (<b>581</b>) is re-hosted on the appliance/server (<b>623</b>) (e.g., as illustrated in <figref idref="DRAWINGS">FIG. <b>31</b></figref>), the application (<b>627</b>) in the virtual address region (<b>581</b>) is executable in the virtual machine (<b>629</b>).</p><p id="p-0305" num="0304">In some instances, the virtual machine (<b>629</b>) in the appliance/server (<b>623</b>) emulates the device (<b>621</b>). Thus, the application (<b>627</b>) can be executed in the device (<b>621</b>) in a native mode without a virtual machine; and the appliance/server (<b>623</b>) can continue the execution of the application (<b>627</b>) once the virtual address region (<b>581</b>) is re-hosted, or cached, or mirrored on the appliance/server (<b>623</b>).</p><p id="p-0306" num="0305">When the virtual address region (<b>581</b>) is hosted on the appliance/server (<b>623</b>), the device (<b>621</b>) can have a cached or mirrored version of the virtual address region (<b>581</b>) in its local memory (<b>211</b>). The appliance/server (<b>623</b>) can execute the application (<b>627</b>) in the virtual address region (<b>581</b>) hosted in its memory region (<b>586</b>), while the device (<b>621</b>) can concurrently execute the application in the virtual address region (<b>581</b>) cached/mirrored in its memory region (<b>588</b>). For example, the running process of the application (<b>627</b>) in the device (<b>621</b>) can fork into two running processes. One of the processes continues in the device (<b>621</b>), and the other process runs in the appliance/server (<b>623</b>). The two running processes can communicate with each other to coordinate data processing and/or data synchronization. One of the running processes can be terminated at a suitable stage, after a period of parallel execution on the device (<b>621</b>) and the appliance/server (<b>623</b>).</p><p id="p-0307" num="0306"><figref idref="DRAWINGS">FIG. <b>32</b></figref> shows a method of distributed computing based on memory as a service (MaaS).</p><p id="p-0308" num="0307">For example, the method of <figref idref="DRAWINGS">FIG. <b>32</b></figref> can be implemented using a computing device and a remote device that is connected to the computing device through a computer network. The computing device and the remote device can be the device (<b>621</b>) and the appliance/server (<b>623</b>) illustrated in <figref idref="DRAWINGS">FIGS. <b>26</b>-<b>31</b></figref>. For example, the computing device and the remote device can be the borrower device (<b>201</b>) and the lender device (<b>203</b>) illustrated in <figref idref="DRAWINGS">FIGS. <b>2</b>, <b>6</b>, <b>9</b>, <b>13</b> to <b>17</b></figref>, and/or <b>19</b>-<b>24</b>. For example, the computing device and the remote device can be some of the devices (<b>101</b>, <b>103</b>) and servers (<b>105</b>, <b>107</b>) illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0309" num="0308">At steps <b>651</b> and <b>671</b>, a computing device borrows memory from a remote device; and the remote device loans the memory to the computing device.</p><p id="p-0310" num="0309">At step <b>653</b>, the computing device allocates a virtual memory address region (e.g., <b>581</b>) to an application (e.g., <b>212</b> or <b>627</b>) running in the computing device.</p><p id="p-0311" num="0310">At step <b>655</b>, the computing device maps the virtual memory address region (e.g., <b>581</b>) into local memory (e.g., <b>211</b>) of the computing device.</p><p id="p-0312" num="0311">At step <b>657</b>, the application (e.g., <b>212</b> or <b>627</b>) running in the computing device stores data in the local memory (e.g., <b>211</b>) of the computing device according to virtual memory addresses in the virtual memory address region, which is mapped onto the local memory (e.g., <b>211</b>) of the computing device.</p><p id="p-0313" num="0312">At step <b>659</b>, the computing device transmits at least a portion of the content of the virtual memory address region (e.g., <b>581</b>) to the remote device. At step <b>673</b>, the remote device receives at least the portion of the content of the virtual memory address region (e.g., <b>581</b>) from the computing device.</p><p id="p-0314" num="0313">At steps <b>661</b> and <b>675</b>, the computing device and the remote device communicate with each other to map the virtual memory address region (e.g., <b>581</b>) into the borrowed portion of the local memory (e.g., <b>231</b>) of the remote device.</p><p id="p-0315" num="0314">At steps <b>663</b> and <b>677</b>, the computing device sends to the remote device a request to process the data in the virtual memory address region (e.g., <b>581</b>); and the remote device receives from the computing device the request to process the data in the virtual memory address region (e.g., <b>581</b>).</p><p id="p-0316" num="0315">At step <b>679</b>, the remote device runs an application (e.g., <b>234</b> or <b>627</b>) according to the request.</p><p id="p-0317" num="0316">At step <b>681</b>, the remote device allocates the virtual memory address region (e.g., <b>581</b>) to the application (e.g., <b>234</b> or <b>627</b>).</p><p id="p-0318" num="0317">At step <b>683</b>, the application (e.g., <b>234</b> or <b>627</b>) running in the remote device processes the data using the virtual memory address region (e.g., <b>581</b>) hosted in the remote device.</p><p id="p-0319" num="0318">For example, the request can be sent (<b>663</b>) from the computing device to the remote device before the termination of the application (e.g., <b>212</b> or <b>627</b>) running in the computing device. After the mapping of the virtual memory address region (e.g., <b>581</b>) into the borrowed/loaned portion of the local memory of the remote device, the computing device can keep a memory region (e.g., <b>588</b>) previously used to host the virtual memory address region (e.g., <b>581</b>) as a backup, mirror, or cache copy of the virtual memory address region (e.g., <b>581</b>) mapped to the remote device. Thus, the computing device and the remote device can run their applications (e.g., <b>212</b>, <b>234</b> or <b>627</b>) concurrently and/or in parallel on the separate copies of the content of the virtual memory address region (e.g., <b>581</b>) (e.g., stored in the memory regions (<b>588</b> and <b>586</b>) respectively in the computing device and the remote device).</p><p id="p-0320" num="0319">Optionally, the computing device and the remote device can communicate with each other to run their applications (e.g., <b>212</b>, <b>234</b> or <b>627</b>) in one of the devices at a time. For example, after the processing (<b>683</b>) performed in the remote device, the remote device can send a request to the computing device to cause the computing device to continue running the application (e.g., <b>212</b> or <b>627</b>) that uses the results of the processing (<b>683</b>) performed in the remote device.</p><p id="p-0321" num="0320">The content of the virtual memory address region (e.g., <b>581</b>) can be updated for running the applications (e.g., <b>212</b>, <b>234</b> or <b>627</b>) through synchronization and/or re-hosting the virtual memory address region (e.g., <b>581</b>). In some instances, the computing device can run the application directly on the virtual memory address region hosted on the remote device (e.g., using the memory access acceleration techniques discussed in connection with <figref idref="DRAWINGS">FIGS. <b>13</b>-<b>17</b></figref>). In some instances, the virtual memory address region (e.g., <b>581</b>) is re-hosted back in the computing device, or cached/mirrored in the computing device, for the application (e.g., <b>212</b> or <b>627</b>) running in the computing device.</p><p id="p-0322" num="0321">Optionally, the applications (e.g., <b>212</b>, <b>234</b> or <b>627</b>) running the computing device and the remote device to use the same virtual memory address region (e.g., <b>581</b>) can have the same set of instructions. Further, the set of instructions can be loaded by the computing device and/or the remote device into the virtual memory address region (e.g., <b>581</b>) for execution, as illustrated in <figref idref="DRAWINGS">FIGS. <b>28</b>-<b>31</b></figref>. For example, a program counter in a processor of the computing device can store a virtual address in the virtual memory address region (e.g., <b>581</b>); and the processor can retrieve an instruction of the application (e.g., <b>627</b>) at the virtual address for the execution of the application (e.g., <b>627</b>).</p><p id="p-0323" num="0322">In some instances, a group of devices, similar to the computing device and the remote device discussed above, can be connected via a computer network to form a system. Each of the devices in the system can be configured via its operating system to: execute an application that accesses memory using a virtual memory address region; map the virtual memory address region to the local memory for a first period of time during which the application is being executed in the respective device; map the virtual memory address region to a local memory of a remote device in the plurality of computing devices for a second period of time after starting the application in the respective device and before terminating the application in the respective device; and request the remote device to process data in the virtual memory address region during at least the second period of time. The virtual memory address region can be dynamically re-hosted on any of the devices in the group to facilitate the computation using the instructions and/or data stored in the virtual memory address region.</p><p id="p-0324" num="0323">In general, each of the devices or servers discussed above (e.g., <b>101</b>, <b>103</b>, <b>105</b>, <b>107</b>, <b>201</b>, <b>203</b>, <b>621</b>, <b>623</b>) can be implemented as one or more data processing systems.</p><p id="p-0325" num="0324">A typical data processing system may include an inter-connect (e.g., bus and system core logic), which interconnects a microprocessor(s) and memory. The microprocessor may also have on-die cache hierarchy.</p><p id="p-0326" num="0325">The inter-connect interconnects the microprocessor(s) and the memory together and also interconnects them to input/output (I/O) device(s) via I/O controller(s). I/O devices may include a display device and/or peripheral devices, such as mice, keyboards, modems, network interfaces, printers, scanners, video cameras and other devices known in the art. In one embodiment, when the data processing system is a server system, some of the I/O devices, such as printers, scanners, mice, and/or keyboards, are optional.</p><p id="p-0327" num="0326">The inter-connect can include one or more buses connected to one another through various bridges, controllers and/or adapters. In one embodiment the I/O controllers include a universal serial bus (USB) adapter for controlling USB peripherals, and/or an IEEE-1394 bus adapter for controlling IEEE-1394 peripherals.</p><p id="p-0328" num="0327">The memory may include one or more of: read only memory (ROM), volatile random access memory (RAM), and non-volatile memory, such as hard drive, flash memory, etc.</p><p id="p-0329" num="0328">Volatile RAM is typically implemented as dynamic RAM (DRAM) which requires power continually in order to refresh or maintain the data in the memory. Non-volatile memory is typically a magnetic hard drive, a magnetic optical drive, an optical drive (e.g., a DVD RAM), flash memory, 3D cross point or other type of memory system which maintains data even after power is removed from the system. The non-volatile memory may also be a random access memory.</p><p id="p-0330" num="0329">The non-volatile memory can be a local device coupled directly to the rest of the components in the data processing system. A non-volatile memory that is remote from the system, such as a network storage device coupled to the data processing system through a network interface such as a modem or ethernet interface, can also be used.</p><p id="p-0331" num="0330">In the present disclosure, some functions and operations are described as being performed by or caused by software code to simplify description. However, such expressions are also used to specify that the functions can result from execution of the code/instructions by a processor, such as a microprocessor or any IP block of SoC (System-on-a-Chip).</p><p id="p-0332" num="0331">Alternatively, or in combination, the functions and operations as described herein can be implemented using special purpose circuitry, with or without software instructions, such as using application-specific integrated circuit (ASIC) or field-programmable gate array (FPGA). Embodiments can be implemented using hardwired circuitry without software instructions, or in combination with software instructions. Thus, the techniques are limited neither to any specific combination of hardware circuitry and software, nor to any particular source for the instructions executed by the data processing system.</p><p id="p-0333" num="0332">While one embodiment can be implemented in fully functioning computers and computer systems, various embodiments are capable of being distributed as a computing product in a variety of forms and are capable of being applied regardless of the particular type of machine or computer-readable media used to actually effect the distribution.</p><p id="p-0334" num="0333">At least some aspects disclosed can be embodied, at least in part, in software. That is, the techniques may be carried out in a computer system or other data processing system in response to its processor, such as a microprocessor, executing sequences of instructions contained in a memory, such as ROM, volatile RAM, non-volatile memory, cache or a remote storage device.</p><p id="p-0335" num="0334">Routines executed to implement the embodiments may be implemented as part of an operating system or a specific application, component, program, object, module or sequence of instructions referred to as &#x201c;computer programs.&#x201d; The computer programs typically include one or more instructions set at various times in various memory and storage devices in a computer, and that, when read and executed by one or more processors in a computer, cause the computer to perform operations necessary to execute elements involving the various aspects.</p><p id="p-0336" num="0335">A machine readable medium can be used to store software and data which when executed by a data processing system causes the system to perform various methods. The executable software and data may be stored in various places including for example ROM, volatile RAM, non-volatile memory and/or cache. Portions of this software and/or data may be stored in any one of these storage devices. Further, the data and instructions can be obtained from centralized servers or peer to peer networks. Different portions of the data and instructions can be obtained from different centralized servers and/or peer to peer networks at different times and in different communication sessions or in a same communication session. The data and instructions can be obtained in entirety prior to the execution of the applications. Alternatively, portions of the data and instructions can be obtained dynamically, just in time, when needed for execution. Thus, it is not required that the data and instructions be on a machine readable medium in entirety at a particular instance of time.</p><p id="p-0337" num="0336">Examples of computer-readable media include but are not limited to non-transitory, recordable and non-recordable type media such as volatile and non-volatile memory devices, read only memory (ROM), random access memory (RAM), flash memory devices, floppy and other removable disks, magnetic disk storage media, optical storage media (e.g., compact disk read-only memory (CD ROM), digital versatile disks (DVDs), etc.), among others. The computer-readable media may store the instructions.</p><p id="p-0338" num="0337">The instructions may also be embodied in digital and analog communication links for electrical, optical, acoustical or other forms of propagated signals, such as carrier waves, infrared signals, digital signals, etc. However, propagated signals, such as carrier waves, infrared signals, digital signals, etc. are not tangible machine readable medium and are not configured to store instructions.</p><p id="p-0339" num="0338">In general, a machine readable medium includes any mechanism that provides (i.e., stores and/or transmits) information in a form accessible by a machine (e.g., a computer, network device, personal digital assistant, manufacturing tool, any device with a set of one or more processors, etc.).</p><p id="p-0340" num="0339">In various embodiments, hardwired circuitry may be used in combination with software instructions to implement the techniques. Thus, the techniques are neither limited to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by the data processing system.</p><p id="p-0341" num="0340">The above description and drawings are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding. However, in certain instances, well known or conventional details are not described in order to avoid obscuring the description. References to one or an embodiment in the present disclosure are not necessarily references to the same embodiment; and, such references mean at least one.</p><p id="p-0342" num="0341">In the foregoing specification, the disclosure has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A computing device, comprising:<claim-text>a communication device;</claim-text><claim-text>a local memory; and</claim-text><claim-text>at least one microprocessor configured to:<claim-text>provide, over a wired or wireless connection, access to a portion of the local memory to a remote device, wherein the remote device is configured to map a virtual memory address region used in execution of first instructions in the remote device to the portion of the local memory;</claim-text><claim-text>receive, from the remote device over the wired or wireless connection, data in the portion of the local memory via the remote device accessing the portion of the local memory via the virtual memory address region;</claim-text><claim-text>receive, from the remote device over the wired or wireless connection, a request to execute second instructions; and</claim-text><claim-text>execute the second instructions to process the data in the virtual memory address region.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one microprocessor is configured via an operating system to create a virtual memory device usable by the remote device over the wired or wireless connection.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one microprocessor is configured via a virtual machine to execute the second instructions.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The computing device of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the remote device is configured to host the virtual machine during execution of the first instructions; and the computing device is configured to host the virtual machine during execution of the second instructions.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The computing device of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the remote device is configured to host the virtual machine, after execution of the second instructions in the virtual machine hosted in the computing device, to execute third instructions of the application in the virtual machine.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The computing device of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the at least one microprocessor is configured to provide, to the remote device over the wired or wireless connection, at least a portion of content in the virtual memory address region updated via execution of the second instructions.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one microprocessor is configured to execute the second instructions before termination of the application initiated in the remote device.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the at least one microprocessor is configured to execute the second instructions, at least partially in parallel with execution of the first instructions in the remote device.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. A method, comprising:<claim-text>providing, by a computing device having a communication device and a local memory and over a wired or wireless connection, access to a portion of the local memory to a remote device, wherein the remote device is configured to map a virtual memory address region used in execution of first instructions in the remote device to the portion of the local memory;</claim-text><claim-text>receiving, in the computing device from the remote device over the wired or wireless connection, data in the portion of the local memory via the remote device accessing the portion of the local memory via the virtual memory address region;</claim-text><claim-text>receiving, from the remote device over the wired or wireless connection, a request to execute second instructions; and</claim-text><claim-text>executing the second instructions to process the data in the virtual memory address region.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising:<claim-text>creating, by an operating system in the computing device, a virtual memory device usable by the remote device over the wired or wireless connection.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising:<claim-text>configuring a virtual machine in the computing device to execute the second instructions.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>hosting the virtual machine in the computing device during execution of the second instructions, wherein the remote device is configured to host the virtual machine during execution of the first instructions.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising:<claim-text>providing, from the computing device to the remote device over the wired or wireless connection, at least a portion of content in the virtual memory address region updated via execution of the second instructions.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the executing of the second instructions is performed before termination of the application initiated in the remote device.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the executing of the second instructions is at least partially in parallel with execution of the first instructions in the remote device.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. A non-transitory computer storage medium storing instructions which when executed on a computing device having a communication device and a local memory, cause the computing device to perform a method, the method comprising:<claim-text>providing, by the computing device over a wired or wireless connection, access to a portion of the local memory to a remote device, wherein the remote device is configured to map a virtual memory address region used in execution of first instructions in the remote device to the portion of the local memory;</claim-text><claim-text>receiving, in the computing device from the remote device over the wired or wireless connection, data in the portion of the local memory via the remote device accessing the portion of the local memory via the virtual memory address region;</claim-text><claim-text>receiving, from the remote device over the wired or wireless connection, a request to execute second instructions; and</claim-text><claim-text>executing the second instructions to process the data in the virtual memory address region.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The non-transitory computer storage medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the method further comprises:<claim-text>creating, by an operating system in the computing device, a virtual memory device usable by the remote device over the wired or wireless connection.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The non-transitory computer storage medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the method further comprises:<claim-text>configuring a virtual machine in the computing device to execute the second instructions; and</claim-text><claim-text>hosting the virtual machine in the computing device during execution of the second instructions, wherein the remote device is configured to host the virtual machine during execution of the first instructions.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The non-transitory computer storage medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the method further comprises:<claim-text>providing, from the computing device to the remote device over the wired or wireless connection, at least a portion of content in the virtual memory address region updated via execution of the second instructions.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The non-transitory computer storage medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the executing of the second instructions is at least partially in parallel with execution of the first instructions in the remote device.</claim-text></claim></claims></us-patent-application>