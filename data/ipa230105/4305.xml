<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004306A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004306</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17688385</doc-number><date>20220307</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>JP</country><doc-number>2021-110810</doc-number><date>20210702</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>06</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>0616</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>0647</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>0679</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">MEMORY SYSTEM</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Kioxia Corporation</orgname><address><city>Tokyo</city><country>JP</country></address></addressbook><residence><country>JP</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>ONISHI</last-name><first-name>Shohei</first-name><address><city>Kawasaki Kanagawa</city><country>JP</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Kioxia Corporation</orgname><role>03</role><address><city>Tokyo</city><country>JP</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">According to one embodiment, a memory system includes a non-volatile memory and a controller. The controller controls writing of data to the non-volatile memory or reading of data from the non-volatile memory in response to a command from a host. The controller manages a first area and a second area in a memory space provided to the host, to which an area of the non-volatile memory is mapped. The first area is an area used by the host as a main memory. The second area is an area where valid data is stored.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="169.93mm" wi="128.02mm" file="US20230004306A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="217.51mm" wi="139.45mm" orientation="landscape" file="US20230004306A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="219.63mm" wi="97.11mm" orientation="landscape" file="US20230004306A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="224.54mm" wi="148.84mm" orientation="landscape" file="US20230004306A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="129.46mm" wi="148.76mm" file="US20230004306A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="153.75mm" wi="148.08mm" file="US20230004306A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="221.06mm" wi="147.40mm" orientation="landscape" file="US20230004306A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="185.84mm" wi="130.05mm" file="US20230004306A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="154.60mm" wi="141.14mm" file="US20230004306A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="204.47mm" wi="144.02mm" orientation="landscape" file="US20230004306A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="221.15mm" wi="146.90mm" orientation="landscape" file="US20230004306A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="221.06mm" wi="148.08mm" orientation="landscape" file="US20230004306A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="221.15mm" wi="146.98mm" orientation="landscape" file="US20230004306A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="235.80mm" wi="148.93mm" file="US20230004306A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="238.68mm" wi="146.13mm" orientation="landscape" file="US20230004306A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="180.68mm" wi="130.05mm" file="US20230004306A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="234.78mm" wi="146.39mm" orientation="landscape" file="US20230004306A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="235.63mm" wi="130.05mm" file="US20230004306A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="163.58mm" wi="152.32mm" file="US20230004306A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="176.78mm" wi="149.52mm" orientation="landscape" file="US20230004306A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="170.77mm" wi="129.96mm" file="US20230004306A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="236.47mm" wi="148.93mm" file="US20230004306A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00022" num="00022"><img id="EMI-D00022" he="182.37mm" wi="129.88mm" file="US20230004306A1-20230105-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00023" num="00023"><img id="EMI-D00023" he="236.30mm" wi="129.96mm" file="US20230004306A1-20230105-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00024" num="00024"><img id="EMI-D00024" he="170.86mm" wi="143.17mm" file="US20230004306A1-20230105-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is based upon and claims the benefit of priority from Japanese Patent Applications No. 2021-110810, filed Jul. 2, 2021, the entire contents of which are incorporated herein by reference.</p><heading id="h-0002" level="1">FIELD</heading><p id="p-0003" num="0002">Embodiments described herein relate generally to a memory system.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">In recent years, a storage class memory (SCM) has been attracting attention as a new layer in the memory hierarchy that bridges the performance gap between main memory (primary storage) and storage (secondary storage). Furthermore, as candidates for SCM, next-generation semiconductor memories such as a resistive random access memory (ReRAM), a phase-change memory (PCM), a magnetoresistive RAM (MRAM), and a ferroelectric RAM (FeRAM) are mentioned.</p><p id="p-0005" num="0004">In an information processing system in which an SCM module (a memory system including an SCM and a controller that controls the SCM) is connected to a host, the host may use a part or the whole of an area of the SCM described above as the main memory. In other words, while the SCM is a non-volatile memory, a part or the whole of the area may be used as a volatile memory by the host. The host may use a part or the whole of the area of the SCM module as the main memory together with a dynamic RAM (DRAM), etc., in a host <b>2</b>, or may use only a part or the whole of the area of the SCM module as the main memory without the DRAM, etc.</p><p id="p-0006" num="0005">SCMs and SCM modules, which are semiconductor memories, require wear-leveling processing to swap data in order to level out the exhaustion of SCMs, and refresh processing to write back data in order to preserve the data stored in SCMs.</p><p id="p-0007" num="0006">The SCM module cannot detect when an area of the SCM used as volatile memory by the host is released by a process running on the host. This may cause the SCM module to perform wear-leveling processing and refresh processing that are originally unnecessary, based on the recognition that valid data is stored even in areas that have already been volatilized (disappeared) on the host, and where data has become invalid. This may consume the SCM's endurance (the number of times data can be rewritten, or the number of times data can be rewritten and read).</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example of a configuration of a memory system of a first embodiment.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a usage pattern assumed in the memory system of the first embodiment.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example of a relationship between each address space set in an information processing system to which the memory system of the first embodiment is applied.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>4</b></figref> explains problems that may occur in a case where a host uses a part of a non-volatile memory area provided in the memory system of the first embodiment as a volatile area.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>5</b></figref> explains an overview of a control method executed by the memory system of the first embodiment for omitting parts of wear-leveling processing and refresh processing that are originally unnecessary.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an example of an update of a power cycle management table used in the memory system of the first embodiment.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flowchart showing a write processing procedure executed by the memory system of the first embodiment.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows an example of address translation using an address translation table of the memory system of the first embodiment.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows an example of adding metadata and a code to data to be written in the memory system of the first embodiment.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows an example of a power cycle management method in the memory system of the first embodiment.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>11</b></figref> explains an operation of a case in which a host requests to read data from a valid data area in a volatile area on a logical address space in the memory system of the first embodiment.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>12</b></figref> explains an operation of a case in which a host requests to read data from an invalid data area in a volatile area on the logical address space in the memory system of the first embodiment.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>13</b></figref> explains an operation of a case in which a host requests to read data from a non-volatile area on the logical address space in the memory system of the first embodiment.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a flowchart showing a read processing procedure executed by the memory system of the first embodiment.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>15</b></figref> explains a mechanism by which the memory system of the first embodiment omits parts of refresh processing that are originally unnecessary.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a flowchart showing a refresh/patrol processing procedure executed by the memory system of the first embodiment.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>17</b></figref> explains a mechanism by which the memory system of the first embodiment omits parts of wear-leveling processing that are originally unnecessary.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is a flowchart showing a wear-leveling processing procedure executed by the memory system of the first embodiment.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>19</b></figref> shows an example of an arrangement of physical page management information in a memory system of a second embodiment.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>20</b></figref> explains a mechanism by which the memory system of the second embodiment omits parts of refresh processing that are originally unnecessary.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>21</b></figref> is a flowchart showing a write processing procedure executed by the memory system of the second embodiment.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>22</b></figref> is a flowchart showing a read processing procedure executed by the memory system of the second embodiment.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>23</b></figref> is a flowchart showing a refresh/patrol processing procedure executed by the memory system of the second embodiment.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>24</b></figref> is a flowchart of a wear-leveling processing procedure executed by the memory system of the second embodiment.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>25</b></figref> shows an example of a WAF reduction effect of the memory system of the first or second embodiment.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0033" num="0032">Embodiments will be described hereinafter with reference to the accompanying drawings.</p><p id="p-0034" num="0033">In general, according to one embodiment, a memory system includes a non-volatile memory and a controller. The controller controls writing of data to the non-volatile memory or reading of data from the non-volatile memory in response to a command from a host. The controller manages a first area and a second area in a memory space provided to the host, to which an area of the non-volatile memory is mapped. The first area is an area used by the host as a main memory. The second area is an area where valid data is stored.</p><heading id="h-0006" level="1">First Embodiment</heading><p id="p-0035" num="0034">First, a first embodiment will be explained.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example of a configuration of a memory system <b>1</b> of the first embodiment. <figref idref="DRAWINGS">FIG. <b>1</b></figref> also shows an example of a configuration of a host <b>2</b> (related to the memory system <b>1</b>) to which the memory system <b>1</b> is connected. In other words, <figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example of an information processing system that includes the memory system <b>1</b> and the host <b>2</b>. The memory system <b>1</b> and the host <b>2</b> are connected by an interface that complies with, for example, a compute express link (CXL) specification. The CXL is an interface standard that provides a function to maintain cache coherency between a host (in this case, the host <b>2</b>) and a device (in this case, the memory system <b>1</b>).</p><p id="p-0037" num="0036">The memory system <b>1</b> includes a media controller <b>11</b> and one or more non-volatile memories <b>12</b>. Here, in the memory system <b>1</b>, the non-volatile memories <b>12</b> are assumed to be realized as SCM modules, which are SCMs. ReRAM, PCM, MRAM, FeRAM, etc., can be applied as SCMs. The media controller <b>11</b> is realized, for example, as a system-on-chip (SoC).</p><p id="p-0038" num="0037">The media controller <b>11</b> communicates with the host <b>2</b> by a protocol defined, for example, in a CXL standard. Furthermore, the media controller <b>11</b> that communicates with the host <b>2</b> controls a non-volatile memory <b>12</b> in response to commands from the host. Specifically, in a case where the media controller <b>11</b> receives a write command from the host, it executes write processing to write data to the non-volatile memory <b>12</b>. In addition, in a case where the media controller <b>11</b> receives a read command from the host, it executes read processing to read data from the non-volatile memory <b>12</b>.</p><p id="p-0039" num="0038">The media controller <b>11</b> spontaneously executes write processing and read processing at a predetermined timing, regardless of the command from the host <b>2</b>. For example, the media controller <b>11</b> executes the write processing and the read processing as part of wear-leveling processing that swaps data to level out the exhaustion of the non-volatile memory <b>12</b> and refresh processing that writes back data to preserve the data stored in the non-volatile memory <b>12</b>.</p><p id="p-0040" num="0039">The media controller <b>11</b> includes an address translator <b>111</b>, a refresh/patrol controller <b>112</b>, a wear-leveling controller <b>113</b>, and a valid data area manager <b>114</b>. Each unit in the media controller <b>11</b> may be realized by hardware, such as an electric circuit, or by a processor (not shown) in the media controller <b>11</b> executing software (program).</p><p id="p-0041" num="0040">The address translator <b>111</b> manages the correspondence between a logical address used by the host <b>2</b> to logically specify a location in the memory space provided by the memory system <b>1</b> and a media address indicating a physical location on the non-volatile memory <b>12</b> in the memory system <b>1</b>. The address translator <b>111</b> includes an address translation table <b>1111</b> for managing the correspondence between logical addresses and media addresses. The address translation table <b>1111</b> is created, for example, on the SCM <b>12</b>. The address translator <b>111</b>, for example, caches a part or the whole of the address translation table <b>1111</b> in a RAM (not shown) in the media controller <b>11</b> or in an external RAM (not shown) connected to the media controller <b>11</b>, and uses the address translation table <b>1111</b> to execute the translation from logical addresses to media addresses.</p><p id="p-0042" num="0041">The refresh/patrol controller <b>112</b> controls the refresh processing. The refresh/patrol controller <b>112</b>, for example, cyclically monitors (patrol processing) an area of one or more non-volatile memories <b>12</b>, and determines areas where the elapsed time since the last data access (writing or reading of data) has exceeded a threshold value, areas where data accesses have been frequently performed, or areas in the vicinity of such areas to be areas subject to refresh processing. The refresh/patrol controller <b>112</b> reads the data stored in the area to be refreshed and writes the read data back to the non-volatile memory <b>12</b> (refresh processing). The destination of the data to be written back in the refresh processing may be the same area as that from which the data was read, or a different area from that from which the data was read. The method of determining whether or not the area should be a refresh target is not limited to a specific method, and various known methods can be applied.</p><p id="p-0043" num="0042">The wear-leveling controller <b>113</b> controls the wear-leveling processing. The wear-leveling controller <b>113</b> swaps the stored data between areas with a high level of exhaustion and areas with a low level of exhaustion in one or more non-volatile memories <b>12</b>. Here, areas with a large number of data rewrites or a large number of data rewrites and data reads are assumed to be areas with a high level of exhaustion. Therefore, areas with a low level of exhaustion are areas where the number of data rewrites or the number of data rewrites and data reads is small. The wear-leveling controller <b>113</b> reads data from both the area with a high level of exhaustion and the area with a low level of exhaustion, swaps write destinations, and writes the respective data back to the non-volatile memory <b>12</b>. With the wear-leveling processing, the correspondence between logical addresses and media addresses managed by the address translator <b>111</b> is updated. The method of selecting the area for wear-leveling is not limited to a specific method, and various known methods can be applied.</p><p id="p-0044" num="0043">The valid data area manager <b>114</b> manages an area that is used by the host <b>2</b> as volatile memory (volatile area) in the memory space provided by the memory system <b>1</b>. The valid data area manager <b>114</b> also manages an area where valid data is stored on the non-volatile memory <b>12</b> (valid data area). The valid data area manager <b>114</b> includes a volatile area management table <b>1141</b> for managing the volatile area and a power cycle management table <b>1142</b> for managing the valid data area or, more specifically, for determining whether the data on the volatile area is valid or not. The volatile area management table <b>1141</b> and the power cycle management table <b>1142</b> are created, for example, on the SCM <b>12</b>. The valid data area manager <b>114</b>, for example, caches a part or the whole of the volatile area management table <b>1141</b> and the power cycle management table <b>1142</b> in a RAM in the media controller <b>11</b> or an external RAM connected to the media controller <b>11</b>, and uses the volatile area management table <b>1141</b> and the power cycle management table <b>1142</b>. The volatile area management table <b>1141</b> and the power cycle management table <b>1142</b> will be described later.</p><p id="p-0045" num="0044">The host <b>2</b> includes a processor (CPU) <b>21</b> and a DRAM <b>22</b>. The processor <b>21</b> executes an operating system (OS) <b>201</b> and a process (application program) <b>202</b> that operates under the control of the OS <b>201</b>. In addition to the area on the DRAM <b>22</b>, the OS <b>201</b> can recognize a part or the whole of the memory space provided by the memory system <b>1</b> as an area for the main memory. In other words, the host <b>2</b> can use a part of the memory space provided by the memory system <b>1</b> as volatile memory. The OS <b>201</b> can also recognize a part or the whole of the memory space provided by the memory system <b>1</b> as an area for the main memory.</p><p id="p-0046" num="0045">The process <b>202</b> operating under the control of the OS <b>201</b> may be a program for constructing one or more virtual machines (VMs). On each VM, a guest OS <b>201</b>&#x2032; and a process <b>202</b>&#x2032; operate. In comparison to the guest OS <b>201</b>&#x2032; operating on each VM, the OS <b>201</b> is referred to as a host OS <b>201</b>.</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example of forms in which the memory system <b>1</b> is used by the host <b>2</b>.</p><p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. <b>2</b></figref>, part (A) shows a form in which an area of the DRAM <b>22</b> of the host <b>2</b> and a part of the memory space provided by the memory system <b>1</b>, specifically, a part of the area of the non-volatile memory (SCM) <b>12</b>, form a single memory space <b>301</b> within the host <b>2</b> and are used as the main memory.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>2</b></figref>, part (B) shows a form in which an area of the DRAM <b>22</b> of the host <b>2</b> and a part of the memory space provided by the memory system <b>1</b>, specifically, a part of the area of the SCM <b>12</b>, form individual memory spaces (<b>301</b>A and <b>301</b>B) in the host <b>2</b>, respectively, and both are used as the main memory.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>2</b></figref>, part (C) shows a form in which only an area of the DRAM <b>22</b> of host <b>2</b> is used as the main memory, and the entire memory space provided by the memory system <b>1</b> is used as a storage.</p><p id="p-0051" num="0050">In the first embodiment, it is assumed that the memory system <b>1</b> is used in the form of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, part (A) or (B). In other words, a form in which a part of the area of the SCM <b>12</b> is used as the main memory by the host <b>2</b> is assumed.</p><p id="p-0052" num="0051">Even in an environment where the memory system <b>1</b> is connected to multiple hosts <b>2</b> and the usage patterns of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, parts (A) to (C) are mixed, the control method of omitting parts of the originally unnecessary wear-leveling processing and refresh processing described below can be applied to the area of the SCM <b>12</b> used as the main memory by the host <b>2</b>.</p><p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example of the relationship between each address space set for the host <b>2</b> to perform data access to the memory space provided by the memory system <b>1</b> in an information processing system including the memory system <b>1</b> and the host <b>2</b>.</p><p id="p-0054" num="0053">As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, in an information processing system that adopts a memory system <b>1</b> equipped with one or more non-volatile memories (SCMs) <b>12</b>, four address spaces such as a media address space <b>401</b>, a logical address space <b>402</b>, a physical address space <b>403</b>, and a virtual address space <b>404</b> are configured.</p><p id="p-0055" num="0054">The media address space <b>401</b> is an address space that is accessed when the media controller <b>11</b> performs read/write to the SCM <b>12</b>. A media address is an address that is associated with a physical entity such as a memory cell of the SCM<b>12</b>. The media address is an address in bytes and is represented by a media page number of a media page, which is the smallest unit of access by the media controller <b>11</b> to the SCM <b>12</b>, and an offset in the media page. The size of the media page is, for example, 128 bytes or 256 bytes. The media page may be configured by bits from a single SCM<b>12</b> or from multiple SCM<b>12</b><i>s</i>. In other words, there are no particular restrictions on the physical structure of the media page.</p><p id="p-0056" num="0055">The logical address space <b>402</b> is an address space provided by the media controller <b>11</b> to the OS <b>201</b> of the host <b>2</b>. The logical address is an address in bytes, and is an address assigned to the memory space provided by the memory system <b>1</b> to the host <b>2</b>. When the host <b>2</b> accesses the memory system <b>1</b>, it specifies the logical address and accesses it in units of cache line size (e.g., 64 bytes). In <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the area on the logical address space corresponding to a physical page described below is illustrated as a logical page. The logical page in the logical address space <b>402</b> and the media page in the media address space <b>401</b> may be different in size. More specifically, the size of the logical page may be a positive integer multiple (two or more) of the size of the media page. The mapping of the media address space <b>401</b> to the logical address space <b>402</b> may be such that the media pages of the media address space <b>401</b> are associated on the logical address space <b>402</b> differently than they are arranged on the media address space <b>401</b> (interleaving).</p><p id="p-0057" num="0056">The physical address space <b>403</b> is the address space managed by the OS <b>201</b> of the host <b>2</b> and to which the logical address space <b>402</b> provided by the media controller <b>11</b> is mapped. In other words, a physical address is an address assigned by the OS <b>201</b> to the memory space provided by the media controller <b>11</b>. The physical address space <b>403</b> is managed by each predetermined size called a physical page. The physical address is represented by a physical page number assigned to each of these physical pages and an offset in the physical page. The mapping of the logical address space <b>402</b> to the physical address space <b>403</b> may also be interleaved.</p><p id="p-0058" num="0057">The virtual address space <b>404</b> is an address space established for each process <b>202</b> or VM. The virtual address space <b>404</b> is constructed by the OS <b>201</b>, which controls the allocation of resources. On the virtual address space <b>404</b>, a virtual page is formed to which physical pages of the physical address space <b>403</b> are associated. A virtual address is represented by a virtual page number of this virtual page and an offset in the virtual page. In other words, the virtual address is an address used by the process <b>202</b> or VM to access the memory system <b>1</b>. As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, in some cases, one physical page of the physical address space <b>403</b> may be associated with virtual pages of multiple virtual address spaces <b>404</b>. By associating the virtual page and the physical page in this manner, for example, data written by a certain process <b>202</b> or VM on the memory system <b>1</b> can be read from the memory system <b>1</b> by another certain process <b>202</b> or VM.</p><p id="p-0059" num="0058">Now, with reference to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, problems that arise in a case where the host <b>2</b> uses a part of the memory space provided by the memory system <b>1</b> as a volatile area.</p><p id="p-0060" num="0059">When setting a system configuration (main memory configuration) of an information processing system, the OS <b>201</b> or process <b>202</b> can notify the memory system <b>1</b> that a part or the whole of the area on the memory space provided by the memory system <b>1</b> is to be used as a volatile area, for example, by issuing a management command to the memory system <b>1</b>. A plurality of volatile areas can be provided on the logical address space <b>402</b>. Alternatively, the media controller <b>11</b> may provide a separate logical address space <b>402</b> for each volatile area to the OS <b>201</b> based on the notification from the OS <b>201</b> or process <b>202</b>.</p><p id="p-0061" num="0060">The OS <b>201</b> or the process <b>202</b> issues a management command that includes, for example, a physical address indicating the location of the beginning of the volatile area on the physical address space <b>403</b> to which the logical address space <b>402</b> is mapped and the size of the volatile area as parameters. In the case of providing multiple volatile areas on the logical address space <b>402</b>, the OS <b>201</b> or process <b>202</b> issues a management command for each volatile area. The management command issued by the process <b>202</b> may include, as a parameter, a virtual address indicating a location on the virtual address space <b>404</b> provided for the process <b>202</b>. In this case, the OS <b>201</b> that relays the management command issued by the process <b>202</b> translates the virtual address into a physical address.</p><p id="p-0062" num="0061">The valid data area manager <b>114</b> of the memory system <b>1</b> (media controller <b>11</b>) sets the volatile area on the logical address space <b>402</b> in response to the management command from the host <b>2</b>. Specifically, it manages the information (logical address range) of the area to be used as the volatile area on the logical address space <b>402</b>. The translation between the physical address of the physical address space <b>403</b> and the logical address of the logical address space <b>402</b> is executed by the OS <b>201</b> of the host <b>2</b>. The setting of the volatile area on the logical address space <b>402</b> remains unchanged unless the system configuration (configuration of the main memory) of the information processing system is changed. In the case where the system configuration of the information processing system is changed, a management command is sent from the host <b>2</b> again.</p><p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example in which two volatile areas (#0, #1) are provided on the logical address space <b>402</b>. Here, it is assumed that data A is stored in volatile area #0 and data B is stored in volatile area #1. It is also assumed that the process <b>202</b> or VM no longer needs data B on the main memory and has released the area allocated on the main memory for storing data B. The timing when the data stored in the volatile area on the logical address space <b>402</b> is no longer needed is when the process <b>202</b> or VM explicitly releases the area, when the process <b>202</b> or VM terminates, when the OS <b>201</b> is restarted, etc.</p><p id="p-0064" num="0063">For example, in a solid state drive (SSD), there is a means for the host <b>2</b> to notify the area where data is no longer needed, such as the trim command. On the other hand, in the SCM module, there is no established means for the host <b>2</b> to notify the area where data is no longer needed relating to the area used as the main memory.</p><p id="p-0065" num="0064">Therefore, the media controller <b>11</b> of the memory system <b>1</b> still recognizes data B stored in area al in volatile area #1 on the logical address space <b>402</b>, which the host <b>2</b> has discarded from the memory system, as valid data. Similarly, for example, when the OS <b>201</b> is restarted, the data in the main memory is once volatilized (disappears), but if no measures are taken, the media controller <b>11</b> will recognize the invalid data stored in the volatile areas (#0, #1) in the logical address space <b>402</b> that have not been written by the host <b>2</b> after the initialization of the main memory as valid data. Therefore, there is a possibility that the media controller <b>11</b> will perform unnecessary refresh processing and wear-leveling processing in the invalid data area based on the recognition that valid data is stored therein. This may consume the endurance (number of times data can be rewritten) of the SCM <b>12</b>.</p><p id="p-0066" num="0065">The above are the problems that may arise in the case where the host <b>2</b> uses a part or the whole of the memory space provided by the memory system <b>1</b> as a volatile area.</p><p id="p-0067" num="0066">Now, with reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, an overview of a control method executed by the memory system <b>1</b> of the first embodiment for omitting parts of the wear-leveling processing and refresh processing that are originally unnecessary will be described.</p><p id="p-0068" num="0067">As described above, in the case where the host <b>2</b> uses a part or the whole on the memory space provided by memory system <b>1</b> as a volatile area, the OS <b>201</b> or the process <b>202</b> notifies the logical address range to be used as a volatile area, for example, by issuing a management command. Based on this notification, the valid data area manager <b>114</b> of the memory system <b>1</b> (media controller <b>11</b>) manages the information (logical address range) of the area to be used as the volatile area on the logical address space <b>402</b> using the volatile area management table <b>1141</b>. In a case where a different logical address space <b>402</b> is provided for each volatile area, one volatile area management table <b>1141</b> is provided for each logical address space <b>402</b>. In this case, the number of entries in each volatile area management table <b>1141</b> is one.</p><p id="p-0069" num="0068">In addition, the valid data area manager <b>114</b> manages, for example, for each unit of the size of a logical page of the logical address space <b>402</b>, written area management information <b>500</b> indicating whether or not writing has been performed by the host <b>2</b> after the initialization of the main memory. For example, &#x201c;0&#x201d; indicates that no writing by the host <b>2</b> has been performed, and &#x201c;1&#x201d; indicates that writing by the host <b>2</b> has been performed.</p><p id="p-0070" num="0069">The media controller <b>11</b> manages the data stored in the area on the logical address space <b>402</b> that is used as a non-volatile area by the host <b>2</b>, other than the logical address range managed by the volatile area management table <b>1141</b>, as valid data. In addition, in an area on the logical address space <b>402</b> used as a volatile area by the host <b>2</b>, the media controller <b>11</b> manages data in an area where the written area management information <b>500</b> indicates as being written by the host, as valid data.</p><p id="p-0071" num="0070">In other words, among the areas on the logical address space <b>402</b> used as the volatile area by the host <b>2</b>, the media controller <b>11</b> manages the areas that have been written by the host <b>2</b> after initialization of the volatile area as valid data areas, and manages the areas that have not been written by the host <b>2</b> as invalid data areas. The refresh/patrol controller <b>112</b> and the wear-leveling controller <b>113</b> omit writing back the data in the invalid data area to the SCM <b>12</b>.</p><p id="p-0072" num="0071">In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, for the sake of clarity of explanation, the written area management information <b>500</b> which indicates by &#x201c;0&#x201d; or &#x201c;1&#x201d; whether or not writing has been performed by the host <b>2</b> after initialization of the main memory is shown, and the media controller <b>11</b> of the first embodiment uses the power cycle management table <b>1142</b> of the valid data area manager <b>114</b> to derive the above &#x201c;0&#x201d; or &#x201c;1&#x201d;. The power cycle management table <b>1142</b> is a table that manages the current PC (power cycle) value of the volatile area on the logical address space <b>402</b>. The PC value is, for example, a value that is incremented each time the host <b>2</b> is booted, or more particularly, each time the OS <b>201</b> is booted. Alternatively, in a case where one or more VMs are built on the host <b>2</b> and the OS <b>201</b> allocates volatile areas on the logical address space <b>402</b> to each of the one or more VMs individually, at the time of termination of the VM, the OS <b>201</b> issues a release request to the memory system <b>1</b> for the volatile area allocated to the VM, and based on this release request, the PC value of that volatile area may be incremented.</p><p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an example of an update of the power cycle management table <b>1142</b> performed in a case where the host <b>2</b> writes data to a volatile area on the logical address space <b>402</b>.</p><p id="p-0074" num="0073">In the memory system <b>1</b> of the first embodiment, the valid data area manager <b>114</b> manages the current PC value of the volatile area together with the logical address range by use of the volatile area management table <b>1141</b>. The current PC value represents the current PC value, and the PC value is a value that is incremented, for example, each time the host <b>2</b> is booted, or more particularly, each time the OS <b>201</b> is booted, as described above. Alternatively, in the case where one or more VMs are built on the host <b>2</b> and the OS <b>201</b> allocates volatile areas on the logical address space <b>402</b> to each of the one or more VMs individually, at the time of termination of the VM, the OS <b>201</b> issues a release request to the memory system <b>1</b> for the volatile area allocated to the VM, and based on this release request, the PC value of that volatile area may be incremented. In <figref idref="DRAWINGS">FIG. <b>6</b></figref>, &#x201c;2&#x201d; is held as the current PC value for volatile areas #0 and #1, respectively.</p><p id="p-0075" num="0074">Here, a case in which data is written by the host <b>2</b> to one of the areas in volatile area #0 on the logical address space <b>402</b> is assumed. At this time, the valid data area manager <b>114</b> checks whether or not the value of the entry in the power cycle management table <b>1142</b> corresponding to the area matches the current PC value in the volatile area management table <b>1141</b>. If it does not match, the valid data area manager <b>114</b> updates the value of the entry to the current PC value. The valid data area manager <b>114</b> may also omit the process of checking whether the value of the entry matches the current PC value, and update the value of the entry to the current PC value each time. The area in which the value in the power cycle management table <b>1142</b> matches the current PC value in the volatile area management table <b>1141</b> is a valid data area that stores data written after the initialization of the volatile area. On the other hand, the area in which the value in the power cycle management table <b>1142</b> does not match the current PC value in the volatile area management table <b>1141</b> is an invalid data area that stores unnecessary data from the past.</p><p id="p-0076" num="0075"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flowchart showing a write processing procedure executed by the memory system <b>1</b> (media controller <b>11</b>) of the first embodiment.</p><p id="p-0077" num="0076">The media controller <b>11</b> receives a write request from the host <b>2</b> (S<b>101</b>). The write request includes a logical address of a write destination and data. The media controller <b>11</b> registers the data received from the host <b>2</b> into a buffer (S<b>102</b>). The buffer may, for example, be provided on Static RAM (SRAM) in the media controller <b>11</b>, or on DRAM connected to the media controller <b>11</b>. If data corresponding to the same logical address (logical address received from the host <b>2</b>) has already been registered in the buffer, the media controller <b>11</b> overwrites the data on the buffer.</p><p id="p-0078" num="0077">For example, in the case where the buffer is full of data, the media controller <b>11</b> writes the oldest data on the buffer to the SCM <b>12</b>. A so-called eviction algorithm to evict data from the buffer is not limited to Least Recently Used (LRU), and various algorithms can be applied, such as Least Frequently Used (LFU). In the case where the media controller <b>11</b> writes data to the SCM <b>12</b> (S<b>103</b>: Yes), the media controller <b>11</b> obtains a media address from the logical address of the write destination by address translation using the address translator <b>111</b> (S<b>104</b>). <figref idref="DRAWINGS">FIG. <b>8</b></figref> shows an example of address translation by the address translator <b>111</b> using the address translation table <b>1111</b>.</p><p id="p-0079" num="0078">In <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the logical address &#x201c;0&#x201d; is associated with the media address &#x201c;5&#x201d; in the address translation table <b>1111</b>. By referring to this address translation table <b>1111</b>, the address translator <b>111</b> can obtain the media address &#x201c;5&#x201d; that is associated with the logical address &#x201c;0&#x201d;. The address translator <b>111</b> can also obtain the logical address &#x201c;0&#x201d; from the media address &#x201c;5&#x201d; by referring to the address translation table <b>1111</b>.</p><p id="p-0080" num="0079">Instead of translating a logical address to a media address using the address translation table <b>1111</b>, the address translator <b>111</b> may translate a logical address to a media address by arithmetic operation using a translation formula. For example, the media address may be obtained from the logical address and exhaustion information. In this case, a function to translate a logical address to a media address may be provided with the logical address and exhaustion information as arguments.</p><p id="p-0081" num="0080">In addition, the media controller <b>11</b> adds metadata and a code to the data to be written (S<b>105</b>). <figref idref="DRAWINGS">FIG. <b>9</b></figref> shows an example of adding metadata and a code to data. The metadata includes a logical address. The code is an error correcting code (ECC), cyclic redundancy code (CRC), etc. Instead of including the logical address in the metadata to be added to the data, the media controller <b>11</b> may further comprise a reverse lookup table to translate the media address to the logical address.</p><p id="p-0082" num="0081">The media controller <b>11</b> may also perform data randomization (swapping bit positions) or the like in S<b>105</b>.</p><p id="p-0083" num="0082">The media controller <b>11</b> updates the exhaustion information of the area (media page) on the media address space <b>401</b> indicated by the media address (S<b>106</b>). The exhaustion information is, for example, the number of times data is written. In addition, the media controller <b>11</b> updates the PC value stored in the entry corresponding to the logical address on the power cycle management table <b>1142</b> to the current PC value stored in the entry corresponding to the relevant volatile area acquired by referring to the volatile area management table <b>1141</b> (S<b>107</b>).</p><p id="p-0084" num="0083">After updating the power cycle management table <b>1142</b>, the media controller <b>11</b> writes data to the SCM <b>12</b> (S<b>108</b>) and releases the buffer (S<b>109</b>). With the release of the buffer, the media controller <b>11</b> ends the write processing. On the other hand, in the case where the buffer is not full of data and no data is to be written to the SCM<b>12</b> (S<b>103</b>: No), the media controller <b>11</b> ends the write processing with the registration of data to the buffer in S<b>102</b>.</p><p id="p-0085" num="0084"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows an example of a power cycle management method performed by the valid data area manager <b>114</b>.</p><p id="p-0086" num="0085">In <figref idref="DRAWINGS">FIG. <b>1</b></figref> and <figref idref="DRAWINGS">FIG. <b>6</b></figref>, a power cycle management table <b>1142</b> is shown to manage power cycles. However, the valid data area manager <b>114</b> is not limited to managing the power cycle with the power cycle management table <b>1142</b>, and may manage the power cycle by other methods.</p><p id="p-0087" num="0086">For example, <figref idref="DRAWINGS">FIG. <b>10</b></figref>, part (A) shows an example of writing a power cycle to a media page by adding it to data. The valid data area manager <b>114</b> may, for example, store a PC value (along with the logical address) in the metadata, and add the metadata to the data. In other words, the valid data area manager <b>114</b> uses the metadata stored in each media page to manage the power cycle.</p><p id="p-0088" num="0087"><figref idref="DRAWINGS">FIG. <b>10</b></figref>, part (B) shows an example of embedding a PC value in the address translation table <b>1111</b> of the address translator <b>111</b>. The valid data area manager <b>114</b> works with the address translator <b>111</b> to manage the power cycle by the address translation table <b>1111</b>.</p><p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. <b>10</b></figref>, part (C) shows an example of managing power cycles by the power cycle management table <b>1142</b>, also shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> and <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0090" num="0089"><figref idref="DRAWINGS">FIG. <b>11</b></figref> explains an operation of the media controller <b>11</b> in a case where the host <b>2</b> requests to read data from a valid data area in a volatile area on the logical address space <b>402</b>.</p><p id="p-0091" num="0090">A case in which the host <b>2</b> requests to read data from a volatile area (in this case, volatile area #0) on the logical address space <b>402</b> is assumed. The valid data area manager <b>114</b> determines whether or not a PC value of an entry in the power cycle management table <b>1142</b> corresponding to a logical address specified by the host <b>2</b> matches a current PC value of volatile area #0 managed in the volatile area management table <b>1141</b>. Here, it is assumed that they match at &#x201c;2&#x201d;. In the case where both values match, the valid data area manager <b>114</b> determines that the area of the logical address specified by the host <b>2</b> is a valid data area.</p><p id="p-0092" num="0091">The media controller <b>11</b> reads data from the media address space <b>401</b>, that is, from the SCM <b>12</b>, and transmits the read data to the host <b>2</b>.</p><p id="p-0093" num="0092">On the other hand, <figref idref="DRAWINGS">FIG. <b>12</b></figref> explains an operation of the media controller <b>11</b> in a case where the host <b>2</b> requests to read data from an invalid data area in a volatile area on the logical address space <b>402</b>.</p><p id="p-0094" num="0093">A case in which the host <b>2</b> requests to read data from a volatile area (in this case, volatile area #1) on logical address space <b>402</b> is assumed. The valid data area manager <b>114</b> determines whether or not a value of an entry in the power cycle management table <b>1142</b> corresponding to a logical address specified by the host <b>2</b> matches a current PC value of volatile area #1 managed in the volatile area management table <b>1141</b>. Here, the value of the entry in the power cycle management table <b>1142</b> is &#x201c;1&#x201d; while the current PC value of volatile area #1 managed in the volatile area management table <b>1141</b> is &#x201c;2&#x201d;, and the two values do not match. In the cases where both values do not match, the valid data area manager <b>114</b> determines that the area of the logical address specified by the host <b>2</b> is an invalid data area. The media controller <b>11</b> transmits predetermined data indicating, for example, an error to the host <b>2</b> without reading data from the SCM <b>12</b>.</p><p id="p-0095" num="0094">This prevents reading data from the past that has already been invalidated in the case where, for example, the process <b>202</b> accidentally attempts to read data from an area in an indefinite state on the main memory.</p><p id="p-0096" num="0095"><figref idref="DRAWINGS">FIG. <b>13</b></figref> explains an operation of the media controller <b>11</b> in a case where the host <b>2</b> requests to read data from an area in a non-volatile area on the logical address space <b>402</b>.</p><p id="p-0097" num="0096">As described above, the valid data area manager <b>114</b> determines that the non-volatile area on the logical address space <b>402</b> is a valid data area, where the stored data is valid data. Therefore, the media controller <b>11</b> reads data from the SCM <b>12</b> and transmits the read data to the host <b>2</b>, regardless of the value of the entry in the power cycle management table <b>1142</b> corresponding to the logical address specified by the host <b>2</b>.</p><p id="p-0098" num="0097">The reason why the entries in the power cycle management table <b>1142</b> also exist for the non-volatile area on the logical address space <b>402</b> is that a volatile area may be established in any range on the logical address space <b>402</b>. The power cycle management table <b>1142</b> may also be a table that manages only the volatile area in a list structure or tree structure.</p><p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a flowchart showing a read processing procedure executed by the memory system <b>1</b> (media controller <b>11</b>) of the first embodiment.</p><p id="p-0100" num="0099">The media controller <b>11</b> receives a read request from the host <b>2</b> (S<b>201</b>). The read request includes a logical address of a read target. The media controller <b>11</b> determines whether or not data corresponding to the logical address of the read target exists in the buffer (S<b>202</b>). The buffer referred to in S<b>202</b> may be only the buffer allocated in S<b>207</b>, or may be both the buffer allocated in S<b>207</b> and the buffer of the write processing (write buffer) described above. In the case where it is only the buffer allocated in S<b>207</b>, the determination of S<b>202</b> follows the process performed in the case where the release of the buffer in S<b>211</b> (allocated in S<b>207</b>) is not performed, and in the case where the release of the buffer in S<b>211</b> is performed, the process proceeds from S<b>201</b> to S<b>203</b>. The case in which the release of the buffer in S<b>211</b> is not performed is a case in which the buffer allocated in S<b>207</b> is used as a read buffer.</p><p id="p-0101" num="0100">In the case where the data exists in the buffer (S<b>202</b>: Yes), the media controller <b>11</b> transfers the data in the buffer to the host <b>2</b> (S<b>210</b>). Here, the case of proceeding from S<b>202</b> to S<b>210</b> is a case in which the data exists in the read buffer or the write buffer. In this case, the media controller <b>11</b> does not perform the release of the buffer in S<b>211</b>, but transfers the data in the buffer to the host <b>2</b>, and then ends the read processing.</p><p id="p-0102" num="0101">In the case where the data does not exist in the buffer (S<b>202</b>: No), the media controller <b>11</b> determines whether or not the logical address received from the host <b>2</b> is in the volatile area (S<b>203</b>). In the case where the data exists in the volatile area (S<b>203</b>: Yes), the media controller <b>11</b> acquires a PC value corresponding to the logical address received from the host <b>2</b> from the power cycle management table <b>1142</b> (S<b>204</b>). The media controller <b>11</b> determines whether or not the acquired PC value matches the current PC value of the relevant volatile area managed in the volatile area management table <b>1141</b> (S<b>205</b>). In the case where the PC values do not match (S<b>205</b>: No), the media controller <b>11</b> transfers predetermined data indicating an error to the host <b>2</b> (S<b>212</b>) and ends the read processing.</p><p id="p-0103" num="0102">In the case where the PC values match (S<b>205</b>: Yes) or in the case where the logical address is not in the volatile area (S<b>203</b>: No), the media controller <b>11</b> obtains a media address from the logical address of the read target by address translation by the address translator <b>111</b> (S<b>206</b>). The case in which the logical address is not in the volatile area is a case in which it is in the non-volatile area.</p><p id="p-0104" num="0103">The media controller <b>11</b> allocates a buffer for storing the read data (S<b>207</b>). As in the case of the write processing described above, the buffer may be provided, for example, on the SRAM in the media controller <b>11</b> or on the DRAM connected to the media controller <b>11</b>. In the case where the process of S<b>211</b> (releasing the buffer allocated in <b>207</b>) is not performed, the media controller <b>11</b> first allocates a buffer of a size that can store a certain amount of data, and if the buffer is full of data, it repeats processing of discarding the oldest data on the buffer and allocating an area to store newly read data. As mentioned above, the so-called eviction algorithm to evict data from the buffer is not limited to LRU, and various algorithms can be applied, such as LFU.</p><p id="p-0105" num="0104">The media controller <b>11</b> reads data from the SCM <b>12</b> based on the media address obtained in S<b>206</b> (S<b>208</b>). The media controller <b>11</b> decodes the read data (S<b>209</b>). The decoding of the data is, for example, an error correction using an error correcting code added to the data. In the case where randomization of data is performed in the write processing described above, the media controller <b>11</b> performs decoding processing for the randomization in S<b>209</b>.</p><p id="p-0106" num="0105">The media controller <b>11</b> transfers the data to the host <b>2</b> (S<b>210</b>). If the buffer allocated in S<b>207</b> is not to be used as a read buffer, the media controller <b>11</b> releases the buffer (S<b>211</b>) and ends the read processing.</p><p id="p-0107" num="0106">Now, with reference to <figref idref="DRAWINGS">FIG. <b>15</b></figref>, the mechanism by which the refresh/patrol controller <b>112</b> omits a part of the refresh process that is originally unnecessary will be described.</p><p id="p-0108" num="0107">The refresh/patrol controller <b>112</b> cyclically monitors the media address space <b>401</b> and detects media pages that require data refreshing. As mentioned above, the method of determining whether or not data refresh is required is not limited to a specific method, and various known methods can be applied. Alternatively, for each media page, refreshing may be executed at predetermined time intervals. Here, it is assumed that media page A (b<b>1</b>) is detected as a page that requires data refresh.</p><p id="p-0109" num="0108">The refresh/patrol controller <b>112</b> reads data from the page to be refreshed (in this case, media page A) of the SCM <b>12</b>. Metadata and a code are added to the data written in the SCM <b>12</b>. The metadata includes a logical address. In the case where this logical address is a volatile area, the refresh/patrol controller <b>112</b> compares the current PC value of the volatile area with the PC value of the logical address. Whether or not the logical address is a volatile area and the current PC value of the volatile area in the case where the logical address is a volatile area can be acquired from the volatile area management table <b>1141</b>. The PC value of the logical address can be acquired from the power cycle management table <b>1142</b>.</p><p id="p-0110" num="0109">In the case where the compared values match, the refresh/patrol controller <b>112</b> writes the data back to the SCM <b>12</b>. On the other hand, in the case where the values do not match, the refresh/patrol controller <b>112</b> omits the process of writing the data back to the SCM <b>12</b>. In <figref idref="DRAWINGS">FIG. <b>15</b></figref>, the current PC value of the volatile area is &#x201c;2&#x201d; while the PC value of the logical address is &#x201c;1&#x201d;, and since they do not match, the data of media page A is not written back to SCM <b>12</b>. As mentioned above, the case in which both values do not match is a case in which the data in the media page is unnecessary data from the past.</p><p id="p-0111" num="0110">By omitting the writing back of unnecessary data in the refresh processing, the memory system <b>1</b> prevents the endurance of the SCM <b>12</b> from being consumed unnecessarily. This allows the life of the SCM <b>12</b> to be extended.</p><p id="p-0112" num="0111"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a flowchart showing the procedure of the refresh/patrol processing executed by the memory system <b>1</b> (media controller <b>11</b>) of the first embodiment. The media controller <b>11</b> selects a media address to be refreshed/patrolled (S<b>301</b>). The media controller <b>11</b> reads data from the SCM <b>12</b> using the selected media address (S<b>302</b>). The media controller <b>11</b> decodes the read data (S<b>303</b>). The data read from the SCM <b>12</b> is given metadata including a logical address. By referring to the metadata, the media controller <b>11</b> can acquire the logical address corresponding to the media address.</p><p id="p-0113" num="0112">The media controller <b>11</b> refers to the volatile area management table <b>1141</b> to determine whether or not the logical address acquired from the metadata is in the volatile area (S<b>304</b>). In the case where the logical address is in the volatile area (S<b>304</b>: Yes), the media controller <b>11</b> acquires a PC value corresponding to the logical address that is added to the read data (S<b>305</b>). The media controller <b>11</b> can acquire the PC value from the power cycle management table <b>1142</b>.</p><p id="p-0114" num="0113">The media controller <b>11</b> compares the PC value corresponding to the logical address with the current PC value corresponding to the volatile area (S<b>306</b>). The media controller <b>11</b> can acquire the current PC value from the volatile area management table <b>1141</b>. In the case where both values do not match (S<b>306</b>: No), the media controller <b>11</b> ends the refresh processing for the media address selected in S<b>301</b> without writing the data back to the SCM <b>12</b> (S<b>307</b> to S<b>308</b>).</p><p id="p-0115" num="0114">In the case where the values match (S<b>306</b>: Yes) or in the case where the logical address is not in the volatile area (S<b>304</b>: No), the media controller <b>11</b> adds metadata and a code to the data to be written back (S<b>307</b>). The media controller <b>11</b> writes the data to the SCM <b>12</b> (S<b>308</b>) and ends the refresh processing.</p><p id="p-0116" num="0115">Now, with reference to <figref idref="DRAWINGS">FIG. <b>17</b></figref>, the mechanism by which the wear-leveling controller <b>113</b> omits a part of the wear-leveling processing that is originally unnecessary will be described.</p><p id="p-0117" num="0116">The wear-leveling controller <b>113</b> selects a media page with a high level of exhaustion as a page to be wear leveled, based on the exhaustion information of the media page. The wear-leveling controller <b>113</b> selects a media page with a low level of exhaustion as a destination for the data of the page to be wear leveled. Here, it is assumed that media page A (c<b>1</b>) is selected as the source of data movement and media page B (c<b>2</b>) is selected as the destination of data movement. The wear-leveling processing is processing in which a source media page and a destination media page are selected, and data is swapped between the two media pages.</p><p id="p-0118" num="0117">Since the wear-leveling processing involves updating the address translation table <b>1111</b> managed by the address translator <b>111</b>, the wear-leveling controller <b>113</b> does not need to consider whether the media page is a volatile area or a non-volatile area when selecting the source media page and the destination media page. In other words, one can be a volatile area and the other can be a non-volatile area.</p><p id="p-0119" num="0118">The wear-leveling controller <b>113</b> reads data from each of the media page A and media page B. Here, in order to reduce the load of the wear-leveling processing, for example, it is assumed that the need to write back is determined only for the destination media page. It is also possible to determine whether or not both media pages need to be written back.</p><p id="p-0120" num="0119">The wear-leveling controller <b>113</b> writes the data read from media page A to media page B. On the other hand, for media page B, the wear-leveling controller <b>113</b> first refers to the volatile area management table <b>1141</b> to determine whether or not the logical address included in the metadata is a volatile area. In the case where the logical address is not a volatile area, i.e., it is a non-volatile area, the wear-leveling controller <b>113</b> determines at that point that the data in media page B needs to be written back to media page A.</p><p id="p-0121" num="0120">In the case where it is a volatile area, the wear-leveling controller <b>113</b> acquires the PC value corresponding to the logical address from the power cycle management table <b>1142</b> and compares it with the current PC value of the relevant volatile area managed in the volatile area management table <b>1141</b>. In the case where both values match, the wear-leveling controller <b>113</b> determines that the data in media page B needs to be written back to media page A. In the case where they do not match, the wear-leveling controller <b>113</b> determines that it is not necessary to write the data in media page B back to media page A.</p><p id="p-0122" num="0121">As in the case of the aforementioned refresh processing, by omitting the writing back of unnecessary data in the wear-leveling processing, the memory system <b>1</b> prevents the endurance of the SCM <b>12</b> from being consumed unnecessary. This allows the life of the SCM <b>12</b> to be extended.</p><p id="p-0123" num="0122"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is a flowchart showing the procedure of the wear-leveling processing executed by the memory system <b>1</b> (media controller <b>11</b>) of the first embodiment.</p><p id="p-0124" num="0123">The media controller <b>11</b> selects media address <b>1</b> of the data movement source (S<b>401</b>). Media address <b>1</b> is, for example, the address indicating media page A shown in <figref idref="DRAWINGS">FIG. <b>17</b></figref>. The media controller <b>11</b> also selects media address <b>2</b> of the data movement destination (S<b>402</b>). Media address <b>2</b> is, for example, the address indicating media page B shown in <figref idref="DRAWINGS">FIG. <b>17</b></figref>.</p><p id="p-0125" num="0124">The media controller <b>11</b> then reads data <b>1</b> from media address <b>1</b> (S<b>403</b>), and also reads data <b>2</b> from media address <b>2</b> (S<b>403</b>). The media controller <b>11</b> decodes data <b>1</b> (S<b>405</b>) and also decodes data <b>2</b> (S<b>406</b>). Then, the media controller <b>11</b> adds metadata and a code to data <b>1</b> (S<b>407</b>), and writes data <b>1</b> to media address <b>2</b> (S<b>408</b>).</p><p id="p-0126" num="0125">The media controller <b>11</b> then determines whether or not logical address B of data <b>2</b> (included in the metadata) is a volatile area (S<b>409</b>). In the case where it is a volatile area (S<b>409</b>: Yes), the media controller <b>11</b> acquires the PC value corresponding to logical address B added to data <b>2</b> (S<b>410</b>). The media controller <b>11</b> compares the acquired PC value with the current PC value of the relevant volatile area (S<b>411</b>). In the case where the values do not match (S<b>411</b>: No), the media controller <b>11</b> omits the process of S<b>412</b> to S<b>413</b> of writing back data <b>2</b> to media address <b>1</b>, updates the address translation table <b>1111</b> (S<b>414</b>), and ends the wear-leveling processing.</p><p id="p-0127" num="0126">In the case where the acquired PC value and the current PC value match (S<b>411</b>: Yes), or in the case where logical address B is not a volatile area (is a non-volatile area) (S<b>409</b>: No), the media controller <b>11</b> adds metadata and a code to data <b>2</b> (S<b>412</b>), and writes data <b>2</b> to media address <b>1</b> (S<b>413</b>). Then, the media controller <b>11</b> updates the address translation table <b>1111</b> (S<b>414</b>) and ends the wear-leveling processing.</p><p id="p-0128" num="0127">Note that the media controller <b>11</b> may also perform processes equivalent to S<b>409</b> to S<b>411</b> for data <b>1</b> as a pre-process to S<b>407</b>. In the case where the media controller <b>11</b> comprises a reverse lookup table for translating media addresses to logical addresses, logical addresses A and B may be acquired by the reverse lookup table at the time of reading data <b>1</b> in S<b>403</b> and at the time of reading data <b>2</b> in S<b>404</b> to determine the necessity of reading the data. In this case, unnecessary reading of data can be further reduced.</p><p id="p-0129" num="0128">As described above, by omitting a part of the refresh processing or wear-leveling processing that is originally unnecessary, the memory system <b>1</b> of the first embodiment can prevent the endurance of the SCM <b>12</b> from being consumed unnecessarily and extend the life of the SCM <b>12</b>.</p><heading id="h-0007" level="1">Second Embodiment</heading><p id="p-0130" num="0129">A second embodiment will now be described.</p><p id="p-0131" num="0130">In the first embodiment, whether a logical page on the logical address space <b>402</b> is valid or invalid was determined by managing the written area management information <b>500</b> that indicates whether or not a write has been performed by the host <b>2</b> after initialization of the main memory (volatile area). Specifically, the power cycle management table <b>1142</b> was used to derive each value of the written area management information <b>500</b>.</p><p id="p-0132" num="0131">In the second embodiment, the area of a DRAM <b>22</b> in a host <b>2</b> and a part of the area of an SCM <b>12</b> in a memory system <b>1</b>, as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, part (B), each form an individual memory space in the host <b>2</b>, and both of them are assumed to be used as main memories. In other words, it is assumed that an OS <b>201</b> of the host <b>2</b> manages the SCM <b>12</b> as a separate area from the DRAM <b>22</b>.</p><p id="p-0133" num="0132">In the second embodiment, it is assumed that the OS <b>201</b> of the host <b>2</b> places physical page management information (page descriptor) regarding the memory space provided by a memory system <b>1</b> at a predetermined location on the memory space provided by the memory system <b>1</b>. Alternatively, the location where the page descriptor is placed may be notified by the host <b>2</b>. Furthermore, the second embodiment assumes that cache coherency is maintained between a processor <b>21</b> of the host <b>2</b> and a media controller <b>11</b> of the memory system <b>1</b>, at least for the physical page management information regarding the memory space provided by the memory system <b>1</b>. As described in the first embodiment, the memory system <b>1</b> and the host <b>2</b> are connected by an interface compliant with, for example, the CXL specification, which enables cache coherency to be maintained.</p><p id="p-0134" num="0133"><figref idref="DRAWINGS">FIG. <b>19</b></figref> shows an example of an arrangement of physical memory management information <b>600</b> in the memory system <b>1</b> of the second embodiment.</p><p id="p-0135" num="0134">The OS <b>201</b> of the host <b>2</b>, for example, places the physical memory management information <b>600</b> at the top on the memory space provided by the memory system <b>1</b>. Although <figref idref="DRAWINGS">FIG. <b>19</b></figref> shows the placement of the physical memory management information <b>600</b> on logical address space <b>402</b>, the OS <b>201</b> of the host <b>2</b> places the physical memory management information <b>600</b> on physical address space <b>403</b> to which the logical address space <b>402</b> is mapped.</p><p id="p-0136" num="0135">The physical memory management information <b>600</b> includes, for example, page descriptors <b>610</b> for the number of physical pages on the physical address space <b>403</b>. A page descriptor <b>610</b> includes a reference counter <b>611</b>. The reference counter <b>611</b> represents the number of physical pages corresponding to the page descriptor that have been allocated to a process or VM at that time. The value of the reference counter is incremented when it is allocated to a process or VM, and decremented when it is released. The value of the reference counter is greater than or equal to 0 in a case where it is allocated to any process or VM.</p><p id="p-0137" num="0136">Therefore, the memory system <b>1</b> of the second embodiment uses this reference counter <b>611</b> to determine whether a logical page on the logical address space <b>402</b> is valid or invalid.</p><p id="p-0138" num="0137">The media controller <b>11</b> receives the following information from the host <b>2</b>, for example, via a register.</p><p id="p-0139" num="0138">(1) Whether or not the page descriptor <b>610</b> relating to the memory space provided by the memory system <b>1</b> is stored in the memory system <b>1</b>.</p><p id="p-0140" num="0139">(2) The logical address in which an array of page descriptors <b>610</b> is stored.</p><p id="p-0141" num="0140">(3) Size of the page descriptor <b>610</b>.</p><p id="p-0142" num="0141">(4) Location of the reference counter <b>611</b> in the page descriptor <b>610</b>.</p><p id="p-0143" num="0142">(5) Size of the reference counter <b>611</b>.</p><p id="p-0144" num="0143">(6) Size of the area on the physical address space <b>403</b> corresponding to one page descriptor <b>610</b> (not necessarily the same as the size of the physical page).</p><p id="p-0145" num="0144">In the case where it is recognized that the page descriptor <b>610</b> is not stored in the memory system <b>1</b> by (1) above, the media controller <b>11</b> does not determine whether the logical page on the logical address space <b>402</b> is valid or invalid, but always executes writing back of the data stored in the logical page selected as the refresh target or wear-leveling target.</p><p id="p-0146" num="0145">With reference to <figref idref="DRAWINGS">FIG. <b>20</b></figref>, a mechanism by which a refresh/patrol controller <b>112</b> of the second embodiment omits a part of refresh processing that is originally unnecessary is described.</p><p id="p-0147" num="0146">The refresh/patrol controller <b>112</b> cyclically monitors media address space <b>401</b> and detects media pages that require data refreshing. The refresh/patrol controller <b>112</b> reads data from a page to be refreshed in the SCM <b>12</b>. Metadata and a code are added to the data written in the SCM <b>12</b>. The metadata includes a logical address.</p><p id="p-0148" num="0147">The refresh/patrol controller <b>112</b> determines whether or not this logical address is a volatile area by referring to a volatile area management table <b>1141</b>. In the case where it is not a volatile area, that is, in the case where it is a non-volatile area, the refresh/patrol controller <b>112</b> determines that the read data is valid data at that point. In other words, it executes the writing back of that data to the SCM <b>12</b>.</p><p id="p-0149" num="0148">On the other hand, in the case where it is a volatile area, the refresh/patrol controller <b>112</b> acquires the value of the reference counter in the page descriptor <b>610</b> corresponding to the logical address. In the case where this value is equal to or greater than a threshold value (e.g., 0 or greater), the refresh/patrol controller <b>112</b> determines that the read data is valid data. In other words, it executes the writing back of that data to the SCM <b>12</b>. In the case where the value of the reference counter is less than the threshold value, the refresh/patrol controller <b>112</b> determines that the read data is invalid data and omits writing it back to the SCM <b>12</b>.</p><p id="p-0150" num="0149">By omitting the writing back of unnecessary data in the refresh processing, the memory system <b>1</b> prevents the endurance of the SCM <b>12</b> from being consumed unnecessarily. This allows the life of the SCM <b>12</b> to be extended.</p><p id="p-0151" num="0150">The wear-leveling controller <b>113</b> of the second embodiment also determines the validity or invalidity of the data stored in the wear-leveling target page in the same manner as the refresh/patrol controller <b>112</b>, and omits the writing back of invalid data to the SCM <b>12</b>. By omitting the writing back of unnecessary data in the wear-leveling processing as well, the memory system <b>1</b> can prevent the endurance of the SCM <b>12</b> from being consumed unnecessarily and extend the life of the SCM <b>12</b>.</p><p id="p-0152" num="0151">Furthermore, also in the second embodiment, the memory system <b>1</b> can prevent, for example, the reading out of past data that has already been invalidated in the case where a process <b>202</b> operating in the host <b>2</b> accidentally tries to read out data from an area in an indefinite state on the main memory.</p><p id="p-0153" num="0152"><figref idref="DRAWINGS">FIG. <b>21</b></figref> is a flowchart showing a write processing procedure executed by the memory system <b>1</b> (media controller <b>11</b>) of the second embodiment.</p><p id="p-0154" num="0153">The media controller <b>11</b> receives a write request from the host <b>2</b> (S<b>501</b>). The write request includes the logical address of a write destination and data. The media controller <b>11</b> registers the data received from the host <b>2</b> into a buffer (S<b>502</b>). In a case where data corresponding to the same logical address (logical address received from host <b>2</b>) has already been registered in the buffer, the media controller <b>11</b> overwrites the data on the buffer.</p><p id="p-0155" num="0154">The media controller <b>11</b>, for example, writes the oldest data on the buffer to the SCM <b>12</b> in a case where the buffer is full of data. In the case where the media controller <b>11</b> writes the data to the SCM <b>12</b> (S<b>503</b>: Yes), the media controller <b>11</b> obtains a media address from the logical address of the write destination by address translation by an address translator <b>111</b> (S<b>504</b>).</p><p id="p-0156" num="0155">In addition, the media controller <b>11</b> adds metadata and a code to the data to be written (S<b>505</b>). In S<b>505</b>, the media controller <b>11</b> may randomize the data (swap bit positions), etc. Furthermore, the media controller <b>11</b> updates exhaustion information of the area (media page) on the media address space <b>401</b> indicated by the media address (S<b>506</b>).</p><p id="p-0157" num="0156">The media controller <b>11</b> writes data to the SCM <b>12</b> (S<b>507</b>) and releases the buffer (S<b>508</b>). With the release of the buffer, the media controller <b>11</b> ends the write processing. On the other hand, in the case where the buffer is not full of data and no data is to be written to the SCM<b>12</b> (S<b>503</b>: No), the media controller <b>11</b> ends the write processing with the registration of data to the buffer in S<b>502</b>.</p><p id="p-0158" num="0157">The above procedure of the write processing in the second embodiment is the procedure of the write processing in the first embodiment shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, excluding the process of updating the power cycle management table in S<b>107</b>.</p><p id="p-0159" num="0158"><figref idref="DRAWINGS">FIG. <b>22</b></figref> is a flowchart showing a read processing procedure executed by the memory system <b>1</b> (media controller <b>11</b>) of the second embodiment.</p><p id="p-0160" num="0159">The media controller <b>11</b> receives a read request from the host <b>2</b> (S<b>601</b>). The read request includes the logical address of a read target. The media controller <b>11</b> determines whether or not data corresponding to the logical address to be read exists in the buffer (S<b>602</b>). In the case where the data exists in the buffer (S<b>602</b>: Yes), the media controller <b>11</b> transfers the data in the buffer to the host <b>2</b> (S<b>610</b>). In the case where the data is to be acquired from the buffer, the media controller <b>11</b> does not perform release of the buffer in S<b>611</b>, and ends the read processing after transferring the data in the buffer to the host <b>2</b>.</p><p id="p-0161" num="0160">In the case where the data does not exist in the buffer (S<b>602</b>: No), the media controller <b>11</b> determines whether or not the logical address received from the host <b>2</b> is in a volatile area (S<b>603</b>). In the case where it is in the volatile area (S<b>603</b>: Yes), the media controller <b>11</b> acquires a reference count corresponding to the logical address (S<b>604</b>). The media controller <b>11</b> determines whether or not the acquired reference count is equal to or greater than a threshold value (S<b>605</b>). In the case where it is less than the threshold value (S<b>605</b>: No), the media controller <b>11</b> transfers predetermined data indicating an error to the host <b>2</b> (S<b>605</b>), and ends the read processing.</p><p id="p-0162" num="0161">In the case where the reference count is equal to or greater than the threshold value (S<b>605</b>: Yes), or in the case where the logical address is not in the volatile area (S<b>603</b>: No), the media controller <b>11</b> obtains a media address from the logical address to be read by address translation by the address translator <b>111</b> (S<b>606</b>). The media controller <b>11</b> allocates a buffer to store the read data (S<b>607</b>) and reads data from the SCM <b>12</b> based on the media address obtained in S<b>606</b> (S<b>608</b>).</p><p id="p-0163" num="0162">The media controller <b>11</b> decodes the read data (S<b>609</b>) and transfers the data to the host <b>2</b> (S<b>610</b>). If the buffer allocated in S<b>607</b> is not to be used as a read buffer, the media controller <b>11</b> releases the buffer (S<b>611</b>) and ends the read processing.</p><p id="p-0164" num="0163">The above procedure of the read processing in the second embodiment is the procedure of the read processing in the first embodiment shown in <figref idref="DRAWINGS">FIG. <b>14</b></figref>, except that the process of determining the validity or invalidity using the PC value in S<b>204</b> to S<b>205</b> is replaced by the process of determining the validity or invalidity using the reference count in S<b>605</b> to S<b>606</b>. <figref idref="DRAWINGS">FIG. <b>23</b></figref> is a flowchart showing a refresh/patrol processing procedure executed by the memory system <b>1</b> (media controller <b>11</b>) of the second embodiment.</p><p id="p-0165" num="0164">The media controller <b>11</b> selects a media address to be refreshed/patrolled (S<b>701</b>). The media controller <b>11</b> reads data from the SCM <b>12</b> using the selected media address (S<b>702</b>). The media controller <b>11</b> decodes the read data (S<b>703</b>).</p><p id="p-0166" num="0165">The media controller <b>11</b> refers to the volatile area management table <b>1141</b> to determine whether or not the logical address acquired from the metadata is in the volatile area (S<b>704</b>). In the case where it is in the volatile area (S<b>704</b>: Yes), the media controller <b>11</b> acquires the reference count corresponding to the logical address added to the read data (S<b>705</b>).</p><p id="p-0167" num="0166">The media controller <b>11</b> determines whether or not the acquired reference count is equal to or greater than a threshold value (S<b>706</b>). In the case where it is less than the threshold value (S<b>706</b>: No), the media controller <b>11</b> ends the refresh processing for the media address selected in S<b>701</b> without writing the data back to the SCM <b>12</b> (S<b>707</b> to S<b>708</b>).</p><p id="p-0168" num="0167">In the case where the reference count is equal to or greater than the threshold value (S<b>706</b>: No), or in the case where the logical address was not in the volatile area (S<b>704</b>: No), the media controller <b>11</b> adds metadata and a code to the data to be written back (S<b>707</b>). The media controller <b>11</b> writes the data to the SCM <b>12</b> (S<b>708</b>) and ends the refresh processing.</p><p id="p-0169" num="0168">The above procedure of the refresh/patrol processing in the second embodiment is the procedure of the refresh/patrol processing in the first embodiment shown in <figref idref="DRAWINGS">FIG. <b>16</b></figref>, except that the process of determining validity or invalidity using the PC value in S<b>304</b> to S<b>305</b> is replaced by the process of determining validity or invalidity using the reference count in S<b>705</b> to S<b>706</b>.</p><p id="p-0170" num="0169"><figref idref="DRAWINGS">FIG. <b>24</b></figref> is a flowchart showing a wear-leveling processing procedure executed by the memory system <b>1</b> (media controller <b>11</b>) of the second embodiment.</p><p id="p-0171" num="0170">The media controller <b>11</b> selects media address <b>1</b> of the data movement source (S<b>801</b>). The media controller <b>11</b> also selects media address <b>2</b> of the data movement destination (S<b>802</b>).</p><p id="p-0172" num="0171">The media controller <b>11</b> then reads data <b>1</b> from media address <b>1</b> (S<b>803</b>) and also reads data <b>2</b> from media address <b>2</b> (S<b>803</b>). The media controller <b>11</b> decodes data <b>1</b> (S<b>805</b>) and also decodes data <b>2</b> (S<b>806</b>). The media controller <b>11</b> then adds metadata and a code to data <b>1</b> (S<b>807</b>), and writes data <b>1</b> to media address <b>2</b> (S<b>808</b>).</p><p id="p-0173" num="0172">Subsequently, the media controller <b>11</b> determines whether or not logical address B of data <b>2</b> is a volatile area (S<b>809</b>). In the case where it is a volatile area (S<b>809</b>: Yes), the media controller <b>11</b> acquires a reference count corresponding to logical address B added to data <b>2</b> (S<b>810</b>). The media controller <b>11</b> determines whether or not the acquired reference count is greater than or equal to a threshold value (S<b>811</b>). In the case where it is less than the threshold value (S<b>811</b>: No), the media controller <b>11</b> updates the address translation table <b>1111</b> (S<b>814</b>) and ends the wear-leveling processing.</p><p id="p-0174" num="0173">In the case where it is greater than or equal to the threshold value (S<b>811</b>: Yes), or in the case where logical address B is not a volatile area (S<b>809</b>: No), the media controller <b>11</b> adds metadata and a code to data <b>2</b> (S<b>812</b>), and writes data <b>2</b> to media address <b>1</b> (S<b>813</b>). The media controller <b>11</b> updates the address translation table <b>1111</b> (S<b>814</b>) and ends the wear-leveling processing.</p><p id="p-0175" num="0174">Note that, as in the first embodiment, the media controller <b>11</b> may also perform processes equivalent to S<b>809</b> to S<b>811</b> for data <b>1</b> as a pre-process to S<b>807</b>. In the case where the media controller <b>11</b> comprises a reverse lookup table for translating media addresses to logical addresses, logical addresses A and B may be acquired by the reverse lookup table at the time of reading data <b>1</b> in S<b>803</b> and at the time of reading data <b>2</b> in S<b>804</b> to determine whether or not the data needs to be read. In this case, unnecessary reading of data can be further reduced.</p><p id="p-0176" num="0175">The above procedure of the wear-leveling processing in the second embodiment is the procedure of the wear-leveling processing in the first embodiment shown in <figref idref="DRAWINGS">FIG. <b>18</b></figref>, except that the process of determining validity or invalidity using the PC value in S<b>410</b> to S<b>411</b> is replaced by the process of determining validity or invalidity using the reference count in S<b>810</b> to S<b>811</b>.</p><p id="p-0177" num="0176">As described above, by omitting a part of the refresh processing or wear-leveling processing that is originally unnecessary, the memory system <b>1</b> of the second embodiment can also prevent the endurance of the SCM <b>12</b> from being consumed unnecessarily and extend the life of the SCM <b>12</b>.</p><p id="p-0178" num="0177"><figref idref="DRAWINGS">FIG. <b>25</b></figref> shows an example of a write amplification factor (WAF) reduction effect of the memory system <b>1</b> of the first or second embodiment.</p><p id="p-0179" num="0178"><figref idref="DRAWINGS">FIG. <b>25</b></figref>, part (A) shows a wear-leveling cycle (the number of times data is written from the host <b>2</b> to the memory system <b>1</b> between the time when certain data is moved by the wear-leveling processing and the time when the same data is moved again by the wear-leveling processing) on a horizontal axis, and a write amplification factor by the wear-leveling processing on a vertical axis. Graph (d<b>1</b>) shows a case in which writing back data in the invalid data area is performed, and graph (d<b>2</b>) shows a case in which writing back data in the invalid data area is omitted in the case of assuming that the area selected as the destination of moving data in the wear-leveling processing is always the invalid data area.</p><p id="p-0180" num="0179"><figref idref="DRAWINGS">FIG. <b>25</b></figref>, part (B) shows a calculation formula of a write amplification factor (WAF) by the wear-leveling processing. A media write amount is an amount of data that the media controller <b>11</b> has written to the SCM <b>12</b> in response to a command from the host <b>2</b>. A W/L write amount is an amount of data that the media controller <b>11</b> has written to the SCM <b>12</b> for the wear-leveling processing. The media controller <b>11</b>, for example, executes the writing of data to the SCM <b>12</b> in units of 128 bytes, and also executes the wear-leveling processing at a granularity of 4096 bytes for the data stored in the SCM <b>12</b>. A host write amount is an amount of data written to memory system <b>1</b> by host <b>2</b>.</p><p id="p-0181" num="0180">WAF<sub>d1 </sub>shows an example of applying the value in the case of performing data write back in the invalid data area (graph d<b>1</b>) as the W/L write amount upon calculation of the WAF. On the other hand, WAF<sub>d2 </sub>shows an example of applying the value in the case of omitting data write back in the invalid data area (graph d<b>2</b>) as the W/L write amount upon calculation of the WAF.</p><p id="p-0182" num="0181">As represented by graphs d<b>1</b> and d<b>2</b> in <figref idref="DRAWINGS">FIG. <b>25</b></figref>, part (A), in the case of omitting the writing back of data in the invalid data area, the write amplification factor by the wear-leveling processing can be reduced compared to the case of writing back data in the invalid data area. The reduction rate of the write amplification factor in the case where the wear-leveling cycle is 100 is 19.5%, and the reduction rate of the write amplification factor in the case where the wear-leveling cycle is 1000 is 3%. Therefore, a particularly high effect can be expected in the case where the wear-leveling cycle is short.</p><p id="p-0183" num="0182">In addition, although <figref idref="DRAWINGS">FIG. <b>25</b></figref> shows the reduction effect of the WAF by the wear-leveling processing, by omitting the writing back of data in the invalid data area, the memory system <b>1</b> of the first or second embodiment can also reduce the write amplification factor by the refresh processing in comparison to the case of writing back data in the invalid data area.</p><p id="p-0184" num="0183">While certain embodiments have been described, these embodiments have been presented by way of example only, and are not intended to limit the scope of the inventions. Indeed, the novel embodiments described herein may be embodied in a variety of other forms; furthermore, various omissions, substitutions and changes in the form of the embodiments described herein may be made without departing from the spirit of the inventions. The accompanying claims and their equivalents are intended to cover such forms or modifications as would fall within the scope and spirit of the inventions.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A memory system comprising:<claim-text>a non-volatile memory; and</claim-text><claim-text>a controller configured to control writing of data to the non-volatile memory or reading of data from the non-volatile memory in response to a command from a host, wherein</claim-text><claim-text>the controller is configured to manage a first area and a second area in a memory space provided to the host, to which an area of the non-volatile memory is mapped, the first area being an area used by the host as a main memory, the second area being an area where valid data is stored.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The memory system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the controller is configured to:<claim-text>execute wear-leveling processing to swap data in order to level out exhaustion of the non-volatile memory; and</claim-text><claim-text>in the wear-leveling processing, in a case where data read from the non-volatile memory is data in an area other than the second area, omit writing of the read data to the non-volatile memory, or omit reading of data from an area other than the second area of the non-volatile memory and writing of the data to the non-volatile memory.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The memory system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the controller is configured to determine that the second area includes an area other than the first area and an area in the first area that is accessed by the host after the host initializes the main memory.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The memory system of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein, in a case of being accessed by the host, the controller is configured to:<claim-text>manage first information for each predetermined unit area on the non-volatile memory including at least the first area, the first information being updated to a value indicating of the access from the host after the initialization of the main memory; and</claim-text><claim-text>determine whether or not the area is included in the second area by referring to the first information.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The memory system of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the controller is configured to:<claim-text>monitor second information stored in a third area on the memory space and used for managing the memory space by the host; and</claim-text><claim-text>determine whether or not the area is included in the second area by referring to a counter included the second information for each predetermined unit area on the memory space, the counter being incremented when allocated to a program running on the host and decremented when released.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The memory system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the controller is configured to, in a case of being notified by the host of an area on the memory space where data is no longer required, exclude the notified area from the second area.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The memory system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the controller is connected to the host by an interface that has a function to maintain cache coherency between the memory system and the host.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The memory system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the controller is configured to:<claim-text>execute refresh processing to write back data stored in the non-volatile memory; and</claim-text><claim-text>in the refresh processing, in a case where data read from the non-volatile memory is data in an area other than the second area, omit writing of the read data to the non-volatile memory, or omit reading of data from an area other than the second area of the non-volatile memory and writing of the data to the non-volatile memory.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The memory system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the controller is configured to determine that the second area includes an area other than the first area and an area in the first area that is accessed by the host after the host initializes the main memory.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The memory system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein, in a case of being accessed by the host, the controller is configured to:<claim-text>manage first information for each predetermined unit area on the non-volatile memory including at least the first area, the first information being updated to a value indicating of the access from the host after the initialization of the main memory; and</claim-text><claim-text>determine whether or not the area is included in the second area by referring to the first information.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The memory system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the controller is configured to:<claim-text>monitor second information stored in a third area on the memory space and used for managing the memory space by the host; and</claim-text><claim-text>determine whether or not the area is included in the second area by referring to a counter included the second information for each predetermined unit area on the memory space, the counter being incremented when allocated to a program running on the host and decremented when released.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The memory system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the controller is configured to, in a case of being notified by the host of an area on the memory space where data is no longer required, exclude the notified area from the second area.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The memory system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the controller is connected to the host by an interface that has a function to maintain cache coherency between the memory system and the host.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The memory system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the controller is configured to, in response to a read command from the host, transmit predetermined data indicating an error to the host in a case where an area specified by the read command is an area other than the second area.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The memory system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the controller is configured to determine that the second area includes an area other than the first area and an area in the first area that is accessed by the host after the host initializes the main memory.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The memory system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein, in a case of being accessed by the host, the controller is configured to:<claim-text>manage first information for each predetermined unit area on the non-volatile memory including at least the first area, the first information being updated to a value indicating of the access from the host after the initialization of the main memory; and</claim-text><claim-text>determine whether or not the area is included in the second area by referring to the first information.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The memory system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the controller is configured to:<claim-text>monitor second information stored in a third area on the memory space and used for managing the memory space by the host; and</claim-text><claim-text>determine whether or not the area is included in the second area by referring to a counter included the second information for each predetermined unit area on the memory space, the counter being incremented when allocated to a program running on the host and decremented when released.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The memory system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the controller is configured to, in a case of being notified by the host of an area on the memory space where data is no longer required, exclude the notified area from the second area.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The memory system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the controller is connected to the host by an interface that has a function to maintain cache coherency between the memory system and the host.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The memory system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the controller is connected to the host by an interface that has a function to maintain cache coherency between the memory system and the host.</claim-text></claim></claims></us-patent-application>