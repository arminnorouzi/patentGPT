<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004585A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004585</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17931167</doc-number><date>20220912</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>28</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>25</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>21</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>288</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>466</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>252</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>212</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">Processing Techniques for Database Transaction Requests with Operations Defined by Different ORM Libraries</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16804407</doc-number><date>20200228</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11442965</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17931167</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>PayPal, Inc.</orgname><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Adhikesavan</last-name><first-name>Rajasudharsan</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Patel</last-name><first-name>Jaykumar</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Sharma</last-name><first-name>Nikhil</first-name><address><city>Milpitas</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Joseph</last-name><first-name>Alwin</first-name><address><city>Dublin</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Techniques are disclosed relating to processing database transactions that include application operations defined by different object relational mapping (ORM) libraries. A transaction router module executing on a computer system receives, from an application, a request for a first database transaction, where the first database transaction includes first and second application operations. The transaction router module then translates the first application operation to one or more first database operations using a first ORM library and the second application operation to one or more second database operations using a second ORM library. Then, the transaction router module determines one or more database connections for the one or more first database operations and the one or more second database operations. Such techniques may advantageously allow applications to switch between using different persistence frameworks and message broker frameworks without substantial adjustments to application code.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="221.49mm" wi="158.75mm" file="US20230004585A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="232.24mm" wi="155.28mm" file="US20230004585A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="253.24mm" wi="169.42mm" file="US20230004585A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="250.02mm" wi="157.73mm" file="US20230004585A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="250.02mm" wi="169.42mm" file="US20230004585A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="250.02mm" wi="170.35mm" file="US20230004585A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="249.68mm" wi="144.10mm" file="US20230004585A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="127.34mm" wi="165.61mm" file="US20230004585A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">RELATED APPLICATIONS</heading><p id="p-0002" num="0001">The present application is a continuation of U.S. application Ser. No. 16/804,407 (Atty. Dkt. No 7879-13900), entitled &#x201c;Processing Techniques for Database Transaction Requests with Operations Defined by Different ORM Libraries,&#x201d; filed Feb. 28, 2020, the disclosure of which is incorporated by reference herein in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><heading id="h-0003" level="1">Technical Field</heading><p id="p-0003" num="0002">This disclosure relates generally to database transactions, and, more specifically, to techniques for managing database transactions with operations defined by different object relational mapping (ORM) libraries.</p><heading id="h-0004" level="1">Description of the Related Art</heading><p id="p-0004" num="0003">An ORM library may be used within the data access layer (DAL) of an application to interface with databases using an object-oriented framework. For example, ORM libraries may allow a developer of an application to write database commands using program code at a higher level of abstraction. Specifically, a developer may generate a database transaction using Python commands instead of SQL commands. To provide for this level of abstraction, an ORM library may include mappings between Python objects specified by the application and tables included in a database. Traditionally, when an application initiates a database transaction, all operations included in the transaction are defined by the same ORM library. For example, an application may initiate a transaction whose operations are defined by a database abstraction layer (DBAL) library.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating an example system configured to determine database connections for operations that are defined by different object relational mapping (ORM) libraries, according to some embodiments.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating an example system that processes only database transactions with operations that are all defined by the same ORM library, according to some embodiments.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram illustrating an example transaction router module that includes multiple transaction manager modules, according to some embodiments.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating an example transaction router module that handles multiple transaction objects per thread, according to some embodiments.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating example transaction management for applications implementing different types of data access layer (DAL) application programming interfaces (APIs), according to some embodiments.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram illustrating a method for processing database transactions with operations defined by different ORM libraries, according to some embodiments.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating an example computing device, according to some embodiments.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0012" num="0011">This specification includes references to various embodiments, to indicate that the present disclosure is not intended to refer to one particular implementation, but rather a range of embodiments that fall within the spirit of the present disclosure, including the appended claims. Particular features, structures, or characteristics may be combined in any suitable manner consistent with this disclosure.</p><p id="p-0013" num="0012">Within this disclosure, different entities (which may variously be referred to as &#x201c;units,&#x201d; &#x201c;circuits,&#x201d; other components, etc.) may be described or claimed as &#x201c;configured&#x201d; to perform one or more tasks or operations. This formulation&#x2014;[entity] configured to [perform one or more tasks]&#x2014;is used herein to refer to structure (i.e., something physical, such as an electronic circuit). More specifically, this formulation is used to indicate that this structure is arranged to perform the one or more tasks during operation. A structure can be said to be &#x201c;configured to&#x201d; perform some task even if the structure is not currently being operated. A &#x201c;computer system configured to translate application operations to database operations using one or more object relational mapping (ORMs) libraries&#x201d; is intended to cover, for example, a computer system that performs this function during operation, even if it is not currently being used (e.g., when its power supply is not connected). Thus, an entity described or recited as &#x201c;configured to&#x201d; perform some task refers to something physical, such as a device, circuit, memory storing program instructions executable to implement the task, etc. This phrase is not used herein to refer to something intangible.</p><p id="p-0014" num="0013">The term &#x201c;configured to&#x201d; is not intended to mean &#x201c;configurable to.&#x201d; An unprogrammed mobile computing device, for example, would not be considered to be &#x201c;configured to&#x201d; perform some specific function, although it may be &#x201c;configurable to&#x201d; perform that function. After appropriate programming, the mobile computing device may then be configured to perform that function.</p><p id="p-0015" num="0014">Reciting in the appended claims that a structure is &#x201c;configured to&#x201d; perform one or more tasks is expressly intended not to invoke 35 U.S.C. &#xa7; 112(f) for that claim element. Accordingly, none of the claims in this application as filed are intended to be interpreted as having means-plus-function elements. Should Applicant wish to invoke Section 112(f) during prosecution, it will recite claim elements using the &#x201c;means for&#x201d; [performing a function] construct.</p><p id="p-0016" num="0015">As used herein, the terms &#x201c;first,&#x201d; &#x201c;second,&#x201d; etc. are used as labels for nouns that they precede, and do not imply any type of ordering (e.g., spatial, temporal, logical, etc.) unless specifically stated. For example, in a computing system having multiple user accounts, the terms &#x201c;first&#x201d; and &#x201c;second&#x201d; user accounts can be used to refer to any users. In other words, the &#x201c;first&#x201d; and &#x201c;second&#x201d; user accounts are not limited to the initial two created user accounts, for example.</p><p id="p-0017" num="0016">As used herein, the term &#x201c;based on&#x201d; is used to describe one or more factors that affect a determination. This term does not foreclose the possibility that additional factors may affect the determination. That is, a determination may be solely based on specified factors or based on the specified factors as well as other, unspecified factors. Consider the phrase &#x201c;determine A based on B.&#x201d; This phrase specifies that B is a factor and is used to determine A or affects the determination of A. This phrase does not foreclose that the determination of A may also be based on some other factor, such as C. This phrase is also intended to cover an embodiment in which A is determined based solely on B. As used herein, the phrase &#x201c;based on&#x201d; is synonymous with the phrase &#x201c;based at least in part on.&#x201d;</p><p id="p-0018" num="0017">As used herein, the term &#x201c;module&#x201d; refers to circuitry configured to perform specified operations or to physical non-transitory computer readable media that store information (e.g., program instructions) that instructs other circuitry (e.g., a processor) to perform specified operations. Modules may be implemented as a memory having program instructions stored therein that are executable by one or more processors to perform the operations. A module may be any suitable form of non-transitory computer readable media storing program instructions executable to perform specified operations.</p><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0019" num="0018">Techniques are disclosed for processing database transactions that include application operations defined by different object relational mapping (ORM) libraries. In addition, the disclosed techniques provide for processing database transactions that include application operations that access different data sources. For example, in the context of an application that includes a Java persistence application programming interface (JPA) (one example of a persistence framework) in its data access layer (DAL), a request for a database transaction may include application operations defined by both a DBAL library (one example of an ORM library) and a hibernate library (another example of an ORM library). In this example, one of the DBAL-based operations may access data organized using a first database schema, while one of the hibernate-based operations may access data organized using a second database schema.</p><p id="p-0020" num="0019">As used herein, the term &#x201c;object relational mapping (ORM)&#x201d; is intended to be construed according to its well-understood meaning, which includes converting data between incompatible type systems using object-oriented programming. For example, an ORM library may enable interfacing with databases using an object-oriented framework. Specifically, an ORM library may include mappings between Java objects specified by a Java application and one or more database tables. Note that an ORM library may also be referred to as an ORM application programming interface (API). Examples of ORM libraries include, without limitation: hibernate API, DBAL API, Spring Java database connectivity (JDBC) template, Java Data Objects (JDO), DataNucleus, etc.</p><p id="p-0021" num="0020">As used herein, the term &#x201c;data access layer (DAL)&#x201d; is intended to be construed according to its well-understood meaning, which includes a layer of a computer program that provides simplified access to data stored in persistent storage. For example, the DAL may enable interfacing between an application and a database by performing a query to the database on behalf of the application and returning the results of the query to the application in the form of an application object (e.g., a Java object). The DAL of an application may be implemented using a persistence framework that includes one or more of the following: an ORM library, a database connection manager, a database connection pool, and a database driver. As one specific example, a DBAL-based application may include a DBAL ORM, a DBAL connection manager, a DBAL connection pool and a DBAL Oracle close callback (OCC) JDBC driver. As discussed above, in some situations, the DAL of an application may include a message broker framework such as ActiveMQ. In some cases, the persistence framework and the message broker framework include different ORM libraries. As used herein, &#x201c;a database connection&#x201d; is intended to be construed according to its well-understood meaning, which includes a path between an entity and a database that allows the entity to communicate with the database.</p><p id="p-0022" num="0021">Traditional transaction processing techniques process database transactions that include application operations defined by the same ORM library. For example, database transactions may be initiated by an application that includes a DAL that supports a single persistency solution for managing these database transactions. In such situations, database transactions initiated by the application include application operations defined by a single ORM library. For example, the application may utilize a DBAL library when translating application operations to database operations for a particular transaction. In such situations, database transactions initiated by the application cannot include application operations defined by different ORM libraries. In addition, a database transaction initiated by the application cannot include operations for different data sources, but rather must execute all operations on the same data source.</p><p id="p-0023" num="0022">In disclosed embodiments, database transactions that include operations defined by different ORM libraries may allow applications to implement newer persistence frameworks within their DAL in addition to legacy frameworks when requesting data from a database. For example, an application that is currently generating requests for database transactions using a DBAL library (an example legacy ORM library) may also begin to generate requests using a hibernate library (an example of a newer ORM library). In addition, disclosed techniques may address limitations faced by some JPA applications that use a hibernate library when attempting to use a message broker framework (e.g., Apache active message queuing (ActiveMQ)) that uses a DBAL library.</p><p id="p-0024" num="0023">In some embodiments, a hybrid transaction manager determines database connections for operations of a particular database transaction request that are defined by different ORM libraries (and that may access different data sources). The disclosed techniques may allow applications to slowly transition from generating operations defined by a first ORM library to generating operations defined by various other ORM libraries when generating requests for database transactions. For example, an application that is currently generating operations defined by a DBAL library may begin generating operations defined by a hibernate library without changing all of the current database operations to hibernate-based operations in one shot. Further, the disclosed techniques may advantageously allow applications to switch between using different persistence frameworks and message broker frameworks, for example, within the same transaction context.</p><heading id="h-0007" level="2">Example Multi-ORM System</heading><p id="p-0025" num="0024">Turning now to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, a block diagram is shown illustrating an example system configured to determine database connections for operations that are defined by different ORM libraries. In the illustrated embodiment, system <b>100</b> includes or implements an application <b>110</b>, a transaction router module <b>140</b>, and a database <b>150</b>.</p><p id="p-0026" num="0025">Transaction router module <b>140</b>, in the illustrated embodiment, receives a database transaction request <b>112</b> from application <b>110</b>. This request <b>112</b> includes application operations defined by different ORM libraries. Each application operation may be in a format defined by an ORM library for translation to underlying database operations. Using multiple appropriate ORM libraries <b>130</b>A-<b>130</b>N, transaction router module <b>140</b> is executable to translate application operations included in request <b>112</b> to database operations <b>122</b>. For example, transaction router module <b>140</b> may use ORM <b>130</b>A for a first set of operations defined by that library and ORM <b>120</b>B for a second set of operations defined by that library. Database operations <b>122</b> may be data access operations (DAOs) for database <b>150</b>. For example, database operations <b>122</b> may be DAOs that issue structured query language (SQL) statements to be executed in database <b>150</b>. Example DAOs include: &#x201c;findAll( ),&#x201d; &#x201c;update( )&#x201d; select( )&#x201d; etc. Use of ORM libraries may allow applications to be ported to various different database implementations.</p><p id="p-0027" num="0026">Transaction router module <b>140</b> may also be executable to select one or more connections <b>152</b> to database <b>150</b> for executing the database operations. Transaction router module <b>140</b> may be included in the DAL of an application <b>110</b> to abstract the complexity of a database by mapping application or business logic to database logic. For example, the database transaction request <b>112</b> may include one or more application operations that are written using business logic.</p><p id="p-0028" num="0027">In some embodiments, transaction router module <b>140</b> is executable to use ORM libraries <b>130</b> to translate application operations (e.g., Java operations) included in the database transaction to database operations (e.g., SQL commands). As used herein, the term &#x201c;database transaction&#x201d; is intended to be construed according to its well-understood meaning, which includes an atomic unit of work performed by a system with respect to a database. Database operations may be described as atomic when they must be committed or rolled back as a single unit. For example, if a database transaction includes a &#x201c;select( )&#x201d; operations and an &#x201c;insert( )&#x201d; operations, these operations must be committed or rolled back together.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a transaction router module <b>140</b> that can process database transactions that include operations defined by different ORM libraries. To further illustrate the embodiment shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, consider a system in which a transaction manager can only process database transactions whose operations are all defined by the same ORM library, as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Further, in <figref idref="DRAWINGS">FIG. <b>2</b></figref> two different transaction manager modules handle database transaction requests from an application implementing a DBAL API and an application implementing JPA, respectively. In contrast to the transaction router module <b>140</b> shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, each transaction manager module illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref> is executable to process database transactions where all operations within a given transaction are defined by the same ORM libraries.</p><heading id="h-0008" level="2">Example Single ORM System</heading><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating an example system that processes only database transactions with operations that are all defined by the same ORM library. In the illustrated embodiment, system <b>200</b> includes two transaction manager modules <b>210</b> for handling requests from DBAL applications and from JPA applications, respectively. In addition, system <b>200</b> includes various threads <b>220</b> for executing database transaction objects <b>212</b> and <b>214</b>.</p><p id="p-0031" num="0030">Transaction manager module <b>210</b>A, in the illustrated embodiment, is executable to receive database transaction requests <b>112</b>A from a DBAL application. DBAL applications may be applications that execute a DBAL API, for example. Each of these requests <b>112</b>A include application operations that are all defined by the same ORM library. For example, transaction manager module <b>210</b>A may translate all application operations included in a first database transaction using a DBAL library and may translate all application operations included in a second database transaction using a hibernate library. In addition to translating application operations specified in requests <b>112</b>A, transaction manager module <b>210</b>A initiates DBAL transaction objects <b>212</b> for respective database transactions. Transaction objects <b>212</b> each hold a connection to database <b>150</b>. Transaction manager module <b>210</b>A may rely on these objects <b>212</b>, for example, to handle commits or rollbacks for their respective database transactions. Transaction manager module <b>210</b>A, in the illustrated embodiment, executes DBAL transaction objects <b>212</b> using different threads <b>220</b>. For example, DBAL transaction object <b>212</b>A is executed within thread <b>220</b>A, while DBAL transaction object <b>212</b>B is executed within thread <b>220</b>B. As used herein, the term &#x201c;thread&#x201d; is intended to be construed according to its well-understood meaning, which includes a set of instructions that are executed independently of other instructions. For example, multiple threads are often simultaneously executed within a computer program.</p><p id="p-0032" num="0031">Transaction manager module <b>210</b>A is also executable to select connections to data source <b>262</b>A for database operations <b>222</b>A included in object <b>212</b>A. Similarly, transaction manager module <b>210</b>A selects connections to data source <b>262</b>B for database operations <b>222</b>B included in object <b>212</b>B. In some situations, the DBAL application specifies a different data source entry in its application configuration file for each data source accessed by the application. For example, the DBAL application may specify that data source <b>262</b>A is a first database schema accessed by the application, while data source <b>262</b>B is a second database schema accessed by the application. For example, the business logic of an application may specify to access these two data sources for a given transaction. These connections may be selected from a pool of database connections maintained for database <b>150</b> (and/or other databases). As used herein, the term &#x201c;data source&#x201d; refers to a structured set of persistent data that is stored and accessible. For example, a data source may be any type of durable storage, including without restriction: a database (e.g., an OLTP database), a database schema, a key-value store, a messaging system, etc.</p><p id="p-0033" num="0032">Transaction manager module <b>210</b>B, in the illustrated embodiment, is executable to receive a database transaction request <b>112</b>B from JPA applications. In some situations, database transaction request <b>112</b>B specifies application operations defined by a hibernate library. Transaction manager module <b>210</b>B translates these application operations to database operations using a hibernate library and initiates a hibernate transaction object <b>214</b> for the database transaction. Transaction manager module <b>210</b>B executes hibernate transaction object <b>214</b> within thread <b>230</b> by selecting a connection to data source <b>262</b>C for hibernate transaction object <b>214</b>. In the illustrated embodiment, transaction manager modules <b>210</b> handle transactions that include operations for a single data source. Therefore, in this example embodiment, different transaction managers handle different database transactions and within a given transaction all operations are defined by a single ORM library and are for a single data source.</p><p id="p-0034" num="0033">Although <figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates one database transaction processing embodiment, these techniques do not provide for processing database transactions that include operations defined by different ORM libraries. For example, the system shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> may require an application that is currently generating operations defined by a DBAL library to change all of its current database operations to hibernate-based operations in a single shot, even in situations where the application is generating a single database transaction that includes operations defined by two different ORM libraries.</p><p id="p-0035" num="0034">In contrast to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, <figref idref="DRAWINGS">FIGS. <b>3</b> and <b>4</b></figref> illustrate two different implementations of transaction router module <b>140</b>, illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, for handling database transactions that include application operations defined by different ORM libraries and that may access different data sources. For example, <figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates an implementation in which transaction router module <b>140</b> uses multiple different transaction manager modules to process database transactions, while <figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an implementation in which transaction router module <b>140</b> processes database transactions without using multiple transaction manager modules. In addition, in the embodiment of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, each transaction manager module handles a single transaction object per thread, while in the embodiment of <figref idref="DRAWINGS">FIG. <b>3</b></figref> transaction router module <b>140</b> handles multiple transaction objects per thread. Further, in <figref idref="DRAWINGS">FIG. <b>3</b></figref> each transaction object may use multiple database connections, while in <figref idref="DRAWINGS">FIG. <b>3</b></figref> each transaction object uses only a single database connection.</p><heading id="h-0009" level="2">Example Transaction Router Module</heading><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram illustrating an example transaction router module that includes multiple transaction manager modules. In the illustrated embodiment, system <b>300</b> includes a transaction router module <b>140</b> and a database <b>150</b>. Transaction router module <b>140</b> in turn includes a manager selection module <b>310</b>, a list <b>312</b> of transaction manager modules, and two different transaction manager modules <b>330</b>.</p><p id="p-0037" num="0036">Transaction router module <b>140</b>, in the illustrated embodiment, is executable to receive database transaction requests <b>112</b> and an application configuration file <b>302</b> from application <b>110</b>. Application configuration file <b>302</b> may be an extensible markup language (XML) file called dsimport.xml, for example. In some embodiments, at the startup of application <b>110</b>, transaction router module <b>140</b> instantiates a transaction manager module <b>330</b> for each data source specified in the application configuration file <b>302</b> and maintains a list <b>312</b> of these modules. In the illustrated example, database transaction requests <b>112</b> include application operations defined by different ORM libraries. In addition, respective database transaction requests <b>112</b> may include operations for different data sources. As a result, transaction router module <b>140</b> selects different transaction manager module <b>330</b> for different database transaction requests <b>112</b> based on the data sources associated with those requests.</p><p id="p-0038" num="0037">Manager selection module <b>310</b>, in the illustrated embodiment, accesses list <b>312</b> of transaction manager modules and selects one or more transaction manager modules <b>330</b> based on the data sources specified in database transaction requests <b>112</b>. Manager selection module <b>310</b> assigns a first database transaction <b>314</b>A to transaction manager module <b>330</b>A and a second database transaction <b>314</b>B to transaction manager module <b>330</b>B. In some embodiments, manager selection module <b>310</b> assigns a database transaction to a particular transaction manager module based on the data source accessed by the first operation included in the transaction. For example, list <b>312</b> may specify a mapping between the data source accessed by the first operation and the particular transaction manager module. In situations where a database transaction includes operations that access different data sources, the data source of the first operation will dictate which transaction manager module is assigned; however, the assigned transaction manager module will select different database connections, within a transaction object, for the operations based on their different data sources.</p><p id="p-0039" num="0038">Transaction manager module <b>330</b>A processes database transaction <b>214</b>A using a single transaction object <b>332</b>A within a single thread <b>320</b>A, while transaction manager module <b>330</b>B processes database transaction <b>314</b>B using a single transaction object <b>332</b>B within a single thread <b>320</b>B.</p><p id="p-0040" num="0039">Within thread <b>320</b>A, transaction manager module <b>330</b>A translates application operations included in database transaction <b>314</b>A to database operations using different ORM libraries. For example, a first application operation included in database transaction <b>314</b>A may be translated using a DBAL library to generate database operation <b>322</b>A, while a second application operation included in database transaction <b>314</b>A may be translated using a hibernate library. Further, in this example, transaction manager module <b>330</b>A translates a third application operation included in database transaction <b>314</b>A using the DBAL library to generate database operation <b>322</b>C for data source <b>262</b>B. Transaction manager module <b>330</b>A, in the illustrated embodiment, selects a database connection to data source <b>262</b>A for database operations <b>322</b>A and <b>322</b>B based on those database operations accessing this data source and selects a different database connection for data source <b>262</b>B for database operations <b>322</b>C based on this database operations accessing this data source. Database transaction <b>314</b>A may include the following:</p><p id="p-0041" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="175pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>JPA Transaction.start( )</entry></row><row><entry/><entry>&#x2003;Hibernate DB op1</entry></row><row><entry/><entry>&#x2003;DBAL DB op2</entry></row><row><entry/><entry>&#x2003;Hibernate DB op3</entry></row><row><entry/><entry>JPA Transaction.commit( ) or Rollback( )</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>In this example, transaction <b>314</b>A is generated by a JPA application and includes operations defined by both hibernate and DBAL libraries. Further, in this example, hibernate database operation <b>1</b> and DBAL database operation <b>2</b> access a first data source, while hibernate database operation <b>3</b> accesses a second data source. Note that, in this example, operations defined by different ORM libraries access the same data source.</p><p id="p-0042" num="0040">Similar to transaction manager module <b>330</b>A, within thread <b>320</b>B, transaction manager module <b>330</b>B translates application operations included in database transaction <b>314</b>B to database operations using different ORM libraries. For example, transaction manager module <b>330</b>B may use a spring JDBC template and a hibernate library to translate application operations of database transaction <b>314</b>B to database operations <b>324</b>. Then, transaction manager module <b>330</b>B selects a database connection for data source <b>262</b>B (which is a JPA schema) for executing database operations <b>324</b>. Transaction manager modules <b>330</b> execute individual transactions using a single thread. For example, transaction manager module <b>330</b>A executes database operations <b>322</b> using a first thread, while transaction manager module <b>330</b>B executes database operations <b>324</b> using a second thread. In addition, transaction manager modules <b>330</b> execute database operations <b>322</b> and database operations <b>324</b> using a single transaction object, respectively. Thus, in the example embodiment shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref> transaction manager modules <b>330</b> each hold a single transaction object per thread.</p><p id="p-0043" num="0041">Turning now to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, a block diagram is shown illustrating an example transaction router module <b>140</b> that handles multiple transactions objects per thread. In the illustrated embodiment, system <b>400</b> includes transaction router module <b>140</b>, with transaction control module <b>410</b> and database <b>150</b>.</p><p id="p-0044" num="0042">Transaction control module <b>410</b>, in the illustrated embodiment, is executable to receive database transaction requests <b>112</b> and application configuration file <b>302</b> from application <b>110</b>. Module <b>410</b> translates application operations included in database transaction requests <b>112</b> using multiple appropriate ORM libraries to generate database transactions <b>412</b>A and <b>412</b>B. Module <b>410</b> then executes these database transactions <b>412</b> using two different threads <b>420</b>.</p><p id="p-0045" num="0043">Specifically, transaction router module <b>140</b> executes two different transaction objects <b>432</b>A and <b>432</b>B within thread <b>420</b>A. Transaction module initiates objects <b>432</b> based on database transaction <b>412</b>A including database operations for two different data sources. For example, transaction object <b>432</b>A includes database operations <b>422</b>A for data source <b>262</b>A, while transaction object <b>432</b>B includes database operations <b>422</b>C for data source <b>262</b>C. Database operations <b>422</b>A may include data access objects (DAOs) that are initiated using both a DBAL library and a hibernate library and that access data source <b>262</b>A.</p><p id="p-0046" num="0044">Transaction control module <b>410</b> processes database transaction <b>412</b>B by generating two different transaction objects <b>434</b>A and <b>434</b>B to handle database operations <b>422</b>B for data source <b>262</b>B and database operations <b>422</b>D for data source <b>262</b>D, respectively. Transaction router module <b>140</b> executes transaction objects <b>434</b> within the same application thread <b>420</b>B.</p><p id="p-0047" num="0045">As one specific example, database transaction <b>412</b>B may include the following database operations: &#x201c;DAO<b>1</b>.findAll( );&#x201d;, &#x201c;DAO<b>2</b>.selectByID( );&#x201d;, &#x201c;DAO<b>3</b>.update( );&#x201d;. DAO<b>1</b> accesses data source <b>262</b>B, while DAO<b>2</b> and DAO<b>3</b> access data source <b>262</b>D. As a result, in this example, transaction control module <b>410</b> initiates transaction object <b>434</b>A for DAO<b>1</b> and transaction object <b>434</b>B for DAO<b>2</b> and DAO<b>3</b>. In this example, transaction router module <b>140</b> manages two different database connections, one for each of data sources <b>262</b> and performs commits or rollbacks on the two different connections sequentially. Performance of commits or rollbacks may provide an application with more control over commit failures, for example.</p><p id="p-0048" num="0046">The embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref> may provide more fine-grained control to owners of an application in terms of handling commit or rollback failures for database transactions on different data sources. In contrast, the embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref> may obscure the complexities of these failures from owners of the application initiating these database transactions. The embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref> may prevent errors from being introduced by the owner of an application, for example, in situations where the owner may miss invoking a commit or rollback for a particular transaction. Both of these embodiments, however, advantageously provide techniques for processing database transactions that includes operations defined by different ORM libraries and that may access different data sources.</p><p id="p-0049" num="0047">Although <figref idref="DRAWINGS">FIGS. <b>3</b> and <b>4</b></figref> illustrate two embodiments of database transaction processing by transaction router module <b>140</b>, <figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates and example interaction of the transaction router module with applications implementing different DAL frameworks. The techniques discussed with reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref> may advantageously allow multiple applications each implementing different DAL frameworks to interact with the same transaction router module <b>140</b> for processing database transactions.</p><heading id="h-0010" level="2">Example DBAL and Spring Application Communication</heading><p id="p-0050" num="0048">Turning now to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, a block diagram is shown illustrating example transaction management for applications implementing different types of DAL frameworks. In the illustrated embodiment, system <b>500</b> includes DBAL application <b>510</b>, spring application <b>520</b>, and DBAL/spring application <b>530</b>. Application <b>510</b> uses the DBAL framework, application <b>520</b> uses the spring framework, and application <b>530</b> uses both frameworks. For example, while application <b>510</b> uses DBAL DAOs and application <b>520</b> uses spring DAOs, application <b>530</b> uses both DBAL and spring DAOs. Note that applications <b>510</b>, <b>520</b>, and <b>530</b> are examples of application <b>110</b> shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0051" num="0049">At initialization, DBAL application <b>510</b> provides DBAL configuration file <b>512</b> to transaction router module <b>140</b>. Based on one or more data sources specified in DBAL configuration file <b>512</b>, transaction router module <b>140</b> generates transaction manager modules and stores a local list <b>312</b>A of transaction manager modules that includes a map of data source names to transaction manager modules, as well as information <b>540</b> mapping transaction manager modules to their respective data sources based on the different data source names.</p><p id="p-0052" num="0050">Spring application <b>520</b> provides spring configuration file <b>522</b> to spring application context <b>550</b>, in the illustrated embodiment. Spring application context <b>550</b> then generates transaction manager modules for data sources specified in file <b>522</b> and maintains a list <b>312</b>B of these transaction manager modules.</p><p id="p-0053" num="0051">DBAL/spring Application <b>530</b>, in the illustrated embodiment, provides DBAL/spring configuration file <b>532</b> to transaction router module <b>140</b>. Based on the data sources specified in file <b>532</b>, transaction router module <b>140</b> updates the local list <b>312</b>A of transaction manager modules. For example, transaction router module <b>140</b> may generate additional transaction manager modules for new data sources listed in file <b>532</b> and may add a map of these additional transaction manager modules to the new data source names to information <b>540</b>.</p><p id="p-0054" num="0052">Transaction router module <b>140</b> receives requests <b>514</b> and <b>534</b> from applications <b>510</b> and <b>530</b>, respectively. After receiving request <b>514</b> from DBAL application <b>510</b>, transaction router module <b>140</b> checks whether spring application context <b>550</b> is available to this application. Since application <b>510</b> is a DBAL application, spring application context <b>550</b> is not available and, as such, transaction router module <b>140</b> provides a transaction manager module <b>330</b>A from list <b>312</b>A to application <b>510</b>. After receiving request <b>534</b> from application <b>530</b>, transaction router module <b>140</b> accesses spring application context <b>550</b> to obtain transaction manager module <b>330</b>C from list <b>312</b>B based on application <b>530</b> implementing the spring framework and, therefore, having access to the spring application context. Spring application context <b>550</b>, after receiving request <b>524</b> from spring application <b>520</b>, selects transaction manager module <b>330</b>B from list <b>312</b>B and provides this module to spring application <b>520</b> for managing a transaction. The system shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates, for example, that transaction router module <b>140</b> is executable to interact with existing applications such as applications <b>510</b> and <b>520</b> as well as new, hybrid transactions such as application <b>530</b>.</p><heading id="h-0011" level="2">Example Methods</heading><p id="p-0055" num="0053"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram illustrating a method for processing database transactions with operations defined by different ORM libraries according to some embodiments. The method <b>600</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref> may be used in conjunction with any of the computer circuitry, systems, devices, elements, or components disclosed herein, among other devices. In various embodiments, some of the method elements shown may be performed concurrently, in a different order than shown, or may be omitted. Additional method elements may also be performed as desired.</p><p id="p-0056" num="0054">At <b>610</b>, in the illustrated embodiment, a transaction router module receives, from an application, a request for a first database transaction, where the first database transaction includes first and second application operations. In some embodiments, the request for the first database transaction generated using a data access layer (DAL) application programming interface (API), where a configuration file of the DAL API specified one or more database schemas.</p><p id="p-0057" num="0055">At <b>620</b>, the transaction router module translates the first application operation to one or more first database operations using a first object relational mapping (ORM) library and the second application operation to one or more second database operations using a second ORM library. In some embodiments, the first ORM library is a database abstraction layer (DBAL) library, and wherein the second ORM library is a hibernate library.</p><p id="p-0058" num="0056">In some embodiments, the transaction router module accesses mapping information that specifies mappings between data sources and transaction manager modules in a set of transaction manager modules included in the transaction router module. In some embodiments, the transaction router module selects a transaction manager module to process the first database transaction based on a data source of the first database transaction and the mapping information. In some embodiments, the selected transaction manager module accesses different data sources for the first and second database operations using database connections corresponding to the different data sources.</p><p id="p-0059" num="0057">In some embodiments, the transaction router module receives a configuration file that specifies one or more data sources accessed by the application. In some embodiments, the transaction router module generates, based on the specified one or more data sources, the set of transaction manager modules and the mapping information. In some embodiments, a first data source specified in the first database transaction is organized according to a first database schema, and wherein a second data source specified in the first database transaction is organized according to a second database schema. In some embodiments, a first data source specified in the first database transaction is a first database and wherein a second data source specified in the first database transaction is a second, different database.</p><p id="p-0060" num="0058">At <b>630</b>, the transaction router module determines one or more database connections for the one or more first database operations and the one or more second database operations. In some embodiments, the transaction router module accesses, based on the determined database connections, a first data source for the one or more first database operations and a second data source for the one or more second database operations.</p><p id="p-0061" num="0059">In some embodiments, the transaction router module processes, using different threads, multiple requests for different database transactions that access different data sources, where the processing includes generating multiple transaction objects for the first database transaction. In some embodiments, the processing includes accessing, by the transaction router module, different data sources for respective transaction objects initiated for the first database transaction. In some embodiments, the multiple requests for different database transactions are generated using different data access layer (DAL) application programming interfaces (APIs) that include different corresponding ORM libraries.</p><p id="p-0062" num="0060">In some embodiments, the transaction router module receives transaction requests from first and second applications using different DAL APIs. In some embodiments, the transaction router module determines, for the first and second application, whether a first list of transaction manager modules is available to the applications. In some embodiments, the transaction router module accesses, based on the determining, one of the first list of transaction manager modules and a second list of transaction manager modules.</p><heading id="h-0012" level="2">Example Computing Device</heading><p id="p-0063" num="0061">Turning now to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, a block diagram of one embodiment of computing device (which may also be referred to as a computing system) <b>710</b> is depicted. Computing device <b>710</b> may be used to implement various portions of this disclosure. Computing device <b>710</b> may be any suitable type of device, including, but not limited to, a personal computer system, desktop computer, laptop or notebook computer, mainframe computer system, web server, workstation, or network computer. As shown, computing device <b>710</b> includes processing unit <b>750</b>, storage <b>712</b>, and input/output (I/O) interface <b>730</b> coupled via an interconnect <b>760</b> (e.g., a system bus). I/O interface <b>730</b> may be coupled to one or more I/O devices <b>740</b>. Computing device <b>710</b> further includes network interface <b>732</b>, which may be coupled to network <b>720</b> for communications with, for example, other computing devices.</p><p id="p-0064" num="0062">In various embodiments, processing unit <b>750</b> includes one or more processors. In some embodiments, processing unit <b>750</b> includes one or more coprocessor units. In some embodiments, multiple instances of processing unit <b>750</b> may be coupled to interconnect <b>760</b>. Processing unit <b>750</b> (or each processor within <b>750</b>) may contain a cache or other form of on-board memory. In some embodiments, processing unit <b>750</b> may be implemented as a general-purpose processing unit, and in other embodiments it may be implemented as a special purpose processing unit (e.g., an ASIC). In general, computing device <b>710</b> is not limited to any particular type of processing unit or processor subsystem.</p><p id="p-0065" num="0063">Storage subsystem <b>712</b> is usable by processing unit <b>750</b> (e.g., to store instructions executable by and data used by processing unit <b>750</b>). Storage subsystem <b>712</b> may be implemented by any suitable type of physical memory media, including hard disk storage, floppy disk storage, removable disk storage, flash memory, random access memory (RAM-SRAM, EDO RAM, SDRAM, DDR SDRAM, RDRAM, etc.), ROM (PROM, EEPROM, etc.), and so on. Storage subsystem <b>712</b> may consist solely of volatile memory, in one embodiment. Storage subsystem <b>712</b> may store program instructions executable by computing device <b>710</b> using processing unit <b>750</b>, including program instructions executable to cause computing device <b>710</b> to implement the various techniques disclosed herein.</p><p id="p-0066" num="0064">I/O interface <b>730</b> may represent one or more interfaces and may be any of various types of interfaces configured to couple to and communicate with other devices, according to various embodiments. In one embodiment, I/O interface <b>730</b> is a bridge chip from a front-side to one or more back-side buses. I/O interface <b>730</b> may be coupled to one or more I/O devices <b>740</b> via one or more corresponding buses or other interfaces. Examples of I/O devices include storage devices (hard disk, optical drive, removable flash drive, storage array, SAN, or an associated controller), network interface devices, user interface devices or other devices (e.g., graphics, sound, etc.).</p><p id="p-0067" num="0065">Various articles of manufacture that store instructions (and, optionally, data) executable by a computing system to implement techniques disclosed herein are also contemplated. The computing system may execute the instructions using one or more processing elements. The articles of manufacture include non-transitory computer-readable memory media. The contemplated non-transitory computer-readable memory media include portions of a memory subsystem of a computing device as well as storage media or memory media such as magnetic media (e.g., disk) or optical media (e.g., CD, DVD, and related technologies, etc.). The non-transitory computer-readable media may be either volatile or nonvolatile memory.</p><p id="p-0068" num="0066">Although specific embodiments have been described above, these embodiments are not intended to limit the scope of the present disclosure, even where only a single embodiment is described with respect to a particular feature. Examples of features provided in the disclosure are intended to be illustrative rather than restrictive unless stated otherwise. The above description is intended to cover such alternatives, modifications, and equivalents as would be apparent to a person skilled in the art having the benefit of this disclosure.</p><p id="p-0069" num="0067">The scope of the present disclosure includes any feature or combination of features disclosed herein (either explicitly or implicitly), or any generalization thereof, whether or not it mitigates any or all of the problems addressed herein. Accordingly, new claims may be formulated during prosecution of this application (or an application claiming priority thereto) to any such combination of features. In particular, with reference to the appended claims, features from dependent claims may be combined with those of the independent claims and features from respective independent claims may be combined in any appropriate manner and not merely in the specific combinations enumerated in the appended claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method related to translation of database transaction application operations specified in at least one of a first programming language and a second, different programming language, comprising:<claim-text>receiving, by a computer system, a request for a first database transaction and a request for a second database transaction;</claim-text><claim-text>translating, by the computer system, one or more application operations included in the first database transaction and specified in a first programming language to one or more first database operations;</claim-text><claim-text>translating, by the computer system, one or more application operations included in the second database transaction and specified in a second, different programming language to one or more second database operations, wherein the computer system is configured to translate application operations that are defined using different object relational mappings (ORMs) to database operations; and</claim-text><claim-text>determining, by the computer system, one or more database connections for the one or more first database operations and the one or more second database operations.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the request for the first database transaction is received from a first application and the request for the second database transaction is received from a second, different application.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>accessing, by the computer system, mapping information that specifies mappings between data sources and transaction manager modules in a set of transaction manager modules included in the computer system; and</claim-text><claim-text>selecting, by the computer system, a transaction manager module to process the first database transaction based on a data source of the first database transaction and the mapping information, wherein the selected transaction manager module is configured to accesses different data sources for the first and second database operations using database connections corresponding to the different data sources.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein prior to selecting a transaction manager module to process the first database transaction, the method further comprises:<claim-text>receiving, by the computer system, a configuration file that specifies one or more data sources accessed by an application corresponding to at least one of the request for the first database transaction and the request for the second database transaction;</claim-text><claim-text>generating, by the computer system based on the one or more data sources specified in the configuration file, the set of transaction manager modules and the mapping information; and</claim-text><claim-text>storing, by the computer system, a local list specifying a map of data source names to transaction manager modules included in the set of transaction manager modules.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein a first data source specified in the first database transaction is organized according to a first database schema, and wherein a second data source specified in the first database transaction is organized according to a second database schema.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>processing, by the computer system using different threads, multiple requests for different database transactions that access different data sources, wherein the processing includes generating multiple transaction objects for the first database transaction, and wherein the multiple requests for different database transactions are generated using different data access layer (DAL) application programming interfaces (APIs) that include different corresponding ORM libraries.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining the one or more database connections includes:<claim-text>selecting, from an existing pool of database connections maintained by a database of the computer system, the one or more database connections.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>receiving, by the computer system, transaction requests from first and second applications using different data access layer (DAL) application programming interfaces (APIs);</claim-text><claim-text>determining, by the computer system for the first and second application, whether a first list of transaction manager modules is available to the applications; and</claim-text><claim-text>accessing, by the computer system based on the determining, one of the first list of transaction manager modules and a second list of transaction manager modules.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. A non-transitory computer-readable medium having instructions stored thereon that are executable by a computing system to perform operations for translating database transaction application operations specified in at least one of a first programming language and a second, different programming language, the operations comprising:<claim-text>receiving a request for a first database transaction and a request for a second database transaction;</claim-text><claim-text>translating one or more application operations included in the first database transaction that are defined by a first object relational mapping (ORM) and specified in a first programming language to one or more first database operations;</claim-text><claim-text>translating one or more application operations included in the second database transaction that are defined by a second ORM and specified in a second, different programming language to one or more second database operations; and</claim-text><claim-text>determining, by the computer system, one or more database connections for the one or more first database operations and the one or more second database operations.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the request for the first database transaction is received from a first application and the request for the second database transaction is received from a second, different application.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the operations further comprise:<claim-text>accessing mapping information that specifies mappings between data sources and transaction manager modules in a set of transaction manager modules; and</claim-text><claim-text>selecting a transaction manager module to process the first database transaction based on a data source of the first database transaction and the mapping information, wherein the selected transaction manager module accesses different data sources for the first and second database operations using database connections corresponding to the different data sources.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein prior to selecting a transaction manager module to process the first database transaction the operations further comprise:<claim-text>receiving a configuration file that specifies one or more data sources accessed by an application corresponding to at least one of the request for the first database transaction and the request for the second database transaction; and</claim-text><claim-text>generating, based on the one or more data sources specified in the configuration file, the set of transaction manager modules and the mapping information.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the operations further comprise:<claim-text>storing a local list specifying a map of data source names to transaction manager modules included in the set of transaction manager modules.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the operations further comprise:<claim-text>processing, using different threads, multiple requests for different database transactions that access different data sources, wherein the processing includes generating multiple transaction objects for the first database transaction.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the operations further comprise:<claim-text>receiving transaction requests from first and second applications using different data access layer (DAL) application programming interfaces (APIs);</claim-text><claim-text>determining, for the first and second applications, whether a first list of transaction manager modules is available to the applications; and</claim-text><claim-text>accessing, based on the determining, one of the first list of transaction manager modules and a second list of transaction manager modules.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. A system, comprising:<claim-text>at least one processor; and</claim-text><claim-text>a memory having instructions stored thereon that are executable by the at least one processor to cause the system to:<claim-text>receive a request for a first database transaction and a request for a second database transaction;</claim-text><claim-text>translate one or more application operations included in the first database transaction that are defined by a first set of object relational mappings (ORMs) to one or more first database operations;</claim-text><claim-text>translate one or more application operations included in the second database transaction that are defined by a second set of ORMs to one or more second database operations, wherein the system is configured to translate database transactions that are specified in different programming languages; and</claim-text><claim-text>identify one or more database connections for the one or more first database operations and the one or more second database operations.</claim-text></claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the instructions are further executable by the at least one processor to cause the system to:<claim-text>access mapping information that specifies mappings between data sources and transaction manager modules in a set of transaction manager modules included in a transaction router module executed by the system; and</claim-text><claim-text>select a transaction manager module to process the first database transaction based on a data source of the first database transaction and the mapping information.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the instructions are further executable by the at least one processor to cause the system to:<claim-text>process, using different threads, multiple requests for different database transactions that access different data sources, wherein the processing includes generating multiple transaction objects for the first database transaction, and wherein the request for the first database transaction generated using a data access layer (DAL) application programming interface (API), and wherein a configuration file of the DAL API specifies one or more database schemas.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the request for the first database transaction is received from a first application and the request for the second database transaction is received from a second, different application.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the first set of ORMs is a database abstraction layer (DBAL) library, and wherein the second set of ORMs is a hibernate library.</claim-text></claim></claims></us-patent-application>