<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007257A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007257</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17890967</doc-number><date>20220818</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="regional"><country>EP</country><doc-number>18306135.7</doc-number><date>20180823</date></priority-claim><priority-claim sequence="02" kind="regional"><country>EP</country><doc-number>18306212.4</doc-number><date>20180917</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>124</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>159</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>18</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>196</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>124</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>159</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>18</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>197</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e79">CODING OF QUANTIZATION MATRICES USING PARAMETRIC MODELS</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17267014</doc-number><date>20210208</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11457214</doc-number></document-id></parent-grant-document><parent-pct-document><document-id><country>WO</country><doc-number>PCT/US2019/045687</doc-number><date>20190808</date></document-id></parent-pct-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17890967</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>InterDigital VC Holdings France, SAS</orgname><address><city>Cesson Sevigne</city><country>FR</country></address></addressbook><residence><country>FR</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>DE LAGRANGE</last-name><first-name>Philippe</first-name><address><city>Cesson-Sevigne</city><country>FR</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>CHEN</last-name><first-name>Ya</first-name><address><city>Cesson-Sevigne</city><country>FR</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>FRANCOIS</last-name><first-name>Edouard</first-name><address><city>Cesson-Sevigne</city><country>FR</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Quantization matrix can be used to adjust quantization of transform coefficients at different frequencies. In one embodiment, a single fixed parametric model, such as a polynomial is used to represent a quantization matrix. Modulation of bit cost and complexity is achieved by specifying only the n first polynomial coefficients, the remaining ones being implicitly set to zero or other default values. One form of the single fixed polynomial is a fully developed polynomial in (x,y), where x,y indicate the coordinates of a given coefficient in a quantization matrix, with terms ordered by increasing exponent. Since higher exponents are the last ones, reducing the number of polynomial coefficients reduces the degree of the polynomial, hence its complexity. The polynomial coefficients can be symmetrical in x and y, and thus reducing the number of polynomial coefficients that need to be signaled in the bitstream.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="97.37mm" wi="158.75mm" file="US20230007257A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="207.69mm" wi="137.75mm" orientation="landscape" file="US20230007257A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="178.48mm" wi="155.11mm" file="US20230007257A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="205.91mm" wi="156.21mm" file="US20230007257A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="219.63mm" wi="158.50mm" file="US20230007257A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="189.06mm" wi="157.99mm" file="US20230007257A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="167.47mm" wi="156.97mm" file="US20230007257A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="205.91mm" wi="159.26mm" file="US20230007257A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="149.86mm" wi="155.53mm" file="US20230007257A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="215.39mm" wi="156.72mm" file="US20230007257A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="192.11mm" wi="130.30mm" file="US20230007257A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="189.23mm" wi="157.06mm" file="US20230007257A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="175.43mm" wi="154.26mm" file="US20230007257A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="234.44mm" wi="145.63mm" file="US20230007257A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="222.67mm" wi="157.23mm" file="US20230007257A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="231.06mm" wi="161.54mm" file="US20230007257A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="230.80mm" wi="137.75mm" file="US20230007257A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a Continuation of U.S. application Ser. No. 17/267,014, filed Feb. 8, 2021, which is a National Phase entry under 35 U.S.C. &#xa7; 371 of International Application No. PCT/US2019/045687, filed Aug. 8, 2019, which claims the benefit of European Patent Application No. 18306212.4, filed Sep. 17, 2018 and European Patent Application No. 18306135.7 filed Aug. 23, 2018, the entirety of which is incorporated by reference herein.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">The present embodiments generally relate to a method and an apparatus for video encoding or decoding, and more particularly, to a method and an apparatus for coding quantization matrices in video encoding or decoding.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">To achieve high compression efficiency, image and video coding schemes usually employ prediction and transform to leverage spatial and temporal redundancy in the video content. Generally, intra or inter prediction is used to exploit the intra or inter frame correlation, then the differences between the original block and the predicted block, often denoted as prediction errors or prediction residuals, are transformed, quantized, and entropy coded. To reconstruct the video, the compressed data are decoded by inverse processes corresponding to the entropy coding, quantization, transform, and prediction.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0005" num="0004">According to an embodiment, a method for video decoding is presented, comprising: accessing a parametric model that is based on a sequence of parameters; determining a plurality of parameters that correspond to a subset of said sequence of parameters; associating each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; de-quantizing transform coefficients of a block of an image based on said quantization matrix; and reconstructing said block of said image responsive to said de-quantized transform coefficients.</p><p id="p-0006" num="0005">According to another embodiment, a method for video encoding is presented, comprising: accessing a parametric model that is based on a sequence of parameters; determining a plurality of parameters that correspond to a subset of said sequence of parameters; associating each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; quantizing transform coefficients of a block of an image based on said quantization matrix; and entropy encoding quantized transform coefficients.</p><p id="p-0007" num="0006">According to another embodiment, an apparatus for video decoding is presented, comprising: means for accessing a parametric model that is based on a sequence of parameters; means for determining a plurality of parameters that correspond to a subset of said sequence of parameters; means for associating each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; means for de-quantizing transform coefficients of a block of an image based on said quantization matrix; and means for reconstructing said block of said image responsive to said de-quantized transform coefficients.</p><p id="p-0008" num="0007">According to another embodiment, an apparatus for video encoding is presented, comprising: means for accessing a parametric model that is based on a sequence of parameters; means for determining a plurality of parameters that correspond to a subset of said sequence of parameters; means for associating each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; means for quantizing transform coefficients of a block of an image based on said quantization matrix; and means for entropy encoding quantized transform coefficients.</p><p id="p-0009" num="0008">According to another embodiment, an apparatus for video decoding is presented, comprising one or more processors, wherein said one or more processors are configured to: access a parametric model that is based on a sequence of parameters; determine a plurality of parameters that correspond to a subset of said sequence of parameters; associate each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; de-quantize transform coefficients of a block of an image based on said quantization matrix; and reconstruct said block of said image responsive to said de-quantized transform coefficients. The apparatus can further comprise one or more memories coupled to said one or more processors.</p><p id="p-0010" num="0009">According to another embodiment, an apparatus for video encoding is presented, comprising one or more processors, wherein said one or more processors are configured to: access a parametric model that is based on a sequence of parameters; determine a plurality of parameters that correspond to a subset of said sequence of parameters; associate each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; quantize transform coefficients of a block of an image based on said quantization matrix; and entropy encode quantized transform coefficients. The apparatus can further comprise one or more memories coupled to said one or more processors.</p><p id="p-0011" num="0010">According to another embodiment, a signal is formatted to include: a value indicating a number of parameters in a plurality of parameters; said plurality of parameters, wherein each parameter of said plurality of parameters is associated with a corresponding parameter of a subset of a sequence of parameters, to represent a quantization matrix, wherein a parametric model is based on said sequence of parameters; and transform coefficients of a block of an image quantized based on said quantization matrix.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a block diagram of an embodiment of a video encoder.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a block diagram of an embodiment of a video decoder.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a pictorial example illustrating 2D separable transform.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates the default intra and inter 8&#xd7;8 quantization matrices (QMs) defined in HEVC.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a process for determining the QM in HEVC.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates the up-right diagonal scanning and the default intra 8&#xd7;8 QM in HEVC.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates different transforms used in JEM (Joint Exploration Model).</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates the example matrices found in standards and encoders.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates two complex-shaped matrices.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates the AVC-type (left) and HVS (right) matrices for size 8, 16 and 32.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>11</b>A</figref> illustrates example matrix layers for an 8&#xd7;8 size, and <figref idref="DRAWINGS">FIG. <b>11</b>B</figref> illustrates 4 regions.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates fitting performance of [JCTVC-H0460] quadratic models for symmetric (left) or asymmetric (right) test intra matrices of size 8&#xd7;8.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates an example of quantization matrix using approximation.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates 16&#xd7;16 AV1 quantization matrices.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates the quantization matrix coding performance.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates a system for decoding the quantization matrix, according to an embodiment.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>17</b></figref> illustrates a method for decoding the quantization matrix, according to an embodiment.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>18</b></figref> illustrates a method for normalizing the matrix coordinates, according to an embodiment.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>19</b></figref> illustrates the dynamic range of coefficients.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>20</b></figref> illustrates the impact of coefficient accuracy on fit quality.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>21</b></figref> illustrates the impact of coefficient bounds on fit quality.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>22</b></figref> illustrates a quantization matrix generator with integer computing, according to an embodiment.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>23</b></figref> illustrates a method for generating a quantization matrix with integer computing, according to an embodiment.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>24</b></figref> illustrates the default HEVC intra matrix with 10-parameter fit.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>25</b></figref> illustrates the impact of clipping on fitting errors.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>26</b></figref> illustrates the default HEVC intra matrix with 6-parameter fit.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>27</b></figref> illustrates a method for generating the QM in an encoder, according to an embodiment.</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>28</b></figref> illustrates a method for generating the QM in a decoder, according to an embodiment.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>29</b></figref> illustrates a block diagram of a system within which aspects of the present embodiments can be implemented.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an exemplary video encoder <b>100</b>, such as a High Efficiency Video Coding (HEVC) encoder. <figref idref="DRAWINGS">FIG. <b>1</b></figref> may also illustrate an encoder in which improvements are made to the HEVC standard or an encoder employing technologies similar to HEVC, such as a VVC (Versatile Video Coding) encoder under development by JVET (Joint Video Exploration Team).</p><p id="p-0042" num="0041">In the present application, the terms &#x201c;reconstructed&#x201d; and &#x201c;decoded&#x201d; may be used interchangeably, the terms &#x201c;encoded&#x201d; or &#x201c;coded&#x201d; may be used interchangeably, and the terms &#x201c;image,&#x201d; &#x201c;picture&#x201d; and &#x201c;frame&#x201d; may be used interchangeably. Usually, but not necessarily, the term &#x201c;reconstructed&#x201d; is used at the encoder side while &#x201c;decoded&#x201d; is used at the decoder side.</p><p id="p-0043" num="0042">Before being encoded, the video sequence may go through pre-encoding processing (101), for example, applying a color transform to the input color picture (e.g., conversion from RGB 4:4:4 to YCbCr 4:2:0), or performing a remapping of the input picture components in order to get a signal distribution more resilient to compression (for instance using a histogram equalization of one of the color components). Metadata can be associated with the pre-processing, and attached to the bitstream.</p><p id="p-0044" num="0043">In HEVC, to encode a video sequence with one or more pictures, a picture is partitioned (<b>102</b>) into one or more slices where each slice can include one or more slice segments. A slice segment is organized into coding units, prediction units, and transform units. The HEVC specification distinguishes between &#x201c;blocks&#x201d; and &#x201c;units,&#x201d; where a &#x201c;block&#x201d; addresses a specific area in a sample array (e.g., luma, Y), and the &#x201c;unit&#x201d; includes the collocated blocks of all encoded color components (Y, Cb, Cr, or monochrome), syntax elements, and prediction data that are associated with the blocks (e.g., motion vectors).</p><p id="p-0045" num="0044">For coding, a picture is partitioned into coding tree blocks (CTB) of square shape with a configurable size, and a consecutive set of coding tree blocks is grouped into a slice. A Coding Tree Unit (CTU) contains the CTBs of the encoded color components. A CTB is the root of a quadtree partitioning into Coding Blocks (CB), and a Coding Block may be partitioned into one or more Prediction Blocks (PB) and forms the root of a quadtree partitioning into Transform Blocks (TBs). Corresponding to the Coding Block, Prediction Block, and Transform Block, a Coding Unit (CU) includes the Prediction Units (PUs) and the tree-structured set of Transform Units (TUs), a PU includes the prediction information for all color components, and a TU includes residual coding syntax structure for each color component. The size of a CB, PB, and TB of the luma component applies to the corresponding CU, PU, and TU. In the present application, the term &#x201c;block&#x201d; can be used to refer, for example, to any of CTU, CU, PU, TU, CB, PB, and TB. In addition, the &#x201c;block&#x201d; can also be used to refer to a macroblock and a partition as specified in H.264/AVC or other video coding standards, and more generally to refer to an array of data of various sizes.</p><p id="p-0046" num="0045">In the exemplary encoder <b>100</b>, a picture is encoded by the encoder elements as described below. The picture to be encoded is processed in units of CUs. Each CU is encoded using either an intra or inter mode. When a CU is encoded in an intra mode, it performs intra prediction (<b>160</b>). In an inter mode, motion estimation (<b>175</b>) and compensation (<b>170</b>) are performed. The encoder decides (<b>105</b>) which one of the intra mode or inter mode to use for encoding the CU, and indicates the intra/inter decision by a prediction mode flag. Prediction residuals are calculated by subtracting (<b>110</b>) the predicted block from the original image block.</p><p id="p-0047" num="0046">The prediction residuals are then transformed (<b>125</b>) and quantized (<b>130</b>). The quantized transform coefficients, as well as motion vectors and other syntax elements, are entropy coded (<b>145</b>) to output a bitstream. The encoder may also skip the transform and apply quantization directly to the non-transformed residual signal on a 4&#xd7;4 TU basis. The encoder may also bypass both transform and quantization, i.e., the residual is coded directly without the application of the transform or quantization process. In direct PCM coding, no prediction is applied and the coding unit samples are directly coded into the bitstream.</p><p id="p-0048" num="0047">The encoder decodes an encoded block to provide a reference for further predictions. The quantized transform coefficients are de-quantized (<b>140</b>) and inverse transformed (<b>150</b>) to decode prediction residuals. Combining (<b>155</b>) the decoded prediction residuals and the predicted block, an image block is reconstructed. In-loop filters (<b>165</b>) are applied to the reconstructed picture, for example, to perform deblocking/SAO (Sample Adaptive Offset) filtering to reduce encoding artifacts. The filtered image is stored at a reference picture buffer (<b>180</b>).</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a block diagram of an exemplary video decoder <b>200</b>, such as an HEVC decoder. In the exemplary decoder <b>200</b>, a bitstream is decoded by the decoder elements as described below. Video decoder <b>200</b> generally performs a decoding pass reciprocal to the encoding pass as described in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, which performs video decoding as part of encoding video data. <figref idref="DRAWINGS">FIG. <b>2</b></figref> may also illustrate a decoder in which improvements are made to the HEVC standard or a decoder employing technologies similar to HEVC, such as a VVC decoder.</p><p id="p-0050" num="0049">In particular, the input of the decoder includes a video bitstream, which may be generated by video encoder <b>100</b>. The bitstream is first entropy decoded (<b>230</b>) to obtain transform coefficients, motion vectors, picture partitioning information, and other coded information. The picture partitioning information indicates the size of the CTUs, and a manner a CTU is split into CUs, and possibly into PUs when applicable. The decoder may therefore divide (<b>235</b>) the picture into CTUs, and each CTU into CUs, according to the decoded picture partitioning information. The transform coefficients are de-quantized (<b>240</b>) and inverse transformed (<b>250</b>) to decode the prediction residuals.</p><p id="p-0051" num="0050">Combining (<b>255</b>) the decoded prediction residuals and the predicted block, an image block is reconstructed. The predicted block may be obtained (<b>270</b>) from intra prediction (<b>260</b>) or motion-compensated prediction (i.e., inter prediction) (<b>275</b>). In-loop filters (<b>265</b>) are applied to the reconstructed image. The filtered image is stored at a reference picture buffer (<b>280</b>). The decoded picture can further go through post-decoding processing (<b>285</b>), for example, an inverse color transform (e.g. conversion from YCbCr 4:2:0 to RGB 4:4:4) or an inverse remapping performing the inverse of the remapping process performed in the pre-encoding processing (<b>101</b>). The post-decoding processing may use metadata derived in the pre-encoding processing and signaled in the bitstream.</p><p id="p-0052" num="0051">As described above, the prediction residuals are transformed and quantized. Considering an M&#xd7;N (M columns&#xd7;N rows) residual block ([U]<sub>M&#xd7;N</sub>) that is input to a 2D M&#xd7;N forward transform, the 2D transform is typically implemented by applying an N-point transform to each column (i.e., vertical transform) and an M-point transform to each row (i.e., horizontal transform) separately, as illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. Mathematically, the forward transform can be expressed as:</p><p id="p-0053" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>[<i>C]</i><sub>M&#xd7;N</sub><i>=[A]</i><sup>T</sup><sub>N&#xd7;N</sub><i>x[U]</i><sub>M&#xd7;N</sub><i>x[B]</i><sub>M&#xd7;M </sub><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0054" num="0000">where [A]<sub>N&#xd7;N </sub>is the N-point transform matrix applied vertically, and [B]<sub>M&#xd7;M </sub>the M-point transform matrix applied horizontally, and &#x201c;T&#x201d; (superscript) is the matrix transposition operator. Thus, the separable transform consists in applying the horizontal and vertical transforms successively on each row and each column of the 2D residual block.</p><p id="p-0055" num="0052">In HEVC, the 2D transforms use the same separable transform for both horizontal and vertical filtering. In other words, matrix B is same as matrix A:</p><p id="p-0056" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>[<i>C]</i><sub>M&#xd7;N</sub><i>=[A]</i><sup>T</sup><sub>N&#xd7;N</sub><i>&#xd7;[U]</i><sub>M&#xd7;N</sub><i>&#xd7;[A]</i><sub>M&#xd7;M </sub><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0057" num="0053">Note that in HEVC, only square transforms are supported, which means N=M.</p><p id="p-0058" num="0054">The resulting M&#xd7;N transform coefficients ([C]<sub>M&#xd7;N</sub>) are then subject to quantization to obtain quantized transform coefficients ([CQ]<sub>M&#xd7;N</sub>). In HEVC, Uniform Reconstruction Quantization (URQ) is used for quantization, which is conceptually equivalent to division by quantization step size (Qstep). More generally for video encoding, it should be noted that other quantization methods may be used, for example, by further considering a quantization rounding offset or using non-uniform quantization.</p><p id="p-0059" num="0055">To quantize the transform coefficients, in HEVC, the encoder can specify, for each transform block size and separately for intra and inter prediction, a customized quantization (scaling) matrix (QM) for use in inverse-quantization scaling by the decoder. The quantization matrix is typically designed to provide more accuracy to coefficients corresponding to frequencies more sensitive to human perception. The goal is to adapt the quantization of the transform coefficients to improve the perceptual quality of the coded video, typically by taking into account the properties of the human visual system to different spatial frequencies of the signal. For example, low frequencies are less quantized than the high frequencies.</p><p id="p-0060" num="0056">Using the quantization matrix generally does not improve objective fidelity as measured by mean-squared error (or, equivalently, PSNR), but it usually improves subjective fidelity. Default values for the quantization scaling matrices are specified in the standard, and the encoder can also choose to use customized values by sending a representation of those values at the sequence or picture level.</p><p id="p-0061" num="0057">More specifically, the transform coefficients are quantized according to the scaling values provided in quantization matrices. After the transform is applied to the residual values, luma and chroma transform coefficients in a Transform Block are individually quantized according to the integer scaling values that are present in the intra and inter QMs for the specific component and block size: 6 matrices for each of transform sizes 4&#xd7;4, 8&#xd7;8, 16&#xd7;16, and 2 matrices for 32&#xd7;32 (chroma in 4:4:4 sampling mode reuses the matrices for 16&#xd7;16), which makes a total of 20 matrices. To reduce memory storage needs, matrix definition is limited to 8&#xd7;8 resolution: full matrices for transform sizes 16&#xd7;16 and 32&#xd7;32 are obtained by 2&#xd7;2 and 4&#xd7;4 sample repetition, respectively.</p><p id="p-0062" num="0058">The HEVC specification defines default intra and inter QMs in HEVC, that are based on human visual model. If the default matrices are not used as indicated using flags, ad hoc matrices explicitly signaled in the bitstream can be used.</p><p id="p-0063" num="0059">The elements in the QMs apply different quantization scaling to transform coefficients at different frequencies in a Transform Block. Therefore, these QMs possess the capacity to control the quantization step size, and thus to adjust the quantization according to the frequency of the transform coefficient. A Transform Block contains DC and AC transform coefficients, where the DC transform coefficient is the lowest frequency component and the AC coefficients correspond to frequency components from low, medium to high. Because low frequency transform coefficients are usually more important for video signal reconstruction, the default QMs in HEVC apply coarser quantization to medium and high frequency AC transform coefficients.</p><p id="p-0064" num="0060">The quantization at the encoder side is not normative and can be done in different ways. Nevertheless, it typically reproduces or approximates the following formula for an HEVC encoder:</p><p id="p-0065" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>CQ[x][y]</i>=sign(<i>C[x][y</i>])*(<i>abs</i>(<i>C[x][y</i>])*invScale[<i>QP</i>% 6]/<i>QM[x][y]+</i>quantOffset)&#x3e;&#x3e;quantShift<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0066" num="0000">where<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0061">CQ is the block of quantized coefficients,</li>        <li id="ul0002-0002" num="0062">C is the block of transform coefficients,</li>        <li id="ul0002-0003" num="0063">QM is the quantization matrix,</li>        <li id="ul0002-0004" num="0064">invScale[k]={26214, 23302, 20560, 18396, 16384, 14564} with k=0, . . . , 5,</li>        <li id="ul0002-0005" num="0065">QP is the quantization parameter,</li>        <li id="ul0002-0006" num="0066">quantShift is a parameter that depends on the scaling involved by the forward transform applied at the encoder, on the transform block size, on the signal bit depth, and on QP.        <ul id="ul0003" list-style="none">            <li id="ul0003-0001" num="0067">In the HEVC reference encoder, quantShift=14+QP+TransformShift, where TransformShift relates to the scaling involved by the forward transform,</li>        </ul>        </li>        <li id="ul0002-0007" num="0068">quantOffset is a parameter that depends on parameter quantShift, for instance, quantOffset=1&#x3c;&#x3c;(quantShift&#x2014;1),</li>        <li id="ul0002-0008" num="0069">(x,y) is the location of the coefficient,</li>        <li id="ul0002-0009" num="0070">abs(r) is the absolute value of r,</li>        <li id="ul0002-0010" num="0071">sign(r)=&#x2212;1 if r&#x3c;0, 1 otherwise,</li>        <li id="ul0002-0011" num="0072">&#x201c;*&#x201d; is the scalar multiplication, &#x201c;/&#x201d; is the integer division with truncation of the result toward zero, and &#x201c;%&#x201d; is the modulus operator.</li>    </ul>    </li></ul></p><p id="p-0067" num="0073">At the decoder side, the QM can be applied in the de-quantization conforming to the HEVC specification based on the following formula:</p><p id="p-0068" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>C&#x2032;[x][y]</i>=(<i>CQ[x][y]*QM[x][y]</i>*levScale[<i>QP</i>%6]&#x3c;&#x3c;(<i>QP/</i>6))+(1&#x3c;&#x3c;(bdShift&#x2212;1)))&#x3e;&#x3e;bdShift<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0069" num="0000">where<ul id="ul0004" list-style="none">    <li id="ul0004-0001" num="0000">    <ul id="ul0005" list-style="none">        <li id="ul0005-0001" num="0074">CQ is the block of quantized coefficients,</li>        <li id="ul0005-0002" num="0075">C&#x2032; is the block of de-quantized coefficients,</li>        <li id="ul0005-0003" num="0076">QM is the quantization matrix,</li>        <li id="ul0005-0004" num="0077">levScale[k]={40, 45, 51, 57, 64, 72} with k=0, . . . , 5,</li>        <li id="ul0005-0005" num="0078">QP is the quantization parameter,</li>        <li id="ul0005-0006" num="0079">bdShift is defined as follows for the HEVC usual profiles: bdShift=Max(20&#x2014;bitDepth, 0), bitDepth is the bit depth of the samples of the considered component (e.g., Y, Cb or Cr),</li>        <li id="ul0005-0007" num="0080">(x,y) is the location of the coefficient.</li>    </ul>    </li></ul></p><p id="p-0070" num="0081">Default QMs are defined in HEVC for 8&#xd7;8 transform blocks only, in order to reduce the memory storage needs. The default intra and inter 8&#xd7;8 QMs defined in HEVC are shown below and illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref> (note that they are both symmetric). The QMs for larger blocks are obtained by upsampling the 8&#xd7;8 QMs. To create a 16&#xd7;16 QM, each entry in an 8&#xd7;8 QM is replicated into a 2&#xd7;2 region. To create a 32&#xd7;32 QM, each entry in an 8&#xd7;8 QM is replicated into a 4&#xd7;4 region. For 4&#xd7;4 transform blocks, the default QM is flat (all components are equal to 16). The default QMs only depend on the intra/inter mode, but are the same for the Y, Cb and Cr components. The replication rule could also be applied to rectangular blocks (e.g., rectangular blocks in JEM).</p><p id="p-0071" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mrow>   <mo>(</mo>   <mtable>    <mtr>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>21</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>19</mn>     </mtd>     <mtd>      <mn>22</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>20</mn>     </mtd>     <mtd>      <mn>22</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>     <mtd>      <mn>29</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>21</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>27</mn>     </mtd>     <mtd>      <mn>31</mn>     </mtd>     <mtd>      <mn>36</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>20</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>30</mn>     </mtd>     <mtd>      <mn>35</mn>     </mtd>     <mtd>      <mn>41</mn>     </mtd>     <mtd>      <mn>47</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>19</mn>     </mtd>     <mtd>      <mn>22</mn>     </mtd>     <mtd>      <mn>27</mn>     </mtd>     <mtd>      <mn>35</mn>     </mtd>     <mtd>      <mn>44</mn>     </mtd>     <mtd>      <mn>54</mn>     </mtd>     <mtd>      <mn>65</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>21</mn>     </mtd>     <mtd>      <mn>22</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>     <mtd>      <mn>31</mn>     </mtd>     <mtd>      <mn>41</mn>     </mtd>     <mtd>      <mn>54</mn>     </mtd>     <mtd>      <mn>70</mn>     </mtd>     <mtd>      <mn>88</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>     <mtd>      <mn>29</mn>     </mtd>     <mtd>      <mn>36</mn>     </mtd>     <mtd>      <mn>47</mn>     </mtd>     <mtd>      <mn>65</mn>     </mtd>     <mtd>      <mn>88</mn>     </mtd>     <mtd>      <mn>115</mn>     </mtd>    </mtr>   </mtable>   <mo>)</mo>  </mrow>  <mo>&#x2062;</mo>  <mrow>   <mo>(</mo>   <mtable>    <mtr>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>20</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>20</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>20</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>     <mtd>      <mn>28</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>16</mn>     </mtd>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>20</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>     <mtd>      <mn>28</mn>     </mtd>     <mtd>      <mn>33</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>17</mn>     </mtd>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>20</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>     <mtd>      <mn>28</mn>     </mtd>     <mtd>      <mn>33</mn>     </mtd>     <mtd>      <mn>41</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>18</mn>     </mtd>     <mtd>      <mn>20</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>     <mtd>      <mn>28</mn>     </mtd>     <mtd>      <mn>33</mn>     </mtd>     <mtd>      <mn>41</mn>     </mtd>     <mtd>      <mn>54</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>20</mn>     </mtd>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>     <mtd>      <mn>28</mn>     </mtd>     <mtd>      <mn>33</mn>     </mtd>     <mtd>      <mn>41</mn>     </mtd>     <mtd>      <mn>54</mn>     </mtd>     <mtd>      <mn>71</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>24</mn>     </mtd>     <mtd>      <mn>25</mn>     </mtd>     <mtd>      <mn>28</mn>     </mtd>     <mtd>      <mn>33</mn>     </mtd>     <mtd>      <mn>41</mn>     </mtd>     <mtd>      <mn>54</mn>     </mtd>     <mtd>      <mn>71</mn>     </mtd>     <mtd>      <mn>91</mn>     </mtd>    </mtr>   </mtable>   <mo>)</mo>  </mrow> </mrow></math></maths></p><p id="p-0072" num="0082">The intra default QM is based on the human visual system, as explained in a patent application by M. Hague et al. (U.S. patent application Ser. No. 13/597,131, Publication No. US2013/0188691, &#x201c;Quantization matrix design for HEVC standard&#x201d;, hereinafter [US20130188691]) or in an article by Long-Wen Chang et al., entitled &#x201c;Designing JPEG quantization tables based on human visual system,&#x201d; Signal Processing: Image Communication, Volume 16, Issue 5, pp 501-506, January 2001 (hereinafter [Chang]), and can be derived as explained in the following process. At first, f, the radial frequency in cycles per degree of the visual angle corresponding to the coefficient at location (x,y), is defined as:</p><p id="p-0073" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mrow>       <mi>f</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <mi>x</mi>        <mo>,</mo>        <mi>y</mi>       </mrow>       <mo>)</mo>      </mrow>      <mo>=</mo>      <mrow>       <mfrac>        <mi>K</mi>        <mrow>         <mrow>          <mi>&#x394;</mi>          <mo>&#xb7;</mo>          <mn>2</mn>         </mrow>         <mo>&#x2062;</mo>         <mi>N</mi>        </mrow>       </mfrac>       <mo>&#x2062;</mo>       <mfrac>        <msqrt>         <mrow>          <msup>           <mi>x</mi>           <mn>2</mn>          </msup>          <mo>+</mo>          <msup>           <mi>y</mi>           <mn>2</mn>          </msup>         </mrow>        </msqrt>        <mrow>         <mi>S</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mi>&#x3b8;</mi>         <mo>)</mo>        </mrow>       </mfrac>       <mo>&#x2062;</mo>       <mtext>   </mtext>       <mi>where</mi>      </mrow>     </mrow>     <mo>&#x2062;</mo>     <mtext></mtext>     <mrow>      <mrow>       <mi>&#x3b8;</mi>       <mo>=</mo>       <mrow>        <mi>arc</mi>        <mo>&#x2062;</mo>        <mrow>         <mi>tan</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mfrac>          <mi>u</mi>          <mi>v</mi>         </mfrac>         <mo>)</mo>        </mrow>       </mrow>      </mrow>      <mo>,</mo>      <mrow>       <mrow>        <mi>S</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mi>&#x3b8;</mi>        <mo>)</mo>       </mrow>       <mo>=</mo>       <mrow>        <mrow>         <mfrac>          <mrow>           <mn>1</mn>           <mo>-</mo>           <mi>s</mi>          </mrow>          <mn>2</mn>         </mfrac>         <mo>*</mo>         <mrow>          <mi>cos</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <mn>4</mn>           <mo>&#x2062;</mo>           <mi>&#x3b8;</mi>          </mrow>          <mo>)</mo>         </mrow>        </mrow>        <mo>+</mo>        <mfrac>         <mrow>          <mn>1</mn>          <mo>+</mo>          <mi>s</mi>         </mrow>         <mn>2</mn>        </mfrac>       </mrow>      </mrow>      <mo>,</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>1</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0074" num="0000">and N is the block width or height (u=0, . . . , N&#x2212;1, v=0, . . . , N&#x2212;1, typically N=8), &#x394;, K and s are constant parameters (to get the HEVC 8&#xd7;8 QM, A should be set to 0.00025, K to 0.00893588, s to 0.7).</p><p id="p-0075" num="0083">Then the Modulation Transfer Function H(f) is defined as</p><p id="p-0076" num="0000"><maths id="MATH-US-00003" num="00003"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>H</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mi>f</mi>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mrow>      <mo>{</mo>      <mtable>       <mtr>        <mtd>         <mrow>          <mn>2.2</mn>          <mo>&#xb7;</mo>          <mrow>           <mo>(</mo>           <mrow>            <mn>0.192</mn>            <mo>+</mo>            <mrow>             <mn>0.114</mn>             <mo>&#xb7;</mo>             <mi>f</mi>            </mrow>           </mrow>           <mo>)</mo>          </mrow>          <mo>&#xb7;</mo>          <mrow>           <mi>exp</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <mo>-</mo>            <msup>             <mrow>              <mo>(</mo>              <mrow>               <mn>0.114</mn>               <mo>&#xb7;</mo>               <mi>f</mi>              </mrow>              <mo>)</mo>             </mrow>             <mn>1.1</mn>            </msup>           </mrow>           <mo>)</mo>          </mrow>         </mrow>        </mtd>        <mtd>         <mrow>          <mrow>           <mi>if</mi>           <mo>&#x2062;</mo>           <mtext>   </mtext>           <mi>f</mi>          </mrow>          <mo>&#x3e;</mo>          <msub>           <mi>f</mi>           <mi>max</mi>          </msub>         </mrow>        </mtd>       </mtr>       <mtr>        <mtd>         <mn>1</mn>        </mtd>        <mtd>         <mi>otherwise</mi>        </mtd>       </mtr>      </mtable>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>2</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0077" num="0000">where f<sub>max</sub>=8 (cycles per degree). The QM values are computed as Round(16/H(f)) where Round(x) gives the nearest integer value to x.</p><p id="p-0078" num="0084">The inter default QM can be derived from the intra default QM using the following process:<ul id="ul0006" list-style="none">    <li id="ul0006-0001" num="0000">    <ul id="ul0007" list-style="none">        <li id="ul0007-0001" num="0085">1. QMinter(0,0)=QMintra(0,0)</li>        <li id="ul0007-0002" num="0086">2. For n=1 . . . N&#x2212;1        <ul id="ul0008" list-style="none">            <li id="ul0008-0001" num="0087">QMinter(0,n)=QMinter(0,n&#x2212;1)+int(S1*(QMintra(0,n)&#x2212;QMintra(0,n&#x2212;1))+0.5),</li>            <li id="ul0008-0002" num="0088">With S1=0.714285714</li>        </ul>        </li>        <li id="ul0007-0003" num="0089">3. QMinter(0,N&#x2212;1)=QMintra(0,N&#x2212;1)</li>        <li id="ul0007-0004" num="0090">4. For m=1 . . . N&#x2212;1        <ul id="ul0009" list-style="none">            <li id="ul0009-0001" num="0091">QMinter(m,N&#x2212;1)=QMinter(m&#x2212;1,N&#x2212;1)+int(S3*(QMintra(m,N&#x2212;1)&#x2212;QMintra(m&#x2212;1,N&#x2212;1))+0.5),</li>            <li id="ul0009-0002" num="0092">With S3=0.733333333, where int(r) is the nearest integer value of r,</li>        </ul>        </li>        <li id="ul0007-0005" num="0093">5. For m=1 . . . N&#x2212;1, For n=0 . . . N&#x2212;2        <ul id="ul0010" list-style="none">            <li id="ul0010-0001" num="0094">QMinter(m, n)=QMinter(m&#x2212;1, n+1)</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0079" num="0095">The coefficients of the quantization matrices are signaled in the bitstream using scaling lists. There is one scaling list per block size, indexed by the parameter sizeld, and per mode, indexed by the parameter matrixId, both specified as follows:<ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0096">sizeId=0&#x2014;block 4&#xd7;4, 1&#x2014;block 8&#xd7;8, 2&#x2014;block 16&#xd7;16, 3&#x2014;block 32&#xd7;32</li>        <li id="ul0012-0002" num="0097">matrixId=0&#x2014;intra Y, 1&#x2014;intra U, 2&#x2014;intra V, 3&#x2014;inter Y, 4&#x2014;inter U, 5&#x2014;inter V For 32&#xd7;32 blocks, matrixId can only be set to 0 or 3.</li>    </ul>    </li></ul></p><p id="p-0080" num="0098">The syntax in HEVC specification for signaling the scaling list is reproduced as follows.</p><p id="p-0081" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>scaling_list_data( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;for( sizeId = 0; sizeId &#x3c; 4; sizeId++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;for( matrixId = 0; matrixId &#x3c; 6; matrixId += ( sizeId = = 3) ? 3 : 1) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;scaling_list_pred_mode_flag[ sizeId ][ matrixId ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if(! scaling_list_pred_mode_flag_sizeId ][ matrixId ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;scaling_list_pred_matrix_id_delta[ sizeId ][ matrixId ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;nextCoef = 8</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;coefNum = Min( 64, (1 &#x3c;&#x3c; (4 + ( sizeId &#x3c;&#x3c; 1 ) ) ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( sizeId &#x3e; l) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;scaling_list_dc_coef_minus8[ sizeId - 2 ][ matrixId ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;nextCoef&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;=</entry><entry/></row><row><entry>scaling_list_dc_coef_minus8[ sizeId &#x2212; 2 ][ matrixId ] + 8</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; coefNum; i++) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;scaling_list_delta_coef</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;nextCoef = ( nextCoef + scaling_list_delta_coef + 256 ) % 256</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ScalingList[ sizeId ][ matrixId ][ i ] = nextCoef</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0082" num="0099">For each possible value of the two parameters sizeld and matrixId, process <b>500</b> illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref> is applied to determine the actual QM from either the default QM, or from explicit decoded values for an exemplary HEVC decoder. At step <b>510</b>, the decoder checks whether the syntax element scaling_list_pred_mode_flag[sizeId][matrixId] is equal to 0. If not, at step <b>550</b>, the decoder decodes scaling list values from the variable ScalingList[sizeId][matrixId][i], i=0, . . . , coefNum&#x2212;1, and builds the QM by the up-right diagonal scanning order as shown in the left of <figref idref="DRAWINGS">FIG. <b>6</b></figref>. If scaling_list_pred_mode_flag[sizeId][matrixId] is equal to 0, at step <b>520</b>, the decoder checks whether the syntax element scaling_list_pred_matrix_id_delta[sizeId][matrixId] is equal to 0. If not, matrixId is modified (<b>530</b>) based on scaling_list_pred_matrix_id_delta[sizeId][matrixId]. At step <b>540</b>, the scaling list values from the default scaling list values identified by sizeld and matrixId are obtained, and the QM is built, where the default matrix for 8&#xd7;8 intra is shown in the right of <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0083" num="0100">As described above, previous video codecs, such as those conforming to HEVC, were based on 2D separable transforms using the same vertical and horizontal transforms. Therefore, the derived QMs were 2D QMs, in general symmetric, adapted to these 2D transforms.</p><p id="p-0084" num="0101">However, in the current JEM, five different horizontal/vertical transforms are defined, derived from five transforms as shown in Table 1 and illustrated for 4&#xd7;4 size in <figref idref="DRAWINGS">FIG. <b>7</b></figref>. Flags are used at the CU level, for size from 4&#xd7;4 to 64&#xd7;64, to control the combination of transforms. When the CU flag is equal to 0, DCT-II is applied as horizontal and vertical transform. When the CU flag is equal to 1, two additional syntax elements are signalled to identify the horizontal and vertical transforms to be used. Note that other horizontal/vertical transforms could also be considered, such as the identity transform (which corresponds to skipping the transform in one direction).</p><p id="p-0085" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Transform basis functions of </entry></row><row><entry>DCT-II/V/VIII and DST-I/VII for N-point input in JEM.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="168pt" align="center"/><tbody valign="top"><row><entry>Transform </entry><entry/></row><row><entry>Type</entry><entry>Basis function T<sub>i</sub>(j), i, j = 0, 1, . . . , N &#x2212; 1</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>DCT-II</entry><entry><maths id="MATH-US-00004" num="00004"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <msub>     <mi>T</mi>     <mi>i</mi>    </msub>    <mo>(</mo>    <mi>j</mi>    <mo>)</mo>   </mrow>   <mo>=</mo>   <mrow>    <msub>     <mi>&#x3c9;</mi>     <mn>0</mn>    </msub>    <mo>&#xb7;</mo>    <msqrt>     <mfrac>      <mn>2</mn>      <mi>N</mi>     </mfrac>    </msqrt>    <mo>&#xb7;</mo>    <mrow>     <mi>cos</mi>     <mo>(</mo>     <mfrac>      <mrow>       <mi>&#x3c0;</mi>       <mo>&#xb7;</mo>       <mi>i</mi>       <mo>&#xb7;</mo>       <mrow>        <mo>(</mo>        <mrow>         <mrow>          <mn>2</mn>          <mo>&#x2062;</mo>          <mi>j</mi>         </mrow>         <mo>+</mo>         <mn>1</mn>        </mrow>        <mo>)</mo>       </mrow>      </mrow>      <mrow>       <mn>2</mn>       <mo>&#x2062;</mo>       <mi>N</mi>      </mrow>     </mfrac>     <mo>)</mo>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry/><entry><maths id="MATH-US-00005" num="00005"><math overflow="scroll"> <mrow>  <mrow>   <mi>where</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <msub>    <mi>&#x3c9;</mi>    <mn>0</mn>   </msub>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <msqrt>       <mfrac>        <mn>2</mn>        <mi>N</mi>       </mfrac>      </msqrt>     </mtd>     <mtd>      <mrow>       <mi>i</mi>       <mo>=</mo>       <mn>0</mn>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>1</mn>     </mtd>     <mtd>      <mrow>       <mi>i</mi>       <mo>&#x2260;</mo>       <mn>0</mn>      </mrow>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry>DCT-V</entry><entry><maths id="MATH-US-00006" num="00006"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <msub>     <mi>T</mi>     <mi>i</mi>    </msub>    <mo>(</mo>    <mi>j</mi>    <mo>)</mo>   </mrow>   <mo>=</mo>   <mrow>    <msub>     <mi>&#x3c9;</mi>     <mn>0</mn>    </msub>    <mo>&#xb7;</mo>    <msub>     <mi>&#x3c9;</mi>     <mn>1</mn>    </msub>    <mo>&#xb7;</mo>    <msqrt>     <mfrac>      <mn>2</mn>      <mrow>       <mrow>        <mn>2</mn>        <mo>&#x2062;</mo>        <mi>N</mi>       </mrow>       <mo>-</mo>       <mn>1</mn>      </mrow>     </mfrac>    </msqrt>    <mo>&#xb7;</mo>    <mrow>     <mi>cos</mi>     <mo>(</mo>     <mfrac>      <mrow>       <mn>2</mn>       <mo>&#x2062;</mo>       <mrow>        <mi>&#x3c0;</mi>        <mo>&#xb7;</mo>        <mi>i</mi>        <mo>&#xb7;</mo>        <mi>j</mi>       </mrow>      </mrow>      <mrow>       <mrow>        <mn>2</mn>        <mo>&#x2062;</mo>        <mi>N</mi>       </mrow>       <mo>-</mo>       <mn>1</mn>      </mrow>     </mfrac>     <mo>)</mo>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry/><entry><maths id="MATH-US-00007" num="00007"><math overflow="scroll"> <mrow>  <mrow>   <mi>where</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <msub>    <mi>&#x3c9;</mi>    <mn>0</mn>   </msub>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mrow>    <mtable>     <mtr>      <mtd>       <msqrt>        <mfrac>         <mn>2</mn>         <mi>N</mi>        </mfrac>       </msqrt>      </mtd>      <mtd>       <mrow>        <mi>i</mi>        <mo>=</mo>        <mn>0</mn>       </mrow>      </mtd>     </mtr>     <mtr>      <mtd>       <mn>1</mn>      </mtd>      <mtd>       <mrow>        <mi>i</mi>        <mo>&#x2260;</mo>        <mn>0</mn>       </mrow>      </mtd>     </mtr>    </mtable>    <mo>,</mo>    <mrow>     <msub>      <mi>&#x3c9;</mi>      <mn>1</mn>     </msub>     <mo>=</mo>     <mrow>      <mo>{</mo>      <mtable>       <mtr>        <mtd>         <msqrt>          <mfrac>           <mn>2</mn>           <mi>N</mi>          </mfrac>         </msqrt>        </mtd>        <mtd>         <mrow>          <mi>j</mi>          <mo>=</mo>          <mn>0</mn>         </mrow>        </mtd>       </mtr>       <mtr>        <mtd>         <mn>1</mn>        </mtd>        <mtd>         <mrow>          <mi>j</mi>          <mo>&#x2260;</mo>          <mn>0</mn>         </mrow>        </mtd>       </mtr>      </mtable>     </mrow>    </mrow>   </mrow>  </mrow> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry>DCT-VIII</entry><entry><maths id="MATH-US-00008" num="00008"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>T</mi>    <mi>i</mi>   </msub>   <mo>(</mo>   <mi>j</mi>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <msqrt>    <mfrac>     <mn>4</mn>     <mrow>      <mrow>       <mn>2</mn>       <mo>&#x2062;</mo>       <mi>N</mi>      </mrow>      <mo>+</mo>      <mn>1</mn>     </mrow>    </mfrac>   </msqrt>   <mo>&#xb7;</mo>   <mrow>    <mi>cos</mi>    <mo>(</mo>    <mfrac>     <mrow>      <mi>&#x3c0;</mi>      <mo>&#xb7;</mo>      <mrow>       <mo>(</mo>       <mrow>        <mrow>         <mn>2</mn>         <mo>&#x2062;</mo>         <mi>i</mi>        </mrow>        <mo>+</mo>        <mn>1</mn>       </mrow>       <mo>)</mo>      </mrow>      <mo>&#xb7;</mo>      <mrow>       <mo>(</mo>       <mrow>        <mrow>         <mn>2</mn>         <mo>&#x2062;</mo>         <mi>j</mi>        </mrow>        <mo>+</mo>        <mn>1</mn>       </mrow>       <mo>)</mo>      </mrow>     </mrow>     <mrow>      <mrow>       <mn>4</mn>       <mo>&#x2062;</mo>       <mi>N</mi>      </mrow>      <mo>+</mo>      <mn>2</mn>     </mrow>    </mfrac>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry>DST-I</entry><entry><maths id="MATH-US-00009" num="00009"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>T</mi>    <mi>i</mi>   </msub>   <mo>(</mo>   <mi>j</mi>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <msqrt>    <mfrac>     <mn>2</mn>     <mrow>      <mi>N</mi>      <mo>+</mo>      <mn>1</mn>     </mrow>    </mfrac>   </msqrt>   <mo>&#xb7;</mo>   <mrow>    <mi>sin</mi>    <mo>(</mo>    <mfrac>     <mrow>      <mi>&#x3c0;</mi>      <mo>&#xb7;</mo>      <mrow>       <mo>(</mo>       <mrow>        <mi>i</mi>        <mo>+</mo>        <mn>1</mn>       </mrow>       <mo>)</mo>      </mrow>      <mo>&#xb7;</mo>      <mrow>       <mo>(</mo>       <mrow>        <mi>j</mi>        <mo>+</mo>        <mn>1</mn>       </mrow>       <mo>)</mo>      </mrow>     </mrow>     <mrow>      <mi>N</mi>      <mo>+</mo>      <mn>1</mn>     </mrow>    </mfrac>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry>DST-VII</entry><entry><maths id="MATH-US-00010" num="00010"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>T</mi>    <mi>i</mi>   </msub>   <mo>(</mo>   <mi>j</mi>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <msqrt>    <mfrac>     <mn>4</mn>     <mrow>      <mrow>       <mn>2</mn>       <mo>&#x2062;</mo>       <mi>N</mi>      </mrow>      <mo>+</mo>      <mn>1</mn>     </mrow>    </mfrac>   </msqrt>   <mo>&#xb7;</mo>   <mrow>    <mi>sin</mi>    <mo>(</mo>    <mfrac>     <mrow>      <mi>&#x3c0;</mi>      <mo>&#xb7;</mo>      <mrow>       <mo>(</mo>       <mrow>        <mrow>         <mn>2</mn>         <mo>&#x2062;</mo>         <mi>i</mi>        </mrow>        <mo>+</mo>        <mn>1</mn>       </mrow>       <mo>)</mo>      </mrow>      <mo>&#xb7;</mo>      <mrow>       <mo>(</mo>       <mrow>        <mi>j</mi>        <mo>+</mo>        <mn>1</mn>       </mrow>       <mo>)</mo>      </mrow>     </mrow>     <mrow>      <mrow>       <mn>2</mn>       <mo>&#x2062;</mo>       <mi>N</mi>      </mrow>      <mo>+</mo>      <mn>1</mn>     </mrow>    </mfrac>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths></entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0086" num="0102">For the intra case, the set of possible transforms depends on the intra mode. Three sets are defined as follows:<ul id="ul0013" list-style="none">    <li id="ul0013-0001" num="0000">    <ul id="ul0014" list-style="none">        <li id="ul0014-0001" num="0103">Set 0: DST-VII, DCT-VIII</li>        <li id="ul0014-0002" num="0104">Set 1: DST-VII, DST-I</li>        <li id="ul0014-0003" num="0105">Set 2: DST-VII, DCT-V<br/>For each intra mode and each transform direction (horizontal/vertical), one of these three sets is enabled. For the inter case, only DST-VII and DCT-VIII are enabled, and the same transform is applied for both horizontal and vertical transforms.</li>    </ul>    </li></ul></p><p id="p-0087" num="0106">As described above, in many codecs, quantization matrices are used. For example, <figref idref="DRAWINGS">FIG. <b>8</b></figref> shows six example matrices found in standards and encoders. From left to right, top to bottom, the matrices are from JPEG, MPEG2-intra, H264-intra, HEVC-intra, an actual DTT H.264 encoder and satellite HEVC broadcast stream. However, as many encoders do not use the default matrices specified in the codec specification, they need to be explicitly coded. The cost of coding such quantization matrices may become significant.</p><p id="p-0088" num="0107">More specifically, one or more of the following problems may arise:<ul id="ul0015" list-style="none">    <li id="ul0015-0001" num="0000">    <ul id="ul0016" list-style="none">        <li id="ul0016-0001" num="0108">There may be many quantization matrices: the matrices may depend on the horizontal/vertical size of the transform block, the horizontal/vertical transform type, and the coding mode of the Coding Unit containing the transform block; the number of possible combinations may become quite large if considering 4, 8, 16, 32, 64-sized transforms with all rectangular variants, intra/inter, and Y/U/V, this makes 150 matrices (to be compared with 8 for H.264 and 20 for HEVC).</li>        <li id="ul0016-0002" num="0109">Recent codecs tend to use larger-sized transforms, which in turn require transmitting larger-sized quantization matrices, which means a greater number of coefficients.</li>        <li id="ul0016-0003" num="0110">As indicated above, one can choose alternate matrices not matching the default ones found in the specification, for psychovisual improvements or other reasons.</li>        <li id="ul0016-0004" num="0111">The quantization matrix may be asymmetric, for instance to adapt to interlaced content, or anamorphic content.</li>        <li id="ul0016-0005" num="0112">It may be required to change the quantization matrices per picture, in order to better adjust the quantization parameter (for instance to emulate QP larger than 51, which is the current maximum value specified in AVC and in HEVC, or to emulate fractional QP).</li>        <li id="ul0016-0006" num="0113">It may be required for the bitrate regulation, to sacrifice some frequencies; this typically appears in &#x201c;panic mode&#x201d;, when the buffer is close to be full; in this case, it is penalizing to spend many bits to code the quantization matrices.</li>        <li id="ul0016-0007" num="0114">It may be required to adjust the transform coefficients differently depending on the temporal distance of the temporal frame used for predicting the block (the residual statistics strongly depend on this temporal distance), thus requiring frequent change of quantization matrices.</li>        <li id="ul0016-0008" num="0115">Even a simple change can be costly if transmission of the full matrix is required.</li>        <li id="ul0016-0009" num="0116">In current codecs (e.g., H.264 and HEVC), the coding cost of the quantization matrices is somewhat related to their complexity thanks to DPCM coding, but this could be pushed further. Similarly, if prediction is used, coding cost should be related to the complexity of change compared to the predictor.</li>    </ul>    </li></ul></p><p id="p-0089" num="0117">Another aspect addressed here is that in current codecs, quantization matrix is used as a multiplier in the dequantization process, which adds complexity compared to no-matrix: it needs two multiplications instead of one and increases the dynamic range of intermediate results. Also, the HVS model underlying the default HEVC matrices follows an exponential trend, which is difficult to match with a low complexity model and few parameters.</p><p id="p-0090" num="0118">Some problems have already been studied in JCT-VC, during the development of HEVC. For example, increase of transform sizes and types have raised discussions and proposals around quantization matrices coding efficiency:<ul id="ul0017" list-style="none">    <li id="ul0017-0001" num="0000">    <ul id="ul0018" list-style="none">        <li id="ul0018-0001" num="0119">Evidence of problem has been provided in an article by K. Sato, H. Sakurai, entitled &#x201c;Necessity of Quantization Matrices Compression in HEVC,&#x201d; JCTVC-E056, JCT-VC 5th Meeting: Geneva, C H, March 16-23, 2011 (hereinafter [JCTVC-E056]).</li>        <li id="ul0018-0002" num="0120">An article by M. Zhou, V. Sze, entitled &#x201c;Compact representation of quantization matrices for HEVC,&#x201d; JCTVC-D024, JCT-VC 4th Meeting: Daegu, Korea, Jan. 20-28, 2011 (hereinafter [JCTVC-D024]), proposed a coding method involving symmetries, subsampling, and linear interpolation.</li>        <li id="ul0018-0003" num="0121">An article by J. Tanaka, Y. Morigami, and T. Suzuki, entitled &#x201c;Quantization Matrix for HEVC,&#x201d; JCTVC-E073, JCT-VC 5th Meeting: Geneva, C H, Mar. 16-23, 2011 (hereinafter [JCTVC-E073]), proposed a coding method with optional prediction from linear models, prediction from other matrices, symmetries, and non-uniform residue quantization.</li>        <li id="ul0018-0004" num="0122">An article by G. Korodi and D. He, entitled &#x201c;QuYK: A Universal, Lossless Compression Method for Quantization Matrices,&#x201d; JCTVC-E435, JCT-VC 5th Meeting: Geneva, Mar. 16-23, 2011 (hereinafter [JCTVC-E435]), proposed two methods, one with advanced entropy coding, and another with symmetries, per-diagonal affine or quadratic prediction, and zero-tree coding of residual.</li>        <li id="ul0018-0005" num="0123">An article by E. Maani, M. Hague, A. Tabatabai, entitled &#x201c;Parameterization of Default Quantization Matrices,&#x201d; JCTVC-G352, JCT-VC 7th Meeting: Geneva, C H, Nov. 21-30, 2011 (hereinafter [JCTVC-G352]), proposed a quadratic model.</li>        <li id="ul0018-0006" num="0124">An article by Y. Wang, J. Zheng, X. Zheng, Yun He, entitled &#x201c;Layered quantization matrices compression,&#x201d; JCTVC-G530, JCT-VC 7th Meeting: Geneva, Nov. 21-30, 2011 (hereinafter [JCTVC-G530]), proposed a coding method with a hierarchical iterative refinement.</li>        <li id="ul0018-0007" num="0125">An article by R. Joshi, J. S. Rojals, M. Karczewicz, entitled &#x201c;Compression and signaling of quantizer matrices,&#x201d; JCTVC-G578, JCT-VC 7th Meeting: Geneva, C H, Nov. 21-30, 2011 (hereinafter [JCTVC-G578]), proposed a raster scan coding mode (instead of diagonal) with modified differential coding, on top of symmetry rules.</li>        <li id="ul0018-0008" num="0126">An article by M. Hague, E. Maani, A. Tabatabai, entitled &#x201c;High-level Syntaxes for the Scaling List Matrices Parameters and Parametric coding,&#x201d; JCTVC-H0460, JCT-VC 8th Meeting: San Jos&#xe9;, Calif., USA, Feb. 1-10, 2012 (hereinafter [JCTVC-H0460]), proposed a prediction using 3 parametric models (quadratic or HVS).</li>        <li id="ul0018-0009" num="0127">An article by S. Jeong, Hendry, B. Jeon, J. Kim, entitled &#x201c;HVS-based Generalized Quantization Matrices,&#x201d; JCTVC-I0518, JCT-VC 9th Meeting: Geneva, C H, Apr. 27 &#x2014; May 7, 2012 (hereinafter [JCTVC-I0518]) proposed an HVS-based model with a single parameter.</li>        <li id="ul0018-0010" num="0128">An article by R. Joshi, J. S. Rojals, M. Karczewicz, entitled &#x201c;Quantization matrix entries as QP offsets,&#x201d; JCTVC-I0284, JCT-VC 9th Meeting: Geneva, C H, Apr. 27 &#x2014; May 7, 2012 (hereinafter [JCTVC-I0284]), suggested the use of quantization matrices as QP offsets.</li>    </ul>    </li></ul></p><p id="p-0091" num="0129">Evidence of increase of quantization matrix coding cost has been shown in [JCTVC-E056]. This has encouraged the development of techniques for more efficient coding of quantization matrices. An article by J. Tanaka, Y. Morigami, and T. Suzuki, entitled &#x201c;Enhancement of quantization matrix coding for HEVC&#x201d;, JCT-VC 6th Meeting: Torino, IT, Jul. 14-22, 2011 (hereinafter [JCTVC-F475]), provided complex-shaped matrices, as shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, to test the coding efficiency of the various proposals. The quantization matrices provided in <figref idref="DRAWINGS">FIG. <b>9</b></figref> are both for 16&#xd7;16, where the left one is symmetric and the right one is asymmetric. They are not meant to be meaningful, but designed for stress test: hard to encode, but not too much.</p><p id="p-0092" num="0130">JCTVC-D0241 involves both x/y and central point symmetries, plus subsampled representation and linear interpolation reconstruction. Note that x/y symmetry means matrix symmetry, namely, M(x,y) =M(y,x). x/y symmetry is called &#x201c;135 degree symmetry&#x201d; in [JCTVC-D024]. Central point symmetry refers to &#x201c;45 degree symmetry&#x201d; in [JCTVC-D024], and mathematically, M(x,y)+M(N&#x2212;1&#x2212;y, N&#x2212;1&#x2212;x)=C, where N is the size of the (square) matrix, C is a constant, and x, y=0, 1, 2, . . . N&#x2212;1. [JCTVC-D024] also proposed restriction to positive-only DPCM coding, but that was withdrawn afterwards.</p><p id="p-0093" num="0131">Central-point symmetry is usually not relevant, and x/y symmetry is not always true. One benefit of the [JCTVC-D024] method comes from subsampled representation, that leads to about 2.5&#xd7; reduction in bit cost with low error. However, since upsampling is not fully regular, it adds a little complexity to the specification.</p><p id="p-0094" num="0132">JCTVC-E0731 offers several coding modes. At first, one mode involved affine prediction of horizontal, vertical, and diagonal axes, and linear interpolation for the rest; but that mode was abandoned in the 2<sup>nd </sup>version ([JCTVC-F475]). The rest involves prediction from other matrices (with fixed tree and upscale), non-uniform residue quantization (quantization matrix for quantization matrix), x/y symmetry, and various scanning and coding options (raster DPCM, zigzag DPCM, or zigzag RLE), and VLC entropy coding. It suggested interpretation of quantization matrices as QP-offset in the first version.</p><p id="p-0095" num="0133">In the [JCTVC-E073] method, the main reduction of bit cost comes from quantization, which creates moderate errors. However, there are many options, and the specification seems too complex for the purpose. The 3-axes affine model followed by linear interpolation is interesting, but probably not better than a single-stage polynomial model with the same number of parameters. Interpretation as a QP-offset has not been further discussed until [JCTVC-I0284] (see below).</p><p id="p-0096" num="0134">JCTVC-E4351 proposed two methods: the first one is an advanced entropy coding with string substitution and arithmetic coding; the second one has three modes: an asymmetry mode where each up-right diagonal is predicted using a quadratic model with its own set of parameters, an x/y symmetry mode with an affine model instead of a quadratic one, and an x/y+central-point symmetry mode where only half of the diagonals are coded. Parameters for each diagonal are transmitted as indices to a finite set of coefficients, plus an offset. Residual is coded using a zero-tree.</p><p id="p-0097" num="0135">For [JCTVC-E435], the first method is a new entropy coding method and seems too complex for the purpose. In the second method, modeling each diagonal with coarse-grained low-degree polynomial is interesting, but probably too complex compared to a global parametric model: diagonals are clearly correlated in real life. The test matrix (same as [JCTVC-D024]) is a bit too simple and biased towards half-diagonal zigzag scanning efficiency; it is not clear whether compression performance comes from per-diagonal affine model or zero-tree coding.</p><p id="p-0098" num="0136">JCTVC-G3521 and [US20130188691] proposed a quadratic polynomial model for default matrices. Matrix coefficients are approximated by</p><p id="p-0099" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>QM</i>(<i>x,y</i>)=(<i>a</i>(<i>x</i><sup>2</sup><i>+y</i><sup>2</sup>)+<i>bxy+c</i>(<i>x+y</i>)+<i>d</i>)/2<sup>q </sup><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0100" num="0000">with x and y the position of the coefficient (from 0 to N-1 for an N&#xd7;N matrix), (a, b, c, d) the parameters of the model as shown in Table 2, and q the bit precision which is typically 10. It is said that simple scaling of (a, b, c, d) would provide a straightforward extension for other matrix sizes: for a 2N&#xd7;2N matrix, they are divided by (4, 4, 2, 1) respectively.</p><p id="p-0101" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Proposed parameters for AVC-type and HVS default matrices</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><colspec colname="3" colwidth="28pt" align="center"/><colspec colname="4" colwidth="28pt" align="center"/><colspec colname="5" colwidth="42pt" align="center"/><colspec colname="6" colwidth="49pt" align="center"/><tbody valign="top"><row><entry>Type</entry><entry>Size</entry><entry>a</entry><entry>b</entry><entry>c</entry><entry>d</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><colspec colname="3" colwidth="28pt" align="char" char="."/><colspec colname="4" colwidth="28pt" align="char" char="."/><colspec colname="5" colwidth="42pt" align="char" char="."/><colspec colname="6" colwidth="49pt" align="char" char="."/><tbody valign="top"><row><entry>AVC</entry><entry>8 &#xd7; 8</entry><entry>&#x2212;56</entry><entry>&#x2212;127</entry><entry>3364</entry><entry>6898</entry></row><row><entry>intra</entry><entry>16 &#xd7; 16</entry><entry>&#x2212;14</entry><entry>&#x2212;32</entry><entry>1682</entry><entry>6898</entry></row><row><entry/><entry>32 &#xd7; 32</entry><entry>&#x2212;4</entry><entry>&#x2212;8</entry><entry>841</entry><entry>6898</entry></row><row><entry>HVS</entry><entry>8 &#xd7; 8</entry><entry>619</entry><entry>1277</entry><entry>&#x2212;4904</entry><entry>20249</entry></row><row><entry>intra</entry><entry>16 &#xd7; 16</entry><entry>171</entry><entry>369</entry><entry>&#x2212;3039</entry><entry>23826</entry></row><row><entry/><entry>32 &#xd7; 32</entry><entry>45</entry><entry>99</entry><entry>&#x2212;1689</entry><entry>26059</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0102" num="0137">This model provides a good fit for AVC-like matrices (easy since they nearly match a plane), but not so for HVS, and it is restricted to convex shapes. Also, dynamic range of parameters vary greatly with x or y exponent, especially for large sizes; this would lead to some accuracy problems with lower bit precision q. <figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates the AVC-type (left) and HVS (right) matrices for size 8, 16 and 32, where the black grid shows the model and the gray surface shows the fitting target.</p><p id="p-0103" num="0138">In [JCTVC-G352], reference is made to a work from Zhang et al. where a quadratic model is used internally by an encoder to optimize quantization matrices, with optimized matrices supposed to be transmitted in a traditional way (see, e.g., a patent application by H. Zhang et al., &#x201c;Method and apparatus for modeling quantization matrices for image/video encoding&#x201d;, U.S. Pat. No. 8,326,068, hereinafter [U.S. Pat. No. 8,326,068]).</p><p id="p-0104" num="0139">JCTVC-G5301 and an article by Y. Wang, J. Zheng, Yun He, entitled &#x201c;Layered quantization matrices representation and compression,&#x201d; JCTVC-H0314, JCT-VC 8th Meeting: San Jos&#xe9;, Calif., USA, Feb. 1-10, 2012 (hereinafter [JCTVC-H314]), proposed a new method. It follows a hierarchical approach, where each position in the matrix is assigned a layer index (this assignment matrix is specific to each matrix size). <figref idref="DRAWINGS">FIG. <b>11</b>A</figref> shows example matrix layers for an 8&#xd7;8 size. First, the coefficients at root level positions are decoded, then coefficients of the next layer are predicted using linear interpolation and corrected with a residual; the process continues to the next layer, and so on. Residuals can be quantized with different scales for the 4 regions defined in [JCTVC-E073] (see <figref idref="DRAWINGS">FIG. <b>11</b>B</figref>) and can be transmitted for a limited number of layers (e.g., only the first 2 layers), the remaining ones being zero. There is an x/y symmetric mode where only half the residuals are transmitted. Residuals are coded with DPCM or RLE depending on the layer. Instead of being coding explicitly as just described, matrices can also be copied from other ones from the same picture (using a fixed tree, from greater size to lowest, using regular subsampling), or coded differentially from the same matrix of the previous picture.</p><p id="p-0105" num="0140">This method outperforms some other methods, with an interesting hierarchical approach, but is typically too complex for the purpose. Specifically, linear interpolation with unevenly spaced anchors is complex, with ratios that can be numbers like 1/3 or 3/7.</p><p id="p-0106" num="0141">JCTVC-G5781 proposed a simple coding method on top of symmetry rules and subsampling: coefficients are scanned in raster order, each one is predicted with the maximum of upper and left neighbors, and corrected with a residual. Next one uses the corrected coefficient for prediction. Residuals are exp-golomb (EG) coded, with signed to unsigned mapping favoring positive value, since matrix coefficients are typically increasing. Residual transmission can be limited to a sub-block of the matrix (e.g., upper-left corner), the remaining one being inferred to O. The second version, as described in an article by R. Joshi, J. S. Rojals, M. Karczewicz, entitled &#x201c;Coding of quantization matrices based on modified prediction and mapping to unsigned values,&#x201d; JCTVC-H0451, JCT-VC 8th Meeting: San Jos&#xe9;, Calif., USA, Feb. 1-10, 2012 (hereinafter [JCTVC-H0451]), added golomb-rice coding with variable order.</p><p id="p-0107" num="0142">This method has good performance (about 40% less bits) in the asymmetric case, with very low complexity. However this might be biased by the test matrix, which is quasi monotonically increasing, thus well fit for max(left, top) prediction, and better than diagonal because of significant asymmetry. Note that 15 of the 40% comes from offset in signed to unsigned mapping, thanks to increasing matrix values. The gains are much lower for the symmetric case, and globally lower for smaller sizes than for big sizes.</p><p id="p-0108" num="0143">JCTVC-H04601 proposed a parametric model-based coding method. First, a parametric model is selected among three possible ones:</p><p id="p-0109" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 3</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Parametric models proposed in [JCTVC-H0460]</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="56pt" align="center"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="119pt" align="center"/><tbody valign="top"><row><entry>Type</entry><entry>Parameters</entry><entry>Definition</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Symmetric </entry><entry>4</entry><entry>QM(x, y) = a(x<sup>2 </sup>+ y<sup>2</sup>) + </entry></row><row><entry>quadratic</entry><entry/><entry>bxy + c(x + y) + d</entry></row><row><entry>(same as </entry><entry/><entry/></row><row><entry>[JCTVC-G352])</entry><entry/><entry/></row><row><entry>Asymmetric </entry><entry>6</entry><entry>According to the document:</entry></row><row><entry>quadratic</entry><entry/><entry>QM(x, y) = (a<sub>1</sub>x + b<sub>1</sub>y + </entry></row><row><entry/><entry/><entry>c<sub>1</sub>)(a<sub>2</sub>x + b<sub>2</sub>y + c<sub>2</sub>)</entry></row><row><entry/><entry/><entry>According to the code:</entry></row><row><entry/><entry/><entry>QM(x, y) = ax<sup>2 </sup>+ by<sup>2 </sup>+ </entry></row><row><entry/><entry/><entry>cxy + dx + ey + f</entry></row><row><entry> </entry></row><row><entry>HVS (like default  matrix)</entry><entry>4</entry><entry><maths id="MATH-US-00011" num="00011"><math overflow="scroll"> <mrow>  <mo>&#xf3a8;</mo>  <mtable>   <mtr>    <mtd>     <mrow>      <mrow>       <mi>H</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <mi>x</mi>        <mo>,</mo>        <mi>y</mi>       </mrow>       <mo>)</mo>      </mrow>      <mo>=</mo>      <mrow>       <mrow>        <mi>a</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <mi>b</mi>         <mo>+</mo>         <mrow>          <mi>c</mi>          <mo>&#xb7;</mo>          <mrow>           <mi>f</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <mi>x</mi>            <mo>,</mo>            <mi>y</mi>           </mrow>           <mo>)</mo>          </mrow>         </mrow>        </mrow>        <mo>)</mo>       </mrow>       <mo>&#xb7;</mo>      </mrow>     </mrow>    </mtd>   </mtr>   <mtr>    <mtd>     <mrow>      <mi>exp</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mrow>       <mo maxsize="1">(</mo>       <mrow>        <mo>-</mo>        <msup>         <mrow>          <mo>(</mo>          <mrow>           <mi>c</mi>           <mo>&#xb7;</mo>           <mrow>            <mi>f</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <mi>x</mi>             <mo>,</mo>             <mi>y</mi>            </mrow>            <mo>)</mo>           </mrow>          </mrow>          <mo>)</mo>         </mrow>         <mi>d</mi>        </msup>       </mrow>       <mo maxsize="1">)</mo>      </mrow>     </mrow>    </mtd>   </mtr>   <mtr>    <mtd>     <mrow>      <mrow>       <mi>QM</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <mi>x</mi>        <mo>,</mo>        <mi>y</mi>       </mrow>       <mo>)</mo>      </mrow>      <mo>=</mo>      <mfrac>       <mn>16</mn>       <mrow>        <mi>H</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <mi>x</mi>         <mo>,</mo>         <mi>y</mi>        </mrow>        <mo>)</mo>       </mrow>      </mfrac>     </mrow>    </mtd>   </mtr>   <mtr>    <mtd>     <mrow>      <mi>with</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mrow>       <mi>f</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <mi>x</mi>        <mo>,</mo>        <mi>y</mi>       </mrow>       <mo>)</mo>      </mrow>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>the</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>frequency</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>function</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>in</mi>     </mrow>    </mtd>   </mtr>   <mtr>    <mtd>     <mrow>      <mrow>       <mo>[</mo>       <mi>Chang</mi>       <mo>]</mo>      </mrow>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>or</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mrow>       <mi>Eq</mi>       <mo>.</mo>       <mtext>   </mtext>       <mrow>        <mo>(</mo>        <mn>1</mn>        <mo>)</mo>       </mrow>      </mrow>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mrow>       <mo>(</mo>       <mrow>        <mi>not</mi>        <mo>&#x2062;</mo>        <mtext>   </mtext>        <mi>found</mi>        <mo>&#x2062;</mo>        <mtext>   </mtext>        <mi>in</mi>        <mo>&#x2062;</mo>        <mtext>   </mtext>        <mi>the</mi>       </mrow>      </mrow>     </mrow>    </mtd>   </mtr>   <mtr>    <mtd>     <mrow>      <mrow>       <mi>test</mi>       <mo>&#x2062;</mo>       <mtext>   </mtext>       <mi>code</mi>      </mrow>      <mo>)</mo>     </mrow>    </mtd>   </mtr>  </mtable> </mrow></math></maths></entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0110" num="0144">Then, optionally, a residual can be transmitted with a conventional method (e.g., zigzag scan and symmetry rule). Test results are given for parameters coded with EG5 and normalized to 32, and residuals. Matrix sizes greater than 8&#xd7;8 are generated using an 8&#xd7;8 representation followed by upsampling.</p><p id="p-0111" num="0145">The plurality of parametric models and other options (like residual coding methods) makes the method complex. Moreover, the HVS model is computationally demanding. Results with residual do not show better performance than traditional method, but it is argued that if residuals are not needed (i.e., model is considered sufficient for the purpose), the representation is very compact. But the model is probably not sufficient since it is limited to 2<sup>nd</sup>-degree polynomials, and the HVS version does not provide more degrees of freedom. In <figref idref="DRAWINGS">FIG. <b>12</b></figref>, fitting performance of [JCTVC-H0460] quadratic models for symmetric (left) or asymmetric (right) test intra matrices of size 8&#xd7;8 is shown, using SSE optimization and positive constraint, where the gray surface represents the target and the black grid the model. Results are in 38 and 56 bits (anchor is in 334 and 380).</p><p id="p-0112" num="0146">JCTVC-I05181 proposed a generalized HVS model to transmit scaling matrices with a single &#x3b1; parameter:</p><p id="p-0113" num="0000"><maths id="MATH-US-00012" num="00012"><math overflow="scroll"> <mrow>  <mrow>   <mi>Q</mi>   <mo>&#x2062;</mo>   <mrow>    <mi>M</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mrow>     <mi>x</mi>     <mo>,</mo>     <mi>y</mi>    </mrow>    <mo>)</mo>   </mrow>  </mrow>  <mo>=</mo>  <mfrac>   <mrow>    <mn>1</mn>    <mo>&#x2062;</mo>    <mn>6</mn>   </mrow>   <msup>    <mrow>     <mi>H</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <mi>x</mi>      <mo>,</mo>      <mi>y</mi>     </mrow>     <mo>)</mo>    </mrow>    <mi>&#x3b1;</mi>   </msup>  </mfrac> </mrow></math></maths></p><p id="p-0114" num="0000">With H the same as in [Chang] or Eq. (2). A simplified computation is also proposed, using an approximation of 1/H as powers of two. An example using the approximation is shown in <figref idref="DRAWINGS">FIG. <b>13</b></figref>.</p><p id="p-0115" num="0147">With only one parameter, this model is very compact, and the exponent probably makes it well fit for intra to inter conversion and temporal distance adaptation. However, the underlying formulas are quite complex and computationally intensive. The simplified computation technique introduces coarse approximation that may not be acceptable (e.g., the lower triangle half is fully flat). Moreover, restriction of quantization matrices to this class of matrices, with only one degree of freedom, is probably too severe.</p><p id="p-0116" num="0148">JCTVC-I02841 suggested the use of quantization matrices as QP offsets (as already proposed in [JCTVC-E073]), explaining that it makes QP adjustment much more uniform in both directions, and also simplifies the dequantization process and potentially saves memory to in some implementations. It requires a local increase of QP granularity, by augmenting the resolution of levScale table in the dequantization process. Matrix would be coded in offset-binary (0-119 with 64 as mid-point).</p><p id="p-0117" num="0149">During the standardization process, the JCT-VC group was very reluctant to increase the complexity of matrix coding, and memory storage was considered as critical as coding cost. Thus, matrix subsampling with repetition was chosen because it reached both goals without additional complexity and with minor quality impact, apart from that the design was kept mostly unchanged from AVC. Various attempts at non-uniform subsampling were rejected, because of increased complexity and unclear benefits. Using symmetry also increases complexity and was not considered worth the effort.</p><p id="p-0118" num="0150">For large matrix sizes, sample repetition was preferred to linear interpolation because the dequantization process can then use the reduced-size representation without needing any on-the-fly computation. It is noted that subjective tests conducted during JCT-VC meeting H suggested that small errors in matrix coefficients had no visual impact, as described in a break-out group report on quantization matrices subjective viewing by T. Suzuki, K. Sato, X. Zhang, R. Joshi, J. Zheng, M. Zhou, entitled &#x201c;Report on Quantization Matrices Subjective Viewing,&#x201d; JCTVC-H0730, JCT-VC 8th Meeting: San Jos&#xe9;, Calif., USA, Feb. 1-10, 2012 (hereinafter [JCTVC-H0730]).</p><p id="p-0119" num="0151">Since small errors seem acceptable, and quantization matrix data is usually smooth, a parametric model would be a good fit. In fact, the data compression approach adopted to compare the different JCT-VC proposals may be misleading, since it is not focused on the real needs of quantization matrix designs. The idea of degrees of freedom may be a better match. Also, anticipated increase of the number of quantization matrices in the next standard pushes towards a more compact representation.</p><p id="p-0120" num="0152">The emerging AV1 video coding standard also uses quantization matrices. Currently it makes use of a set of 16 possible matrix sets, hard-coded in both encoder and decoder. One matrix set comprises matrices for each block size, luma, and chroma. Like in HEVC, each matrix coefficient is used as a multiplicative factor of the quantization step for the matching coefficient of the transformed block.</p><p id="p-0121" num="0153">An index specifying which set out of 16 to use can be signaled by the encoder at picture level or 64&#xd7;64 block level, and separately for each color component. This index is called &#x201c;QM level&#x201d; by AV1. <figref idref="DRAWINGS">FIG. <b>14</b></figref> shows 16&#xd7;16 AV1 quantization matrices, for luma and chroma index 0 at the top row, and for luma index 4 and 8 at the bottom row.</p><p id="p-0122" num="0154">According to the hard-coded tables, increasing levels lead to flatter and flatter matrices. Matrices for index 15 are fully flat (with normalization value=32). Actually, a decoder interprets index 15 as &#x201c;bypass&#x201d; and skips matrix in the dequantization process in that case.</p><p id="p-0123" num="0155">Here, the problem of transmitting many matrices is completely avoided by relying on hard-coded matrices. Flexibility is provided by choosing between 16 possibilities, but this is quite limited: this can be compared to varying the c factor in the HVS model of [JCTVC-H0460], or the alpha exponent in [JCTVC-I0518]. However, compared to HEVC, flexibility is improved by the ability to select the matrix at the block level.</p><p id="p-0124" num="0156">On the other hand, hard-coded matrices take up much space in read-only memory, code, and specification. In particular, currently there are 107008 8-bit values in 6767 lines of code for decoder matrices, and as many for the encoder.</p><p id="p-0125" num="0157">The present application proposes a compact representation of quantization matrices using a simple fixed polynomial model, with monomials sorted by increasing complexity, and a variable number of parameters, so that trading more bits for better accuracy reduces to code more or fewer parameters. In the following, some advantages of the proposed techniques are provided in comparison with other known works.</p><p id="p-0126" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="126pt" align="left"/><colspec colname="2" colwidth="133pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Advantages</entry><entry>Prior art</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>A single fixed model, leading to simple</entry><entry>Some fixed models were proposed, but either</entry></row><row><entry>implementation</entry><entry>too restrictive or too complex</entry></row><row><entry>Variable number of parameters, directly</entry><entry>Parametric models with fixed number of</entry></row><row><entry>driving coding cost, accuracy and</entry><entry>parameters. Monomials ordered by</entry></row><row><entry>complexity</entry><entry>decreasing complexity.</entry></row><row><entry>Very compact representation (typically</entry><entry>Parametric models with comparable bit</entry></row><row><entry>10x less bits than traditional approach for</entry><entry>savings</entry></row><row><entry>8 &#xd7; 8 matrix), saving bits in a video</entry><entry/></row><row><entry>bitstream, and allowing a higher variety</entry><entry/></row><row><entry>of quantization matrices, thus improving</entry><entry/></row><row><entry>psychovisual adaptation</entry><entry/></row><row><entry>High flexibility, allowing complex</entry><entry>Parametric models with lacking flexibility,</entry></row><row><entry>shapes</entry><entry>or layered method but less bit-efficient, or</entry></row><row><entry/><entry>full specification with more bits.</entry></row><row><entry>Independent of block size</entry><entry>Block-size dependent</entry></row><row><entry>Interpretation as QP-offset can bring</entry><entry>Some benefits can apply too</entry></row><row><entry>additional benefits</entry><entry/></row><row><entry>Computations can be performed on the</entry><entry>Applicable for simple parametric models</entry></row><row><entry>fly in the dequantization process,</entry><entry>(e.g., quadratic)</entry></row><row><entry>minimizing memory needs</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0127" num="0158">The proposed technique can be used as direct matrix coding, or as a residual from a prediction, and either for default matrices or custom (transmitted) ones. In one embodiment, a residual using another coding method may be added to adjust QM coefficients further.</p><p id="p-0128" num="0159">As described above, we anticipate a high pressure on bit cost of quantization matrices in the future video standard. In various embodiments, parametric models are used to offer a very compact representation, at the expense of some loss of freedom.</p><p id="p-0129" num="0160">Since quantization matrices are usually very smooth, full control over each matrix coefficient is not required: this is clear from the results of subjective viewing in JCT-VC meeting H where no difference could be detected between lossy and lossless QM transmission techniques, and the final decision to represent big matrices with an 8&#xd7;8 resolution. Thus, a solution to encode the quantization matrix can be defining the global shape with &#x201c;enough&#x201d; freedom.</p><p id="p-0130" num="0161">In one embodiment, a polynomial model is proposed, because among possible parametric surface models, polynomials probably offer the highest flexibility for the lowest complexity.</p><p id="p-0131" num="0162">Note that even if the proposed representation is block-size independent, it is compatible with an expansion limited to 8&#xd7;8 maximum, with repetition for higher sizes, like in HEVC. <figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates the quantization matrix coding performance, where the simplest variant of the model proposed here (using 3, 4, 6, 8, 10, 11, 13, 15, 17, 19, or 21 parameters) is compared to the layered method proposed by [JCTVC-G530] (best &#x201c;lossy&#x201d; method proposed for HEVC), with AVC/HEVC coding method as a reference, for some 8&#xd7;8 matrices (comparable results are obtained for other matrices). The proposed model generally extends and outperforms [JCTVC-G530] on the low-bitrate side.</p><p id="p-0132" num="0163"><figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates system <b>1600</b> for decoding the quantization matrix, according to an embodiment. From the input bitstream, parameter decoder <b>1610</b> obtains model parameters, e.g., polynomial coefficients {Pi}, for the current quantization matrix. Then quantization matrix generator <b>1620</b> generates the current quantization matrix based on the matrix size and the model parameters.</p><p id="p-0133" num="0164"><figref idref="DRAWINGS">FIG. <b>17</b></figref> illustrates method <b>1700</b> for decoding the quantization matrix, according to an embodiment. Method <b>1700</b> starts at step <b>1705</b>. From the input bitstream, the decoder <b>1710</b> obtains model parameters, e.g., polynomial coefficients {Pi}, for the current quantization matrix. Then the decoder generates <b>1720</b> the current quantization matrix based on the matrix size and the model parameters. Method <b>1700</b> ends at step <b>1799</b>. Method <b>1700</b> can be implemented in system <b>1600</b>. In the following, the modeling of the quantization matrix will be described in further detail.</p><p id="p-0134" num="0165">In one embodiment, the present technique uses a single fixed polynomial to represent a quantization matrix, to keep minimal complexity. Modulation of bit cost and complexity is achieved by specifying only the n first polynomial coefficients (also called &#x201c;polynomial parameters&#x201d;), the remaining ones being implicitly set to zero (or any relevant neutral values).</p><p id="p-0135" num="0166">One form of the single fixed polynomial is a fully developed polynomial in (x,y), where x, y indicate the coordinates of a given coefficient in a quantization matrix, with monomials (also called &#x201c;terms&#x201d;) ordered by increasing exponent, as shown in Eq. (3) expressing the way a quantization matrix coefficient M(x,y) is derived as a function of polynomial parameters P<sub>i</sub>.</p><p id="p-0136" num="0000"><maths id="MATH-US-00013" num="00013"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>M</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <mi>x</mi>       <mo>,</mo>       <mi>y</mi>      </mrow>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mrow>      <munder>       <mo>&#x2211;</mo>       <mi>i</mi>      </munder>      <mrow>       <msub>        <mi>P</mi>        <mi>i</mi>       </msub>       <mo>&#xb7;</mo>       <mrow>        <msub>         <mi>m</mi>         <mi>i</mi>        </msub>        <mo>(</mo>        <mrow>         <mi>x</mi>         <mo>,</mo>         <mi>y</mi>        </mrow>        <mo>)</mo>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>3</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0137" num="0000">where P<sub>i </sub>are the polynomial coefficients, and m<sub>i</sub>(x,y)=x<sup>px</sup><sup><sub2>i</sub2></sup>y<sup>py</sup><sup><sub2>i </sub2></sup>are the terms, px<sub>i </sub>and py<sub>i </sub>being the exponents of x and y for monomial m<sub>i</sub>.</p><p id="p-0138" num="0167">This form provides high flexibility with reasonable complexity, controlled by the number of polynomial coefficients that are specified. Since higher exponents are the last ones, reducing the polynomial number of coefficients reduces de facto the degree of the polynomial, hence its complexity. Note that the exponent on a variable (i.e., x or y) in a term (i.e., m<sub>i</sub>(x,y)) is called the degree of that variable in that term; the degree of the term is the sum of the degrees of the variables in that term, and the degree of a polynomial is the largest degree of any one term with non-zero coefficient.</p><p id="p-0139" num="0000"><maths id="MATH-US-00014" num="00014"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mtable>     <mtr>      <mtd>       <mrow>        <mrow>         <mi>More</mi>         <mo>&#x2062;</mo>         <mtext>   </mtext>         <mi>specifically</mi>        </mrow>        <mo>,</mo>        <mrow>         <mrow>          <mi>M</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <mi>x</mi>           <mo>,</mo>           <mi>y</mi>          </mrow>          <mo>)</mo>         </mrow>         <mo>=</mo>         <malignmark/>         <mrow>          <msub>           <mi>P</mi>           <mn>0</mn>          </msub>          <mo>+</mo>         </mrow>        </mrow>       </mrow>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <malignmark/>        <mrow>         <msub>          <mi>P</mi>          <mn>1</mn>         </msub>         <mo>&#x2062;</mo>         <mi>x</mi>        </mrow>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mrow>        <msub>         <mi>P</mi>         <mn>2</mn>        </msub>        <mo>&#x2062;</mo>        <mi>y</mi>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <malignmark/>        <mrow>         <msub>          <mi>P</mi>          <mn>3</mn>         </msub>         <mo>&#x2062;</mo>         <mi>xy</mi>        </mrow>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mrow>        <msub>         <mi>P</mi>         <mn>4</mn>        </msub>        <mo>&#x2062;</mo>        <msup>         <mi>x</mi>         <mn>2</mn>        </msup>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mrow>        <msub>         <mi>P</mi>         <mn>5</mn>        </msub>        <mo>&#x2062;</mo>        <msup>         <mi>y</mi>         <mn>2</mn>        </msup>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <malignmark/>        <mrow>         <msub>          <mi>P</mi>          <mn>6</mn>         </msub>         <mo>&#x2062;</mo>         <msup>          <mi>x</mi>          <mn>2</mn>         </msup>         <mo>&#x2062;</mo>         <mi>y</mi>        </mrow>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mrow>        <msub>         <mi>P</mi>         <mn>7</mn>        </msub>        <mo>&#x2062;</mo>        <msup>         <mi>xy</mi>         <mn>2</mn>        </msup>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mrow>        <msub>         <mi>P</mi>         <mn>8</mn>        </msub>        <mo>&#x2062;</mo>        <msup>         <mi>x</mi>         <mn>3</mn>        </msup>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mrow>        <msub>         <mi>P</mi>         <mn>9</mn>        </msub>        <mo>&#x2062;</mo>        <msup>         <mi>y</mi>         <mn>3</mn>        </msup>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <malignmark/>        <mrow>         <msub>          <mi>P</mi>          <mn>10</mn>         </msub>         <mo>&#x2062;</mo>         <msup>          <mi>x</mi>          <mn>2</mn>         </msup>         <mo>&#x2062;</mo>         <msup>          <mi>y</mi>          <mn>2</mn>         </msup>        </mrow>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mrow>        <msub>         <mi>P</mi>         <mn>11</mn>        </msub>        <mo>&#x2062;</mo>        <msup>         <mi>x</mi>         <mn>3</mn>        </msup>        <mo>&#x2062;</mo>        <mi>y</mi>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mrow>        <msub>         <mi>P</mi>         <mn>12</mn>        </msub>        <mo>&#x2062;</mo>        <msup>         <mi>xy</mi>         <mn>3</mn>        </msup>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>      <mtd>       <mrow>        <mrow>         <msub>          <mi>P</mi>          <mn>13</mn>         </msub>         <mo>&#x2062;</mo>         <msup>          <mi>x</mi>          <mn>4</mn>         </msup>        </mrow>        <mo>+</mo>        <mrow>         <msub>          <mi>P</mi>          <mn>14</mn>         </msub>         <mo>&#x2062;</mo>         <msup>          <mi>y</mi>          <mn>4</mn>         </msup>        </mrow>       </mrow>      </mtd>      <mtd>       <mo>+</mo>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <malignmark/>        <mo>&#x2026;</mo>       </mrow>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>      <mtd>       <mtext> </mtext>      </mtd>     </mtr>    </mtable>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>4</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0140" num="0168">Here monomials are sorted by:<ul id="ul0019" list-style="none">    <li id="ul0019-0001" num="0000">    <ul id="ul0020" list-style="none">        <li id="ul0020-0001" num="0169">Rule 1. Increasing degree of the term;</li>        <li id="ul0020-0002" num="0170">Rule 2. Increasing maximal (x or y) exponent; and</li>        <li id="ul0020-0003" num="0171">Rule 3. Increasing y exponent.</li>    </ul>    </li></ul></p><p id="p-0141" num="0172">In Eq. (4), different subsets of polynomial coefficients define M(x,y) at different degrees. For example, line 1 (&#x201c;P<sub>0</sub>&#x201d;) defines a degree-0 polynomial (i.e., constant), lines 1 and 2 (&#x201c;P<sub>0</sub>+P<sub>1</sub>x+P<sub>2</sub>y&#x201d;) define a degree-1 polynomial, lines 1-3 (P<sub>0</sub>+P<sub>1</sub>x+P<sub>2</sub>y+P<sub>3</sub>xy+P<sub>4</sub>x<sup>2</sup>+P<sub>s</sub>y<sup>2</sup>) define a degree-2 polynomial (like JCTVC-H0460), etc. Each line adds the terms for the next degree. Note that the maximal number of coefficients for degrees 0, 1, 2, 3, 4, 5, are respectively 1, 3, 6, 10, 15, and 21.</p><p id="p-0142" num="0173">The series can be continued, but we suggest stopping at degree 4 (i.e., 15 parameters, P<sub>0</sub>-P<sub>14</sub>), because higher degrees need more and more parameters, with increasing complexity and challenging dynamic range for intermediate computations.</p><p id="p-0143" num="0174">Note that the polynomial may take different forms. For example, rule 2 can be ignored, or rule 3 can be modified to follow increasing x exponent. While different forms of M (x,y) can be used, the encoder and decoder should both have the knowledge of the ordered sequence of the monomials m<sub>i</sub>(x,y), i=0, 1, 2 . . . Subsequently, when the polynomial parameters are transmitted or received, the i-th polynomial coefficient P<sub>i </sub>corresponds to the i-th monomial m<sub>i</sub>(x,y), and thus the polynomial can be constructed, by associating the polynomial coefficient and the monomial at the same index (i.e., pairing P<sub>i </sub>and m<sub>i</sub>(x,y)), as M(x,y)=&#x3a3;<sub>i</sub>P<sub>i</sub>&#xb7;m<sub>i</sub>(x,y).</p><p id="p-0144" num="0175">Here, by using a well-defined transmission (or storage) order of polynomial parameters, the complexity of the quantization matrix can be controlled easily through the number of polynomial parameters used to represent the quantization matrix. In one example, the number of polynomial parameters is transmitted, explicitly or implicitly, in the bitstream as part of the syntax.</p><p id="p-0145" num="0176">Default polynomial coefficients can be used, or the polynomial coefficients can be transmitted in the bitstream. In one example, a limited number of polynomial parameters can be specified, and the remaining ones can be inferred to be zero. Transmitting fewer parameters typically needs fewer bits, and a simpler shape that is easy to compute, and more parameters mean more bits, and more complex shape that is harder to compute.</p><p id="p-0146" num="0177">With a degree-4, the number of polynomial parameters can go from 0 to 15, which can be coded with 4 bits if it needs to be transmitted. 0 can be interpreted as default matrix (or to default parameters).</p><p id="p-0147" num="0178">In one embodiment, a symmetry flag, e.g., sym, can be added to specify the same coefficient for monomials that are symmetrical in x and y, thus forming a symmetric polynomial, with a reduced number of parameters (e.g., 9 instead of 15 for degree 4). The mapping is shown in Table 4 for degree-4.</p><p id="p-0148" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="280pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 4</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Mapping of symmetrical polynomial parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="16"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="14pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="14pt" align="left"/><colspec colname="6" colwidth="14pt" align="left"/><colspec colname="7" colwidth="14pt" align="left"/><colspec colname="8" colwidth="21pt" align="left"/><colspec colname="9" colwidth="21pt" align="left"/><colspec colname="10" colwidth="14pt" align="left"/><colspec colname="11" colwidth="14pt" align="left"/><colspec colname="12" colwidth="21pt" align="left"/><colspec colname="13" colwidth="21pt" align="left"/><colspec colname="14" colwidth="21pt" align="left"/><colspec colname="15" colwidth="14pt" align="left"/><colspec colname="16" colwidth="14pt" align="left"/><tbody valign="top"><row><entry/><entry>1</entry><entry>x</entry><entry>y</entry><entry>xy</entry><entry>x<sup>2</sup></entry><entry>y<sup>2</sup></entry><entry>x<sup>2</sup>y</entry><entry>xy<sup>2</sup></entry><entry>x<sup>3</sup></entry><entry>y<sup>3</sup></entry><entry>x<sup>2</sup>y<sup>2</sup></entry><entry>x<sup>3</sup>y</entry><entry>xy<sup>3 </sup></entry><entry>x<sup>4</sup></entry><entry>y<sup>4</sup></entry></row><row><entry namest="1" nameend="16" align="center" rowsep="1"/></row><row><entry>sym = 0</entry><entry>P<sub>0</sub></entry><entry>P<sub>1</sub></entry><entry>P<sub>2</sub></entry><entry>P<sub>3</sub></entry><entry>P<sub>4</sub></entry><entry>P<sub>5</sub></entry><entry>P<sub>6</sub></entry><entry>P<sub>7</sub></entry><entry>P<sub>8</sub></entry><entry>P<sub>9</sub></entry><entry>P<sub>10</sub></entry><entry>P<sub>11</sub></entry><entry>P<sub>12</sub></entry><entry>P<sub>13</sub></entry><entry>P<sub>14</sub></entry></row><row><entry>sym = 1</entry><entry>P&#x2032;<sub>0</sub></entry><entry>P&#x2032;<sub>1</sub></entry><entry>P&#x2032;<sub>1</sub></entry><entry>P&#x2032;<sub>2</sub></entry><entry>P&#x2032;<sub>3</sub></entry><entry>P&#x2032;<sub>3</sub></entry><entry>P&#x2032;<sub>4</sub></entry><entry>P&#x2032;<sub>4</sub></entry><entry>P&#x2032;<sub>5</sub></entry><entry>P&#x2032;<sub>5</sub></entry><entry>P&#x2032;<sub>6</sub></entry><entry>P&#x2032;<sub>7</sub></entry><entry>P&#x2032;<sub>7</sub></entry><entry>P&#x2032;<sub>8</sub></entry><entry>P&#x2032;<sub>8</sub></entry></row><row><entry namest="1" nameend="16" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0007" level="2">Normalization of x and y</heading><p id="p-0149" num="0179">In one embodiment, we propose to normalize the x and y variables, which was not done in previous work like [JCTVC-G352] or [JCTVC-H0460], to:</p><p id="p-0150" num="0180">1&#x2014;Equalize dynamic range between the various polynomial coefficients. In Table 2, taken from previous work, coefficients a and d have very different range, which can lead to severe problems if increasing polynomial degree and/or matrix size. With normalization, this problem is solved, and polynomial coefficients can be transmitted with a fixed number of bits. This is simpler, and has proven more efficient in our tests than exp-Golomb coding of parameters without x and y normalization, for the same accuracy on the resulting matrix.</p><p id="p-0151" num="0181">2&#x2014;Use the same polynomial coefficients for different matrix sizes, including rectangular ones. With this method, using the same polynomial for a half-size matrix is exactly equivalent to take every other coefficient of the full-size one; this works in x direction, y, or both.</p><p id="p-0152" num="0182">Let us define a normalization value N, so that</p><p id="p-0153" num="0000"><maths id="MATH-US-00015" num="00015"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>x</mi>      <mo>=</mo>      <mrow>       <mi>N</mi>       <mo>&#x2062;</mo>       <mfrac>        <msup>         <mi>x</mi>         <mo>&#x2032;</mo>        </msup>        <msub>         <mi>size</mi>         <mi>x</mi>        </msub>       </mfrac>      </mrow>     </mrow>     <mo>,</mo>     <mrow>      <mi>y</mi>      <mo>=</mo>      <mrow>       <mi>N</mi>       <mo>&#x2062;</mo>       <mfrac>        <msup>         <mi>y</mi>         <mo>&#x2032;</mo>        </msup>        <msub>         <mi>size</mi>         <mi>y</mi>        </msub>       </mfrac>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>5</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0154" num="0000">with x&#x2032;,y&#x2032; integers in the interval [0 . . . size<sub>x/y</sub>&#x2212;1] (i. e., the indices of the columns and rows of the matrix), where size<sub>x </sub>and size<sub>y </sub>are horizontal and vertical size of the matrix.</p><p id="p-0155" num="0183"><figref idref="DRAWINGS">FIG. <b>18</b></figref> illustrates method <b>1800</b> for normalizing the matrix coordinates, according to an embodiment. Method <b>1800</b> can be implemented in quantization matrix generate <b>1620</b>, or can be used for performing step <b>1720</b>.</p><p id="p-0156" num="0184">Specifically, for the matrix coordinate x&#x2032;, based on the horizontal size of the quantization matrix and the normalization value N, x normalization (<b>1810</b>) can be performed:</p><p id="p-0157" num="0000"><maths id="MATH-US-00016" num="00016"><math overflow="scroll"> <mrow>  <mi>x</mi>  <mo>=</mo>  <mrow>   <mi>N</mi>   <mo>&#x2062;</mo>   <mrow>    <mfrac>     <msup>      <mi>x</mi>      <mo>&#x2032;</mo>     </msup>     <msub>      <mi>size</mi>      <mi>x</mi>     </msub>    </mfrac>    <mo>.</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0158" num="0000">similarly, for the matrix coordinate y&#x2032;, based on the vertical size of the quantization matrix and the normalization value N, y normalization (<b>1830</b>) can be performed:</p><p id="p-0159" num="0000"><maths id="MATH-US-00017" num="00017"><math overflow="scroll"> <mrow>  <mi>y</mi>  <mo>=</mo>  <mrow>   <mi>N</mi>   <mo>&#x2062;</mo>   <mrow>    <mfrac>     <msup>      <mi>y</mi>      <mo>&#x2032;</mo>     </msup>     <msub>      <mi>size</mi>      <mi>y</mi>     </msub>    </mfrac>    <mo>.</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0160" num="0000">Then the normalized matrix coordinates x and y can be used in modelling (<b>1820</b>) the quantization matrix, for example, used in Eq. (4) to generate M(x,y).</p><p id="p-0161" num="0185">An obvious choice for N is 1, since this makes every monomial in the [0 . . . 1) range, so the maximal impact of the variation (accuracy) of each coefficient is the same. This is an important consideration when trying to define the number of significant bits needed. However, the dynamic range of polynomial coefficients to match a given shape varies a lot, depending on the number of polynomial coefficients, and on the rank (index i in P,) of each coefficient. (y<sup>th </sup>and 1<sup>st </sup>degree polynomial coefficients tend to be smaller than others, and a higher number of polynomial coefficients yield bigger dynamic range for all of them.</p><p id="p-0162" num="0186">Unconstrained least squares fitting has been performed, for example, by minimizing mean squared error between reconstructed matrix and test matrix, on a test set based on H.264, HEVC, and other test 8&#xd7;8 matrices. In <figref idref="DRAWINGS">FIG. <b>19</b></figref>, the left figure shows the maximum absolute value of each coefficient, for several experiments with 6, 10, 15, 21 polynomial coefficients; the right figure shows the maximum absolute value among all polynomial coefficients, for different numbers of coefficients (3 to 21).</p><p id="p-0163" num="0187">Theoretically, polynomial coefficients could be transmitted with unlimited range, using exp-golomb coding. But large polynomial coefficients would be unrealistic for use in matrix computation, which shall be fully specified, thus bit-limited. This implies defining the range of polynomial coefficients and their accuracy.</p><p id="p-0164" num="0188">Since quantization matrices are typically defined as 8-bit numbers, it makes sense to define polynomial coefficients with a similar bit depth. If the number of polynomial coefficients is limited to 15 (i.e., degree 4), they could be constrained to [&#x2212;512 . . . 511] range (i.e., 10-bit signed), and dropping 2 LSBs (Least Significant Bits) would make them 8-bit signed. This would reduce accuracy of matrix (0,0) value by a factor 4, but overall accuracy can be satisfying because each coefficient affects matrix at different places with various levels.</p><p id="p-0165" num="0189">Normalization value N=1 is not the only possible choice, and other values yield other compromises on coefficient range and accuracy: for N&#x3e;1, accuracy of higher-index coefficients have greater impact, as shown on <figref idref="DRAWINGS">FIG. <b>20</b></figref>. Impact of coefficient bounds (i.e., dynamic range) on fitting quality for various N is shown on <figref idref="DRAWINGS">FIG. <b>21</b></figref>, suggesting 512, 256, and 128 for N=1, &#x221a;{square root over (2)}, 2.</p><p id="p-0166" num="0190">A recommended N is 2, because it yields stable low coefficient range with a good compromise on overall accuracy, and keeps full accuracy for (0,0) matrix position, which is valuable.</p><heading id="h-0008" level="2">Efficient Computation</heading><p id="p-0167" num="0191">Since size<sub>x </sub>and size<sub>y </sub>are typically powers of 2, and if N is also a power of two (we recommend N=2), the division in Eq. (5) will simplify to bit shifts. Let sx=log2 (size<sub>x</sub>)&#x2212;log2 (N) and sy=log2 (size<sub>y</sub>)&#x2212;log2 (N), then equation (5) can be written as:</p><p id="p-0168" num="0000"><maths id="MATH-US-00018" num="00018"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>x</mi>      <mo>=</mo>      <mfrac>       <msup>        <mi>x</mi>        <mo>&#x2032;</mo>       </msup>       <msup>        <mn>2</mn>        <mi>sx</mi>       </msup>      </mfrac>     </mrow>     <mo>,</mo>     <mrow>      <mi>y</mi>      <mo>=</mo>      <mfrac>       <msup>        <mi>y</mi>        <mo>&#x2032;</mo>       </msup>       <msup>        <mn>2</mn>        <mi>sy</mi>       </msup>      </mfrac>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>6</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0169" num="0192">Reported in Eq. (3), this becomes:</p><p id="p-0170" num="0000"><maths id="MATH-US-00019" num="00019"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>M</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <msup>        <mi>x</mi>        <mo>&#x2032;</mo>       </msup>       <mo>,</mo>       <msup>        <mi>y</mi>        <mo>&#x2032;</mo>       </msup>      </mrow>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mrow>      <mrow>       <munder>        <mo>&#x2211;</mo>        <mi>i</mi>       </munder>       <mrow>        <msup>         <mrow>          <msub>           <mi>P</mi>           <mi>i</mi>          </msub>          <mo>(</mo>          <mfrac>           <msup>            <mi>x</mi>            <mo>&#x2032;</mo>           </msup>           <msup>            <mn>2</mn>            <mi>sx</mi>           </msup>          </mfrac>          <mo>)</mo>         </mrow>         <msub>          <mi>px</mi>          <mi>i</mi>         </msub>        </msup>        <mo>&#x2062;</mo>        <msup>         <mrow>          <mo>(</mo>          <mfrac>           <msup>            <mi>y</mi>            <mo>&#x2032;</mo>           </msup>           <msup>            <mn>2</mn>            <mi>sy</mi>           </msup>          </mfrac>          <mo>)</mo>         </mrow>         <msub>          <mi>py</mi>          <mi>i</mi>         </msub>        </msup>       </mrow>      </mrow>      <mo>=</mo>      <mrow>       <munder>        <mo>&#x2211;</mo>        <mi>i</mi>       </munder>       <mrow>        <msub>         <mi>P</mi>         <mi>i</mi>        </msub>        <mo>&#x2062;</mo>        <mfrac>         <mrow>          <msup>           <mi>x</mi>           <mrow>            <mo>&#x2032;</mo>            <mo>&#x2062;</mo>            <msub>             <mi>px</mi>             <mi>i</mi>            </msub>           </mrow>          </msup>          <mo>&#x2062;</mo>          <msup>           <mi>y</mi>           <mrow>            <mo>&#x2032;</mo>            <mo>&#x2062;</mo>            <msub>             <mi>py</mi>             <mi>i</mi>            </msub>           </mrow>          </msup>         </mrow>         <msup>          <mn>2</mn>          <mrow>           <mrow>            <mi>sx</mi>            <mo>.</mo>            <msub>             <mi>px</mi>             <mi>i</mi>            </msub>           </mrow>           <mo>+</mo>           <mrow>            <mi>sy</mi>            <mo>.</mo>            <msub>             <mi>py</mi>             <mi>i</mi>            </msub>           </mrow>          </mrow>         </msup>        </mfrac>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>7</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0171" num="0193">Now if defining smax=max(sx. px+sy. py), we can write</p><p id="p-0172" num="0000"><maths id="MATH-US-00020" num="00020"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>M</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <msup>        <mi>x</mi>        <mo>&#x2032;</mo>       </msup>       <mo>,</mo>       <msup>        <mi>y</mi>        <mo>&#x2032;</mo>       </msup>      </mrow>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mfrac>      <mrow>       <msub>        <mo>&#x2211;</mo>        <mi>i</mi>       </msub>       <mrow>        <msub>         <mi>P</mi>         <mi>i</mi>        </msub>        <mo>&#x2062;</mo>        <msup>         <mi>x</mi>         <mrow>          <mo>&#x2032;</mo>          <mo>&#x2062;</mo>          <msub>           <mi>px</mi>           <mi>i</mi>          </msub>         </mrow>        </msup>        <mo>&#x2062;</mo>        <msup>         <mi>y</mi>         <mrow>          <mo>&#x2032;</mo>          <mo>&#x2062;</mo>          <msub>           <mi>py</mi>           <mi>i</mi>          </msub>         </mrow>        </msup>        <msup>         <mtext>.2</mtext>         <mrow>          <mi>smax</mi>          <mo>-</mo>          <mrow>           <mi>sx</mi>           <mo>.</mo>           <msub>            <mi>px</mi>            <mi>i</mi>           </msub>          </mrow>          <mo>-</mo>          <mrow>           <mi>sy</mi>           <mo>.</mo>           <msub>            <mi>py</mi>            <mi>i</mi>           </msub>          </mrow>         </mrow>        </msup>       </mrow>      </mrow>      <msup>       <mn>2</mn>       <mi>smax</mi>      </msup>     </mfrac>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>8</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0173" num="0000">With m&#x2032;<sub>i</sub>(x&#x2032;,y&#x2032;)=x&#x2032;<sup>px</sup><sup><sub2>i</sub2></sup>y&#x2032;<sup>py</sup><sup><sub2>i</sub2></sup>,</p><p id="p-0174" num="0000"><maths id="MATH-US-00021" num="00021"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>M</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <msup>        <mi>x</mi>        <mo>&#x2032;</mo>       </msup>       <mo>,</mo>       <msup>        <mi>y</mi>        <mo>&#x2032;</mo>       </msup>      </mrow>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mfrac>      <mrow>       <msub>        <mo>&#x2211;</mo>        <mi>i</mi>       </msub>       <mrow>        <msub>         <mi>P</mi>         <mi>i</mi>        </msub>        <mo>&#x2062;</mo>        <mrow>         <msubsup>          <mi>m</mi>          <mi>i</mi>          <mo>&#x2032;</mo>         </msubsup>         <mo>(</mo>         <mrow>          <msup>           <mi>x</mi>           <mo>&#x2032;</mo>          </msup>          <mo>,</mo>          <msup>           <mi>y</mi>           <mo>&#x2032;</mo>          </msup>         </mrow>         <mo>)</mo>        </mrow>        <msup>         <mtext>.2</mtext>         <mrow>          <mi>smax</mi>          <mo>-</mo>          <mrow>           <mi>sx</mi>           <mo>.</mo>           <msub>            <mi>px</mi>            <mi>i</mi>           </msub>          </mrow>          <mo>-</mo>          <mrow>           <mi>sy</mi>           <mo>.</mo>           <msub>            <mi>py</mi>            <mi>i</mi>           </msub>          </mrow>         </mrow>        </msup>       </mrow>      </mrow>      <msup>       <mn>2</mn>       <mi>smax</mi>      </msup>     </mfrac>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>9</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0175" num="0194">Since smax&#x2265;0 and smax&#x2212;sx. px<sub>i</sub>&#x2212;sy. py<sub>i</sub>&#x2265;0, the multiplication by 2<sup>smax&#x2212;sx. px</sup><sup><sub2>i</sub2></sup><sup>&#x2212;sy. py</sup><sup><sub2>i </sub2></sup>simplifies to left shifting, and the final division by 2<sup>smax </sup>can be implemented with a right shift, preferably with rounding:</p><p id="p-0176" num="0000"><maths id="MATH-US-00022" num="00022"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mrow>       <mrow>        <mi>M</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msup>          <mi>x</mi>          <mo>&#x2032;</mo>         </msup>         <mo>,</mo>         <msup>          <mi>y</mi>          <mo>&#x2032;</mo>         </msup>        </mrow>        <mo>)</mo>       </mrow>       <mo>=</mo>       <mrow>        <mo>(</mo>        <mrow>         <mrow>          <mo>(</mo>          <mrow>           <munder>            <mo>&#x2211;</mo>            <mi>i</mi>           </munder>           <mrow>            <msub>             <mi>P</mi>             <mi>i</mi>            </msub>            <mo>&#x2062;</mo>            <mrow>             <msubsup>              <mi>m</mi>              <mi>i</mi>              <mo>&#x2032;</mo>             </msubsup>             <mo>(</mo>             <mrow>              <msup>               <mi>x</mi>               <mo>&#x2032;</mo>              </msup>              <mo>,</mo>              <msup>               <mi>y</mi>               <mo>&#x2032;</mo>              </msup>             </mrow>             <mo>)</mo>            </mrow>            <mo>&#x2062;</mo>            <mrow>             <mo>&#xf761;</mo>             <msub>              <mi>s</mi>              <mi>i</mi>             </msub>            </mrow>           </mrow>          </mrow>          <mo>)</mo>         </mrow>         <mo>+</mo>         <mi>rnd</mi>        </mrow>        <mo>)</mo>       </mrow>      </mrow>      <mo>&#xf762;</mo>     </mrow>     <mo>&#x2062;</mo>     <mi>smax</mi>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>10</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0177" num="0000">with s<sub>i</sub>=smax&#x2212;(sx. px<sub>i</sub>+sy. py<sub>i</sub>) and rnd=1&#x3c;&#x3c;(smax&#x2212;1).</p><p id="p-0178" num="0195">This method retains good accuracy, with integer computations. <figref idref="DRAWINGS">FIG. <b>22</b></figref> illustrates quantization matrix generator <b>2200</b> with integer computing, according to an embodiment. Generator <b>2200</b> can be used as module <b>1620</b>.</p><p id="p-0179" num="0196">From the matrix size (size<sub>x</sub>, size<sub>y</sub>) and the normalization value N, sx=log2 (size<sub>x</sub>)&#x2212;log2(N) and sy=log2(size<sub>y</sub>)&#x2212;log2(N), and the normalization data can be derived (<b>2220</b>): s<sub>i</sub>=smax&#x2212;(sx. px<sub>i</sub>+sy. py<sub>i</sub>). The rounding and shifting value can be derived (<b>2230</b>) as: smax=max(sx. px+sy. py), and rnd=1&#x3c;&#x3c;(smax&#x2212;1).</p><p id="p-0180" num="0197">From quantization matrix coordinate x&#x2032; and y&#x2032;, the i-th monomial can be derived (<b>2210</b>) as: m&#x2032;<sub>i</sub>(x&#x2032;,y&#x2032;)=x&#x2032;<sup>px</sup><sup><sub2>i</sub2></sup>y&#x2032;<sup>py</sup><sup><sub2>i</sub2></sup><sup>py</sup><sup><sub2>i</sub2></sup>. Pairing (<b>2240</b>) the i-th monomial with the i-th polynomial parameter P<sub>i</sub>, P<sub>i</sub>m&#x2032;<sub>i</sub>(x&#x2032;,y&#x2032;) is formed (<b>2240</b>). Then left shifting is applied (<b>2250</b>): P<sub>i</sub>m&#x2032;<sub>i</sub>(x&#x2032;,y&#x2032;)&#x3c;&#x3c;s<sub>i</sub>, and the shifted results are summed (<b>2260</b>) up: &#x3a3;<sub>i</sub>P<sub>i</sub>m&#x2032;<sub>i</sub>(x&#x2032;,y&#x2032;)&#x3c;&#x3c;s<sub>i</sub>, rounded by adding (rnd) (<b>2270</b>) and right shifted (<b>2280</b>) by smax to form the elements in the quantization matrix: M(x&#x2032;,y&#x2032;)=((&#x3a3;<sub>i</sub>P<sub>i</sub>m&#x2032;<sub>i</sub>(x&#x2032;,y&#x2032;)&#x3c;&#x3c;s<sub>i</sub>)+rnd)&#x3e;&#x3e;smax.</p><p id="p-0181" num="0198"><figref idref="DRAWINGS">FIG. <b>23</b></figref> illustrates method <b>2300</b> for generating the quantization matrix with integer computing, according to an embodiment. Generator <b>2300</b> can be used as in module <b>1620</b> or be performed in step <b>1720</b>.</p><p id="p-0182" num="0199">Method <b>2300</b> starts at step <b>2305</b>. From the matrix size (size<sub>x</sub>, size<sub>y</sub>) and the normalization value N, sx=log2(size<sub>x</sub>)&#x2212;log2(N) and sy=log2(size<sub>y</sub>)&#x2212;log2(N), the rounding and shifting value can be derived (<b>2310</b>) as: smax=max(sx. px+sy. py), and rnd=1&#x3c;&#x3c;(smax&#x2212;1).</p><p id="p-0183" num="0200">The decoder then initializes (<b>2320</b>) variable i to 0, and M (x&#x2032;,y&#x2032;)=rnd. At step <b>2330</b>, the normalization data can be derived: s<sub>i</sub>=smax&#x2212;(sx. px<sub>i</sub>+sy. py<sub>i</sub>). From quantization matrix coordinate x&#x2032; and y&#x2032;, the i-th monomial can be derived (<b>2340</b>) as: m&#x2032;<sub>i</sub>(x&#x2032;,y&#x2032;)=x&#x2032;<sup>px</sup><sup><sub2>i</sub2></sup>y&#x2032;<sup>py</sup><sup><sub2>i</sub2></sup>. Pairing (<b>2350</b>) the i-th monomial with the i-th polynomial parameter P<sub>i</sub>, P<sub>i</sub>m&#x2032;<sub>i</sub>(x&#x2032;,y&#x2032;) is formed, and added to M(x,y) after left shifting (<b>2350</b>): M(x&#x2032;,y&#x2032;)+=P<sub>i</sub>m&#x2032;<sub>i</sub>(x&#x2032;,y&#x2032;)&#x3c;&#x3c;s<sub>i</sub>. At step <b>2360</b>, variable i is incremented by 1. At step <b>2370</b>, the decoder checks whether the last monomial has been processed. If not, the control returns to step <b>2330</b>. Otherwise, at step <b>2380</b>, M(x&#x2032;,y&#x2032;) is right shifted by smax to form the elements in the quantization matrix: M(x&#x2032;,y&#x2032;)&#x3e;&#x3e;=smax. Method <b>2300</b> ends at step <b>2399</b>.</p><p id="p-0184" num="0201">Most variables can be pre-computed, since rnd and smax only depend on matrix size, s<sub>i </sub>depend on matrix size and monomial index. Table 5 shows an example:</p><p id="p-0185" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 5</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Example computation of s<sub>i</sub>, rnd, smax</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="16"><colspec colname="1" colwidth="14pt" align="center"/><colspec colname="2" colwidth="7pt" align="center"/><colspec colname="3" colwidth="7pt" align="center"/><colspec colname="4" colwidth="7pt" align="center"/><colspec colname="5" colwidth="14pt" align="center"/><colspec colname="6" colwidth="14pt" align="center"/><colspec colname="7" colwidth="14pt" align="center"/><colspec colname="8" colwidth="14pt" align="center"/><colspec colname="9" colwidth="14pt" align="center"/><colspec colname="10" colwidth="14pt" align="center"/><colspec colname="11" colwidth="14pt" align="center"/><colspec colname="12" colwidth="21pt" align="center"/><colspec colname="13" colwidth="14pt" align="center"/><colspec colname="14" colwidth="21pt" align="center"/><colspec colname="15" colwidth="14pt" align="center"/><colspec colname="16" colwidth="14pt" align="center"/><tbody valign="top"><row><entry>m<sub>i</sub></entry><entry>1</entry><entry>x</entry><entry>y</entry><entry>xy</entry><entry>x<sup>2</sup></entry><entry>y<sup>2</sup></entry><entry>x<sup>2</sup>y</entry><entry>xy<sup>2</sup></entry><entry>x<sup>3</sup></entry><entry>y<sup>3</sup></entry><entry>x<sup>2</sup>y<sup>2</sup></entry><entry>x<sup>3</sup>y</entry><entry>xy<sup>3 </sup></entry><entry>x<sup>4</sup></entry><entry>y<sup>4</sup></entry></row><row><entry namest="1" nameend="16" align="center" rowsep="1"/></row><row><entry>px<sub>i</sub></entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>0</entry><entry>2</entry><entry>1</entry><entry>3</entry><entry>0</entry><entry>2</entry><entry>3</entry><entry>1</entry><entry>4</entry><entry>0</entry></row><row><entry>py<sub>i</sub></entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>1</entry><entry>0</entry><entry>2</entry><entry>1</entry><entry>2</entry><entry>0</entry><entry>3</entry><entry>2</entry><entry>1</entry><entry>3</entry><entry>0</entry><entry>4</entry></row><row><entry namest="1" nameend="16" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0186" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="273pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>For an 8 &#xd7; 8 matrix and N = 2: sx = 2, sy = 2, smax = 8, and rnd = 128</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="16"><colspec colname="1" colwidth="63pt" align="center"/><colspec colname="2" colwidth="14pt" align="center"/><colspec colname="3" colwidth="14pt" align="center"/><colspec colname="4" colwidth="14pt" align="center"/><colspec colname="5" colwidth="14pt" align="center"/><colspec colname="6" colwidth="14pt" align="center"/><colspec colname="7" colwidth="14pt" align="center"/><colspec colname="8" colwidth="14pt" align="center"/><colspec colname="9" colwidth="14pt" align="center"/><colspec colname="10" colwidth="14pt" align="center"/><colspec colname="11" colwidth="14pt" align="center"/><colspec colname="12" colwidth="14pt" align="center"/><colspec colname="13" colwidth="14pt" align="center"/><colspec colname="14" colwidth="14pt" align="center"/><colspec colname="15" colwidth="14pt" align="center"/><colspec colname="16" colwidth="14pt" align="center"/><tbody valign="top"><row><entry>sx &#xb7; px<sub>i </sub>+ sy &#xb7; py<sub>i</sub></entry><entry>0</entry><entry>2</entry><entry>2</entry><entry>4</entry><entry>4</entry><entry>4</entry><entry>6</entry><entry>6</entry><entry>6</entry><entry>6</entry><entry>8</entry><entry>8</entry><entry>8</entry><entry>8</entry><entry>8</entry></row><row><entry>s<sub>i</sub></entry><entry>8</entry><entry>6</entry><entry>6</entry><entry>4</entry><entry>4</entry><entry>4</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>2</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry></row><row><entry namest="1" nameend="16" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0187" num="0202">It can be noted that m&#x2032;<sub>i </sub>do not depend on matrix size, hence they can be computed once lit for all, with a subpart used for smaller sizes. Efficient incremental implementations are possible, with very few multiplications.</p><p id="p-0188" num="0203">Alternatively, shifting by s<sub>i </sub>can be applied to P<sub>i </sub>before the computation of the matrix, so that the latter is a series of multiply-accumulate, initialized by rnd, and followed by a right shift, which is a very commonplace operation.</p><heading id="h-0009" level="2">Analysis of Intermediate Computation Bit Depth</heading><p id="p-0189" num="0204">For the example above (8&#xd7;8 matrix with N=2), with 8-bit signed P<sub>i</sub>, Table 6 shows the bit depth of m&#x2032;<sub>i</sub>, P<sub>i</sub>m&#x2032;<sub>i </sub>and P<sub>i</sub>m&#x2032;<sub>i</sub>&#x3c;&#x3c;s<sub>i</sub>.</p><p id="p-0190" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="16"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="14pt" align="center"/><colspec colname="3" colwidth="14pt" align="center"/><colspec colname="4" colwidth="14pt" align="center"/><colspec colname="5" colwidth="14pt" align="center"/><colspec colname="6" colwidth="14pt" align="center"/><colspec colname="7" colwidth="14pt" align="center"/><colspec colname="8" colwidth="14pt" align="center"/><colspec colname="9" colwidth="14pt" align="center"/><colspec colname="10" colwidth="14pt" align="center"/><colspec colname="11" colwidth="14pt" align="center"/><colspec colname="12" colwidth="14pt" align="center"/><colspec colname="13" colwidth="14pt" align="center"/><colspec colname="14" colwidth="14pt" align="center"/><colspec colname="15" colwidth="14pt" align="center"/><colspec colname="16" colwidth="14pt" align="center"/><thead><row><entry namest="1" nameend="16" rowsep="1">TABLE 6</entry></row><row><entry namest="1" nameend="16" align="center" rowsep="1"/></row><row><entry>i</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry><entry>5</entry><entry>6</entry><entry>7</entry><entry>8</entry><entry>9</entry><entry>10</entry><entry>11</entry><entry>12</entry><entry>13</entry><entry>14</entry><entry>15</entry></row><row><entry namest="1" nameend="16" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="16"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="14pt" align="char" char="."/><colspec colname="3" colwidth="14pt" align="char" char="."/><colspec colname="4" colwidth="14pt" align="char" char="."/><colspec colname="5" colwidth="14pt" align="char" char="."/><colspec colname="6" colwidth="14pt" align="char" char="."/><colspec colname="7" colwidth="14pt" align="char" char="."/><colspec colname="8" colwidth="14pt" align="char" char="."/><colspec colname="9" colwidth="14pt" align="char" char="."/><colspec colname="10" colwidth="14pt" align="char" char="."/><colspec colname="11" colwidth="14pt" align="char" char="."/><colspec colname="12" colwidth="14pt" align="center"/><colspec colname="13" colwidth="14pt" align="center"/><colspec colname="14" colwidth="14pt" align="center"/><colspec colname="15" colwidth="14pt" align="center"/><colspec colname="16" colwidth="14pt" align="center"/><tbody valign="top"><row><entry>m&#x2032;<sub>i </sub>bitdepth</entry><entry>0</entry><entry>3</entry><entry>3</entry><entry>6</entry><entry>6</entry><entry>6</entry><entry>9</entry><entry>9</entry><entry>9</entry><entry>9</entry><entry>12</entry><entry>12</entry><entry>12</entry><entry>12</entry><entry>12</entry></row><row><entry>P<sub>i</sub>m&#x2032;<sub>i </sub>&#x2192;</entry><entry>8</entry><entry>11</entry><entry>11</entry><entry>14</entry><entry>14</entry><entry>14</entry><entry>17</entry><entry>17</entry><entry>17</entry><entry>17</entry><entry>20</entry><entry>20</entry><entry>20</entry><entry>20</entry><entry>20</entry></row><row><entry>P<sub>i</sub>m&#x2032;<sub>i </sub>&#x3c;&#x3c; S<sub>i </sub>&#x2192;</entry><entry>16</entry><entry>17</entry><entry>17</entry><entry>18</entry><entry>18</entry><entry>18</entry><entry>19</entry><entry>19</entry><entry>19</entry><entry>19</entry><entry>20</entry><entry>20</entry><entry>20</entry><entry>20</entry><entry>20</entry></row><row><entry namest="1" nameend="16" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0191" num="0205">However, we expect a result with mbd (matrix bit depth)=8 bits (unsigned) for the matrix values, after shifting right by smax=8 bits. P<sub>i </sub>shall be constrained at design time so that the result is positive and within bounds (0-255). Furthermore, truncation (of upper bits) after shifting (mbd=8 bits), or before (mbd+smax=16 bits), is equivalent. Also, for an addition, truncating operands make no difference if the result is truncated to the same bit depth, and two's complement representation of signed values makes this applicable to both signed and unsigned numbers.</p><p id="p-0192" num="0206">This means that the accumulator of P<sub>i</sub>m&#x2032;<sub>i</sub>&#x3c;&#x3c;s<sub>i </sub>can be limited to (mbd+smax)=16 bits. However, multipliers cannot be reduced (but their result can be truncated to the working bit depth). In the 8&#xd7;8 example, they must have 12 and 8-bit inputs and 16-bit result; for a 256&#xd7;256 matrix, they should have 32 and 8-bit inputs, and 36-bit result.</p><p id="p-0193" num="0207">The final right shift could be adjusted, to give some flexibility on the range and accuracy of P<sub>i</sub>. Eq. (10) is then modified as follows:</p><p id="p-0194" num="0000"><maths id="MATH-US-00023" num="00023"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mrow>       <mrow>        <mi>M</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msup>          <mi>x</mi>          <mo>&#x2032;</mo>         </msup>         <mo>,</mo>         <msup>          <mi>y</mi>          <mo>&#x2032;</mo>         </msup>        </mrow>        <mo>)</mo>       </mrow>       <mo>=</mo>       <mrow>        <mo>(</mo>        <mrow>         <mrow>          <mo>(</mo>          <mrow>           <munder>            <mo>&#x2211;</mo>            <mi>i</mi>           </munder>           <mrow>            <msub>             <mi>P</mi>             <mi>i</mi>            </msub>            <mo>&#x2062;</mo>            <mrow>             <msubsup>              <mi>m</mi>              <mi>i</mi>              <mo>&#x2032;</mo>             </msubsup>             <mo>(</mo>             <mrow>              <msup>               <mi>x</mi>               <mo>&#x2032;</mo>              </msup>              <mo>,</mo>              <msup>               <mi>y</mi>               <mo>&#x2032;</mo>              </msup>             </mrow>             <mo>)</mo>            </mrow>            <mo>&#x2062;</mo>            <mrow>             <mo>&#xf761;</mo>             <msub>              <mi>s</mi>              <mi>i</mi>             </msub>            </mrow>           </mrow>          </mrow>          <mo>)</mo>         </mrow>         <mo>+</mo>         <mi>rnd</mi>        </mrow>        <mo>)</mo>       </mrow>      </mrow>      <mo>&#xf762;</mo>     </mrow>     <mo>&#x2062;</mo>     <mrow>      <mo>(</mo>      <mrow>       <mi>smax</mi>       <mo>-</mo>       <msub>        <mi>s</mi>        <mi>base</mi>       </msub>      </mrow>      <mo>)</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>11</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0195" num="0208">This is intended to be used with positive values, to improve accuracy of the parameters. to If negative values are used to increase dynamic range, it should be noted that this will have an impact on intermediate computation bit depth (for example, &#x2212;1 will add 1 bit the accumulator bit depth).</p><p id="p-0196" num="0209">Rounding value rnd should be adjusted accordingly: rnd=1&#x3c;&#x3c;(smax&#x2212;s<sub>base</sub>&#x2212;1).</p><p id="p-0197" num="0210">Lower clipping can be added on top of polynomial representation, as shown in Eq. (12) (this is also applicable on top of Eq. (10) or (11)). This can improve fitting to usual quantization matrices because they often have a flat area on the lower end.</p><p id="p-0198" num="0000"><maths id="MATH-US-00024" num="00024"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>M</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <mi>x</mi>       <mo>,</mo>       <mi>y</mi>      </mrow>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mrow>      <mi>max</mi>      <mo>(</mo>      <mrow>       <mrow>        <munder>         <mo>&#x2211;</mo>         <mi>i</mi>        </munder>        <mrow>         <msub>          <mi>P</mi>          <mi>i</mi>         </msub>         <mo>&#x2062;</mo>         <mrow>          <msub>           <mi>m</mi>           <mi>i</mi>          </msub>          <mo>(</mo>          <mrow>           <mi>x</mi>           <mo>,</mo>           <mi>y</mi>          </mrow>          <mo>)</mo>         </mrow>        </mrow>       </mrow>       <mo>,</mo>       <mi>clip</mi>      </mrow>      <mo>)</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>12</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0199" num="0000">This has a significant impact on fitting quality, especially for small number of parameters, as illustrated in <figref idref="DRAWINGS">FIG. <b>24</b></figref> and <figref idref="DRAWINGS">FIG. <b>25</b></figref> (tested without symmetry flag nor custom shifting). In particular, the left figure in <figref idref="DRAWINGS">FIG. <b>24</b></figref> shows the fitting for the default HEVC intra matrix using 10-parameters, without clipping, and the right figure is with clipping. The figures in <figref idref="DRAWINGS">FIG. <b>25</b></figref> shows the impact of clipping on fitting error for the default HEVC intra 8&#xd7;8 matrix (left), JCTVC-F475 8&#xd7;8 asymmetric test matrix (middle), H.264 matrix (right).</p><p id="p-0200" num="0211">It should be noted that discussions around polynomial result range are no more applicable on the lower side, because of clipping: polynomial is now unbounded below zero, since clipping will correct it. Either the polynomial coefficients should be constrained to give result within matrix range, or the result bit depth should be increased to accommodate for the bigger range, with relaxed constraint. The recommended option is to have 1 bit more, to allow negative polynomial (up to &#x2212;256 for 8-bit matrix coefficients); clipping would make the result positive and drop the sign bit.</p><p id="p-0201" num="0212">Current HEVC syntax is reproduced in the following (see HEVC standard version 3, April 2015):</p><p id="p-0202" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="224pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>scaling_list_data( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry>&#x2003;&#x2003;nextCoef = 8</entry><entry/></row><row><entry>&#x2003;&#x2003;coefNum = Min( 64, ( 1 &#x3c;&#x3c; ( 4 + ( sizeId &#x3c;&#x3c; 1 ) ) ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( sizeld &#x3e; l ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;scaling_list_dc_ minus8[ sizeId - 2 ][ matrixId ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;nextCoef = scaling_list_dc_coef_minus8[ sizeId &#x2212; 2 ][ matrixId ] + 8</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; coefNum; i++) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;scaling_list_delta_coef</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;nextCoef = ( nextCoef + scaling_list_delta coef + 256 ) % 256</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ScalingList[ sizeId ][ matrixId ][ i ] = nextCoef</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0203" num="0213">Based on the proposed model, this portion of syntax can be replaced for example by:</p><p id="p-0204" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="161pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>scaling_list_data( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;scaling_poly_nb_param</entry><entry>u(4)</entry></row><row><entry/><entry>&#x2003;&#x2003;if( scaling_poly_nb_param &#x3e; 0 ) {</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;scaling_poly_symmetric</entry><entry>f(1)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;scaling_poly_shift[ sizeId ][ matrixId ]</entry><entry>u(2)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;scaling_poly_clip[ sizeId ][ matrixId ]</entry><entry>f(4)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; scaling_poly_nb_param; i++) {</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;scaling_poly_param[ i ]</entry><entry>i(8)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0205" num="0214">scaling_poly_nb_param=0 means &#x201c;default parameters&#x201d;. In that case the following syntax elements are skipped. Otherwise, it defines the number of scaling_poly_param present to in the syntax. Please note that it may be taken from a list of predefined values. The number of parameters may also be indicated using a look-up table, for example, a table nb_param[i][sym] may be known at both the encoder and decoder, and index i of the table is signaled in the bitstream. In one example, the number of parameters is restricted to 1, 3, 4, 6, 8, 10, 11, 13, and 15.</p><p id="p-0206" num="0215">scaling_poly_symmetric, if 1, indicates that scaling_poly_param should be repeated for x/y symmetric polynomial coefficients. This flag can be removed if this feature is not desired. If removed, it should be inferred to 0 in the following.</p><p id="p-0207" num="0216">scaling_poly_shift selects s<sub>base </sub>from a set of predefined values. For example, s<sub>base</sub>=scaling_poly_shift&#x2014;offset, with offset selected in accordance to normalization. For N=2, we recommend 0 to 3 range, i.e., use s<sub>base</sub>=scaling_poly_shift.</p><p id="p-0208" num="0217">scaling_poly_clip defines the lower clipping value from a range of predefined values. It can take fewer bits than shown in the table, for example, it can use 2 or 3 instead of 4 bits. This could be [1, 4, 8, 16], for example. Please note that the lower clipping value typically is no greater than 16 (the neutral value for 8-bit matrix coefficients used as quantization scaling factors as in HEVC).</p><p id="p-0209" num="0218">scaling_poly_param is used to represent the polynomial coefficients for the selected matrix (scaling_poly_coef, that matches P<sub>i </sub>in equations (3), (11), (12), and others).</p><p id="p-0210" num="0219">The size, order, and format of syntax elements can be changed, and some of them can depend on scaling_poly_nb_param. For example, scaling_poly_symmetric is useless if scaling_poly_nb_param is 0 or 1, and the number of bits of scaling_poly_shift can increase with the number of parameters, etc. In addition, the syntax can vary, and polynomial coefficients could be derived in an indirect way.</p><p id="p-0211" num="0220">In HEVC, the scaling list is signaled in SPS (Sequence Parameter Set) or PPS (Picture</p><p id="p-0212" num="0221">Parameter Set). It should be noted that the present embodiments are not limited to transmitting the quantization matrix information in SPS or PPS. For example, the quantization matrix information can be transmitted in a parameter set dedicated to transmitting matrices. In another example, the quantization matrix information can be transmitted at the block level, possibly with the number of parameters being variable.</p><p id="p-0213" num="0222">The following algorithm can be used to duplicate symmetric elements on the fly when needed:</p><p id="p-0214" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="28pt" align="left"/><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="154pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;</entry><entry>k = n = degree = 0;</entry></row><row><entry/><entry/><entry>for( i = 0; i &#x3c; scaling_poly_nb_param; i++ ) {</entry></row><row><entry/><entry/><entry>&#x2003;scaling_poly_coef[sizeId] [matrixId]</entry></row><row><entry/><entry/><entry>&#x2003;[n++] = scaling_poly_param[i] ;</entry></row><row><entry/><entry/><entry>&#x2003;if( scaling_poly_symmetric ) {</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;k++;</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;if( k &#x3e; (degree+1) % 2 ) {</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;scaling_poly_coef[sizeId] [matrixId]</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;[n++] = scaling_poly_param[i] ;</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;k++;</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;}</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;if( k &#x3e; degree ) {</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;degree ++;</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;k = 0;</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;}</entry></row><row><entry/><entry/><entry>&#x2003;}</entry></row><row><entry/><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0215" num="0223">With this method, there is no need to save symmetric flag because all coefficients are derived on the fly. Note that this is a simple copy when scaling_poly_symmetric is zero.</p><p id="p-0216" num="0224">Note that non-specified parameters should have no effect: either scaling_poly_coef should be initialized to zero, or n should be saved so that matrix computation can terminate early.</p><p id="p-0217" num="0225">This algorithm can be written in tabular form as follows:</p><p id="p-0218" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="238pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>scaling_list_data( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry>&#x2003;&#x2003;scaling_poly_nb_param</entry><entry>u(4)</entry></row><row><entry>&#x2003;&#x2003;if( scaling_poly_nb_param &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;scaling_poly_symmetric</entry><entry>f(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;scaling_poly_shift[ sizeId ][ matrixId ]</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;scaling_poly_clip[ sizeId ][ matrixId ]</entry><entry>f(4)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;k = n = degree = 0;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; scaling_poly_nb_param; i++) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;scaling_poly_param</entry><entry>i(8)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;scaling_poly_coef[ sizeId ][ matrixId ][ n++ ] = scaling_poly_param</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;k++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( scaling_poly_symmetric &#x26;&#x26; k &#x3e; (degree+1) % 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;scaling_poly_coef[&#x2003;sizeId&#x2003;][&#x2003;matrixId&#x2003;][&#x2003;n++&#x2003;]&#x2003;=</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;scaling_poly_param</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;k++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( k &#x3e; degree ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;degree++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;k = 0</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0010" level="2">Residuals</heading><p id="p-0219" num="0226">As in [JCTVC-H0460], residuals can be added to further improve the fit to a given matrix shape. To optimize coding cost, the number of residuals should be variable, with a scanning order following low-frequency to high-frequency coefficients order, such as up-right diagonal (as in HEVC) or zig-zag (as in AVC), because low-frequency coefficients are often regarded as more critical. Non-coded residuals are inferred to 0.</p><p id="p-0220" num="0227">This can be coded with the following syntax, immediately after polynomial definition:</p><p id="p-0221" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="161pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>scaling_list_data( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;scaling_residual_nb</entry><entry>ue(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; scaling_residual_nb; i++) {</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;scaling_residual_list[ sizeId ][ matrixId ][i]</entry><entry>se(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0222" num="0228">In another embodiment, residuals may not be recommended, because of complexity and memory considerations.</p><heading id="h-0011" level="2">Matrix as QP Offset</heading><p id="p-0223" num="0229">As in [JCTVC-I0284], quantization matrices can be used as QP offsets (denoted as &#x201c;QP-offset mode&#x201d; or &#x201c;log scale mode&#x201d; because QP represents quantizer scale in a log scale) rather than scaling factors (denoted as &#x201c;linear scale mode&#x201d;), since it brings several advantages:<ul id="ul0021" list-style="none">    <li id="ul0021-0001" num="0000">    <ul id="ul0022" list-style="none">        <li id="ul0022-0001" num="0230">Simpler dequantization, by removal of a multiplication, which in turn reduces computation dynamic range. This leaves room for increased accuracy for levScale, which allows its use as &#x221a;{square root over (2)} factor (using an additional QP offset) for some non-square transform normalization, and completely removes multiplications other than levScale.</li>        <li id="ul0022-0002" num="0231">Quantization is similarly simplified by the removal of the division by quantization matrix coefficient (usually implemented as a multiplication by inverse of quantization matrix, with accuracy compromise, memory impact, and even more pressure on dynamic range than for dequantization), leaving only multiplication by inverse of levScale.</li>        <li id="ul0022-0003" num="0232">It makes sense to unify the representation of all quantization adjustments</li>        <li id="ul0022-0004" num="0233">Neutral value (flat matrix) is zero</li>        <li id="ul0022-0005" num="0234">Log scale naturally provides better accuracy to low frequency coefficients, which are more critical</li>        <li id="ul0022-0006" num="0235">HEVC default matrix formula uses an exponent; log scale representation should be easier to fit with a polynomial. In general, fit is expected to be better in log scale, further reducing the need for residual or a high number of parameters, or even clipping.</li>        <li id="ul0022-0007" num="0236">Exponentiation would turn to a multiplication, which is much easier to implement</li>        <li id="ul0022-0008" num="0237">Log scale representation being signed (e.g., &#x2212;128 to +127), dynamic range extension related to clipping may not be needed</li>        <li id="ul0022-0009" num="0238">Increased QP granularity, required for smooth matrix definition, also provides better rate control</li>    </ul>    </li></ul></p><p id="p-0224" num="0239">The drawback is the need for finer QP granularity, which impacts at least<ul id="ul0023" list-style="none">    <li id="ul0023-0001" num="0000">    <ul id="ul0024" list-style="none">        <li id="ul0024-0001" num="0240">levScale definition,</li>        <li id="ul0024-0002" num="0241">delta-QP bit cost for slice header: would barely add two bits</li>        <li id="ul0024-0003" num="0242">delta-QP bit cost for coding units. This can be mitigated by introducing a delta-QP scale (in PPS, or slice header), as already proposed in the past (e.g., [JCTVC-C135], D. Hoang, &#x201c;Flexible scaling of quantization parameter,&#x201d; JCTVC-C135, JCT-VC 3rd Meeting: Guangzhou, CN, Oct. 7-15, 2010), which can actually decrease delta-QP coding cost.</li>        <li id="ul0024-0004" num="0243">threshold tables used by deblocking filter</li>        <li id="ul0024-0005" num="0244">Lagrange multipliers used at various places</li>    </ul>    </li></ul></p><p id="p-0225" num="0245">Please note that the impact can be limited to levScale if QP granularity is increased for quantization matrices only, as in [JCTVC-I0284].</p><p id="p-0226" num="0246">We further recommend adopting a QP scale with 1/16 step (as in [JCTVC-A114], J. Jung et al, &#x201c;Description of video coding technology proposal by France Telecom, NTT, NTT DOCOMO, Panasonic and Technicolor&#x201d;, JCTVC-A114, JCT-VC 1st Meeting: Dresden, Del., Apr. 15-23, 2010) instead of &#x2159;, or 1/12 as in [JCTVC-I0284]. This further simplifies the quantization/dequantization operations, by removing division by 6 and modulo-6 operations, which are replaced by bit mask and shift (no actual operation in hardware). This also eases the implementation of QP offsets.</p><p id="p-0227" num="0247">Then, QP would generally use two more bits as a result of increased accuracy. An appropriate conversion formula can be defined to convert QP values (let us call them QP<sub>6</sub>) to the new standard (QP16). Quantization matrix bit depth can be decreased to 7 bits signed: &#x2212;64 to +63 range matches the 1/16 to 16 range of linear-scale matrix definition, with 30% better resolution around the neutral value. This in turn reduces the bit depth of polynomial parameters to 7-bit, leading to lower coding cost, and reduces matrix computation dynamic range as discussed above.</p><p id="p-0228" num="0248">The syntax would be changed to the following (scaling_poly_param reduced to 7-bit):</p><p id="p-0229" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="175pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>scaling_list_data( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry>&#x2003;&#x2003;scaling_poly_nb_param</entry><entry>u(4)</entry></row><row><entry>&#x2003;&#x2003;if( scaling_poly_nb_param &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;scaling_poly_symmetric</entry><entry>f(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;scaling_poly_shift[ sizeId ][ matrixId ]</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;scaling_poly_clip[ sizeId ][ matrixId ]</entry><entry>f(4?)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; scaling_poly_nb_param; i++) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;scaling_poly_param[ i ]</entry><entry>i(7)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;. . .</entry><entry/></row><row><entry>s}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0230" num="0249"><figref idref="DRAWINGS">FIG. <b>26</b></figref> illustrates the fitting results for the default HEVC intra matrix with 6 parameters. The test is performed without symmetry, shift, nor clipping. The left figure shows the result from using the quantization matrix for linear scaling (51 bits used to encode the quantization matrix), and the right figure shows the result from using the quantization matrix for QP offsets (46 bits used to encode the quantization matrix). Overall, in various tests, fit generally looks better in QP-offset mode, even when evaluated in linear domain.</p><heading id="h-0012" level="2">Default Parameters</heading><p id="p-0231" num="0250">Example parameters to match default HEVC 8&#xd7;8 intra matrix can be found below:</p><heading id="h-0013" level="2">Linear Scale Mode:</heading><p id="p-0232" num="0000"><ul id="ul0025" list-style="none">    <li id="ul0025-0001" num="0000">    <ul id="ul0026" list-style="none">        <li id="ul0026-0001" num="0251">clip=16, Sbase=0, sym=1</li>        <li id="ul0026-0002" num="0252">5-parameters (8-bit) P<sub>i</sub>=[&#x2212;53, 94, &#x2212;121, &#x2212;29, 36]</li>        <li id="ul0026-0003" num="0253">7-parameters (8-bit) P<sub>i</sub>=[6, 8, 18, 0,&#x2212;17, 1, 21]</li>    </ul>    </li></ul></p><heading id="h-0014" level="2">QP-Offset Mode:</heading><p id="p-0233" num="0000"><ul id="ul0027" list-style="none">    <li id="ul0027-0001" num="0000">    <ul id="ul0028" list-style="none">        <li id="ul0028-0001" num="0254">clip=0, Sbase=0, sym=1</li>        <li id="ul0028-0002" num="0255">4-parameters (7-bit) P<sub>i</sub>=[&#x2212;2, &#x2212;2, 10, 4]</li>        <li id="ul0028-0003" num="0256">5-parameters (7-bit) P<sub>i</sub>=[&#x2212;27, 32, &#x2212;26, &#x2212;7, 8]</li>        <li id="ul0028-0004" num="0257">6-parameters (7-bit) P<sub>i</sub>=[&#x2212;8, 2, &#x2212;3, 11, 3, &#x2212;4]</li>        <li id="ul0028-0005" num="0258">7-parameters (7-bit) P<sub>i</sub>=[1, &#x2212;17, 38, 21, &#x2212;16, &#x2212;5, 9]</li>        <li id="ul0028-0006" num="0259">8-parameters (7-bit) P<sub>i</sub>=[&#x2212;3, &#x2212;1, 6, 3, 4, 1, 6, &#x2212;5]</li>        <li id="ul0028-0007" num="0260">9-parameters (7-bit) P<sub>i</sub>=[0, &#x2212;8, 10, 14, 3, &#x2212;7, 6, &#x2212;5, 2]</li>    </ul>    </li></ul></p><p id="p-0234" num="0261">Coding default HEVC intra 8&#xd7;8 matrix with HEVC syntax would take 265 bits (1 bit to code scaling_list_pred_mode_flag, and 264 bits to code the scaling list delta coef values).</p><p id="p-0235" num="0262">For the linear scale mode and QP-offset mode, the coding bit cost and average fitting absolute error for the suggested parameters are analyzed as follows:<ul id="ul0029" list-style="none">    <li id="ul0029-0001" num="0000">    <ul id="ul0030" list-style="none">        <li id="ul0030-0001" num="0263">4 bits for scaling_poly_nb_param,</li>        <li id="ul0030-0002" num="0264">1 bit for scaling_poly_symmetric,</li>        <li id="ul0030-0003" num="0265">2 bits for scaling_poly_shift,</li>        <li id="ul0030-0004" num="0266">4 bits for scaling_poly_clip, and</li>        <li id="ul0030-0005" num="0267">8 or 7 bits for each parameter.</li>    </ul>    </li></ul></p><p id="p-0236" num="0268">To enable error comparison, error for QP offset mode is computed in linear demain, i.e., by first converting back the QP offsets to scale factors. LF error is the average absolute error for low frequencies half (x+y&#x3c;8). It can be seen from Table 7 that using 51 bits for the linear scale mode, and 46 bits for the QP offset mode, the error for representing the quantization matrix is small. Thus, compared to 265 bits used by the HEVC standard, the proposed methods achieved a good bit saving in encoding the quantization matrix without a big loss in accuracy. In addition, as also shown in Table 7 the method can be easily scaled, by using more polynomial parameters, to improve the accuracy in representing the quantization matrix.</p><p id="p-0237" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="98pt" align="center"/><colspec colname="3" colwidth="84pt" align="center"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 7</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Number of</entry><entry>Linear scale</entry><entry>QP offset</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="35pt" align="center"/><colspec colname="3" colwidth="21pt" align="center"/><colspec colname="4" colwidth="42pt" align="center"/><colspec colname="5" colwidth="21pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><colspec colname="7" colwidth="28pt" align="center"/><tbody valign="top"><row><entry>parameters</entry><entry>Bits</entry><entry>Error</entry><entry>LF error</entry><entry>Bits</entry><entry>Error</entry><entry>LF error</entry></row><row><entry namest="1" nameend="7" align="center" rowsep="1"/></row><row><entry>4</entry><entry/><entry/><entry/><entry>39</entry><entry>1.23</entry><entry>0.60</entry></row><row><entry>5</entry><entry>51</entry><entry>0.89</entry><entry>0.89</entry><entry>46</entry><entry>1.26</entry><entry>0.58</entry></row><row><entry>6</entry><entry/><entry/><entry/><entry>53</entry><entry>0.79</entry><entry>0.48</entry></row><row><entry>7</entry><entry>67</entry><entry>0.50</entry><entry>0.36</entry><entry>60</entry><entry>0.57</entry><entry>0.43</entry></row><row><entry>8</entry><entry/><entry/><entry/><entry>67</entry><entry>0.59</entry><entry>0.34</entry></row><row><entry>9</entry><entry/><entry/><entry/><entry>74</entry><entry>0.66</entry><entry>0.23</entry></row><row><entry namest="1" nameend="7" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0238" num="0269">Polynomial coefficients can be obtained by least squares fitting to an existing 8&#xd7;8 matrix, with constraints on coefficient range, and resulting matrix values. If relevant, lower clipping can be set manually.</p><p id="p-0239" num="0270">In some embodiments, the polynomial can take other forms than what is described above, or be a combination of several sub-polynomials:<ul id="ul0031" list-style="none">    <li id="ul0031-0001" num="0000">    <ul id="ul0032" list-style="none">        <li id="ul0032-0001" num="0271">x and y can be replaced by u and v, with u=(x+y) and v=(x&#x2212;y), or even u=(ax+by) and v=(bx&#x2212;ay), with a+b=1, and a possibly transmitted. For flat-diagonal matrices, all coefficients in v would be zero, and for symmetric matrices (with respect to u axis), all coefficients with odd powers of v would be zero. However, the benefits may be difficult to take advantage of, and an additional parameter (a) may be required.</li>        <li id="ul0032-0002" num="0272">Two separable polynomials may be combined to generate a matrix, for example, M(x,y)=P<sub>1</sub>(x)&#xb7;P<sub>2</sub>(y) or M(x,y)=P<sub>1</sub>(x)+P<sub>2</sub>(y), with x and y possibly replaced by u and v defined above, and with P<sub>1 </sub>and P<sub>2 </sub>defined separately with possibly a different number of parameters for each.</li>    </ul>    </li></ul></p><p id="p-0240" num="0273">Various methods as described above may be used to modify, e.g., the quantization module and de-quantization module (<b>130</b>, <b>140</b>, <b>240</b>) of the encoder <b>100</b> and decoder <b>200</b> as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> and <figref idref="DRAWINGS">FIG. <b>2</b></figref>, respectively. Moreover, the present embodiments are not limited to VVC or HEVC, and may be applied to other standards, recommendations, and extensions thereof.</p><p id="p-0241" num="0274">Various methods are described herein, and each of the methods comprises one or more steps or actions for achieving the described method. Unless a specific order of steps or actions is required for proper operation of the method, the order and/or use of specific steps and/or actions may be modified or combined. Unless indicated otherwise, or technically precluded, the aspects described in this application can be used individually or in combination. Various numeric values are used in the present application, for example, the parameter used in bit shifting for integer implementation, and the example polynomial parameters. The specific values are for example purposes and the aspects described are not limited to these specific values.</p><p id="p-0242" num="0275"><figref idref="DRAWINGS">FIG. <b>27</b></figref> illustrates a method (<b>2700</b>) of encoding video data, according to an embodiment. At step <b>2710</b>, a parametric model based on a sequence of parameters is accessed by the encoder. At step <b>2720</b>, the encoder determines a plurality of parameters to model the quantization matrix. At step <b>2730</b>, the encoder associates each parameter of the plurality of parameters with a corresponding parameter of a subset of the sequence of parameters, to represent the quantization matrix. At step <b>2740</b>, the encoder quantizes transform coefficients of a block of an image based on the quantization matrix. At step <b>2750</b>, the encoder encodes quantized transform coefficients, for example, using an entropy encoder.</p><p id="p-0243" num="0276"><figref idref="DRAWINGS">FIG. <b>28</b></figref> illustrates a method (<b>2800</b>) of decoding video data, according to an embodiment. At step <b>2810</b>, a parametric model based on a sequence of parameters is accessed by the decoder. At step <b>2820</b>, the decoder determines a plurality of parameters to model the quantization matrix. At step <b>2830</b>, the decoder associates each parameter of the plurality of parameters with a corresponding parameter of a subset of the sequence of parameters, to represent a quantization matrix. At step <b>2840</b>, the decoder de-quantizes transform coefficients of a block of an image based on the quantization matrix. At step <b>2850</b>, the decoder reconstructs the block of the image responsive to the de-quantized transform coefficients.</p><p id="p-0244" num="0277"><figref idref="DRAWINGS">FIG. <b>29</b></figref> illustrates a block diagram of an example of a system in which various aspects and embodiments are implemented. System <b>2900</b> can be embodied as a device including the various components described below and is configured to perform one or more of the aspects described in this application. Examples of such devices, include, but are not limited to, various electronic devices such as personal computers, laptop computers, smartphones, tablet computers, digital multimedia set top boxes, digital television receivers, personal video recording systems, connected home appliances, and servers. Elements of system <b>2900</b>, singly or in combination, can be embodied in a single integrated circuit, multiple ICs, and/or discrete components. For example, in at least one embodiment, the processing and encoder/decoder elements of system <b>2900</b> are distributed across multiple ICs and/or discrete components. In various embodiments, the system <b>2900</b> is communicatively coupled to other systems, or to other electronic devices, via, for example, a communications bus or through dedicated input and/or output ports. In various embodiments, the system <b>2900</b> is configured to implement one or more of the aspects described in this application.</p><p id="p-0245" num="0278">The system <b>2900</b> includes at least one processor <b>2910</b> configured to execute instructions loaded therein for implementing, for example, the various aspects described in this application. Processor <b>2910</b> can include embedded memory, input output interface, and various other circuitries as known in the art. The system <b>2900</b> includes at least one memory <b>2920</b> (e.g., a volatile memory device, and/or a non-volatile memory device). System <b>2900</b> includes a storage device <b>2940</b>, which can include non-volatile memory and/or volatile memory, including, but not limited to, EEPROM, ROM, PROM, RAM, DRAM, SRAM, flash, magnetic disk drive, and/or optical disk drive. The storage device <b>2940</b> can include an internal storage device, an attached storage device, and/or a network accessible storage device, as non-limiting examples.</p><p id="p-0246" num="0279">System <b>2900</b> includes an encoder/decoder module <b>2930</b> configured, for example, to process data to provide an encoded video or decoded video, and the encoder/decoder module <b>2930</b> can include its own processor and memory. The encoder/decoder module <b>2930</b> represents module(s) that can be included in a device to perform the encoding and/or decoding functions. As is known, a device can include one or both of the encoding and decoding modules. Additionally, encoder/decoder module <b>2930</b> can be implemented as a separate element of system <b>2900</b> or can be incorporated within processor <b>2910</b> as a combination of hardware and software as known to those skilled in the art.</p><p id="p-0247" num="0280">Program code to be loaded onto processor <b>2910</b> or encoder/decoder <b>2930</b> to perform the various aspects described in this application can be stored in storage device <b>2940</b> and subsequently loaded onto memory <b>2920</b> for execution by processor <b>2910</b>. In accordance with various embodiments, one or more of processor <b>2910</b>, memory <b>2920</b>, storage device <b>2940</b>, and encoder/decoder module <b>2930</b> can store one or more of various items during the performance of the processes described in this application. Such stored items can include, but are not limited to, the input video, the decoded video or portions of the decoded video, the bitstream, matrices, variables, and intermediate or final results from the processing of equations, formulas, operations, and operational logic.</p><p id="p-0248" num="0281">In several embodiments, memory inside of the processor <b>2910</b> and/or the encoder/decoder module <b>2930</b> is used to store instructions and to provide working memory for processing that is needed during encoding or decoding. In other embodiments, however, a memory external to the processing device (for example, the processing device can be either the processor <b>2910</b> or the encoder/decoder module <b>2930</b>) is used for one or more of these functions. The external memory can be the memory <b>2920</b> and/or the storage device <b>2940</b>, for example, a dynamic volatile memory and/or a non-volatile flash memory. In several embodiments, an external non-volatile flash memory is used to store the operating system of a television. In at least one embodiment, a fast external dynamic volatile memory such as a RAM is used as working memory for video coding and decoding operations, such as for MPEG-2, HEVC, or VVC (Versatile Video Coding).</p><p id="p-0249" num="0282">The input to the elements of system <b>2900</b> can be provided through various input devices as indicated in block <b>2905</b>. Such input devices include, but are not limited to, (i) an RF portion that receives an RF signal transmitted, for example, over the air by a broadcaster, (ii) a Composite input terminal, (iii) a USB input terminal, and/or (iv) an HDMI input terminal.</p><p id="p-0250" num="0283">In various embodiments, the input devices of block <b>2905</b> have associated respective input processing elements as known in the art. For example, the RF portion can be associated with elements suitable for (i) selecting a desired frequency (also referred to as selecting a signal, or band-limiting a signal to a band of frequencies), (ii) downconverting the selected signal, (iii) band-limiting again to a narrower band of frequencies to select (for example) a signal frequency band which can be referred to as a channel in certain embodiments, (iv) demodulating the downconverted and band-limited signal, (v) performing error correction, and (vi) demultiplexing to select the desired stream of data packets. The RF portion of various embodiments includes one or more elements to perform these functions, for example, frequency selectors, signal selectors, band-limiters, channel selectors, filters, downconverters, demodulators, error correctors, and demultiplexers. The RF portion can include a tuner that performs various of these functions, including, for example, downconverting the received signal to a lower frequency (for example, an intermediate frequency or a near-baseband frequency) or to baseband. In one set-top box embodiment, the RF portion and its associated input processing element receives an RF signal transmitted over a wired (for example, cable) medium, and performs frequency selection by filtering, downconverting, and filtering again to a desired frequency band. Various embodiments rearrange the order of the above-described (and other) elements, remove some of these elements, and/or add other elements performing similar or different functions. Adding elements can include inserting elements in between existing elements, for example, inserting amplifiers and an analog-to-digital converter. In various embodiments, the RF portion includes an antenna.</p><p id="p-0251" num="0284">Additionally, the USB and/or HDMI terminals can include respective interface processors for connecting system <b>2900</b> to other electronic devices across USB and/or HDMI connections. It is to be understood that various aspects of input processing, for example, Reed-Solomon error correction, can be implemented, for example, within a separate input processing</p><p id="p-0252" num="0285">IC or within processor <b>2910</b> as necessary. Similarly, aspects of USB or HDMI interface processing can be implemented within separate interface ICs or within processor <b>2910</b> as necessary. The demodulated, error corrected, and demultiplexed stream is provided to various processing elements, including, for example, processor <b>2910</b>, and encoder/decoder <b>2930</b> operating in combination with the memory and storage elements to process the datastream as necessary for presentation on an output device.</p><p id="p-0253" num="0286">Various elements of system <b>2900</b> can be provided within an integrated housing, Within the integrated housing, the various elements can be interconnected and transmit data therebetween using suitable connection arrangement <b>2915</b>, for example, an internal bus as known in the art, including the I2C bus, wiring, and printed circuit boards.</p><p id="p-0254" num="0287">The system <b>2900</b> includes communication interface <b>2950</b> that enables communication with other devices via communication channel <b>2990</b>. The communication interface <b>2950</b> can include, but is not limited to, a transceiver configured to transmit and to receive data over communication channel <b>2990</b>. The communication interface <b>2950</b> can include, but is not limited to, a modem or network card and the communication channel <b>2990</b> can be implemented, for example, within a wired and/or a wireless medium.</p><p id="p-0255" num="0288">Data is streamed to the system <b>2900</b>, in various embodiments, using a Wi-Fi network such as IEEE 802.11. The Wi-Fi signal of these embodiments is received over the communications channel <b>2990</b> and the communications interface <b>2950</b> which are adapted for Wi-Fi communications. The communications channel <b>2990</b> of these embodiments is typically connected to an access point or router that provides access to outside networks including the Internet for allowing streaming applications and other over-the-top communications. Other embodiments provide streamed data to the system <b>2900</b> using a set-top box that delivers the data over the HDMI connection of the input block <b>2905</b>. Still other embodiments provide streamed data to the system <b>2900</b> using the RF connection of the input block <b>2905</b>.</p><p id="p-0256" num="0289">The system <b>2900</b> can provide an output signal to various output devices, including a display <b>2965</b>, speakers <b>2975</b>, and other peripheral devices <b>2985</b>. The other peripheral devices <b>2985</b> include, in various examples of embodiments, one or more of a stand-alone DVR, a disk player, a stereo system, a lighting system, and other devices that provide a function based on the output of the system <b>2900</b>. In various embodiments, control signals are communicated between the system <b>2900</b> and the display <b>2965</b>, speakers <b>2975</b>, or other peripheral devices <b>2985</b> using signaling such as AV.Link, CEC, or other communications protocols that enable device-to-device control with or without user intervention. The output devices can be communicatively coupled to system <b>2900</b> via dedicated connections through respective interfaces <b>2960</b>, <b>2970</b>, and <b>2980</b>. Alternatively, the output devices can be connected to system <b>2900</b> using the communications channel <b>2990</b> via the communications interface <b>2950</b>. The display <b>2965</b> and speakers <b>2975</b> can be integrated in a single unit with the other components of system <b>2900</b> in an electronic device, for example, a television. In various embodiments, the display interface <b>2960</b> includes a display driver, for example, a timing controller (T Con) chip.</p><p id="p-0257" num="0290">The display <b>2965</b> and speaker <b>2975</b> can alternatively be separate from one or more of the other components, for example, if the RF portion of input <b>2905</b> is part of a separate set-top box. In various embodiments in which the display <b>2965</b> and speakers <b>2975</b> are external components, the output signal can be provided via dedicated output connections, including, for example, HDMI ports, USB ports, or COMP outputs.</p><p id="p-0258" num="0291">According to an embodiment, a method for video decoding is presented, comprising:</p><p id="p-0259" num="0292">accessing a parametric model that is based on a sequence of parameters; determining a plurality of parameters that correspond to a subset of said sequence of parameters; associating each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; de-quantizing transform coefficients of a block of an image based on said quantization matrix; and reconstructing said block of said image responsive to said de-quantized transform coefficients.</p><p id="p-0260" num="0293">According to another embodiment, a method for video encoding is presented, comprising: accessing a parametric model that is based on a sequence of parameters; determining a plurality of parameters that correspond to a subset of said sequence of parameters; associating each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; quantizing transform coefficients of a block of an image based on said quantization matrix; and entropy encoding quantized transform coefficients.</p><p id="p-0261" num="0294">According to another embodiment, an apparatus for video decoding is presented, comprising one or more processors, wherein said one or more processors are configured to: access a parametric model that is based on a sequence of parameters; determine a plurality of parameters that correspond to a subset of said sequence of parameters; associate each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; de-quantize transform coefficients of a block of an image based on said quantization matrix; and reconstruct said block of said image responsive to said de-quantized transform coefficients. The apparatus can further comprise one or more memories coupled to said one or more processors.</p><p id="p-0262" num="0295">According to another embodiment, an apparatus for video encoding is presented, comprising one or more processors, wherein said one or more processors are configured to: access a parametric model that is based on a sequence of parameters; determine a plurality of parameters that correspond to a subset of said sequence of parameters; associate each parameter of said plurality of parameters with a corresponding parameter of said subset of said sequence of parameters, to represent a quantization matrix; quantize transform coefficients of a block of an image based on said quantization matrix; and entropy encode quantized transform coefficients. The apparatus can further comprise one or more memories coupled to said one or more processors.</p><p id="p-0263" num="0296">According to another embodiment, a signal is formatted to include: a value indicating a number of parameters in a plurality of parameters; said plurality of parameters, wherein each parameter of said plurality of parameters is associated with a corresponding parameter of a subset of a sequence of parameters, to represent a quantization matrix, wherein a parametric model is based on said sequence of parameters; and transform coefficients of a block of an image quantized based on said quantization matrix.</p><p id="p-0264" num="0297">According to one embodiment, a value is encoded or decoded to indicate the number of parameters in said plurality of parameters. Usually, as the number of parameters increases, the quantization matrix becomes more complex.</p><p id="p-0265" num="0298">According to one embodiment, the parametric model corresponds to a polynomial in (x, y), where x and y indicate matrix coordinates, said sequence of parameters corresponding to an ordered sequence of polynomial coefficients, said polynomial being defined by said ordered sequence of polynomial coefficients and an ordered sequence of terms.</p><p id="p-0266" num="0299">According to one embodiment, said ordered sequence of polynomial coefficients are symmetrical in x and y.</p><p id="p-0267" num="0300">According to one embodiment, a set of polynomial coefficients is decoded from a bitstream, wherein said ordered sequence of polynomial coefficients is determined responsive to said decoded set of polynomial coefficients.</p><p id="p-0268" num="0301">According to one embodiment, a value indicating a degree of said polynomial is encoded or decoded, wherein said value indicating the number of parameters is obtained from said value indicating said degree. In one example, the degree of said polynomial is set to 4.</p><p id="p-0269" num="0302">According to one embodiment, there is a one-to-one correspondence between said ordered sequence of polynomial coefficients and said ordered sequence of terms.</p><p id="p-0270" num="0303">According to one embodiment, said polynomial is represented as</p><p id="p-0271" num="0000"><maths id="MATH-US-00025" num="00025"><math overflow="scroll"> <mrow>  <mrow>   <mi>M</mi>   <mo>&#x2061;</mo>   <mo>(</mo>   <mrow>    <mi>x</mi>    <mo>,</mo>    <mi>y</mi>   </mrow>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <msub>    <mi>P</mi>    <mn>0</mn>   </msub>   <mo>+</mo>   <mtext></mtext>   <mtable>    <mtr>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>1</mn>       </msub>       <mo>&#x2062;</mo>       <mi>x</mi>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>2</mn>       </msub>       <mo>&#x2062;</mo>       <mi>y</mi>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>3</mn>       </msub>       <mo>&#x2062;</mo>       <mi>xy</mi>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>4</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>x</mi>        <mn>2</mn>       </msup>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>5</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>y</mi>        <mn>2</mn>       </msup>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>6</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>x</mi>        <mn>2</mn>       </msup>       <mo>&#x2062;</mo>       <mi>y</mi>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>7</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>xy</mi>        <mn>2</mn>       </msup>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>8</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>x</mi>        <mn>3</mn>       </msup>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>9</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>y</mi>        <mn>3</mn>       </msup>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>10</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>x</mi>        <mn>2</mn>       </msup>       <mo>&#x2062;</mo>       <msup>        <mi>y</mi>        <mn>2</mn>       </msup>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>11</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>x</mi>        <mn>3</mn>       </msup>       <mo>&#x2062;</mo>       <mi>y</mi>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>12</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>xy</mi>        <mn>3</mn>       </msup>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>13</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>x</mi>        <mn>4</mn>       </msup>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>     <mtd>      <mrow>       <msub>        <mi>P</mi>        <mn>14</mn>       </msub>       <mo>&#x2062;</mo>       <msup>        <mi>y</mi>        <mn>4</mn>       </msup>      </mrow>     </mtd>     <mtd>      <mo>+</mo>     </mtd>    </mtr>    <mtr>     <mtd>      <mo>&#x2026;</mo>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>     <mtd>      <mtext> </mtext>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths></p><p id="p-0272" num="0304">According to one embodiment, one or more parameters in said sequence of parameters, other than said subset of parameters, are set to respective default values. In one example, the default values are set to 0.</p><p id="p-0273" num="0305">According to one embodiment, said polynomial is a fully developed polynomial.</p><p id="p-0274" num="0306">According to one embodiment, said ordered sequence of terms is ordered by increasing degree of terms.</p><p id="p-0275" num="0307">According to one embodiment, said ordered sequence of terms is further ordered by an increasing maximum of x and y exponents.</p><p id="p-0276" num="0308">According to one embodiment, said ordered sequence of terms is further ordered by increasing x or y exponent.</p><p id="p-0277" num="0309">According to one embodiment, a k-th parameter of said plurality of parameters is associated with a k-th term of said ordered sequence of terms.</p><p id="p-0278" num="0310">According to one embodiment, said matrix coordinates are normalized. Normalization can be performed as</p><p id="p-0279" num="0000"><maths id="MATH-US-00026" num="00026"><math overflow="scroll"> <mrow>  <mrow>   <mi>x</mi>   <mo>=</mo>   <mrow>    <mi>N</mi>    <mo>&#x2062;</mo>    <mfrac>     <msup>      <mi>x</mi>      <mo>&#x2032;</mo>     </msup>     <msub>      <mi>size</mi>      <mi>x</mi>     </msub>    </mfrac>   </mrow>  </mrow>  <mo>,</mo>  <mrow>   <mi>y</mi>   <mo>=</mo>   <mrow>    <mi>N</mi>    <mo>&#x2062;</mo>    <mfrac>     <msup>      <mi>y</mi>      <mo>&#x2032;</mo>     </msup>     <msub>      <mi>size</mi>      <mi>y</mi>     </msub>    </mfrac>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0280" num="0000">where x&#x2032; and y&#x2032; are the indices of the columns and rows of the quantization matrix, size<sub>x </sub>is the horizontal size of the matrix, size<sub>y </sub>is the vertical size of the matrix, and N is a normalization value. In one example, N is set to 2.</p><p id="p-0281" num="0311">According to one embodiment, said quantization matrix is used for quantizer step scaling or for quantizer parameter offset.</p><p id="p-0282" num="0312">According to one embodiment, matrix coefficients are computed by an integer process comprising limiting left-shifted polynomial terms to n bits by dropping most significant bits (including the sign bit), then adding them together using adders also restricted to n-bit output (still by dropping MSBs), and right-shifting the result by a value smax-sbase to obtain a matrix coefficient, n being equal to matrix coefficient bitdepth (mbd) plus maximum allowed value of (smax-sbase).</p><p id="p-0283" num="0313">According to one embodiment, when a matrix coefficient is further clipped to a minimum value, bit depth before clipping may be increased by one to retain a sign bit, and in that case said n is increased by one.</p><p id="p-0284" num="0314">According to one embodiment, said polynomial in (x,y) corresponds to one polynomial in x and one polynomial in y.</p><p id="p-0285" num="0315">According to one embodiment, variables x and y are replaced by u and v, with u=(x+y) and v=(x&#x2212;y).</p><p id="p-0286" num="0316">According to one embodiment, variables x and y are replaced by u and v, with u=(ax+by) and v=(bx&#x2212;ay), with a+b=1.</p><p id="p-0287" num="0317">According to one embodiment, two separable polynomials are combined to generate a quantization matrix, for example M(x,y)=P<sub>1</sub>(x)&#xb7;P<sub>2</sub>(y) or M (x,y)=P<sub>1</sub>(x)+P<sub>2</sub>(y).</p><p id="p-0288" num="0318">An embodiment provides a computer program comprising instructions which when executed by one or more processors cause the one or more processors to perform the encoding method or decoding method according to any of the embodiments described above. One or more of the present embodiments also provide a computer readable storage medium having stored thereon instructions for encoding or decoding video data according to the methods described above. One or more embodiments also provide a computer readable storage medium having stored thereon a bitstream generated according to the methods described above. One or more embodiments also provide a method and apparatus for transmitting or receiving the bitstream generated according to the methods described above.</p><p id="p-0289" num="0319">Various implementations involve decoding. &#x201c;Decoding,&#x201d; as used in this application, can encompass all or part of the processes performed, for example, on a received encoded sequence in order to produce a final output suitable for display. In various embodiments, such processes include one or more of the processes typically performed by a decoder, for example, entropy decoding, inverse quantization, inverse transformation, and differential decoding. Whether the phrase &#x201c;decoding process&#x201d; is intended to refer specifically to a subset of operations or generally to the broader decoding process will be clear based on the context of the specific descriptions and is believed to be well understood by those skilled in the art.</p><p id="p-0290" num="0320">Various implementations involve encoding. In an analogous way to the above discussion about &#x201c;decoding&#x201d;, &#x201c;encoding&#x201d; as used in this application can encompass all or part of the processes performed, for example, on an input video sequence in order to produce an encoded bitstream.</p><p id="p-0291" num="0321">The implementations and aspects described herein can be implemented in, for example, a method or a process, an apparatus, a software program, a data stream, or a signal. Even if only discussed in the context of a single form of implementation (for example, discussed only as a method), the implementation of features discussed can also be implemented in other forms (for example, an apparatus or program). An apparatus can be implemented in, for example, appropriate hardware, software, and firmware. The methods can be implemented in, for example, an apparatus, for example, a processor, which refers to processing devices in general, including, for example, a computer, a microprocessor, an integrated circuit, or a programmable logic device. Processors also include communication devices, for example, computers, cell phones, portable/personal digital assistants (&#x201c;PDAs&#x201d;), and other devices that facilitate communication of information between end-users.</p><p id="p-0292" num="0322">Reference to &#x201c;one embodiment&#x201d; or &#x201c;an embodiment&#x201d; or &#x201c;one implementation&#x201d; or &#x201c;an implementation&#x201d;, as well as other variations thereof, means that a particular feature, structure, characteristic, and so forth described in connection with the embodiment is included in at least one embodiment. Thus, the appearances of the phrase &#x201c;in one embodiment&#x201d; or &#x201c;in an embodiment&#x201d; or &#x201c;in one implementation&#x201d; or &#x201c;in an implementation&#x201d;, as well any other variations, appearing in various places throughout this application are not necessarily all referring to the same embodiment.</p><p id="p-0293" num="0323">Additionally, this application may refer to &#x201c;determining&#x201d; various pieces of information. Determining the information can include one or more of, for example, estimating the information, calculating the information, predicting the information, or retrieving the information from memory.</p><p id="p-0294" num="0324">Further, this application may refer to &#x201c;accessing&#x201d; various pieces of information. Accessing the information can include one or more of, for example, receiving the information, retrieving the information (for example, from memory), storing the information, moving the information, copying the information, calculating the information, determining the information, predicting the information, or estimating the information.</p><p id="p-0295" num="0325">Additionally, this application may refer to &#x201c;receiving&#x201d; various pieces of information. Receiving is, as with &#x201c;accessing&#x201d;, intended to be a broad term. Receiving the information can include one or more of, for example, accessing the information, or retrieving the information (for example, from memory). Further, &#x201c;receiving&#x201d; is typically involved, in one way or another, during operations, for example, storing the information, processing the information, transmitting the information, moving the information, copying the information, erasing the information, calculating the information, determining the information, predicting the information, or estimating the information.</p><p id="p-0296" num="0326">It is to be appreciated that the use of any of the following &#x201c;/&#x201d;, &#x201c;and/or&#x201d;, and &#x201c;at least one of&#x201d;, for example, in the cases of &#x201c;A/B&#x201d;, &#x201c;A and/or B&#x201d; and &#x201c;at least one of A and B&#x201d;, is intended to encompass the selection of the first listed option (A) only, or the selection of the second listed option (B) only, or the selection of both options (A and B). As a further example, in the cases of &#x201c;A, B, and/or C&#x201d; and &#x201c;at least one of A, B, and C&#x201d;, such phrasing is intended to encompass the selection of the first listed option (A) only, or the selection of the second listed option (B) only, or the selection of the third listed option (C) only, or the selection of the first and the second listed options (A and B) only, or the selection of the first and third listed options (A and C) only, or the selection of the second and third listed options (B and C) only, or the selection of all three options (A and B and C). This may be extended, as is clear to one of ordinary skill in this and related arts, for as many items as are listed.</p><p id="p-0297" num="0327">As will be evident to one of ordinary skill in the art, implementations can produce a variety of signals formatted to carry information that can be, for example, stored or transmitted. The information can include, for example, instructions for performing a method, or data produced by one of the described implementations. For example, a signal can be formatted to carry the bitstream of a described embodiment. Such a signal can be formatted, for example, as an electromagnetic wave (for example, using a radio frequency portion of spectrum) or as a baseband signal. The formatting can include, for example, encoding a data stream and modulating a carrier with the encoded data stream. The information that the signal carries can be, for example, analog or digital information. The signal can be transmitted over a variety of different wired or wireless links, as is known. The signal can be stored on a processor-readable medium.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230007257A1-20230105-M00001.NB"><img id="EMI-M00001" he="55.71mm" wi="76.20mm" file="US20230007257A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230007257A1-20230105-M00002.NB"><img id="EMI-M00002" he="13.72mm" wi="76.20mm" file="US20230007257A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00003" nb-file="US20230007257A1-20230105-M00003.NB"><img id="EMI-M00003" he="6.69mm" wi="76.20mm" file="US20230007257A1-20230105-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00004" nb-file="US20230007257A1-20230105-M00004.NB"><img id="EMI-M00004" he="7.03mm" wi="37.76mm" file="US20230007257A1-20230105-M00004.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00005" nb-file="US20230007257A1-20230105-M00005.NB"><img id="EMI-M00005" he="10.24mm" wi="26.84mm" file="US20230007257A1-20230105-M00005.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00006" nb-file="US20230007257A1-20230105-M00006.NB"><img id="EMI-M00006" he="7.03mm" wi="41.23mm" file="US20230007257A1-20230105-M00006.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00007" nb-file="US20230007257A1-20230105-M00007.NB"><img id="EMI-M00007" he="10.24mm" wi="48.34mm" file="US20230007257A1-20230105-M00007.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00008" nb-file="US20230007257A1-20230105-M00008.NB"><img id="EMI-M00008" he="7.03mm" wi="44.45mm" file="US20230007257A1-20230105-M00008.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00009" nb-file="US20230007257A1-20230105-M00009.NB"><img id="EMI-M00009" he="7.03mm" wi="40.56mm" file="US20230007257A1-20230105-M00009.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00010" nb-file="US20230007257A1-20230105-M00010.NB"><img id="EMI-M00010" he="7.03mm" wi="43.01mm" file="US20230007257A1-20230105-M00010.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00011" nb-file="US20230007257A1-20230105-M00011.NB"><img id="EMI-M00011" he="22.61mm" wi="39.88mm" file="US20230007257A1-20230105-M00011.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00012" nb-file="US20230007257A1-20230105-M00012.NB"><img id="EMI-M00012" he="6.01mm" wi="76.20mm" file="US20230007257A1-20230105-M00012.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00013" nb-file="US20230007257A1-20230105-M00013.NB"><img id="EMI-M00013" he="6.01mm" wi="76.20mm" file="US20230007257A1-20230105-M00013.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00014" nb-file="US20230007257A1-20230105-M00014.NB"><img id="EMI-M00014" he="20.07mm" wi="96.27mm" file="US20230007257A1-20230105-M00014.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00015" nb-file="US20230007257A1-20230105-M00015.NB"><img id="EMI-M00015" he="6.35mm" wi="76.20mm" file="US20230007257A1-20230105-M00015.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00016" nb-file="US20230007257A1-20230105-M00016.NB"><img id="EMI-M00016" he="6.01mm" wi="76.20mm" file="US20230007257A1-20230105-M00016.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00017" nb-file="US20230007257A1-20230105-M00017.NB"><img id="EMI-M00017" he="6.35mm" wi="76.20mm" file="US20230007257A1-20230105-M00017.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00018" nb-file="US20230007257A1-20230105-M00018.NB"><img id="EMI-M00018" he="5.67mm" wi="76.20mm" file="US20230007257A1-20230105-M00018.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00019" nb-file="US20230007257A1-20230105-M00019.NB"><img id="EMI-M00019" he="7.03mm" wi="76.20mm" file="US20230007257A1-20230105-M00019.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00020" nb-file="US20230007257A1-20230105-M00020.NB"><img id="EMI-M00020" he="7.03mm" wi="76.20mm" file="US20230007257A1-20230105-M00020.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00021" nb-file="US20230007257A1-20230105-M00021.NB"><img id="EMI-M00021" he="7.03mm" wi="76.20mm" file="US20230007257A1-20230105-M00021.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00022" nb-file="US20230007257A1-20230105-M00022.NB"><img id="EMI-M00022" he="6.01mm" wi="76.20mm" file="US20230007257A1-20230105-M00022.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00023" nb-file="US20230007257A1-20230105-M00023.NB"><img id="EMI-M00023" he="6.01mm" wi="76.20mm" file="US20230007257A1-20230105-M00023.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00024" nb-file="US20230007257A1-20230105-M00024.NB"><img id="EMI-M00024" he="6.01mm" wi="76.20mm" file="US20230007257A1-20230105-M00024.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00025" nb-file="US20230007257A1-20230105-M00025.NB"><img id="EMI-M00025" he="22.18mm" wi="76.20mm" file="US20230007257A1-20230105-M00025.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00026" nb-file="US20230007257A1-20230105-M00026.NB"><img id="EMI-M00026" he="6.35mm" wi="76.20mm" file="US20230007257A1-20230105-M00026.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of video decoding, comprising:<claim-text>decoding at least a syntax element representing a value N, where N indicates a number of polynomial coefficients, N being selected from among a plurality of values;</claim-text><claim-text>obtaining N polynomial coefficients;</claim-text><claim-text>forming a polynomial function with N monomials, wherein said polynomial function is a function of matrix coordinates, and wherein each one of said N polynomial coefficients is associated with a corresponding monomial of said N monomials;</claim-text><claim-text>obtaining a quantization matrix based on said polynomial function of matrix coordinates; and</claim-text><claim-text>decoding a block of a picture based on said quantization matrix.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a k-th polynomial coefficient of said N polynomial coefficients is associated with a k-th monomial of said N monomials.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>decoding a set of polynomial coefficients, wherein said N polynomial coefficients are determined responsive to said decoded set of polynomial coefficients.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said monomials are ordered by an increasing maximum of x and y exponents, where x and y indicate matrix coordinate.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said monomials are ordered by increasing x or y exponent, where x and y indicate matrix coordinate.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said polynomial function is a function of a first variable and a second variable, wherein said first variable is a linear combination of horizontal coordinate and vertical coordinate, and wherein said second variable is a linear combination of horizontal coordinate and vertical coordinate.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. An apparatus for video decoding, comprising:<claim-text>one or more processors, wherein said one or more processors are configured to:</claim-text><claim-text>decode at least a syntax element representing a value N, where N indicates a number of polynomial coefficients, N being determined from among a plurality of values;</claim-text><claim-text>obtain N polynomial coefficients;</claim-text><claim-text>form a polynomial function with N monomials, wherein said polynomial function is a function of matrix coordinates, and wherein each one of said N polynomial coefficients is associated with a corresponding monomial of said N monomials;</claim-text><claim-text>obtain a quantization matrix based on said polynomial function of matrix coordinates; and</claim-text><claim-text>decode a block of a picture based on said quantization matrix.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein a k-th polynomial coefficient of said N polynomial coefficients is associated with a k-th monomial of said N monomials.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein said one or more processors are further configured to decode a set of polynomial coefficients, wherein said N polynomial coefficients are determined responsive to said decoded set of polynomial coefficients.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein said monomials are ordered by an increasing maximum of x and y exponents, where x and y indicate matrix coordinate.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein said monomials are ordered by increasing x or y exponent, where x and y indicate matrix coordinate.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The apparatus of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein said polynomial function is a function of a first variable and a second variable, wherein said first variable is a linear combination of horizontal coordinate and vertical coordinate, and wherein said second variable is a linear combination of horizontal coordinate and vertical coordinate.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of video encoding, comprising:<claim-text>determining a value N, indicating a number of polynomial coefficients;</claim-text><claim-text>encoding at least a syntax element representing said value N;</claim-text><claim-text>obtaining N polynomial coefficients;</claim-text><claim-text>forming a polynomial function with N monomials, wherein said polynomial function is a function of matrix coordinates, and wherein each one of said N polynomial coefficients is associated with a corresponding monomial of said N monomials;</claim-text><claim-text>obtaining a quantization matrix based on said polynomial function of matrix coordinates; and</claim-text><claim-text>encoding a block of a picture based on said quantization matrix.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein a k-th polynomial coefficient of said N polynomial coefficients is associated with a k-th monomial of said N monomials.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:<claim-text>encoding a set of polynomial coefficients, wherein said N polynomial coefficients are determined responsive to said set of polynomial coefficients.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein said polynomial function is a function of a to first variable and a second variable, wherein said first variable is a linear combination of horizontal coordinate and vertical coordinate, and wherein said second variable is a linear combination of horizontal coordinate and vertical coordinate.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. An apparatus for video encoding, comprising:<claim-text>one or more processors, wherein said one or more processors are configured to:</claim-text><claim-text>determine a value N, indicating a number of polynomial coefficients;</claim-text><claim-text>encode at least a syntax element representing said value N;</claim-text><claim-text>obtain N polynomial coefficients;</claim-text><claim-text>form a polynomial function with N monomials, wherein said polynomial function is a function of matrix coordinates, and wherein each one of said N polynomial coefficients is associated with a corresponding monomial of said N monomials;</claim-text><claim-text>obtain a quantization matrix based on said polynomial function of matrix coordinates; and</claim-text><claim-text>encode a block of a picture based on said quantization matrix.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The apparatus of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein a k-th polynomial coefficient of said N polynomial coefficients is associated with a k-th monomial of said N monomials.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The apparatus of <claim-ref idref="CLM-00017">claim 17</claim-ref>, said one or more processors are further configured to encode a set of polynomial coefficients, wherein said N polynomial coefficients are determined responsive to said set of polynomial coefficients.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The apparatus of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein said polynomial function is a function of a first variable and a second variable, wherein said first variable is a linear combination of horizontal coordinate and vertical coordinate, and wherein said second variable is a linear combination of horizontal coordinate and vertical coordinate.</claim-text></claim></claims></us-patent-application>