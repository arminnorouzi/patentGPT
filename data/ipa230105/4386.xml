<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004387A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004387</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17359538</doc-number><date>20210626</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>499</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>523</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>38</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30014</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>499</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>523</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3818</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30112</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">APPARATUS AND METHOD FOR VECTOR PACKED MULTIPLY OF SIGNED AND UNSIGNED WORDS</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Intel Corporation</orgname><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Madduri</last-name><first-name>Venkateswara Rao</first-name><address><city>Austin</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Valentine</last-name><first-name>Robert</first-name><address><city>Kiryat Tivon</city><country>IL</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Charney</last-name><first-name>Mark J.</first-name><address><city>Lexington</city><state>MA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Intel Corporation</orgname><role>02</role><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">An apparatus and method for performing a vector packed multiplication of signed and unsigned words. For example, one embodiment of a processor includes a decoder to decode a vector packed multiply instruction having operands to identify a first and a second plurality of packed words, first and second source registers to store the first and second plurality of packed words, and execution circuitry to execute the decoded instruction. The execution circuitry includes multiplier circuitry to multiply each packed word in the first source register with a corresponding packed word in the second source register to generate a plurality of doubleword products and rounding circuitry to round each of the doubleword products according to a rounding method to generate a plurality of rounded doubleword products. Each upper word of the rounded doubleword results is then stored into a corresponding word data element positions of a destination register.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="59.86mm" wi="92.54mm" file="US20230004387A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="223.60mm" wi="161.12mm" orientation="landscape" file="US20230004387A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="225.72mm" wi="159.85mm" orientation="landscape" file="US20230004387A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="221.40mm" wi="147.15mm" orientation="landscape" file="US20230004387A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="233.68mm" wi="173.82mm" orientation="landscape" file="US20230004387A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="209.97mm" wi="170.77mm" orientation="landscape" file="US20230004387A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="193.63mm" wi="149.35mm" orientation="landscape" file="US20230004387A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="188.21mm" wi="56.05mm" orientation="landscape" file="US20230004387A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="113.79mm" wi="137.58mm" orientation="landscape" file="US20230004387A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="199.73mm" wi="140.46mm" orientation="landscape" file="US20230004387A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="193.46mm" wi="132.00mm" orientation="landscape" file="US20230004387A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="190.25mm" wi="100.67mm" orientation="landscape" file="US20230004387A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="198.04mm" wi="104.65mm" orientation="landscape" file="US20230004387A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="233.51mm" wi="179.32mm" orientation="landscape" file="US20230004387A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="212.01mm" wi="102.70mm" orientation="landscape" file="US20230004387A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="238.68mm" wi="175.26mm" orientation="landscape" file="US20230004387A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="232.58mm" wi="143.59mm" file="US20230004387A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="232.58mm" wi="143.59mm" file="US20230004387A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><heading id="h-0002" level="1">Field of the Invention</heading><p id="p-0002" num="0001">The embodiments of the invention relate generally to the field of computer processors. More particularly, the embodiments relate to an apparatus and method for performing vector packed multiply of signed and unsigned words.</p><heading id="h-0003" level="1">Description of the Related Art</heading><p id="p-0003" num="0002">An instruction set, or instruction set architecture (ISA), is the part of the computer architecture related to programming, including the native data types, instructions, register architecture, addressing modes, memory architecture, interrupt and exception handling, and external input and output (I/O). It should be noted that the term &#x201c;instruction&#x201d; generally refers herein to macro-instructions&#x2014;that is instructions that are provided to the processor for execution&#x2014;as opposed to micro-instructions or micro-ops&#x2014;that is the result of a processor's decoder decoding macro-instructions. The micro-instructions or micro-ops can be configured to instruct an execution unit on the processor to perform operations to implement the logic associated with the macro-instruction.</p><p id="p-0004" num="0003">The ISA is distinguished from the microarchitecture, which is the set of processor design techniques used to implement the instruction set. Processors with different microarchitectures can share a common instruction set. For example, Intel&#xae; Pentium 4 processors, Intel&#xae; Core&#x2122; processors, and processors from Advanced Micro Devices, Inc. of Sunnyvale Calif. implement nearly identical versions of the x86 instruction set (with some extensions that have been added with newer versions), but have different internal designs. For example, the same register architecture of the ISA may be implemented in different ways in different microarchitectures using well-known techniques, including dedicated physical registers, one or more dynamically allocated physical registers using a register renaming mechanism (e.g., the use of a Register Alias Table (RAT), a Reorder Buffer (ROB) and a retirement register file). Unless otherwise specified, the phrases register architecture, register file, and register are used herein to refer to that which is visible to the software/programmer and the manner in which instructions specify registers. Where a distinction is required, the adjective &#x201c;logical,&#x201d; &#x201c;architectural,&#x201d; or &#x201c;software visible&#x201d; will be used to indicate registers/files in the register architecture, while different adjectives will be used to designate registers in a given microarchitecture (e.g., physical register, reorder buffer, retirement register, register pool).</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004">A better understanding of the present invention can be obtained from the following detailed description in conjunction with the following drawings, in which:</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIGS. <b>1</b>A and <b>1</b>B</figref> are block diagrams illustrating a generic vector friendly instruction format and instruction templates thereof according to embodiments of the invention;</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIGS. <b>2</b>A-C</figref> are block diagrams illustrating an exemplary VEX instruction format according to embodiments of the invention;</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram of a register architecture according to one embodiment of the invention; and</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is a block diagram illustrating both an exemplary in-order fetch, decode, retire pipeline and an exemplary register renaming, out-of-order issue/execution pipeline according to embodiments of the invention;</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> is a block diagram illustrating both an exemplary embodiment of an in-order fetch, decode, retire core and an exemplary register renaming, out-of-order issue/execution architecture core to be included in a processor according to embodiments of the invention;</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> is a block diagram of a single processor core, along with its connection to an on-die interconnect network;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> illustrates an expanded view of part of the processor core in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref> according to embodiments of the invention;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of a single core processor and a multicore processor with integrated memory controller and graphics according to embodiments of the invention;</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a block diagram of a system in accordance with one embodiment of the present invention;</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a block diagram of a second system in accordance with an embodiment of the present invention;</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates a block diagram of a third system in accordance with an embodiment of the present invention;</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a block diagram of a system on a chip (SoC) in accordance with an embodiment of the present invention;</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates a block diagram contrasting the use of a software instruction converter to convert binary instructions in a source instruction set to binary instructions in a target instruction set according to embodiments of the invention;</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates a processor architecture on which embodiments of the invention may be implemented;</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates a plurality of packed data elements containing real and/or complex values in accordance with one embodiment;</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIGS. <b>14</b></figref> illustrate exemplary architectures for executing instructions for performing vector packed multiplication instructions;</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates a method in accordance with one embodiment of the invention; and</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates a method in accordance with one embodiment of the invention.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0024" num="0023">In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the invention described below. It will be apparent, however, to one skilled in the art that the embodiments of the invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the embodiments of the invention.</p><heading id="h-0006" level="1">Exemplary Processor Architectures, Instruction Formats, and Data Types</heading><p id="p-0025" num="0024">An instruction set includes one or more instruction formats. A given instruction format defines various fields (number of bits, location of bits) to specify, among other things, the operation to be performed (opcode) and the operand(s) on which that operation is to be performed. Some instruction formats are further broken down though the definition of instruction templates (or subformats). For example, the instruction templates of a given instruction format may be defined to have different subsets of the instruction format's fields (the included fields are typically in the same order, but at least some have different bit positions because there are less fields included) and/or defined to have a given field interpreted differently. Thus, each instruction of an ISA is expressed using a given instruction format (and, if defined, in a given one of the instruction templates of that instruction format) and includes fields for specifying the operation and the operands. For example, an exemplary ADD instruction has a specific opcode and an instruction format that includes an opcode field to specify that opcode and operand fields to select operands (source1/destination and source2); and an occurrence of this ADD instruction in an instruction stream will have specific contents in the operand fields that select specific operands.</p><p id="p-0026" num="0025">Embodiments of the instruction(s) described herein may be embodied in different formats. Additionally, exemplary systems, architectures, and pipelines are detailed below. Embodiments of the instruction(s) may be executed on such systems, architectures, and pipelines, but are not limited to those detailed.</p><heading id="h-0007" level="1">Generic Vector Friendly Instruction Format</heading><p id="p-0027" num="0026">A vector friendly instruction format is an instruction format that is suited for vector instructions (e.g., there are certain fields specific to vector operations). While embodiments are described in which both vector and scalar operations are supported through the vector friendly instruction format, alternative embodiments use only vector operations the vector friendly instruction format.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIGS. <b>1</b>A-<b>1</b>B</figref> are block diagrams illustrating a generic vector friendly instruction format and instruction templates thereof according to embodiments of the invention. <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> is a block diagram illustrating a generic vector friendly instruction format and class A instruction templates thereof according to embodiments of the invention; while <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> is a block diagram illustrating the generic vector friendly instruction format and class B instruction templates thereof according to embodiments of the invention. Specifically, a generic vector friendly instruction format <b>100</b> for which are defined class A and class B instruction templates, both of which include no memory access <b>105</b> instruction templates and memory access <b>120</b> instruction templates. The term generic in the context of the vector friendly instruction format refers to the instruction format not being tied to any specific instruction set.</p><p id="p-0029" num="0028">While embodiments of the invention will be described in which the vector friendly instruction format supports the following: a 64 byte vector operand length (or size) with 32 bit (4 byte) or 64 bit (8 byte) data element widths (or sizes) (and thus, a 64 byte vector consists of either 16 doubleword-size elements or alternatively, 8 quadword-size elements); a 64 byte vector operand length (or size) with 16 bit (2 byte) or 8 bit (1 byte) data element widths (or sizes); a 32 byte vector operand length (or size) with 32 bit (4 byte), 64 bit (8 byte), 16 bit (2 byte), or 8 bit (1 byte) data element widths (or sizes); and a 16 byte vector operand length (or size) with 32 bit (4 byte), 64 bit (8 byte), 16 bit (2 byte), or 8 bit (1 byte) data element widths (or sizes); alternative embodiments may support more, less and/or different vector operand sizes (e.g., 256 byte vector operands) with more, less, or different data element widths (e.g., 128 bit (16 byte) data element widths).</p><p id="p-0030" num="0029">The class A instruction templates in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> include: 1) within the no memory access <b>105</b> instruction templates there is shown a no memory access, full round control type operation <b>110</b> instruction template and a no memory access, data transform type operation <b>115</b> instruction template; and 2) within the memory access <b>120</b> instruction templates there is shown a memory access, temporal <b>125</b> instruction template and a memory access, non-temporal <b>130</b> instruction template. The class B instruction templates in <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> include: 1) within the no memory access <b>105</b> instruction templates there is shown a no memory access, write mask control, partial round control type operation <b>112</b> instruction template and a no memory access, write mask control, vsize type operation <b>117</b> instruction template; and 2) within the memory access <b>120</b> instruction templates there is shown a memory access, write mask control <b>127</b> instruction template.</p><p id="p-0031" num="0030">The generic vector friendly instruction format <b>100</b> includes the following fields listed below in the order illustrated in <figref idref="DRAWINGS">FIGS. <b>1</b>A-<b>1</b>B</figref>.</p><p id="p-0032" num="0031">Format field <b>140</b>&#x2014;a specific value (an instruction format identifier value) in this field uniquely identifies the vector friendly instruction format, and thus occurrences of instructions in the vector friendly instruction format in instruction streams. As such, this field is optional in the sense that it is not needed for an instruction set that has only the generic vector friendly instruction format.</p><p id="p-0033" num="0032">Base operation field <b>142</b>&#x2014;its content distinguishes different base operations.</p><p id="p-0034" num="0033">Register index field <b>144</b>&#x2014;its content, directly or through address generation, specifies the locations of the source and destination operands, be they in registers or in memory. These include a sufficient number of bits to select N registers from a P&#xd7;Q (e.g. 32&#xd7;512, 16&#xd7;128, 32&#xd7;1024, 64&#xd7;1024) register file. While in one embodiment N may be up to three sources and one destination register, alternative embodiments may support more or less sources and destination registers (e.g., may support up to two sources where one of these sources also acts as the destination, may support up to three sources where one of these sources also acts as the destination, may support up to two sources and one destination).</p><p id="p-0035" num="0034">Modifier field <b>146</b>&#x2014;its content distinguishes occurrences of instructions in the generic vector instruction format that specify memory access from those that do not; that is, between no memory access <b>105</b> instruction templates and memory access <b>120</b> instruction templates. Memory access operations read and/or write to the memory hierarchy (in some cases specifying the source and/or destination addresses using values in registers), while non-memory access operations do not (e.g., the source and destinations are registers). While in one embodiment this field also selects between three different ways to perform memory address calculations, alternative embodiments may support more, less, or different ways to perform memory address calculations.</p><p id="p-0036" num="0035">Augmentation operation field <b>150</b>&#x2014;its content distinguishes which one of a variety of different operations to be performed in addition to the base operation. This field is context specific. In one embodiment of the invention, this field is divided into a class field <b>168</b>, an alpha field <b>152</b>, and a beta field <b>154</b>. The augmentation operation field <b>150</b> allows common groups of operations to be performed in a single instruction rather than 2, 3, or 4 instructions.</p><p id="p-0037" num="0036">Scale field <b>160</b>&#x2014;its content allows for the scaling of the index field's content for memory address generation (e.g., for address generation that uses 2<sup>scale</sup>*index+base).</p><p id="p-0038" num="0037">Displacement Field <b>162</b>A&#x2014;its content is used as part of memory address generation (e.g., for address generation that uses 2<sup>scale</sup>*index+base+displacement).</p><p id="p-0039" num="0038">Displacement Factor Field <b>1626</b> (note that the juxtaposition of displacement field <b>162</b>A directly over displacement factor field <b>162</b>B indicates one or the other is used)&#x2014;its content is used as part of address generation; it specifies a displacement factor that is to be scaled by the size of a memory access (N)&#x2014;where N is the number of bytes in the memory access (e.g., for address generation that uses 2<sup>scale</sup>*index+base+scaled displacement). Redundant low-order bits are ignored and hence, the displacement factor field's content is multiplied by the memory operands total size (N) in order to generate the final displacement to be used in calculating an effective address. The value of N is determined by the processor hardware at runtime based on the full opcode field <b>174</b> (described later herein) and the data manipulation field <b>154</b>C. The displacement field <b>162</b>A and the displacement factor field <b>162</b>B are optional in the sense that they are not used for the no memory access <b>105</b> instruction templates and/or different embodiments may implement only one or none of the two.</p><p id="p-0040" num="0039">Data element width field <b>164</b>&#x2014;its content distinguishes which one of a number of data element widths is to be used (in some embodiments for all instructions; in other embodiments for only some of the instructions). This field is optional in the sense that it is not needed if only one data element width is supported and/or data element widths are supported using some aspect of the opcodes.</p><p id="p-0041" num="0040">Write mask field <b>170</b>&#x2014;its content controls, on a per data element position basis, whether that data element position in the destination vector operand reflects the result of the base operation and augmentation operation. Class A instruction templates support merging-writemasking, while class B instruction templates support both merging- and zeroing-writemasking. When merging, vector masks allow any set of elements in the destination to be protected from updates during the execution of any operation (specified by the base operation and the augmentation operation); in other one embodiment, preserving the old value of each element of the destination where the corresponding mask bit has a 0. In contrast, when zeroing vector masks allow any set of elements in the destination to be zeroed during the execution of any operation (specified by the base operation and the augmentation operation); in one embodiment, an element of the destination is set to 0 when the corresponding mask bit has a 0 value. A subset of this functionality is the ability to control the vector length of the operation being performed (that is, the span of elements being modified, from the first to the last one); however, it is not necessary that the elements that are modified be consecutive. Thus, the write mask field <b>170</b> allows for partial vector operations, including loads, stores, arithmetic, logical, etc. While embodiments of the invention are described in which the write mask field's <b>170</b> content selects one of a number of write mask registers that contains the write mask to be used (and thus the write mask field's <b>170</b> content indirectly identifies that masking to be performed), alternative embodiments instead or additional allow the mask write field's <b>170</b> content to directly specify the masking to be performed.</p><p id="p-0042" num="0041">Immediate field <b>172</b>&#x2014;its content allows for the specification of an immediate. This field is optional in the sense that is it not present in an implementation of the generic vector friendly format that does not support immediate and it is not present in instructions that do not use an immediate.</p><p id="p-0043" num="0042">Class field <b>168</b>&#x2014;its content distinguishes between different classes of instructions. With reference to <figref idref="DRAWINGS">FIGS. <b>1</b>A-B</figref>, the contents of this field select between class A and class B instructions. In <figref idref="DRAWINGS">FIGS. <b>1</b>A-B</figref>, rounded corner squares are used to indicate a specific value is present in a field (e.g., class A <b>168</b>A and class B <b>168</b>B for the class field <b>168</b> respectively in <figref idref="DRAWINGS">FIGS. <b>1</b>A-B</figref>).</p><heading id="h-0008" level="1">Instruction Templates of Class A</heading><p id="p-0044" num="0043">In the case of the non-memory access <b>105</b> instruction templates of class A, the alpha field <b>152</b> is interpreted as an RS field <b>152</b>A, whose content distinguishes which one of the different augmentation operation types are to be performed (e.g., round <b>152</b>A.<b>1</b> and data transform <b>152</b>A.<b>2</b> are respectively specified for the no memory access, round type operation <b>110</b> and the no memory access, data transform type operation <b>115</b> instruction templates), while the beta field <b>154</b> distinguishes which of the operations of the specified type is to be performed. In the no memory access <b>105</b> instruction templates, the scale field <b>160</b>, the displacement field <b>162</b>A, and the displacement scale filed <b>162</b>B are not present.</p><heading id="h-0009" level="1">No-Memory Access Instruction Templates&#x2014;Full Round Control Type Operation</heading><p id="p-0045" num="0044">In the no memory access full round control type operation <b>110</b> instruction template, the beta field <b>154</b> is interpreted as a round control field <b>154</b>A, whose content(s) provide static rounding. While in the described embodiments of the invention the round control field <b>154</b>A includes a suppress all floating point exceptions (SAE) field <b>156</b> and a round operation control field <b>158</b>, alternative embodiments may support may encode both these concepts into the same field or only have one or the other of these concepts/fields (e.g., may have only the round operation control field <b>158</b>).</p><p id="p-0046" num="0045">SAE field <b>156</b>&#x2014;its content distinguishes whether or not to disable the exception event reporting; when the SAE field's <b>156</b> content indicates suppression is enabled, a given instruction does not report any kind of floating-point exception flag and does not raise any floating point exception handler.</p><p id="p-0047" num="0046">Round operation control field <b>158</b>&#x2014;its content distinguishes which one of a group of rounding operations to perform (e.g., Round-up, Round-down, Round-towards-zero and Round-to-nearest). Thus, the round operation control field <b>158</b> allows for the changing of the rounding mode on a per instruction basis. In one embodiment of the invention where a processor includes a control register for specifying rounding modes, the round operation control field's <b>150</b> content overrides that register value.</p><heading id="h-0010" level="1">No Memory Access Instruction Templates&#x2014;Data Transform Type Operation</heading><p id="p-0048" num="0047">In the no memory access data transform type operation <b>115</b> instruction template, the beta field <b>154</b> is interpreted as a data transform field <b>1546</b>, whose content distinguishes which one of a number of data transforms is to be performed (e.g., no data transform, swizzle, broadcast).</p><p id="p-0049" num="0048">In the case of a memory access <b>120</b> instruction template of class A, the alpha field <b>152</b> is interpreted as an eviction hint field <b>1526</b>, whose content distinguishes which one of the eviction hints is to be used (in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, temporal <b>1526</b>.<b>1</b> and non-temporal <b>1526</b>.<b>2</b> are respectively specified for the memory access, temporal <b>125</b> instruction template and the memory access, non-temporal <b>130</b> instruction template), while the beta field <b>154</b> is interpreted as a data manipulation field <b>154</b>C, whose content distinguishes which one of a number of data manipulation operations (also known as primitives) is to be performed (e.g., no manipulation; broadcast; up conversion of a source; and down conversion of a destination). The memory access <b>120</b> instruction templates include the scale field <b>160</b>, and optionally the displacement field <b>162</b>A or the displacement scale field <b>1626</b>.</p><p id="p-0050" num="0049">Vector memory instructions perform vector loads from and vector stores to memory, with conversion support. As with regular vector instructions, vector memory instructions transfer data from/to memory in a data element-wise fashion, with the elements that are actually transferred is dictated by the contents of the vector mask that is selected as the write mask.</p><heading id="h-0011" level="1">Memory Access Instruction Templates&#x2014;Temporal</heading><p id="p-0051" num="0050">Temporal data is data likely to be reused soon enough to benefit from caching. This is, however, a hint, and different processors may implement it in different ways, including ignoring the hint entirely.</p><heading id="h-0012" level="1">Memory Access Instruction Templates&#x2014;Non-Temporal</heading><p id="p-0052" num="0051">Non-temporal data is data unlikely to be reused soon enough to benefit from caching in the 1st-level cache and should be given priority for eviction. This is, however, a hint, and different processors may implement it in different ways, including ignoring the hint entirely.</p><heading id="h-0013" level="1">Instruction Templates of Class B</heading><p id="p-0053" num="0052">In the case of the instruction templates of class B, the alpha field <b>152</b> is interpreted as a write mask control (Z) field <b>152</b>C, whose content distinguishes whether the write masking controlled by the write mask field <b>170</b> should be a merging or a zeroing.</p><p id="p-0054" num="0053">In the case of the non-memory access <b>105</b> instruction templates of class B, part of the beta field <b>154</b> is interpreted as an RL field <b>157</b>A, whose content distinguishes which one of the different augmentation operation types are to be performed (e.g., round <b>157</b>A.<b>1</b> and vector length (VSIZE) <b>157</b>A.<b>2</b> are respectively specified for the no memory access, write mask control, partial round control type operation <b>112</b> instruction template and the no memory access, write mask control, VSIZE type operation <b>117</b> instruction template), while the rest of the beta field <b>154</b> distinguishes which of the operations of the specified type is to be performed. In the no memory access <b>105</b> instruction templates, the scale field <b>160</b>, the displacement field <b>162</b>A, and the displacement scale filed <b>162</b>B are not present.</p><p id="p-0055" num="0054">In the no memory access, write mask control, partial round control type operation <b>110</b> instruction template, the rest of the beta field <b>154</b> is interpreted as a round operation field <b>159</b>A and exception event reporting is disabled (a given instruction does not report any kind of floating-point exception flag and does not raise any floating point exception handler).</p><p id="p-0056" num="0055">Round operation control field <b>159</b>A&#x2014;just as round operation control field <b>158</b>, its content distinguishes which one of a group of rounding operations to perform (e.g., Round-up, Round-down, Round-towards-zero and Round-to-nearest). Thus, the round operation control field <b>159</b>A allows for the changing of the rounding mode on a per instruction basis. In one embodiment of the invention where a processor includes a control register for specifying rounding modes, the round operation control field's <b>150</b> content overrides that register value.</p><p id="p-0057" num="0056">In the no memory access, write mask control, VSIZE type operation <b>117</b> instruction template, the rest of the beta field <b>154</b> is interpreted as a vector length field <b>159</b>B, whose content distinguishes which one of a number of data vector lengths is to be performed on (e.g., 128, 256, or 512 byte).</p><p id="p-0058" num="0057">In the case of a memory access <b>120</b> instruction template of class B, part of the beta field <b>154</b> is interpreted as a broadcast field <b>157</b>B, whose content distinguishes whether or not the broadcast type data manipulation operation is to be performed, while the rest of the beta field <b>154</b> is interpreted the vector length field <b>159</b>B. The memory access <b>120</b> instruction templates include the scale field <b>160</b>, and optionally the displacement field <b>162</b>A or the displacement scale field <b>162</b>B.</p><p id="p-0059" num="0058">With regard to the generic vector friendly instruction format <b>100</b>, a full opcode field <b>174</b> is shown including the format field <b>140</b>, the base operation field <b>142</b>, and the data element width field <b>164</b>. While one embodiment is shown where the full opcode field <b>174</b> includes all of these fields, the full opcode field <b>174</b> includes less than all of these fields in embodiments that do not support all of them. The full opcode field <b>174</b> provides the operation code (opcode).</p><p id="p-0060" num="0059">The augmentation operation field <b>150</b>, the data element width field <b>164</b>, and the write mask field <b>170</b> allow these features to be specified on a per instruction basis in the generic vector friendly instruction format.</p><p id="p-0061" num="0060">The combination of write mask field and data element width field create typed instructions in that they allow the mask to be applied based on different data element widths.</p><p id="p-0062" num="0061">The various instruction templates found within class A and class B are beneficial in different situations. In some embodiments of the invention, different processors or different cores within a processor may support only class A, only class B, or both classes. For instance, a high performance general purpose out-of-order core intended for general-purpose computing may support only class B, a core intended primarily for graphics and/or scientific (throughput) computing may support only class A, and a core intended for both may support both (of course, a core that has some mix of templates and instructions from both classes but not all templates and instructions from both classes is within the purview of the invention). Also, a single processor may include multiple cores, all of which support the same class or in which different cores support different class. For instance, in a processor with separate graphics and general purpose cores, one of the graphics cores intended primarily for graphics and/or scientific computing may support only class A, while one or more of the general purpose cores may be high performance general purpose cores with out of order execution and register renaming intended for general-purpose computing that support only class B. Another processor that does not have a separate graphics core, may include one more general purpose in-order or out-of-order cores that support both class A and class B. Of course, features from one class may also be implement in the other class in different embodiments of the invention. Programs written in a high level language would be put (e.g., just in time compiled or statically compiled) into an variety of different executable forms, including: 1) a form having only instructions of the class(es) supported by the target processor for execution; or 2) a form having alternative routines written using different combinations of the instructions of all classes and having control flow code that selects the routines to execute based on the instructions supported by the processor which is currently executing the code.</p><heading id="h-0014" level="1">VEX Instruction Format</heading><p id="p-0063" num="0062">VEX encoding allows instructions to have more than two operands, and allows SIMD vector registers to be longer than <b>28</b> bits. The use of a VEX prefix provides for three-operand (or more) syntax. For example, previous two-operand instructions performed operations such as A=A+B, which overwrites a source operand. The use of a VEX prefix enables operands to perform nondestructive operations such as A=B+C.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> illustrates an exemplary AVX instruction format including a VEX prefix <b>202</b>, real opcode field <b>230</b>, Mod R/M byte <b>240</b>, SIB byte <b>250</b>, displacement field <b>262</b>, and IMM8 <b>272</b>. <figref idref="DRAWINGS">FIG. <b>2</b>B</figref> illustrates which fields from <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> make up a full opcode field <b>274</b> and a base operation field <b>241</b>. <figref idref="DRAWINGS">FIG. <b>2</b>C</figref> illustrates which fields from <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> make up a register index field <b>244</b>.</p><p id="p-0065" num="0064">VEX Prefix (Bytes 0-2) <b>202</b> is encoded in a three-byte form. The first byte is the Format Field <b>290</b> (VEX Byte 0, bits [7:0]), which contains an explicit C4 byte value (the unique value used for distinguishing the C4 instruction format). The second-third bytes (VEX Bytes 1-2) include a number of bit fields providing specific capability. Specifically, REX field <b>205</b> (VEX Byte 1, bits [7-5]) consists of a VEX.R bit field (VEX Byte 1, bit [7]&#x2014;R), VEX.X bit field (VEX byte 1, bit [6]&#x2014;X), and VEX.B bit field (VEX byte 1, bit[5]&#x2014;B). Other fields of the instructions encode the lower three bits of the register indexes as is known in the art (rrr, xxx, and bbb), so that Rrrr, Xxxx, and Bbbb may be formed by adding VEX.R, VEX.X, and VEX.B. Opcode map field <b>215</b> (VEX byte 1, bits [4:0]&#x2014;mmmmm) includes content to encode an implied leading opcode byte. W Field <b>264</b> (VEX byte 2, bit [7]&#x2014;W)&#x2014;is represented by the notation VEX.W, and provides different functions depending on the instruction. The role of VEX.vvvv <b>220</b> (VEX Byte 2, bits [6:3]&#x2014;vvvv) may include the following: 1) VEX.vvvv encodes the first source register operand, specified in inverted (1s complement) form and is valid for instructions with 2 or more source operands; 2) VEX.vvvv encodes the destination register operand, specified in 1s complement form for certain vector shifts; or 3) VEX.vvvv does not encode any operand, the field is reserved and should contain 1111b. If VEX.L 268 Size field (VEX byte 2, bit [2]&#x2014;L)=0, it indicates 28 bit vector; if VEX.L=1, it indicates 256 bit vector. Prefix encoding field <b>225</b> (VEX byte 2, bits [1:0]&#x2014;pp) provides additional bits for the base operation field <b>241</b>.</p><p id="p-0066" num="0065">Real Opcode Field <b>230</b> (Byte 3) is also known as the opcode byte. Part of the opcode is specified in this field.</p><p id="p-0067" num="0066">MOD R/M Field <b>240</b> (Byte 4) includes MOD field <b>242</b> (bits [7-6]), Reg field <b>244</b> (bits [5-3]), and R/M field <b>246</b> (bits [2-0]). The role of Reg field <b>244</b> may include the following: encoding either the destination register operand or a source register operand (the rrr of Rrrr), or be treated as an opcode extension and not used to encode any instruction operand. The role of R/M field <b>246</b> may include the following: encoding the instruction operand that references a memory address, or encoding either the destination register operand or a source register operand.</p><p id="p-0068" num="0067">Scale, Index, Base (SIB)&#x2014;The content of Scale field <b>250</b> (Byte 5) includes SS <b>252</b> (bits [7-6]), which is used for memory address generation. The contents of SIB.xxx <b>254</b> (bits [5-3]) and SIB.bbb <b>256</b> (bits [2-0]) have been previously referred to with regard to the register indexes Xxxx and Bbbb.</p><p id="p-0069" num="0068">The Displacement Field <b>262</b> and the immediate field (IMM8) <b>272</b> contain data.</p><heading id="h-0015" level="1">Exemplary Register Architecture</heading><p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram of a register architecture <b>300</b> according to one embodiment of the invention. In the embodiment illustrated, there are 32 vector registers <b>310</b> that are 512 bits wide; these registers are referenced as zmm0 through zmm31. The lower order 256 bits of the lower 6 zmm registers are overlaid on registers ymm0-15. The lower order 128 bits of the lower 6 zmm registers (the lower order 128 bits of the ymm registers) are overlaid on registers xmm0-15.</p><p id="p-0071" num="0070">General-purpose registers <b>325</b>&#x2014;in the embodiment illustrated, there are sixteen 64-bit general-purpose registers that are used along with the existing x86 addressing modes to address memory operands. These registers are referenced by the names RAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP, and R8 through R15.</p><p id="p-0072" num="0071">Scalar floating point stack register file (x87 stack) <b>345</b>, on which is aliased the MMX packed integer flat register file <b>350</b>&#x2014;in the embodiment illustrated, the x87 stack is an eight-element stack used to perform scalar floating-point operations on 32/64/80-bit floating point data using the x87 instruction set extension; while the MMX registers are used to perform operations on 64-bit packed integer data, as well as to hold operands for some operations performed between the MMX and XMM registers.</p><p id="p-0073" num="0072">Alternative embodiments of the invention may use wider or narrower registers. Additionally, alternative embodiments of the invention may use more, less, or different register files and registers.</p><heading id="h-0016" level="1">Exemplary Core Architectures, Processors, and Computer Architectures</heading><p id="p-0074" num="0073">Processor cores may be implemented in different ways, for different purposes, and in different processors. For instance, implementations of such cores may include: 1) a general purpose in-order core intended for general-purpose computing; 2) a high performance general purpose out-of-order core intended for general-purpose computing; 3) a special purpose core intended primarily for graphics and/or scientific (throughput) computing. Implementations of different processors may include: 1) a CPU including one or more general purpose in-order cores intended for general-purpose computing and/or one or more general purpose out-of-order cores intended for general-purpose computing; and 2) a coprocessor including one or more special purpose cores intended primarily for graphics and/or scientific (throughput). Such different processors lead to different computer system architectures, which may include: 1) the coprocessor on a separate chip from the CPU; 2) the coprocessor on a separate die in the same package as a CPU; 3) the coprocessor on the same die as a CPU (in which case, such a coprocessor is sometimes referred to as special purpose logic, such as integrated graphics and/or scientific (throughput) logic, or as special purpose cores); and 4) a system on a chip that may include on the same die the described CPU (sometimes referred to as the application core(s) or application processor(s)), the above described coprocessor, and additional functionality. Exemplary core architectures are described next, followed by descriptions of exemplary processors and computer architectures. Detailed herein are circuits (units) that comprise exemplary cores, processors, etc.</p><heading id="h-0017" level="1">Exemplary Core Architectures</heading><p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is a block diagram illustrating both an exemplary in-order pipeline and an exemplary register renaming, out-of-order issue/execution pipeline according to embodiments of the invention. <figref idref="DRAWINGS">FIG. <b>4</b>B</figref> is a block diagram illustrating both an exemplary embodiment of an in-order architecture core and an exemplary register renaming, out-of-order issue/execution architecture core to be included in a processor according to embodiments of the invention. The solid lined boxes in <figref idref="DRAWINGS">FIGS. <b>4</b>A-B</figref> illustrate the in-order pipeline and in-order core, while the optional addition of the dashed lined boxes illustrates the register renaming, out-of-order issue/execution pipeline and core. Given that the in-order aspect is a subset of the out-of-order aspect, the out-of-order aspect will be described.</p><p id="p-0076" num="0075">In <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, a processor pipeline <b>400</b> includes a fetch stage <b>402</b>, a length decode stage <b>404</b>, a decode stage <b>406</b>, an allocation stage <b>408</b>, a renaming stage <b>410</b>, a scheduling (also known as a dispatch or issue) stage <b>412</b>, a register read/memory read stage <b>414</b>, an execute stage <b>416</b>, a write back/memory write stage <b>418</b>, an exception handling stage <b>422</b>, and a commit stage <b>424</b>.</p><p id="p-0077" num="0076"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> shows processor core <b>490</b> including a front end unit <b>430</b> coupled to an execution engine unit <b>450</b>, and both are coupled to a memory unit <b>470</b>. The core <b>490</b> may be a reduced instruction set computing (RISC) core, a complex instruction set computing (CISC) core, a very long instruction word (VLIW) core, or a hybrid or alternative core type. As yet another option, the core <b>490</b> may be a special-purpose core, such as, for example, a network or communication core, compression engine, coprocessor core, general purpose computing graphics processing unit (GPGPU) core, graphics core, or the like.</p><p id="p-0078" num="0077">The front end unit <b>430</b> includes a branch prediction unit <b>432</b> coupled to an instruction cache unit <b>434</b>, which is coupled to an instruction translation lookaside buffer (TLB) <b>436</b>, which is coupled to an instruction fetch unit <b>438</b>, which is coupled to a decode unit <b>440</b>. The decode unit <b>440</b> (or decoder) may decode instructions, and generate as an output one or more micro-operations, micro-code entry points, microinstructions, other instructions, or other control signals, which are decoded from, or which otherwise reflect, or are derived from, the original instructions. The decode unit <b>440</b> may be implemented using various different mechanisms. Examples of suitable mechanisms include, but are not limited to, look-up tables, hardware implementations, programmable logic arrays (PLAs), microcode read only memories (ROMs), etc. In one embodiment, the core <b>490</b> includes a microcode ROM or other medium that stores microcode for certain macroinstructions (e.g., in decode unit <b>440</b> or otherwise within the front end unit <b>430</b>). The decode unit <b>440</b> is coupled to a rename/allocator unit <b>452</b> in the execution engine unit <b>450</b>.</p><p id="p-0079" num="0078">The execution engine unit <b>450</b> includes the rename/allocator unit <b>452</b> coupled to a retirement unit <b>454</b> and a set of one or more scheduler unit(s) <b>456</b>. The scheduler unit(s) <b>456</b> represents any number of different schedulers, including reservations stations, central instruction window, etc. The scheduler unit(s) <b>456</b> is coupled to the physical register file(s) unit(s) <b>458</b>. Each of the physical register file(s) units <b>458</b> represents one or more physical register files, different ones of which store one or more different data types, such as scalar integer, scalar floating point, packed integer, packed floating point, vector integer, vector floating point, status (e.g., an instruction pointer that is the address of the next instruction to be executed), etc. In one embodiment, the physical register file(s) unit <b>458</b> comprises a vector registers unit and a scalar registers unit. These register units may provide architectural vector registers, vector mask registers, and general purpose registers. The physical register file(s) unit(s) <b>458</b> is overlapped by the retirement unit <b>454</b> to illustrate various ways in which register renaming and out-of-order execution may be implemented (e.g., using a reorder buffer(s) and a retirement register file(s); using a future file(s), a history buffer(s), and a retirement register file(s); using a register maps and a pool of registers; etc.). The retirement unit <b>454</b> and the physical register file(s) unit(s) <b>458</b> are coupled to the execution cluster(s) <b>460</b>. The execution cluster(s) <b>460</b> includes a set of one or more execution units <b>462</b> and a set of one or more memory access units <b>464</b>. The execution units <b>462</b> may perform various operations (e.g., shifts, addition, subtraction, multiplication) and on various types of data (e.g., scalar floating point, packed integer, packed floating point, vector integer, vector floating point). While some embodiments may include a number of execution units dedicated to specific functions or sets of functions, other embodiments may include only one execution unit or multiple execution units that all perform all functions. The scheduler unit(s) <b>456</b>, physical register file(s) unit(s) <b>458</b>, and execution cluster(s) <b>460</b> are shown as being possibly plural because certain embodiments create separate pipelines for certain types of data/operations (e.g., a scalar integer pipeline, a scalar floating point/packed integer/packed floating point/vector integer/vector floating point pipeline, and/or a memory access pipeline that each have their own scheduler unit, physical register file(s) unit, and/or execution cluster&#x2014;and in the case of a separate memory access pipeline, certain embodiments are implemented in which only the execution cluster of this pipeline has the memory access unit(s) <b>464</b>). It should also be understood that where separate pipelines are used, one or more of these pipelines may be out-of-order issue/execution and the rest in-order.</p><p id="p-0080" num="0079">The set of memory access units <b>464</b> is coupled to the memory unit <b>470</b>, which includes a data TLB unit <b>472</b> coupled to a data cache unit <b>474</b> coupled to a level 2 (L2) cache unit <b>476</b>. In one exemplary embodiment, the memory access units <b>464</b> may include a load unit, a store address unit, and a store data unit, each of which is coupled to the data TLB unit <b>472</b> in the memory unit <b>470</b>. The instruction cache unit <b>434</b> is further coupled to a level 2 (L2) cache unit <b>476</b> in the memory unit <b>470</b>. The L2 cache unit <b>476</b> is coupled to one or more other levels of cache and eventually to a main memory.</p><p id="p-0081" num="0080">By way of example, the exemplary register renaming, out-of-order issue/execution core architecture may implement the pipeline <b>400</b> as follows: 1) the instruction fetch <b>438</b> performs the fetch and length decoding stages <b>402</b> and <b>404</b>; 2) the decode unit <b>440</b> performs the decode stage <b>406</b>; 3) the rename/allocator unit <b>452</b> performs the allocation stage <b>408</b> and renaming stage <b>410</b>; 4) the scheduler unit(s) <b>456</b> performs the schedule stage <b>412</b>; 5) the physical register file(s) unit(s) <b>458</b> and the memory unit <b>470</b> perform the register read/memory read stage <b>414</b>; the execution cluster <b>460</b> perform the execute stage <b>416</b>; 6) the memory unit <b>470</b> and the physical register file(s) unit(s) <b>458</b> perform the write back/memory write stage <b>418</b>; 7) various units may be involved in the exception handling stage <b>422</b>; and 8) the retirement unit <b>454</b> and the physical register file(s) unit(s) <b>458</b> perform the commit stage <b>424</b>.</p><p id="p-0082" num="0081">The core <b>490</b> may support one or more instructions sets (e.g., the x86 instruction set (with some extensions that have been added with newer versions); the MIPS instruction set of MIPS Technologies of Sunnyvale, Calif.; the ARM instruction set (with optional additional extensions such as NEON) of ARM Holdings of Sunnyvale, Calif.), including the instruction(s) described herein. In one embodiment, the core <b>490</b> includes logic to support a packed data instruction set extension (e.g., AVX1, AVX2), thereby allowing the operations used by many multimedia applications to be performed using packed data.</p><p id="p-0083" num="0082">It should be understood that the core may support multithreading (executing two or more parallel sets of operations or threads), and may do so in a variety of ways including time sliced multithreading, simultaneous multithreading (where a single physical core provides a logical core for each of the threads that physical core is simultaneously multithreading), or a combination thereof (e.g., time sliced fetching and decoding and simultaneous multithreading thereafter such as in the Intel&#xae; Hyperthreading technology).</p><p id="p-0084" num="0083">While register renaming is described in the context of out-of-order execution, it should be understood that register renaming may be used in an in-order architecture. While the illustrated embodiment of the processor also includes separate instruction and data cache units <b>434</b>/<b>474</b> and a shared L2 cache unit <b>476</b>, alternative embodiments may have a single internal cache for both instructions and data, such as, for example, a Level 1 (L1) internal cache, or multiple levels of internal cache. In some embodiments, the system may include a combination of an internal cache and an external cache that is external to the core and/or the processor. Alternatively, all of the cache may be external to the core and/or the processor.</p><heading id="h-0018" level="1">Specific Exemplary In-Order Core Architecture</heading><p id="p-0085" num="0084"><figref idref="DRAWINGS">FIGS. <b>5</b>A-B</figref> illustrate a block diagram of a more specific exemplary in-order core architecture, which core would be one of several logic blocks (including other cores of the same type and/or different types) in a chip. The logic blocks communicate through a high-bandwidth interconnect network (e.g., a ring network) with some fixed function logic, memory I/O interfaces, and other necessary I/O logic, depending on the application.</p><p id="p-0086" num="0085"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> is a block diagram of a single processor core, along with its connection to the on-die interconnect network <b>502</b> and with its local subset of the Level 2 (L2) cache <b>504</b>, according to embodiments of the invention. In one embodiment, an instruction decoder <b>500</b> supports the x86 instruction set with a packed data instruction set extension. An L1 cache <b>506</b> allows low-latency accesses to cache memory into the scalar and vector units. While in one embodiment (to simplify the design), a scalar unit <b>508</b> and a vector unit <b>510</b> use separate register sets (respectively, scalar registers <b>512</b> and vector registers <b>514</b>) and data transferred between them is written to memory and then read back in from a level 1 (L1) cache <b>506</b>, alternative embodiments of the invention may use a different approach (e.g., use a single register set or include a communication path that allow data to be transferred between the two register files without being written and read back).</p><p id="p-0087" num="0086">The local subset of the L2 cache <b>504</b> is part of a global L2 cache that is divided into separate local subsets, one per processor core. Each processor core has a direct access path to its own local subset of the L2 cache <b>504</b>. Data read by a processor core is stored in its L2 cache subset <b>504</b> and can be accessed quickly, in parallel with other processor cores accessing their own local L2 cache subsets. Data written by a processor core is stored in its own L2 cache subset <b>504</b> and is flushed from other subsets, if necessary. The ring network ensures coherency for shared data. The ring network is bi-directional to allow agents such as processor cores, L2 caches and other logic blocks to communicate with each other within the chip. Each ring data-path is 1024-bits wide per direction in some embodiments.</p><p id="p-0088" num="0087"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> is an expanded view of part of the processor core in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref> according to embodiments of the invention. <figref idref="DRAWINGS">FIG. <b>5</b>B</figref> includes an L1 data cache <b>506</b>A part of the L1 cache <b>504</b>, as well as more detail regarding the vector unit <b>510</b> and the vector registers <b>514</b>. Specifically, the vector unit <b>510</b> is a 6-wide vector processing unit (VPU) (see the 16-wide ALU <b>528</b>), which executes one or more of integer, single-precision float, and double-precision float instructions. The VPU supports swizzling the register inputs with swizzle unit <b>520</b>, numeric conversion with numeric convert units <b>522</b>A-B, and replication with replication unit <b>524</b> on the memory input.</p><heading id="h-0019" level="1">Processor With Integrated Memory Controller and Graphics</heading><p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of a processor <b>600</b> that may have more than one core, may have an integrated memory controller, and may have integrated graphics according to embodiments of the invention. The solid lined boxes in <figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrate a processor <b>600</b> with a single core <b>602</b>A, a system agent <b>610</b>, a set of one or more bus controller units <b>616</b>, while the optional addition of the dashed lined boxes illustrates an alternative processor <b>600</b> with multiple cores <b>602</b>A-N, a set of one or more integrated memory controller unit(s) <b>614</b> in the system agent unit <b>610</b>, and special purpose logic <b>608</b>.</p><p id="p-0090" num="0089">Thus, different implementations of the processor <b>600</b> may include: 1) a CPU with the special purpose logic <b>608</b> being integrated graphics and/or scientific (throughput) logic (which may include one or more cores), and the cores <b>602</b>A-N being one or more general purpose cores (e.g., general purpose in-order cores, general purpose out-of-order cores, a combination of the two); 2) a coprocessor with the cores <b>602</b>A-N being a large number of special purpose cores intended primarily for graphics and/or scientific (throughput); and 3) a coprocessor with the cores <b>602</b>A-N being a large number of general purpose in-order cores. Thus, the processor <b>600</b> may be a general-purpose processor, coprocessor or special-purpose processor, such as, for example, a network or communication processor, compression engine, graphics processor, GPGPU (general purpose graphics processing unit), a high-throughput many integrated core (MIC) coprocessor (including 30 or more cores), embedded processor, or the like. The processor may be implemented on one or more chips. The processor <b>600</b> may be a part of and/or may be implemented on one or more substrates using any of a number of process technologies, such as, for example, BiCMOS, CMOS, or NMOS.</p><p id="p-0091" num="0090">The memory hierarchy includes one or more levels of cache within the cores <b>604</b>A-N, a set or one or more shared cache units <b>606</b>, and external memory (not shown) coupled to the set of integrated memory controller units <b>614</b>. The set of shared cache units <b>606</b> may include one or more mid-level caches, such as level 2 (L2), level 3 (L3), level 4 (L4), or other levels of cache, a last level cache (LLC), and/or combinations thereof. While in one embodiment a ring based interconnect unit <b>612</b> interconnects the integrated graphics logic <b>608</b>, the set of shared cache units <b>606</b>, and the system agent unit <b>610</b>/integrated memory controller unit(s) <b>614</b>, alternative embodiments may use any number of well-known techniques for interconnecting such units. In one embodiment, coherency is maintained between one or more cache units <b>606</b> and cores <b>602</b>-A-N.</p><p id="p-0092" num="0091">In some embodiments, one or more of the cores <b>602</b>A-N are capable of multi-threading. The system agent <b>610</b> includes those components coordinating and operating cores <b>602</b>A-N. The system agent unit <b>610</b> may include for example a power control unit (PCU) and a display unit. The PCU may be or include logic and components needed for regulating the power state of the cores <b>602</b>A-N and the integrated graphics logic <b>608</b>. The display unit is for driving one or more externally connected displays.</p><p id="p-0093" num="0092">The cores <b>602</b>A-N may be homogenous or heterogeneous in terms of architecture instruction set; that is, two or more of the cores <b>602</b>A-N may be capable of execution the same instruction set, while others may be capable of executing only a subset of that instruction set or a different instruction set.</p><heading id="h-0020" level="1">Exemplary Computer Architectures</heading><p id="p-0094" num="0093"><figref idref="DRAWINGS">FIGS. <b>7</b>-<b>10</b></figref> are block diagrams of exemplary computer architectures. Other system designs and configurations known in the arts for laptops, desktops, handheld PCs, personal digital assistants, engineering workstations, servers, network devices, network hubs, switches, embedded processors, digital signal processors (DSPs), graphics devices, video game devices, set-top boxes, micro controllers, cell phones, portable media players, hand held devices, and various other electronic devices, are also suitable. In general, a huge variety of systems or electronic devices capable of incorporating a processor and/or other execution logic as disclosed herein are generally suitable.</p><p id="p-0095" num="0094">Referring now to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, shown is a block diagram of a system <b>700</b> in accordance with one embodiment of the present invention. The system <b>700</b> may include one or more processors <b>710</b>, <b>715</b>, which are coupled to a controller hub <b>720</b>. In one embodiment, the controller hub <b>720</b> includes a graphics memory controller hub (GMCH) <b>790</b> and an Input/Output Hub (IOH) <b>750</b> (which may be on separate chips); the GMCH <b>790</b> includes memory and graphics controllers to which are coupled memory <b>740</b> and a coprocessor <b>745</b>; the IOH <b>750</b> is couples input/output (I/O) devices <b>760</b> to the GMCH <b>790</b>. Alternatively, one or both of the memory and graphics controllers are integrated within the processor (as described herein), the memory <b>740</b> and the coprocessor <b>745</b> are coupled directly to the processor <b>710</b>, and the controller hub <b>720</b> in a single chip with the IOH <b>750</b>.</p><p id="p-0096" num="0095">The optional nature of additional processors <b>715</b> is denoted in <figref idref="DRAWINGS">FIG. <b>7</b></figref> with broken lines. Each processor <b>710</b>, <b>715</b> may include one or more of the processing cores described herein and may be some version of the processor <b>600</b>.</p><p id="p-0097" num="0096">The memory <b>740</b> may be, for example, dynamic random access memory (DRAM), phase change memory (PCM), or a combination of the two. For at least one embodiment, the controller hub <b>720</b> communicates with the processor(s) <b>710</b>, <b>715</b> via a multi-drop bus, such as a frontside bus (FSB), point-to-point interface, or similar connection <b>795</b>.</p><p id="p-0098" num="0097">In one embodiment, the coprocessor <b>745</b> is a special-purpose processor, such as, for example, a high-throughput MIC processor, a network or communication processor, compression engine, graphics processor, GPGPU, embedded processor, or the like. In one embodiment, controller hub <b>720</b> may include an integrated graphics accelerator.</p><p id="p-0099" num="0098">There can be a variety of differences between the physical resources <b>710</b>, <b>7155</b> in terms of a spectrum of metrics of merit including architectural, microarchitectural, thermal, power consumption characteristics, and the like.</p><p id="p-0100" num="0099">In one embodiment, the processor <b>710</b> executes instructions that control data processing operations of a general type. Embedded within the instructions may be coprocessor instructions. The processor <b>710</b> recognizes these coprocessor instructions as being of a type that should be executed by the attached coprocessor <b>745</b>. Accordingly, the processor <b>710</b> issues these coprocessor instructions (or control signals representing coprocessor instructions) on a coprocessor bus or other interconnect, to coprocessor <b>745</b>. Coprocessor(s) <b>745</b> accept and execute the received coprocessor instructions.</p><p id="p-0101" num="0100">Referring now to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, shown is a block diagram of a first more specific exemplary system <b>800</b> in accordance with an embodiment of the present invention. As shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, multiprocessor system <b>800</b> is a point-to-point interconnect system, and includes a first processor <b>870</b> and a second processor <b>880</b> coupled via a point-to-point interconnect <b>850</b>. Each of processors <b>870</b> and <b>880</b> may be some version of the processor <b>600</b>. In one embodiment of the invention, processors <b>870</b> and <b>880</b> are respectively processors <b>710</b> and <b>715</b>, while coprocessor <b>838</b> is coprocessor <b>745</b>. In another embodiment, processors <b>870</b> and <b>880</b> are respectively processor <b>710</b> coprocessor <b>745</b>.</p><p id="p-0102" num="0101">Processors <b>870</b> and <b>880</b> are shown including integrated memory controller (IMC) units <b>872</b> and <b>882</b>, respectively. Processor <b>870</b> also includes as part of its bus controller units point-to-point (P-P) interfaces <b>876</b> and <b>878</b>; similarly, second processor <b>880</b> includes P-P interfaces <b>886</b> and <b>888</b>. Processors <b>870</b>, <b>880</b> may exchange information via a point-to-point (P-P) interface <b>850</b> using P-P interface circuits <b>878</b>, <b>888</b>. As shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, IMCs <b>872</b> and <b>882</b> couple the processors to respective memories, namely a memory <b>832</b> and a memory <b>834</b>, which may be portions of main memory locally attached to the respective processors.</p><p id="p-0103" num="0102">Processors <b>870</b>, <b>880</b> may each exchange information with a chipset <b>890</b> via individual P-P interfaces <b>852</b>, <b>854</b> using point to point interface circuits <b>876</b>, <b>894</b>, <b>886</b>, <b>898</b>. Chipset <b>890</b> may optionally exchange information with the coprocessor <b>838</b> via a high-performance interface <b>892</b>. In one embodiment, the coprocessor <b>838</b> is a special-purpose processor, such as, for example, a high-throughput MIC processor, a network or communication processor, compression engine, graphics processor, GPGPU, embedded processor, or the like.</p><p id="p-0104" num="0103">A shared cache (not shown) may be included in either processor or outside of both processors, yet connected with the processors via P-P interconnect, such that either or both processors' local cache information may be stored in the shared cache if a processor is placed into a low power mode.</p><p id="p-0105" num="0104">Chipset <b>890</b> may be coupled to a first bus <b>816</b> via an interface <b>896</b>. In one embodiment, first bus <b>816</b> may be a Peripheral Component Interconnect (PCI) bus, or a bus such as a PCI Express bus or another I/O interconnect bus, although the scope of the present invention is not so limited.</p><p id="p-0106" num="0105">As shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, various I/O devices <b>814</b> may be coupled to first bus <b>816</b>, along with a bus bridge <b>818</b> which couples first bus <b>816</b> to a second bus <b>820</b>. In one embodiment, one or more additional processor(s) <b>815</b>, such as coprocessors, high-throughput MIC processors, GPGPU's, accelerators (such as, e.g., graphics accelerators or digital signal processing (DSP) units), field programmable gate arrays, or any other processor, are coupled to first bus <b>816</b>. In one embodiment, second bus <b>820</b> may be a low pin count (LPC) bus. Various devices may be coupled to a second bus <b>820</b> including, for example, a keyboard and/or mouse <b>822</b>, communication devices <b>827</b> and a storage unit <b>828</b> such as a disk drive or other mass storage device which may include instructions/code and data <b>830</b>, in one embodiment. Further, an audio I/O <b>824</b> may be coupled to the second bus <b>816</b>. Note that other architectures are possible. For example, instead of the point-to-point architecture of <figref idref="DRAWINGS">FIG. <b>8</b></figref>, a system may implement a multi-drop bus or other such architecture.</p><p id="p-0107" num="0106">Referring now to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, shown is a block diagram of a second more specific exemplary system <b>900</b> in accordance with an embodiment of the present invention. Like elements in <figref idref="DRAWINGS">FIGS. <b>8</b> and <b>9</b></figref> bear like reference numerals, and certain aspects of <figref idref="DRAWINGS">FIG. <b>8</b></figref> have been omitted from <figref idref="DRAWINGS">FIG. <b>9</b></figref> in order to avoid obscuring other aspects of <figref idref="DRAWINGS">FIG. <b>9</b></figref>.</p><p id="p-0108" num="0107"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates that the processors <b>870</b>, <b>880</b> may include integrated memory and I/O control logic (&#x201c;CL&#x201d;) <b>972</b> and <b>982</b>, respectively. Thus, the CL <b>972</b>, <b>982</b> include integrated memory controller units and include I/O control logic. <figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates that not only are the memories <b>832</b>, <b>834</b> coupled to the CL <b>872</b>, <b>882</b>, but also that I/O devices <b>914</b> are also coupled to the control logic <b>872</b>, <b>882</b>. Legacy I/O devices <b>915</b> are coupled to the chipset <b>890</b>.</p><p id="p-0109" num="0108">Referring now to <figref idref="DRAWINGS">FIG. <b>10</b></figref>, shown is a block diagram of a SoC <b>1000</b> in accordance with an embodiment of the present invention. Similar elements in <figref idref="DRAWINGS">FIG. <b>6</b></figref> bear like reference numerals. Also, dashed lined boxes are optional features on more advanced SoCs. In <figref idref="DRAWINGS">FIG. <b>10</b></figref>, an interconnect unit(s) <b>1002</b> is coupled to: an application processor <b>1010</b> which includes a set of one or more cores <b>102</b>A-N, cache units <b>604</b>A-N, and shared cache unit(s) <b>606</b>; a system agent unit <b>610</b>; a bus controller unit(s) <b>616</b>; an integrated memory controller unit(s) <b>614</b>; a set or one or more coprocessors <b>1020</b> which may include integrated graphics logic, an image processor, an audio processor, and a video processor; an static random access memory (SRAM) unit <b>1030</b>; a direct memory access (DMA) unit <b>1032</b>; and a display unit <b>1040</b> for coupling to one or more external displays. In one embodiment, the coprocessor(s) <b>1020</b> include a special-purpose processor, such as, for example, a network or communication processor, compression engine, GPGPU, a high-throughput MIC processor, embedded processor, or the like.</p><p id="p-0110" num="0109">Embodiments of the mechanisms disclosed herein may be implemented in hardware, software, firmware, or a combination of such implementation approaches. Embodiments of the invention may be implemented as computer programs or program code executing on programmable systems comprising at least one processor, a storage system (including volatile and non-volatile memory and/or storage elements), at least one input device, and at least one output device.</p><p id="p-0111" num="0110">Program code, such as code <b>830</b> illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, may be applied to input instructions to perform the functions described herein and generate output information. The output information may be applied to one or more output devices, in known fashion. For purposes of this application, a processing system includes any system that has a processor, such as, for example; a digital signal processor (DSP), a microcontroller, an application specific integrated circuit (ASIC), or a microprocessor.</p><p id="p-0112" num="0111">The program code may be implemented in a high level procedural or object oriented programming language to communicate with a processing system. The program code may also be implemented in assembly or machine language, if desired. In fact, the mechanisms described herein are not limited in scope to any particular programming language. In any case, the language may be a compiled or interpreted language.</p><p id="p-0113" num="0112">One or more aspects of at least one embodiment may be implemented by representative instructions stored on a machine-readable medium which represents various logic within the processor, which when read by a machine causes the machine to fabricate logic to perform the techniques described herein. Such representations, known as &#x201c;IP cores&#x201d; may be stored on a tangible, machine readable medium and supplied to various customers or manufacturing facilities to load into the fabrication machines that actually make the logic or processor.</p><p id="p-0114" num="0113">Such machine-readable storage media may include, without limitation, non-transitory, tangible arrangements of articles manufactured or formed by a machine or device, including storage media such as hard disks, any other type of disk including floppy disks, optical disks, compact disk read-only memories (CD-ROMs), compact disk rewritable's (CD-RWs), and magneto-optical disks, semiconductor devices such as read-only memories (ROMs), random access memories (RAMs) such as dynamic random access memories (DRAMs), static random access memories (SRAMs), erasable programmable read-only memories (EPROMs), flash memories, electrically erasable programmable read-only memories (EEPROMs), phase change memory (PCM), magnetic or optical cards, or any other type of media suitable for storing electronic instructions.</p><p id="p-0115" num="0114">Accordingly, embodiments of the invention also include non-transitory, tangible machine-readable media containing instructions or containing design data, such as Hardware Description Language (HDL), which defines structures, circuits, apparatuses, processors and/or system features described herein. Such embodiments may also be referred to as program products.</p><heading id="h-0021" level="1">Emulation (Including Binary Translation, Code Morphing, Etc.)</heading><p id="p-0116" num="0115">In some cases, an instruction converter may be used to convert an instruction from a source instruction set to a target instruction set. For example, the instruction converter may translate (e.g., using static binary translation, dynamic binary translation including dynamic compilation), morph, emulate, or otherwise convert an instruction to one or more other instructions to be processed by the core. The instruction converter may be implemented in software, hardware, firmware, or a combination thereof. The instruction converter may be on processor, off processor, or part on and part off processor.</p><p id="p-0117" num="0116"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a block diagram contrasting the use of a software instruction converter to convert binary instructions in a source instruction set to binary instructions in a target instruction set according to embodiments of the invention. In the illustrated embodiment, the instruction converter is a software instruction converter, although alternatively the instruction converter may be implemented in software, firmware, hardware, or various combinations thereof. <figref idref="DRAWINGS">FIG. <b>11</b></figref> shows a program in a high level language <b>1102</b> may be compiled using an first compiler <b>1104</b> to generate a first binary code (e.g., x86) <b>1106</b> that may be natively executed by a processor with at least one first instruction set core <b>1116</b>. In some embodiments, the processor with at least one first instruction set core <b>1116</b> represents any processor that can perform substantially the same functions as an Intel processor with at least one x86 instruction set core by compatibly executing or otherwise processing (1) a substantial portion of the instruction set of the Intel x86 instruction set core or (2) object code versions of applications or other software targeted to run on an Intel processor with at least one x86 instruction set core, in order to achieve substantially the same result as an Intel processor with at least one x86 instruction set core. The first compiler <b>1104</b> represents a compiler that is operable to generate binary code of the first instruction set <b>1106</b> (e.g., object code) that can, with or without additional linkage processing, be executed on the processor with at least one first instruction set core <b>1116</b>. Similarly, <figref idref="DRAWINGS">FIG. <b>11</b></figref> shows the program in the high level language <b>1102</b> may be compiled using an alternative instruction set compiler <b>1108</b> to generate alternative instruction set binary code <b>1110</b> that may be natively executed by a processor without at least one first instruction set core <b>1114</b> (e.g., a processor with cores that execute the MIPS instruction set of MIPS Technologies of Sunnyvale, Calif. and/or that execute the ARM instruction set of ARM Holdings of Sunnyvale, Calif.). The instruction converter <b>1112</b> is used to convert the first binary code <b>1106</b> into code that may be natively executed by the processor without an first instruction set core <b>1114</b>. This converted code is not likely to be the same as the alternative instruction set binary code <b>1110</b> because an instruction converter capable of this is difficult to make; however, the converted code will accomplish the general operation and be made up of instructions from the alternative instruction set. Thus, the instruction converter <b>1112</b> represents software, firmware, hardware, or a combination thereof that, through emulation, simulation or any other process, allows a processor or other electronic device that does not have a first instruction set processor or core to execute the first binary code <b>1106</b>.</p><heading id="h-0022" level="1">Apparatus and Method For Digital Signal Processing Instructions</heading><p id="p-0118" num="0117">Digital signal processing (DSP) instructions are described below. In one embodiment, the circuitry and logic to perform the DSP operations is integrated within the execution engine unit <b>450</b> shown in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>, within the various cores described above (see, e.g., cores <b>602</b>A-N in <figref idref="DRAWINGS">FIGS. <b>6</b> and <b>10</b></figref>), and/or within the vector unit <b>510</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref>. For example, the various source and destination registers may be SIMD registers within the physical register file unit(s) <b>458</b> in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref> and/or vector registers <b>310</b> in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. The multiplication circuits, adder circuits, accumulation circuits, and other circuitry described below may be integrated within the execution components of the architectures described above including, by way of example and not limitation, the execution unit(s) <b>462</b> in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>. It should be noted, however, that the underlying principles of the invention are not limited to these specific architectures.</p><p id="p-0119" num="0118">One embodiment of the invention includes circuitry and/or logic for processing digital signal processing (DSP) instructions. In particular, one embodiment comprises a multiply-accumulate (MAC) architecture with eight 16&#xd7;16-bit multipliers and two 64-bit accumulators. The instruction set architecture (ISA) described below can process various multiply and MAC operations on 128-bit packed (8-bit, 16-bit or 32-bit data elements) integer, fixed point and complex data types. In addition, certain instructions have direct support for highly efficient Fast Fourier Transform (FFT) and Finite Impulse Response (FIR) filtering, and post-processing of accumulated data by shift, round, and saturate operations.</p><p id="p-0120" num="0119">One embodiment of the new DSP instructions use a VEX.128 prefix based opcode encoding and several of the SSE/SSE2/AVX instructions that handle post-processing of data are used with the DSP ISA. The VEX-encoded 128-bit DSP instructions with memory operands may have relaxed memory alignment requirements.</p><p id="p-0121" num="0120">In one embodiment, the instructions also support a variety of integer and fixed point data types including:</p><p id="p-0122" num="0000">1) a Q31 data type for signals requiring analog to digital conversion (ADC) and digital to analog conversion (DAC) with greater than 16 bits;<br/>2) a Q15 data type which is common in DSP algorithms;<br/>3) a complex 16-bit data type; and<br/>4) a complex 32-bit data type.</p><p id="p-0123" num="0121">The instruction set architecture described herein targets a wide range of standard DSP (e.g., FFT, filtering, pattern matching, correlation, polynomial evaluation, etc) and statistical operations (e.g., mean, moving average, variance, etc.).</p><p id="p-0124" num="0122">Target applications of the embodiments of the invention include sensor, audio, classification tasks for computer vision, and speech recognition. The DSP ISA described herein includes a wide range of instructions that are applicable to deep neural networks (DNN), automatic speech recognition (ASR), sensor fusion with Kalman filtering, other major DSP applications, etc. Given the sequence of weights {w<sub>1</sub>, w<sub>2</sub>, . . . w<sub>k</sub>} and the input sequence {x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>, . . . x<sub>n</sub>} many image processing, machine learning tasks require to compute the result sequence {y<sub>1</sub>, y<sub>2</sub>, y<sub>3</sub>, . . . y<sub>n+1&#x2212;k</sub>} defined by y<sub>i</sub>=w<sub>1</sub>x<sub>i</sub>+w<sub>2</sub>x<sub>i+1</sub>+ . . . +w<sub>k</sub>x<sub>i+k&#x2212;1</sub>.</p><p id="p-0125" num="0123"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates an exemplary processor <b>1255</b> on which embodiments of the invention may be implemented which includes a plurality of cores 0-N for simultaneously executing a plurality of instruction threads. The illustrated embodiment includes DSP instruction decode circuitry/logic <b>1231</b> within the decoder <b>1230</b> and DSP instruction execution circuitry/logic <b>1341</b> within the execution unit <b>1240</b>. These pipeline components may perform the operations described herein responsive to the decoding and execution of the DSP instructions, such as the vector packed multiply instructions (e.g., DVPMULUWR, DVPMULWR, DVPMULWS, etc.) described below. While details of only a single core (Core <b>0</b>) are shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, it will be understood that each of the other cores of processor <b>1255</b> may include similar components.</p><p id="p-0126" num="0124">Prior to describing specific details of the embodiments of the invention, a description of the various components of the exemplary processor <b>1255</b> are provided directly below. The plurality of cores <b>0</b>-N may each include a memory management unit <b>1290</b> for performing memory operations (e.g., such as load/store operations), a set of general purpose registers (GPRs) <b>1205</b>, a set of vector registers <b>1206</b>, and a set of mask registers <b>1207</b>. In one embodiment, multiple vector data elements are packed into each vector register <b>1206</b> which may have a 512 bit width for storing two 256 bit values, four 128 bit values, eight 64 bit values, sixteen 32 bit values, etc. However, the underlying principles of the invention are not limited to any particular size/type of vector data. In one embodiment, the mask registers <b>1207</b> include eight 64-bit operand mask registers used for performing bit masking operations on the values stored in the vector registers <b>1206</b> (e.g., implemented as mask registers k0-k7 described herein). However, the underlying principles of the invention are not limited to any particular mask register size/type.</p><p id="p-0127" num="0125">Each core <b>0</b>-N may include a dedicated Level 1 (L1) cache 1212 and Level 2 (L2) cache <b>1211</b> for caching instructions and data according to a specified cache management policy. The L1 cache <b>1212</b> includes a separate instruction cache <b>1220</b> for storing instructions and a separate data cache <b>1221</b> for storing data. The instructions and data stored within the various processor caches are managed at the granularity of cache lines which may be a fixed size (e.g., 64, 128, 512 Bytes in length). Each core of this exemplary embodiment has an instruction fetch unit <b>1210</b> for fetching instructions from main memory <b>1200</b> and/or a shared Level 3 (L3) cache <b>1216</b>. The instruction fetch unit <b>1210</b> includes various well known components including a next instruction pointer <b>1203</b> for storing the address of the next instruction to be fetched from memory <b>1200</b> (or one of the caches); an instruction translation look-aside buffer (ITLB) <b>1204</b> for storing a map of recently used virtual-to-physical instruction addresses to improve the speed of address translation; a branch prediction unit <b>1202</b> for speculatively predicting instruction branch addresses; and branch target buffers (BTBs) <b>1201</b> for storing branch addresses and target addresses.</p><p id="p-0128" num="0126">As mentioned, a decode unit <b>1230</b> includes DSP instruction decode circuitry/logic <b>1231</b> for decoding the DSP instructions (e.g., vector packed multiply instructions) described herein into micro-operations or &#x201c;uops&#x201d; and the execution unit <b>1240</b> includes DSP instruction execution circuitry/logic <b>1241</b> for executing the DSP instructions. A writeback/retirement unit <b>1250</b> retires the executed instructions and writes back the results.</p><heading id="h-0023" level="1">Embodiments for Performing Vector Packed Multiply of Signed and Unsigned Words</heading><p id="p-0129" num="0127">In some sensors or sensing applications, results from vector packed multiplications may offer more precision than necessary for the usage. For example, in several sensing applications that use 16-bit integer data types (signed or unsigned), after the vector packed multiplication between two packed source operands, the upper 16-bits of each of the resulting products may be sufficient for the sensing application after the lower 16-bits of each resulting product is rounded off. In some cases, different types of rounding may be performed. For example, the type of rounding may be controlled by a rounding control bit(s) stored in a register (e.g., one of the general-purpose registers <b>1205</b> of <figref idref="DRAWINGS">FIG. <b>12</b></figref>). The rounding control bit(s) may be set to different values, each value indicating or corresponding to a specific rounding method, so that different rounding methods can be specified to accommodate different usages and/or applications.</p><p id="p-0130" num="0128">One embodiment of the invention includes an instruction for performing a vector packed multiply of unsigned words between two source registers, rounding each of the resulting doubleword products according to a rounding method, and storing the higher bits of each rounded resulting doubleword products in packed data element positions of a destination register. A register, such as a machine-specific register (MSR) or computer-specific register (CSR), is used to store one or more bits of a rounding control to specify the rounding method to be performed.</p><p id="p-0131" num="0129">Another embodiment of the invention includes an instruction for performing a vector packed multiply of signed words between two source registers, rounding each of the resulting doubleword products according to a rounding method, and storing the higher bits of each rounded resulting doubleword products in packed data element positions in a destination register. Again, the rounding method to be performed may be specified by one or more bits of a rounding control stored in a register such as an MSR or CSR.</p><p id="p-0132" num="0130">Yet another embodiment of the invention includes an instruction that performs a vector packed multiply of signed words between two source registers, saturates each of the resulting doubleword products to a saturated lower word result, and stores each saturated lower word result in one of the packed data element positions of a destination register. For each of the resulting doubleword products, it is saturated to a minimum or maximum word value if any of the upper word bits of the resulting double word product is set. In one embodiment, a saturation bit is set whenever at least one of resulting doubleword products is saturated to the minimum or maximum word value. The saturation bit may be stored in a MSR or CSR.</p><p id="p-0133" num="0131">One embodiment includes the instruction DVPMULUWR xmm1, xmm2, xmm3/m128 (2 source, 1 destination), which performs a vector packed multiply of unsigned words of xmm2/m128 (a packed data register or memory location) with unsigned words of xmm3/m128 (a packed data register or memory location), rounds each result, and writes/stores the high results (i.e., the upper word portion of each of the rounded results) into packed word locations in xmm1/m128 (a packed data register or memory location).</p><p id="p-0134" num="0132">Another embodiment includes the instruction DVPMULWR xmm1, xmm2, xmm3/m128 (2 source, 1 destination), which performs a vector packed multiply of signed words of xmm2/m128 (a packed data register or memory location) with signed words of xmm3/m128 (a packed data register or memory location), rounds each result, and writes/stores the high results (i.e., the upper word portion of each of the rounded results) into packed word locations in xmm1/m128 (a packed data register or memory location).</p><p id="p-0135" num="0133">In addition, one embodiment includes the instruction DVPMULWS xmm1, xmm2, xmm3/m128 (2 source, 1 destination) which performs vector packed multiply of signed words of xmm2/m128 (a packed data register or memory location) with signed words of xmm3/m128 (a packed data register or memory location), saturates each result to a lower word result, and writes/stores the low word results into packed word locations of xmm1/m128 (a packed data register or memory location). Saturating a result to a maximum or minimum word value (e.g., 0x7FFF or 0x8000) is performed if at least one of the upper word bits of the result is set. In some cases, a saturation bit is set if any of the results is saturated to a maximum or minimum word value.</p><p id="p-0136" num="0134"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates exemplary data element and bit distributions for an exemplary source register and/or destination register (SRCx/DESTx). Data elements may be packed into the source register and/or destination register in words (16 bits), doublewords (32 bits), and/or quadwords (64 bits) as illustrated. In the implementations described herein, for example, the source and destination registers store words (illustrated as elements 16 bit data elements A-H). Other embodiments may store larger or smaller values such as doublewords (illustrated as elements B-A, D-C, F-E, and H-G) or quadwords (illustrated as a low quadword D-A and a high quadword H-E) or bytes, respectively. However, the underlying principles of the invention are not limited to any particular data sizes.</p><p id="p-0137" num="0135"><figref idref="DRAWINGS">FIGS. <b>14</b></figref> illustrates an exemplary architecture for executing instructions for performing a vector packed multiply, rounding, saturation operation with signed/unsigned words. One embodiment uses packed word data elements stored in registers SRC1 <b>1401</b> and SRC2 <b>1402</b>. For purposes of explanation, the word values in <figref idref="DRAWINGS">FIG. <b>14</b></figref> are identified as 16-bit elements A-H. In the implementations described herein, the word values may be signed or unsigned packed data values.</p><p id="p-0138" num="0136">In one embodiment, the exemplary architecture illustrated in <figref idref="DRAWINGS">FIG. <b>14</b></figref> performs the following operation:</p><p id="p-0139" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>DEST<sub>X</sub><i>=SAT</i>31(<i>RND</i>16(SRC1<sub>x</sub>&#x2297;SRC2<sub>x</sub>))[31:16]<?in-line-formulae description="In-line Formulae" end="tail"?><ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0137">1. x=A, B, C, D, E, F, G, H</li>        <li id="ul0002-0002" num="0138">2. SAT31, RND16 are optional</li>        <li id="ul0002-0003" num="0139">3. &#x2297; may optionally be fractional multiplication, otherwise standard multiplication</li>    </ul>    </li></ul></p><p id="p-0140" num="0140">In one embodiment, the vector packed multiply instructions may be executed via input multiplexer <b>1403</b> which selects words or data elements from registers SRC1 <b>1401</b> and SRC2 <b>1402</b>, multiplier circuitry <b>1405</b> which performs signed/unsigned multiplication on words or data elements, adder networks <b>1410</b>-<b>1411</b> which perform rounding operations, saturation circuitry <b>1440</b>-<b>1441</b> which performs any necessary saturations, and output multiplexer <b>1450</b> which routes results to the destination register <b>1460</b>.</p><p id="p-0141" num="0141">The architecture shown in <figref idref="DRAWINGS">FIGS. <b>14</b></figref> may be used to execute a variety of different DSP-based instructions such as multiply accumulate, reciprocal, reciprocal square root, shift and extract, and multiplication, and addition/multiplication of complex numbers, to name a few. The various components illustrated in <figref idref="DRAWINGS">FIGS. <b>14</b></figref> may be used to execute certain instructions but not others. In one embodiment, for example, the accumulators <b>1420</b>-<b>1421</b> are not used when executing the vector packed multiply instructions described herein. In other embodiments, only the adder networks (for rounding operations) are used but not the saturation circuitry, or vice versa. In such cases, the data may simply bypass any unused circuits without modification.</p><p id="p-0142" num="0142">One embodiment of the DVPMULUWR xmm1, xmm2, xmm3/m128 instruction is represented by the following code sequence:</p><heading id="h-0024" level="2">TEMP0[31:0]&#x2190;SRC1[15:0]*SRC2[15:0]; (* UnSigned Multiplication *)</heading><heading id="h-0025" level="2">TEMP1[31:0]&#x2190;SRC1[31:16]*SRC2[31:16];</heading><heading id="h-0026" level="2">TEMP2[31:0]&#x2190;SRC1[47:32]*SRC2[47:32];</heading><heading id="h-0027" level="2">TEMP3[31:0]&#x2190;SRC1[63:48]*SRC2[63:48];</heading><heading id="h-0028" level="2">TEMP4[31:0]&#x2190;SRC1[79:64]*SRC2[79:64];</heading><heading id="h-0029" level="2">TEMP5[31:0]&#x2190;SRC1[95:80]*SRC2[95:80];</heading><heading id="h-0030" level="2">TEMP6[31:0]&#x2190;SRC1[111:96]*SRC2[111:96];</heading><heading id="h-0031" level="2">TEMP7[31:0]&#x2190;SRC1[127:112]*SRC2[127:112];</heading><heading id="h-0032" level="2">DEST[15:0]&#x2190;RoundWrapToUnSignedWord (TEMP0[31:0], MXCSR.IRM[1:0], DEST[15:0]);</heading><heading id="h-0033" level="2">DEST[31:16]&#x2190;RoundWrapToUnSignedWord (TEMP1[31:0], MXCSR.IRM[1:0], DEST[31:16]);</heading><heading id="h-0034" level="2">DEST[47:32]&#x2190;RoundWrapToUnSignedWord (TEMP2[31:0], MXCSR.IRM[1:0], DEST[47:32]);</heading><heading id="h-0035" level="2">DEST[63:48]&#x2190;RoundWrapToUnSignedWord (TEMP3[31:0], MXCSR.IRM[1:0], DEST[63:48]);</heading><heading id="h-0036" level="2">DEST[79:64]&#x2190;RoundWrapToUnSignedWord (TEMP4[31:0], MXCSR.IRM[1:0], DEST[79:64]);</heading><heading id="h-0037" level="2">DEST[95:80]&#x2190;RoundWrapToUnSignedWord (TEMP5[31:0], MXCSR.IRM[1:0], DEST[95:80]);</heading><heading id="h-0038" level="2">DEST[111:96]&#x2190;RoundWrapToUnSignedWord (TEMP6[31:0], MXCSR.IRM[1:0], DEST[111:96]);</heading><heading id="h-0039" level="2">DEST[127:112]&#x2190;RoundWrapToUnSignedWord (TEMP7[31:0], MXCSR.IRM[1:0], DEST[127:112]);</heading><p id="p-0143" num="0143">Where RoundWrapToUnSignedWord is represented by the following code sequence:</p><p id="p-0144" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>RoundWrapToUnSignedWord(SRC[31:0], MXCSR.IRM[1:0], DEST[15:0])</entry></row><row><entry>&#x2003;IF(MXSCR.IRM[1:0] == 2&#x2032;b11) THEN (* Round Down *)</entry></row><row><entry>&#x2003;&#x2003;Temp_RoundBit &#x2190; 1&#x2032;b0;</entry></row><row><entry>&#x2003;ELSE IF (MXSCR.IRM[1:0] == 2&#x2032;b10) THEN (* Halfway away from zero *)</entry></row><row><entry>&#x2003;&#x2003;Temp_RoundBit &#x2190; SRC[15];</entry></row><row><entry>&#x2003;ELSE IF (MXSCR.IRM[1:0] == 2&#x2032;b00) (* Convergent Rounding *)</entry></row><row><entry>&#x2003;&#x2003;IF (SRC[15:0] == 0x8000)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;Temp_RoundBit &#x2190; SRC[16];</entry></row><row><entry>&#x2003;&#x2003;ELSE</entry></row><row><entry>&#x2003;&#x2003;&#x2003;Temp_RoundBit &#x2190; SRC[15];</entry></row><row><entry>&#x2003;ELSE IF (MXSCR.IRM[1:0] == 2&#x2032;b01) (* Round Half Up *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;Temp_RoundBit &#x2190; SRC[15];</entry></row><row><entry>DEST[15:0] &#x2190; (SRC[31:16] + {15&#x2032;b0, Temp_RoundBit}); (* Add Rounding bit</entry></row><row><entry>with wrapping *)</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0145" num="0144">In the above code, the DVPMULUWR instruction performs an unsigned multiplication of each of the words in source register SRC1 (e.g., SRC1[15:0]) with a corresponding word in source register SRC2 (e.g., SRC2[15:0]) to generate multiple temporary doubleword results. Each of the temporary doubleword results is stored into a corresponding temporary register or memory location of at least 32 bits (e.g., TEMP0[31:0]). Then, each of the temporary doubleword results is rounded according to a rounding method to generate a rounded word result. Each of the rounded word result is then stored into a corresponding word data element position of the destination register (e.g., DEST[15:0]).</p><p id="p-0146" num="0145">As illustrated by the code sequence of RoundWrapToUnSignedWord, the rounding method is indicated by the rounding control bit(s) stored in a register (e.g., MXCSR.IRM[1:0]). The available rounding methods may include rounding down, rounding half way away from zero, convergent rounding, and/or round half up). In one embodiment, each rounded word result is an unsigned word.</p><p id="p-0147" num="0146">One embodiment of the DVPMULWR xmm1, xmm2, xmm3/m128 instruction is represented by the following code sequence:</p><heading id="h-0040" level="2">TEMP0[31:0]&#x2190;SRC1[15:0]*SRC2[15:0]; (* Signed Multiplication *)</heading><heading id="h-0041" level="2">TEMP1[31:0]&#x2190;SRC1[31:16]*SRC2[31:16];</heading><heading id="h-0042" level="2">TEMP2[31:0]&#x2190;SRC1[47:32]*SRC2[47:32];</heading><heading id="h-0043" level="2">TEMP3[31:0]&#x2190;SRC1[63:48]*SRC2[63:48];</heading><heading id="h-0044" level="2">TEMP4[31:0]&#x2190;SRC1[79:64]*SRC2[79:64];</heading><heading id="h-0045" level="2">TEMP5[31:0]&#x2190;SRC1[95:80]*SRC2[95:80];</heading><heading id="h-0046" level="2">TEMP6[31:0]&#x2190;SRC1[111:96]*SRC2[111:96];</heading><heading id="h-0047" level="2">TEMP7[31:0]&#x2190;SRC1[127:112]*SRC2[127:112];</heading><heading id="h-0048" level="2">DEST[15:0]&#x2190;RoundWrapToSignedWord (TEMP0[31:0], MXCSR.IRM[1:0], DEST[15:0]);</heading><heading id="h-0049" level="2">DEST[31:16]&#x2190;RoundWrapToSignedWord (TEMP1[31:0], MXCSR.IRM[1:0], DEST[31:16]);</heading><heading id="h-0050" level="2">DEST[47:32]&#x2190;RoundWrapToSignedWord (TEMP2[31:0], MXCSR.IRM[1:0], DEST[47:32]);</heading><heading id="h-0051" level="2">DEST[63:48]&#x2190;RoundWrapToSignedWord (TEMP3[31:0], MXCSR.IRM[1:0], DEST[63:48]);</heading><heading id="h-0052" level="2">DEST[79:64]&#x2190;RoundWrapToSignedWord (TEMP4[31:0], MXCSR.IRM[1:0], DEST[79:64]);</heading><heading id="h-0053" level="2">DEST[95:80]&#x2190;RoundWrapToSignedWord (TEMP5[31:0], MXCSR.IRM[1:0], DEST[95:80]);</heading><heading id="h-0054" level="2">DEST[111:96]&#x2190;RoundWrapToSignedWord (TEMP6[31:0], MXCSR.IRM[1:0], DEST[111:96]);</heading><heading id="h-0055" level="2">DEST[127:112]&#x2190;RoundWrapToSignedWord (TEMP7[31:0], MXCSR.IRM[1:0], DEST[127:112]);</heading><p id="p-0148" num="0147">Where RoundWrapToSignedWord is represented by the following code sequence:</p><p id="p-0149" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>RoundWrapToSignedWord(SRC[31:0], MXCSR.IRM[1:0], DEST[15:0])</entry></row><row><entry>&#x2003;IF(MXSCR.IRM[1:0] == 2&#x2032;b11) THEN (* Round Down *)</entry></row><row><entry>&#x2003;&#x2003;Temp_RoundBit &#x2190; 1&#x2032;b0;</entry></row><row><entry>&#x2003;ELSE IF (MXSCR.IRM[1:0] == 2&#x2032;b10) THEN (* Halfway away from zero *)</entry></row><row><entry>&#x2003;&#x2003;IF (SRC[15:0] == 0x8000)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;Temp_RoundBit &#x2190; if (~SRC[31] ? SRC[15]: 1&#x2032;b0); (* i.e.</entry></row><row><entry>Round Up if positive, Truncate if negative (to get higher magnitude result) *)</entry></row><row><entry>&#x2003;&#x2003;ELSE</entry></row><row><entry>&#x2003;&#x2003;&#x2003;Temp_RoundBit &#x2190; SRC[15];</entry></row><row><entry>&#x2003;ELSE IF (MXSCR.IRM[1:0] == 2&#x2032;b00) (* Convergent Rounding *)</entry></row><row><entry>&#x2003;&#x2003;IF (SRC[15:0] == 0x8000)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;Temp_RoundBit &#x2190; SRC[16];</entry></row><row><entry>&#x2003;&#x2003;ELSE</entry></row><row><entry>&#x2003;&#x2003;&#x2003;Temp_RoundBit &#x2190; SRC[15];</entry></row><row><entry>&#x2003;ELSE IF (MXSCR.IRM[1:0] == 2&#x2032;b01) (* Round Half Up *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;Temp_RoundBit &#x2190; SRC[15];</entry></row><row><entry>DEST[15:0] &#x2190; (SRC[31:16] + {15&#x2032;b0, Temp_RoundBit}); (* Add Rounding bit</entry></row><row><entry>with wrapping *)</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0150" num="0148">In the above code, the DVPMULWR instruction performs a signed multiplication of each of the words in source register SRC1 (e.g., SRC1[15:0]) with a corresponding word in source register SRC2 (e.g., SRC2[15:0]) to generate multiple temporary doubleword results. Each of the temporary doubleword results is stored into a corresponding temporary register or memory location of at least 32 bits (e.g., TEMP0[31:0]). Then, each of the temporary doubleword results is rounded according to a rounding method to generate a rounded word result. Each of the rounded word result is then stored into a corresponding word data element position of the destination register (e.g., DEST[15:0]).</p><p id="p-0151" num="0149">As illustrated by the code sequence of RoundWrapToSignedWord, the rounding method is indicated by the rounding control bit(s) stored in a register (MXCSR.IRM[1:0]). The available rounding methods may include rounding down, rounding half way away from zero, convergent rounding, and/or round half up). In one embodiment, each rounded word result is a signed word.</p><p id="p-0152" num="0150">One embodiment of the DVPMULWS xmm1, xmm2, xmm3/m128 instruction is represented by the following code sequence:</p><heading id="h-0056" level="2">TEMP0[31:0]&#x2190;SRC1[15:0]*SRC2[15:0]; (* Signed Multiplication *)</heading><heading id="h-0057" level="2">TEMP1[31:0]&#x2190;SRC1[31:16]*SRC2[31:16];</heading><heading id="h-0058" level="2">TEMP2[31:0]&#x2190;SRC1[47:32]*SRC2[47:32];</heading><heading id="h-0059" level="2">TEMP3[31:0]&#x2190;SRC1[63:48]*SRC2[63:48];</heading><heading id="h-0060" level="2">TEMP4[31:0]&#x2190;SRC1[79:64]*SRC2[79:64];</heading><heading id="h-0061" level="2">TEMP5[31:0]&#x2190;SRC1[95:80]*SRC2[95:80];</heading><heading id="h-0062" level="2">TEMP6[31:0]&#x2190;SRC1[111:96]*SRC2[111:96];</heading><heading id="h-0063" level="2">TEMP7[31:0]&#x2190;SRC1[127:112]*SRC2[127:112];</heading><heading id="h-0064" level="2">DEST[15:0]&#x2190;SaturateToLowerSignedWord (TEMP0[31:0], DEST[15:0]);</heading><heading id="h-0065" level="2">DEST[31:16]&#x2190;SaturateToLowerSignedWord (TEMP1[31:0], DEST[31:16]);</heading><heading id="h-0066" level="2">DEST[47:32]&#x2190;SaturateToLowerSignedWord (TEMP2[31:0], DEST[47:32]);</heading><heading id="h-0067" level="2">DEST[63:48]&#x2190;SaturateToLowerSignedWord (TEMP3[31:0], DEST[63:48]);</heading><heading id="h-0068" level="2">DEST[79:64]&#x2190;SaturateToLowerSignedWord (TEMP4[31:0], DEST[79:64]);</heading><heading id="h-0069" level="2">DEST[95:80]&#x2190;SaturateToLowerSignedWord (TEMP5[31:0], DEST[95:80]);</heading><heading id="h-0070" level="2">DEST[111:96]&#x2190;SaturateToLowerSignedWord (TEMP6[31:0], DEST[111:96]);</heading><heading id="h-0071" level="2">DEST[127:112]&#x2190;SaturateToLowerSignedWord (TEMP7[31:0],</heading><heading id="h-0072" level="2">DEST[127:112]);</heading><p id="p-0153" num="0151">Where SaturateToLowerSignedWord is represented by the following code sequence:</p><p id="p-0154" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>SaturateToLowerSignedWord (SRC[31:0], DEST[15:0])</entry></row><row><entry>&#x2003;IF ( (SRC[31] == 0) AND (OR (SRC[30:16])) ) (* If any of the bits [30:16]</entry></row><row><entry>are set *)</entry></row><row><entry>&#x2003;&#x2003;DEST[15:0] &#x2190; 0x7FFF; (* Most Positive Number *)</entry></row><row><entry>&#x2003;&#x2003;MXCSR.Sat &#x2190; 1;</entry></row><row><entry>&#x2003;ELSE IF ( (SRC[31] == 1) AND (OR (SRC[30:16])) ) (* If any of the bits</entry></row><row><entry>[30:16] are set *)</entry></row><row><entry>&#x2003;&#x2003;DEST[15:0] &#x2190; 0x8000; (* Most Negative Number *)</entry></row><row><entry>&#x2003;&#x2003;MXCSR.Sat &#x2190; 1;</entry></row><row><entry>&#x2003;ELSE</entry></row><row><entry>&#x2003;&#x2003;DEST[15:0] &#x2190; SRC[15:0];</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0155" num="0152">In the above code, the DVPMULWS instruction performs a signed multiplication of each of the words in source register SRC1 (e.g., SRC1[15:0]) with a corresponding word in source register SRC2 (e.g., SRC2[15:0]) to generate multiple temporary doubleword results. Each of the temporary doubleword results is stored into a corresponding temporary register or memory location of at least 32 bits (e.g., TEMP0[31:0]). Next, a saturate to lower signed word operation is performed on the temporary doubleword results to generate a plurality of final word results. Each of the plurality of final word results is then is stored into a corresponding word data element position of the destination register (e.g., DEST[15:0]).</p><p id="p-0156" num="0153">As illustrated by the code sequence of SaturateToLowerSignedWord, saturation to a minimum or maximum signed word value is performed on a temporary doubleword result if any of its upper bits (e.g., bits [30:16]) is set. For example, if saturation is performed, the temporary doubleword result is saturated to either the most positive word value (e.g., 0x7FFF or the maximum signed word value) or the most negative word value (e.g., 0x8000 or the minimum signed word value) based on a sign bit (e.g., bit [31]) in the temporary doubleword result. The saturated word value (0x7FFF or 0x8000) is then stored to a corresponding word data element position in the destination register. On the other hand, if saturation is not performed, such that none of the bits [30:16] of the temporary doubleword result are set, then the lower word (i.e., the lower 16 bits) of the temporary doubleword result is stored to the corresponding word data element position in the destination register.</p><p id="p-0157" num="0154">A method in accordance with one embodiment of the invention is illustrated in <figref idref="DRAWINGS">FIG. <b>15</b></figref>. The method may be implemented within the context of the processor and system architectures described above but is not limited to any particular system architecture.</p><p id="p-0158" num="0155">At <b>1502</b>, a vector packed multiply instruction is fetched having fields for a first source operand and a second source operand to indicate a first and second plurality of packed words, respectively. In one embodiment, the fields also include a destination operand indicating a plurality of packed words or packed word data element positions. At <b>1504</b> the vector packed multiply instruction is decoded to generate a first decoded instruction (e.g., into a plurality of microoperations). At <b>1506</b>, the first and second plurality of packed word values are retrieved and stored in into packed data element locations of respective first and second source registers. The packed word values may be all signed word values or unsigned word values. The decoded instruction is then scheduled for execution.</p><p id="p-0159" num="0156">At <b>1508</b> the decoded instruction is executed to perform a vector packed multiplication between the packed data elements or word values in the first and second source registers. For instance, each packed word in the first source register is multiplied with a corresponding packed word in the second source register to generate a plurality of doubleword products. The multiplication may be signed or unsigned depending on type of packed words (signed or unsigned) in the first and second source registers. Each of the doubleword products is then rounded according to a rounding method to generate a plurality of rounded doubleword products. Various different types of rounding method may be performed. The rounding method may be specified by a set of rounding control bits which may be stored in a rounding control register.</p><p id="p-0160" num="0157">At <b>1510</b>, the plurality of rounded doubleword products, or part there of, is stored to the destination register. In one embodiment, the upper word (e.g., bits [31:16]) of each rounded doubleword product is stored into a corresponding one of the plurality of packed words or packed word data element positions of the destination register.</p><p id="p-0161" num="0158">Another method in accordance with one embodiment of the invention is illustrated in <figref idref="DRAWINGS">FIG. <b>16</b></figref>. The method may be implemented within the context of the processor and system architectures described above but is not limited to any particular system architecture.</p><p id="p-0162" num="0159">At <b>1602</b>, a vector packed multiply instruction is fetched having fields for a first source operand and a second source operand to indicate a first and second plurality of packed words, respectively. In one embodiment, the fields also include a destination operand indicating a plurality of packed words or packed word data element positions. At <b>1504</b> the vector packed multiply instruction is decoded to generate a first decoded instruction (e.g., into a plurality of microoperations). At <b>1506</b>, the first and second plurality of packed word values are retrieved and stored in into packed data element locations of respective first and second source registers. The packed word values, according to an embodiment, are signed word values. The decoded instruction is then scheduled for execution.</p><p id="p-0163" num="0160">At <b>1508</b> the decoded instruction is executed to perform a vector packed multiplication between the packed data elements or word values in the first and second source registers. For instance, each packed word in the first source register is multiplied (e.g., signed multiplication) with a corresponding packed word in the second source register to generate a plurality of doubleword products. Each of the doubleword products is then saturated to generate a plurality of final word results. In one embodiment, each doubleword product is saturated to the maximum signed word value (0x7FFF), the minimum signed word value (0x8000), or a lower word value (e.g., bits [15:0]) of the temporary doubleword result depending on the value of the sign bit (e.g., bit [31]) as well as other bits in the upper word (e.g., bits [30:16]) of the temporary doubleword result. If any of the doubleword products is saturated to the maximum or minimum signed word value, then a saturation indicator bit(s) is set to indicate the performance of saturation. At <b>1610</b>, each of the plurality of final word results is stored into one of the plurality of packed words or packed word data element positions of the destination register.</p><p id="p-0164" num="0161">While the examples described herein relate to operations on packed word data elements, embodiments of the present invention may be applied to data elements of other sizes. For instance, instead of packed words, the source and destination registers may include packed bytes, doublewords, or quadwords, etc. The multiplication, rounding, and/or saturation operations are then performed on the packed bytes, doublewords, or quadwords in similar manner as those described herein. For example, an embodiment of the invention may include an instruction for performing vector packed multiplication on packed doublewords, rounding operations on the resulting quadword products, and storing the upper doubleword of each rounded quadword products into corresponding doubleword data element positions in the destination register.</p><heading id="h-0073" level="1">EXAMPLES</heading><p id="p-0165" num="0162">The following are example implementations of different embodiments of the invention.</p><p id="p-0166" num="0163">Example 1. A processor that includes a decoder to decode a vector packed multiply instruction, which includes operands to identify a first and a second plurality of packed words, to generate a decoded vector packed multiply instruction; a first source register to store the first plurality of packed words; a second source register to store the second plurality of packed words; execution circuitry to execute the decoded vector packed multiply instruction; and destination register to store the results from executing the decoded vector packed multiple instruction. The execution circuitry includes multiplier circuitry to multiply each packed word in the first source register with a corresponding packed word in the second source register to generate a plurality of doubleword products. The execution circuitry further includes rounding circuitry to round each of the plurality of doubleword products according to a rounding method to generate a plurality of rounded doubleword products. Each upper word of the plurality of rounded doubleword results is then stored into a corresponding one of a plurality of word data element positions of the destination register.</p><p id="p-0167" num="0164">Example 2. The processor of Example 1, further including a plurality of temporary registers. Each of the temporary register is used to store one of the plurality of doubleword products generated by the multiplier circuitry.</p><p id="p-0168" num="0165">Example 3. The processor of Example 1, wherein the first and the second plurality of packed words are signed words.</p><p id="p-0169" num="0166">Example 4. The processor of Example 1, wherein the first and the second plurality of packed words are unsigned words.</p><p id="p-0170" num="0167">Example 5. The processor of Example 1, wherein the possible rounding methods include rounding down, rounding halfway away from zero, convergent rounding, and/or rounding half up.</p><p id="p-0171" num="0168">Example 6. The processor of Example 1, further including a rounding control register to store a rounding control value for specifying the rounding method.</p><p id="p-0172" num="0169">Example 7. The processor of Example 1, wherein the first and second source registers are 128-bit registers, each storing 8 packed words.</p><p id="p-0173" num="0170">Example 8. A method that includes: decoding a vector packed multiply instruction having operands to identify a first and a second plurality of packed words to generate a decoded vector packed multiply instruction; storing the first plurality of packed words in a first source register; storing the second plurality of packed words in a second source register; executing the decoded vector packed multiply instruction; multiplying each packed word in the first source register with a corresponding packed word in the second source register to generate a plurality of doubleword products; rounding each of the plurality of doubleword products according to a rounding method to generate a plurality of rounded doubleword products; and storing an upper word of each of the plurality of rounded doubleword products in one of a plurality of word data element positions of a destination register.</p><p id="p-0174" num="0171">Example 9. The method of Example 8, further including storing the plurality of doubleword products in a plurality of temporary registers.</p><p id="p-0175" num="0172">Example 10. The method of Example 8, wherein the first and the second plurality of packed words are signed words.</p><p id="p-0176" num="0173">Example 11. The method of Example 8, wherein the first and the second plurality of packed words are unsigned words.</p><p id="p-0177" num="0174">Example 12. The method of Example 8, wherein the possible rounding methods include rounding down, rounding halfway away from zero, convergent rounding, and/or rounding half up.</p><p id="p-0178" num="0175">Example 13. The method of Example 8, wherein the rounding method is indicated by a value stored in a rounding control register.</p><p id="p-0179" num="0176">Example 14. The method of Example 8, wherein the first and second source registers are 128-bit registers, each storing 8 packed words.</p><p id="p-0180" num="0177">Example 15. A processor that includes a decoder to decode a vector packed multiply instruction, which includes operands to identify a first and a second plurality of packed words, to generate a decoded vector packed multiply instruction; a first source register to store the first plurality of packed signed words; a second source register to store the second plurality of packed signed words; execution circuitry to execute the decoded vector packed multiply instruction; and destination register to store the results from executing the decoded vector packed multiple instruction. The execution circuitry includes multiplier circuitry to multiply each packed word in the first source register with a corresponding packed word in the second source register to generate a plurality of doubleword products. The execution circuitry further includes saturation circuitry to perform saturation on the plurality of doubleword products to generate a plurality of signed final word results. Each of the plurality of signed final word results corresponds to one of the plurality of doubleword products and contains either the most positive signed word value, the most negative signed word value, or the lower word of the corresponding doubleword product. Each of the signed final word results is then stored into a corresponding one of a plurality of word data element positions of the destination register.</p><p id="p-0181" num="0178">Example 16. The processor of Example 15, further including a plurality of temporary registers. Each temporary register is used to store one of the plurality of doubleword products generated by the multiplier circuitry.</p><p id="p-0182" num="0179">Example 17. The processor of Example 15, further including a saturation register to store a saturation bit to indicate whether any of the plurality of doubleword products has been saturated to either the most positive signed word value or the most negative signed word value by the saturation circuitry.</p><p id="p-0183" num="0180">Example 18. The processor of Example 17, wherein the saturation circuitry is to set the saturation bit when at least one of the plurality of doubleword products is saturated to either the most positive signed word value or the most negative signed word value by the saturation circuitry.</p><p id="p-0184" num="0181">Example 19. The processor of Example 15, wherein a first doubleword product of the plurality of doubleword products is saturated to the most positive word value, or the hexadecimal value 0x7FFF, when a sign bit of the first doubleword product is not set and at least one bit in an upper word of the first doubleword product is set.</p><p id="p-0185" num="0182">Example 20. The processor of Example 19, wherein the first doubleword product is saturated to the most negative value, or the hexadecimal value 0x8000, when both a sign bit of the first doubleword product and at least one bit in the upper word of the first doubleword product are set.</p><p id="p-0186" num="0183">Example 21. A method that includes: decoding a vector packed multiply instruction having operands to identify a first and a second plurality of packed words to generate a decoded vector packed multiply instruction; storing the first plurality of packed signed words in a first source register; storing the second plurality of packed signed words in a second source register; executing the decoded vector packed multiply instruction; multiplying each packed signed word in the first source register with a corresponding packed signed word in the second source register to generate a plurality of doubleword products; performing saturation on the plurality of doubleword products to generate a plurality of signed final word results, each of which corresponds to one of the plurality of doubleword products and is either the most positive signed word value, the most negative signed word value, and the lower word of the corresponding doubleword product; and storing each of the plurality of signed final word results in one of a plurality of word data element positions of the destination register.</p><p id="p-0187" num="0184">Example 22. The method of Example 21, further including storing the plurality of doubleword products in a plurality of temporary registers.</p><p id="p-0188" num="0185">Example 23. The method of Example 21, further including storing a saturation bit in a saturation register to indicate whether any of the plurality of doubleword products has been saturated to either the most positive signed word value or the most negative signed word value.</p><p id="p-0189" num="0186">Example 24. The method of Example 23, further including setting the saturation bit when at least one of the plurality of doubleword products is saturated to either the most positive signed word value or the most negative signed word value.</p><p id="p-0190" num="0187">Example 25. The method of Example 21, further including saturating a first doubleword product of the plurality of doubleword products to the most positive word value, or the hexadecimal value 0x7FFF, when a sign bit of the first doubleword product is not set and at least one bit in an upper word of the first doubleword product is set.</p><p id="p-0191" num="0188">Example 26. The method of Example 25, further including saturating the first doubleword product to the most negative value, or the hexadecimal value 0x8000, when both a sign bit of the first doubleword product and at least one bit in the upper word of the first doubleword product are set.</p><p id="p-0192" num="0189">In the foregoing specification, the embodiments of invention have been described with reference to specific exemplary embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.</p><p id="p-0193" num="0190">Embodiments of the invention may include various steps, which have been described above. The steps may be embodied in machine-executable instructions which may be used to cause a general-purpose or special-purpose processor to perform the steps. Alternatively, these steps may be performed by specific hardware components that contain hardwired logic for performing the steps, or by any combination of programmed computer components and custom hardware components.</p><p id="p-0194" num="0191">As described herein, instructions may refer to specific configurations of hardware such as application specific integrated circuits (ASICs) configured to perform certain operations or having a predetermined functionality or software instructions stored in memory embodied in a non-transitory computer readable medium. Thus, the techniques shown in the Figures can be implemented using code and data stored and executed on one or more electronic devices (e.g., an end station, a network element, etc.). Such electronic devices store and communicate (internally and/or with other electronic devices over a network) code and data using computer machine-readable media, such as non-transitory computer machine-readable storage media (e.g., magnetic disks; optical disks; random access memory; read only memory; flash memory devices; phase-change memory) and transitory computer machine-readable communication media (e.g., electrical, optical, acoustical or other form of propagated signals&#x2014;such as carrier waves, infrared signals, digital signals, etc.). In addition, such electronic devices typically include a set of one or more processors coupled to one or more other components, such as one or more storage devices (non-transitory machine-readable storage media), user input/output devices (e.g., a keyboard, a touchscreen, and/or a display), and network connections. The coupling of the set of processors and other components is typically through one or more busses and bridges (also termed as bus controllers). The storage device and signals carrying the network traffic respectively represent one or more machine-readable storage media and machine-readable communication media. Thus, the storage device of a given electronic device typically stores code and/or data for execution on the set of one or more processors of that electronic device. Of course, one or more parts of an embodiment of the invention may be implemented using different combinations of software, firmware, and/or hardware. Throughout this detailed description, for the purposes of explanation, numerous specific details were set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the invention may be practiced without some of these specific details. In certain instances, well known structures and functions were not described in elaborate detail in order to avoid obscuring the subject matter of the present invention. Accordingly, the scope and spirit of the invention should be judged in terms of the claims which follow.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A processor comprising:<claim-text>a decoder to decode a vector packed multiply instruction to generate a decoded vector packed multiply instruction, the vector packed multiply instruction including operands to identify a first and a second plurality of packed words;</claim-text><claim-text>a first source register to store the first plurality of packed words;</claim-text><claim-text>a second source register to store the second plurality of packed words;</claim-text><claim-text>execution circuitry to execute the decoded vector packed multiply instruction, the execution circuitry comprising:<claim-text>multiplier circuitry to multiply each packed word in the first source register with a corresponding packed word in the second source register to generate a plurality of doubleword products; and</claim-text><claim-text>rounding circuitry to round each of the plurality of doubleword products according to a rounding method to generate a plurality of rounded doubleword products; and</claim-text></claim-text><claim-text>a destination register comprising a plurality of word data element positions, each word data element position to store an upper word of a corresponding one of the plurality of rounded doubleword products.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a plurality of temporary registers, each temporary register to store one of the plurality of doubleword products generated by the multiplier circuitry.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first and the second plurality of packed words comprise signed words.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first and the second plurality of packed words comprise unsigned words.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the rounding method comprises one of rounding down, rounding halfway away from zero, convergent rounding, and rounding half up.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a rounding control register to store a rounding control value for specifying the rounding method.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first and second source registers comprise 128-bit registers, each storing 8 packed words.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A method comprising:<claim-text>decoding a vector packed multiply instruction to generate a decoded vector packed multiply instruction, the vector packed multiply instruction including operands to identify a first and a second plurality of packed words;</claim-text><claim-text>storing the first plurality of packed words in a first source register;</claim-text><claim-text>storing the second plurality of packed words in a second source register;</claim-text><claim-text>executing the decoded vector packed multiply instruction;</claim-text><claim-text>multiplying each packed word in the first source register with a corresponding packed word in the second source register to generate a plurality of doubleword products;</claim-text><claim-text>rounding each of the plurality of doubleword products according to a rounding method to generate a plurality of rounded doubleword products; and</claim-text><claim-text>storing an upper word of each of the plurality of rounded doubleword products in one of a plurality of word data element positions of a destination register.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising storing the plurality of doubleword products in a plurality of temporary registers.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the first and the second plurality of packed words comprise signed words.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the first and the second plurality of packed words comprise unsigned words.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the rounding method comprises one of rounding down, rounding halfway away from zero, convergent rounding, and rounding half up.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the rounding method is indicated by a value stored in a rounding control register.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the first and second source registers comprise 128-bit registers, each storing 8 packed words.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A processor comprising:<claim-text>a decoder to decode a vector packed multiply instruction to generate a decoded vector packed multiply instruction, the vector packed multiply instruction including operands to identify a first and a second plurality of packed signed words;</claim-text><claim-text>a first source register to store the first plurality of packed signed words;</claim-text><claim-text>a second source register to store the second plurality of packed signed words;</claim-text><claim-text>execution circuitry to execute the decoded vector packed multiply instruction, the execution circuitry comprising:<claim-text>multiplier circuitry to multiply each packed signed word in the first source register with a corresponding packed signed word in the second source register to generate a plurality of doubleword products; and</claim-text><claim-text>saturation circuitry to perform saturation on the plurality of doubleword products to generate a plurality of signed final word results, each of the plurality of signed final word results corresponding to one of the plurality of doubleword products and comprising one of a most positive signed word value, a most negative signed word value, and a lower word of the corresponding doubleword product; and</claim-text></claim-text><claim-text>a destination register comprising a plurality of word data element positions, each word data element position to store a corresponding one of the plurality of signed final word results.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The processor of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising a plurality of temporary registers, each temporary register to store one of the plurality of doubleword products generated by the multiplier circuitry.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The processor of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising a saturation register to store a saturation bit to indicate whether any of the plurality of doubleword products has been saturated to either the most positive signed word value or the most negative signed word value by the saturation circuitry.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The processor of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the saturation circuitry is to set the saturation bit when at least one of the plurality of doubleword products is saturated to either the most positive signed word value or the most negative signed word value by the saturation circuitry.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The processor of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein a first doubleword product of the plurality of doubleword products is saturated to the most positive word value or hexadecimal value 0x7FFF when a sign bit of the first doubleword product is not set and at least one bit in an upper word of the first doubleword product is set.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The processor of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the first doubleword product is saturated to the most negative value or hexadecimal value 0x8000 when both a sign bit of the first doubleword product and at least one bit in the upper word of the first doubleword product are set.</claim-text></claim></claims></us-patent-application>