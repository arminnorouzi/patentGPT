<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230006661A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230006661</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17894222</doc-number><date>20220824</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>03</class><subclass>K</subclass><main-group>3</main-group><subgroup>38</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>3</main-group><subgroup>04</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>10</main-group><subgroup>00</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>03</class><subclass>K</subclass><main-group>19</main-group><subgroup>195</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>03</class><subclass>K</subclass><main-group>3</main-group><subgroup>38</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>3</main-group><subgroup>04</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>10</main-group><subgroup>00</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>03</class><subclass>K</subclass><main-group>19</main-group><subgroup>195</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">Quantum Controller Architecture</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17459062</doc-number><date>20210827</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11463075</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17894222</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17088973</doc-number><date>20201104</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11115011</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17459062</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16708780</doc-number><date>20191210</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10862465</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17088973</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62894905</doc-number><date>20190902</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Quantum Machines</orgname><address><city>Tel Aviv</city><country>IL</country></address></addressbook><residence><country>IL</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Cohen</last-name><first-name>Yonatan</first-name><address><city>Tel Aviv</city><country>IL</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Ofek</last-name><first-name>Nissim</first-name><address><city>Tel Aviv</city><country>IL</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Sivan</last-name><first-name>Itamar</first-name><address><city>Tel Aviv</city><country>IL</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Shani</last-name><first-name>Tal</first-name><address><city>Tel Aviv</city><country>IL</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A system comprises pulse generation and measurement circuitry comprising a plurality of pulse generator circuits and a plurality of ports, and management circuitry. The management circuitry is operable to analyze a specification of a controlled system and controlled elements that comprises a definition of a controlled element of the control system, and a definition of one or more pulses available for transmission by the control system. The management circuitry is operable to configure, based on the specification, the pulse generation and measurement circuitry to: generate the one or more pulses via one or more of the plurality of pulse generator circuits; and output the one or more pulses to the controlled element via one or more of the plurality of ports.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="119.30mm" wi="158.75mm" file="US20230006661A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="180.59mm" wi="167.81mm" orientation="landscape" file="US20230006661A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="243.25mm" wi="92.63mm" orientation="landscape" file="US20230006661A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="181.44mm" wi="156.97mm" orientation="landscape" file="US20230006661A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="242.91mm" wi="170.60mm" orientation="landscape" file="US20230006661A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="120.14mm" wi="100.50mm" orientation="landscape" file="US20230006661A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="231.31mm" wi="143.00mm" orientation="landscape" file="US20230006661A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="228.18mm" wi="170.26mm" orientation="landscape" file="US20230006661A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="213.11mm" wi="172.64mm" orientation="landscape" file="US20230006661A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="248.07mm" wi="170.01mm" orientation="landscape" file="US20230006661A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="191.01mm" wi="157.65mm" orientation="landscape" file="US20230006661A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="217.00mm" wi="84.33mm" file="US20230006661A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="223.27mm" wi="87.71mm" file="US20230006661A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="184.40mm" wi="109.39mm" file="US20230006661A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="223.18mm" wi="168.99mm" file="US20230006661A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="232.58mm" wi="168.83mm" file="US20230006661A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="223.52mm" wi="94.83mm" orientation="landscape" file="US20230006661A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="231.31mm" wi="161.97mm" orientation="landscape" file="US20230006661A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="231.31mm" wi="140.89mm" orientation="landscape" file="US20230006661A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">PRIORITY CLAIM</heading><p id="p-0002" num="0001">This application claims priority to U.S. provisional patent application 62/894,905 Sep. 2, 2019, each of which is hereby incorporated herein by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">Limitations and disadvantages of conventional approaches to quantum computer control systems will become apparent to one of skill in the art, through comparison of such approaches with some aspects of the present method and system set forth in the remainder of this disclosure with reference to the drawings.</p><heading id="h-0003" level="1">BRIEF SUMMARY</heading><p id="p-0004" num="0003">Methods and systems are provided for a quantum controller, substantially as illustrated by and/or described in connection with at least one of the figures, as set forth more completely in the claims.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIGS. <b>1</b>A and <b>1</b>B</figref> compare some aspects of classical (binary) computing and quantum computing.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example quantum orchestration platform.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> shows an example quantum orchestration platform (QOP) architecture in accordance with various example implementations of this disclosure.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> shows an example implementation of the quantum controller circuitry of <figref idref="DRAWINGS">FIG. <b>3</b>A</figref>.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example implementation of the pulser of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows an example implementation of the pulse operations manager and pulse operations circuitry of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> shows frequency generation circuitry of the quantum controller of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> shows example components of the control signal IF<sub>l </sub>of <figref idref="DRAWINGS">FIG. <b>6</b>A</figref>.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows an example implementation of the digital manager of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows an example implementation of the digital manager of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates configuration and control of the quantum controller via the quantum programming subsystem.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIGS. <b>10</b>A-<b>10</b>C</figref> show an example quantum machine specification.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow chart showing an example operation of the QOP.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>12</b>A</figref> shows a portion of a quantum machine configured to perform a Power Rabi calibration.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>12</b>B</figref> shows the result of a Power Rabi calibration.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIGS. <b>13</b>A and <b>13</b>B</figref> illustrate the modular and reconfigurable nature of the QOP.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0021" num="0020">Classical computers operate by storing information in the form of binary digits (&#x201c;bits&#x201d;) and processing those bits via binary logic gates. At any given time, each bit takes on only one of two discrete values: 0 (or &#x201c;off&#x201d;) and <b>1</b> (or &#x201c;on&#x201d;). The logical operations performed by the binary logic gates are defined by Boolean algebra and circuit behavior is governed by classical physics. In a modern classical system, the circuits for storing the bits and realizing the logical operations are usually made from electrical wires that can carry two different voltages, representing the <b>0</b> and <b>1</b> of the bit, and transistor-based logic gates that perform the Boolean logic operations.</p><p id="p-0022" num="0021">Shown in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> is a simple example of a classical computer configured to a bit <b>102</b> and apply a single logic operation <b>104</b> to the bit <b>102</b>. At time t<b>0</b> the bit <b>102</b> is in a first state, at time t<b>1</b> the logic operation <b>104</b> is applied to the bit <b>102</b>, and at time t<b>2</b> the bit <b>102</b> is in a second state determined by the state at time t<b>0</b> and the logic operation. So, for example, the bit <b>102</b> may typically be stored as a voltage (e.g., 1 Vdc for a &#x201c;1&#x201d; or 0 Vdc for a &#x201c;0&#x201d;) which is applied to an input of the logic operation <b>104</b> (comprised of one or more transistors). The output of the logic gate is then either 1 Vdc or 0 Vdc, depending on the logic operation performed.</p><p id="p-0023" num="0022">Obviously, a classical computer with a single bit and single logic gate is of limited use, which is why modern classical computers with even modest computation power contain billions of bits and transistors. That is to say, classical computers that can solve increasingly complex problems inevitably require increasingly large numbers of bits and transistors and/or increasingly long amounts of time for carrying out the algorithms. There are, however, some problems which would require an infeasibly large number of transistors and/or infeasibly long amount of time to arrive at a solution. Such problems are referred to as intractable.</p><p id="p-0024" num="0023">Quantum computers operate by storing information in the form of quantum bits (&#x201c;qubits&#x201d;) and processing those qubits via quantum gates. Unlike a bit which can only be in one state (either 0 or 1) at any given time, a qubit can be in a superposition of the two states at the same time. More precisely, a quantum bit is a system whose state lives in a two dimensional Hilbert space and is therefore described as a linear combination &#x3b1;|0<img id="CUSTOM-CHARACTER-00001" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/>+&#x3b2;|1<img id="CUSTOM-CHARACTER-00002" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/>, where |0<img id="CUSTOM-CHARACTER-00003" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/> and |1<img id="CUSTOM-CHARACTER-00004" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/> are two basis states, and &#x3b1; and &#x3b2; are complex numbers, usually called probability amplitudes, which satisfy |&#x3b1;|<sup>2</sup>+|&#x3b2;|<b>3</b><sup>2</sup>=1. Using this notation, when the qubit is measured, it will be 0 with probability |&#x3b1;|<sup>2 </sup>and will be 1 with probability |&#x3b2;|<sup>2</sup>. |0<img id="CUSTOM-CHARACTER-00005" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/> and |1<img id="CUSTOM-CHARACTER-00006" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/> can also be represented by two-dimensional basis vectors</p><p id="p-0025" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mo>[</mo>    <mtable>     <mtr>      <mtd>       <mn>1</mn>      </mtd>     </mtr>     <mtr>      <mtd>       <mn>0</mn>      </mtd>     </mtr>    </mtable>    <mo>]</mo>   </mrow>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mrow>    <mi>and</mi>    <mtext>   </mtext>    <mo>[</mo>    <mtable>     <mtr>      <mtd>       <mn>0</mn>      </mtd>     </mtr>     <mtr>      <mtd>       <mn>1</mn>      </mtd>     </mtr>    </mtable>    <mo>]</mo>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0026" num="0000">respectively, and then the qubit state is represented by</p><p id="p-0027" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mrow>  <mrow>   <mo>[</mo>   <mtable>    <mtr>     <mtd>      <mi>&#x3b1;</mi>     </mtd>    </mtr>    <mtr>     <mtd>      <mi>&#x3b2;</mi>     </mtd>    </mtr>   </mtable>   <mo>]</mo>  </mrow>  <mo>.</mo> </mrow></math></maths></p><p id="p-0028" num="0000">The operations performed by the quantum gates are defined by linear algebra over Hilbert space and circuit behavior is governed by quantum physics. This extra richness in the mathematical behavior of qubits and the operations on them, enables quantum computers to solve some problems much faster than classical computers (in fact some problems that are intractable for classical computers may become trivial for quantum computers).</p><p id="p-0029" num="0024">Shown in <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> is a simple example of a quantum computer configured to store a qubit <b>122</b> and apply a single quantum gate operation <b>124</b> to the qubit <b>122</b>. At time t<b>0</b> the qubit <b>122</b> is described by &#x3b1;<sub>1</sub>|0<img id="CUSTOM-CHARACTER-00007" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/>+&#x3b2;<sub>1</sub>|<img id="CUSTOM-CHARACTER-00008" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/> at time t<b>1</b> the logic operation <b>104</b> is applied to the qubit <b>122</b>, and at time t<b>2</b> the qubits <b>122</b> is described by &#x3b1;<sub>2</sub>|0<img id="CUSTOM-CHARACTER-00009" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/>+&#x3b2;<sub>2</sub>|1<img id="CUSTOM-CHARACTER-00010" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/>.</p><p id="p-0030" num="0025">Unlike a classical bit, a qubit cannot be stored as a single voltage value on a wire. Instead, a qubit is physically realized using a two-level quantum mechanical system. Many physical implementations of qubits have been proposed and developed over the years with some being more promising than others. Some examples of leading qubits implementations include superconducting circuits, spin qubits, and trapped ions.</p><p id="p-0031" num="0026">It is the job of the quantum controller to generate the precise series of external signals, usually pulses of electromagnetic waves and pulses of base band voltage, to perform the desired logic operations (and thus carry out the desired quantum algorithm). Example implementations of a quantum controller are described in further detail below.</p><p id="p-0032" num="0027"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example quantum orchestration platform (QOP). The system comprises a quantum programming subsystem <b>202</b>, a quantum controller <b>210</b>, and a quantum processor <b>218</b>.</p><p id="p-0033" num="0028">The quantum programming subsystem <b>202</b> comprises circuitry operable to generate a quantum algorithm description <b>206</b> which configures the quantum controller <b>210</b> and includes instructions the quantum controller <b>210</b> can execute to carry out the quantum algorithm (i.e., generate the necessary outbound quantum control pulse(s) <b>213</b>) with little or no human intervention during runtime. In an example implementation, the quantum programming system <b>202</b> is a personal computer comprising a processor, memory, and other associated circuitry (e.g., an x86 or x64 chipset) having installed on it a quantum orchestration software development kit (SDK) that enables creation (e.g., by a user via a text editor, integrated development environment (IDE), and/or by automated quantum algorithm description generation circuitry) of a high-level (as opposed to binary or &#x201c;machine code&#x201d;) quantum algorithm description <b>206</b>. In an example implementation, the high-level quantum algorithm description uses a high-level programming language (e.g., Python, R, Java, Matlab, etc.) simply as a &#x201c;host&#x201d; programming language in which are embedded the QOP programming constructs.</p><p id="p-0034" num="0029">The high-level quantum algorithm description may comprise a specification (an example of which is shown in <figref idref="DRAWINGS">FIGS. <b>10</b>A-<b>10</b>C</figref>) and a program (an example program for a Power Rabi calibration is discussed below). Although the specification and program may be part of one or more larger databases and/or contained in one or more files, and one or more formats, the remainder of this disclosure will, for simplicity of description, assume the configuration data structure and the program data structure each takes the form of a plain-text file recognizable by an operating system (e.g., windows, Linux, Mac, or another OS) on which quantum programming subsystem runs. The quantum programming subsystem <b>202</b> then compiles the high-level quantum algorithm description <b>206</b> to a machine code version of the quantum algorithm description <b>206</b> (i.e., series of binary vectors that represent instructions that the quantum controller's hardware can interpret and execute directly). An example implementation of the data structures/vectors used for realizing the machine code version of the quantum algorithm description are described below.</p><p id="p-0035" num="0030">The quantum programming subsystem <b>202</b> is coupled to the quantum controller <b>210</b> via interconnect <b>204</b> which may, for example, utilize universal serial bus (USB), peripheral component interconnect (PCIe) bus, wired or wireless Ethernet, or any other suitable communication protocol. The quantum controller <b>210</b> comprises circuitry operable to load the machine code quantum algorithm description <b>206</b> from the programming subsystem <b>202</b> via interconnect <b>204</b>. Then, execution of the machine code by the quantum controller <b>210</b> causes the quantum controller <b>210</b> to generate the necessary outbound quantum control pulse(s) <b>213</b> that correspond to the desired operations to be performed on the quantum processor <b>218</b> (e.g., sent to qubit(s) for manipulating a state of the qubit(s) or to readout resonator(s) for reading the state of the qubit(s), etc.). Depending on the quantum algorithm to be performed, outbound pulse(s) <b>213</b> for carrying out the algorithm may be predetermined at design time and/or may need to be determined during runtime. The runtime determination of the pulses may comprise performance of classical calculations and processing in the quantum controller <b>210</b> and/or the quantum programing subsystem <b>202</b> during runtime of the algorithm (e.g., runtime analysis of inbound pulses <b>215</b> received from the quantum processor <b>218</b>).</p><p id="p-0036" num="0031">During runtime and/or upon completion of a quantum algorithm performed by the quantum controller <b>210</b>, the quantum controller <b>210</b> may output data/results <b>208</b> to the quantum programming subsystem <b>202</b>. In an example implementation these results may be used to generate a new quantum algorithm description <b>206</b> for a subsequent run of the quantum algorithm and/or update the quantum algorithm description during runtime.</p><p id="p-0037" num="0032">The quantum controller <b>210</b> is coupled to the quantum processor <b>218</b> via interconnect <b>212</b> which may comprise, for example, one or more conductors and/or optical fibers. The quantum controller <b>210</b> may comprise a plurality of interconnected, but physically distinct quantum control modules (e.g., each module being a desktop or rack mounted device) such that quantum control systems requiring relatively fewer resources can be realized with relatively fewer quantum control modules and quantum control systems requiring relatively more resources can be realized with relatively more quantum control modules.</p><p id="p-0038" num="0033">The quantum processor <b>218</b> comprises K (an integer) quantum elements <b>122</b>, which includes qubits (which could be of any type such as superconducting, spin qubits, ion trapped, etc.), and, where applicable, any other element(s) for processing quantum information, storing quantum information (e.g. storage resonator), and/or coupling the outbound quantum control pulses <b>213</b> and inbound quantum control pulses <b>215</b> between interconnect <b>212</b> and the quantum element(s) <b>122</b> (e.g., readout resonator(s)). In an example implementation in which the quantum processor comprises readout resonators (or other readout circuitry), K may be equal to the total number of qubits plus the number of readout circuits. That is, if each of Q (an integer) qubits of the quantum processor <b>218</b> is associated with a dedicated readout circuit, then K may be equal to 2Q. For ease of description, the remainder of this disclosure will assume such an implementation, but it need not be the case in all implementations. Other elements of the quantum processor <b>218</b> may include, for example, flux lines (electronic lines for carrying current), gate electrodes (electrodes for voltage gating), current/voltage lines, amplifiers, classical logic circuits residing on-chip in the quantum processor <b>218</b>, and/or the like.</p><p id="p-0039" num="0034"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> shows an example quantum controller architecture in accordance with various example implementations of this disclosure. The quantum controller <b>210</b> comprises L (an integer &#x2265;1) pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>and shared circuitry <b>310</b>.</p><p id="p-0040" num="0035">In the example implementation shown, each pulser circuit <b>302</b><sub>l </sub>(l an integer between 0 and L&#x2212;1) comprises circuitry for exchanging information over signal paths <b>304</b><sub>l</sub>, <b>306</b><sub>l</sub>, and <b>308</b><sub>l</sub>, where the signal path <b>308</b><sub>l </sub>carries outbound pulses (e.g., <b>213</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>) generated by the pulser circuit <b>302</b><sub>l </sub>(which may be, for example, control pulses sent to the quantum processor <b>218</b> to manipulate one or more properties of one or more quantum elements&#x2014;e.g., manipulate a state of one or more qubits, manipulate a frequency of a qubit using flux biasing, etc., and/or readout a state of one or more quantum elements), the signal path <b>306</b><sub>l </sub>carries inbound quantum element readout pulses (e.g., <b>215</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>) to be processed by the pulser circuit <b>302</b><sub>l</sub>, and signal path <b>304</b><sub>l </sub>carries control information. Each signal path may comprise one or more conductors, optical channels, and/or wireless channels.</p><p id="p-0041" num="0036">Each pulser circuit <b>302</b><sub>l </sub>comprises circuitry operable to generate outbound pulses on signal path <b>308</b><sub>l </sub>according to quantum control operations to be performed on the quantum processor <b>218</b>. This involves very precisely controlling characteristics such as phase, frequency, amplitude, and timing of the outbound pulses. The characteristics of an outbound pulse generated at any particular time may be determined, at least in part, on inbound pulses received from the quantum processor <b>218</b> (via shared circuitry <b>310</b> and signal path <b>306</b><sub>l</sub>) at a prior time. In an example implementation, the time required to close the feedback loop (i.e., time from receiving a first pulse on one or more of paths <b>315</b><sub>1</sub>-<b>315</b><sub>L </sub>(e.g., at an analog to digital converter of the path) to sending a second pulse on one or more of paths <b>313</b><sub>0</sub>-<b>313</b><sub>L-1</sub>, (e.g., at an output of a digital-to-analog converter of the path), where the second pulse is based on the first pulse, is significantly less than the coherence time of the qubits of the quantum processor <b>218</b>. For example, the time to close the feedback loop may be on the order of 100 nanoseconds. It should be noted that each signal path in <figref idref="DRAWINGS">FIG. <b>3</b>A</figref> may in practice be a set of signal paths for supporting generation of multi-pulse sets (e.g., two signal paths for two-pulse pairs, three signal paths for three-pulse sets, and so on).</p><p id="p-0042" num="0037">In the example implementation shown, the shared circuitry <b>310</b> comprises circuitry for exchanging information with the pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>over signal paths <b>304</b><sub>0</sub>-<b>304</b><sub>L-1</sub>, <b>306</b><sub>0</sub>-<b>306</b><sub>L-1</sub>, and <b>308</b><sub>0</sub>-<b>308</b><sub>L-1</sub>, where each signal path <b>308</b><sub>l </sub>carries outbound pulses generated by the pulser circuit <b>302</b><sub>l</sub>, each signal path <b>306</b><sub>l </sub>carries inbound pulses to be processed by pulser circuit <b>302</b><sub>l</sub>, and each signal path <b>304</b><sub>l </sub>carries control information such as flag/status signals, data read from memory, data to be stored in memory, data streamed to/from the quantum programming subsystem <b>202</b>, and data to be exchanged between two or more pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L</sub>. Similarly, in the example shown the shared circuitry <b>310</b> comprises circuitry for exchanging information with the quantum processor <b>218</b> over signal paths <b>315</b><sub>0</sub>-<b>315</b><sub>M-1 </sub>and <b>313</b><sub>1</sub>-<b>313</b><sub>K-1</sub>, where each signal path <b>315</b><sub>m </sub>(m an integer between 0 and M&#x2212;1) carries inbound pulses from the quantum processor <b>218</b>, and each signal path <b>313</b><sub>k </sub>(k an integer between 0 and K&#x2212;1) carries outbound pulses to the quantum processor <b>218</b>. Additionally, in the example shown the shared circuitry <b>310</b> comprises circuitry for exchanging information with the quantum programming subsystem over signal path <b>311</b>. The shared circuitry <b>310</b> may be: integrated with the quantum controller <b>210</b> (e.g., residing on one or more of the same field programmable gate arrays or application specific integrated circuits or printed circuit boards); external to the quantum controller (e.g., on a separate FPGA, ASIC, or PCB connected to the quantum controller via one or more cables, backplanes, or other devices connected to the quantum processor <b>218</b>, etc.); or partially integrated with the quantum controller <b>210</b> and partially external to the quantum controller <b>210</b>.</p><p id="p-0043" num="0038">In various implementations, M may be less than, equal to, or greater than L, K may be less than, equal to, or greater than L, and M may be less than, equal to, or greater than K. For example, the nature of some quantum algorithms is such that not all K quantum elements need to be driven at the same time. For such algorithms, L may be less than K and one or more of the L pulsers <b>302</b><sub>l </sub>may be shared among multiple of the K quantum elements circuits. That is, any pulser <b>302</b><sub>l </sub>may generate pulses for different quantum elements at different times. This ability of a pulser <b>302</b><sub>l </sub>to generate pulses for different quantum elements at different times can reduce the number of pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>(i.e., reduce L) required to support a given number of quantum elements (thus saving significant resources, cost, size, overhead when scaling to larger numbers of qubits, etc.).</p><p id="p-0044" num="0039">The ability of a pulser <b>302</b><sub>l </sub>to generate pulses for different quantum elements at different times also enables reduced latency. As just one example, assume a quantum algorithm which needs to send a pulse to quantum element <b>122</b><sub>0 </sub>at time T<b>1</b>, but whether the pulse is to be of a first type or second type (e.g., either an X pulse or a Hadamard pulse) cannot be determined until after processing an inbound readout pulse at time T<b>1</b>-DT (i.e., DT time intervals before the pulse is to be output). If there were a fixed assignment of pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>to quantum elements of the quantum processor <b>218</b> (i.e., if <b>302</b><sub>0 </sub>could only send pulses to quantum element <b>122</b><sub>0</sub>, and pulser <b>302</b><sub>1 </sub>could only send pulses to quantum element <b>1221</b>, and so on), then pulser <b>302</b><sub>0 </sub>might not be able to start generating the pulse until it determined what the type was to be. In the depicted example implementation, on the other hand, pulser <b>302</b><sub>0 </sub>can start generating the first type pulse and pulser <b>302</b><sub>1 </sub>can start generating the second type pulse and then either of the two pulses can be released as soon as the necessary type is determined. Thus, if the time to generate the pulse is T<sub>lat</sub>, in this example the example quantum controller <b>210</b> may reduce latency of outputting the pulse by T<sub>lat</sub>.</p><p id="p-0045" num="0040">The shared circuitry <b>310</b> is thus operable to receive pulses via any one or more of the signals paths <b>308</b><sub>0</sub>-<b>308</b><sub>L-1 </sub>and/or <b>315</b><sub>0</sub>-<b>315</b><sub>M-1</sub>, process the received pulses as necessary for carrying out a quantum algorithm, and then output the resulting processed pulses via any one or more of the signal paths <b>306</b><sub>0</sub>-<b>306</b><sub>L-1 </sub>and/or <b>313</b><sub>0</sub>-<b>313</b><sub>K-1</sub>. The processing of the pulses may take place in the digital domain and/or the analog domain. The processing may comprise, for example: frequency translation/modulation, phase translation/modulation, frequency and/or time division multiplexing, time and/or frequency division demultiplexing, amplification, attenuation, filtering in the frequency domain and/or time domain, time-to-frequency-domain or frequency-to-time-domain conversion, upsampling, downsampling, and/or any other signal processing operation. At any given time, the decision as to from which signal path(s) to receive one or more pulse(s), and the decision as to onto which signal path(s) to output the pulse(s) may be: predetermined (at least in part) in the quantum algorithm description; and/or dynamically determined (at least in part) during runtime of the quantum algorithm based on classical programs/computations performed during runtime, which may involve processing of inbound pulses. As an example of predetermined pulse generation and routing, a quantum algorithm description may simply specify that a particular pulse with predetermined characteristics is to be sent to signal path <b>313</b><sub>1 </sub>at a predetermined time. As an example of dynamic pulse determination and routing, a quantum algorithm description may specify that an inbound readout pulse at time T-DT should be analyzed and its characteristics (e.g., phase, frequency, and/or amplitude) used to determine, for example, whether at time T pulser <b>302</b><sub>l </sub>should output a pulse to a first quantum element or to a second quantum element or to determine, for example, whether at time T pulser <b>302</b><sub>l </sub>should output a first pulse to a first quantum element or a second pulse to the first quantum element. In various implementations of the quantum controller <b>210</b>, the shared circuitry <b>310</b> may perform various other functions instead of and/or in addition to those described above. In general, the shared circuitry <b>310</b> may perform functions that are desired to be performed outside of the individual pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>. For example, a function may be desirable to implement in the shared circuitry <b>310</b> where the same function is needed by a number of pulser circuits from <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>and thus may be shared among these pulser circuits instead of redundantly being implemented inside each pulser circuit. As another example, a function may be desirable to implement in the shared circuitry <b>310</b> where the function is not needed by all pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>at the same time and/or on the same frequency and thus fewer than L circuits for implementing the function may be shared among the L pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>through time and/or frequency division multiplexing. As another example, a function may be desirable to implement in the shared circuitry <b>310</b> where the function involves making decisions based on inputs, outputs, and/or state of multiple of the L pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>, or other circuits. Utilizing a centralized coordinator/decision maker in the shared circuitry <b>310</b> may have the benefit(s) of: (1) reducing pinout and complexity of the pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>; and/or (2) reducing decision-making latency. Nevertheless, in some implementations, decisions affecting multiple pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>may be made by one or more of the pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>where the information necessary for making the decision can be communicated among pulser circuits within a suitable time frame (e.g., still allowing the feedback loop to be closed within the qubit coherence time) over a tolerable number of pins/traces.</p><p id="p-0046" num="0041"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> shows an example implementation of the quantum controller of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. The example quantum controller shown comprises pulsers <b>302</b><sub>1</sub>-<b>302</b><sub>L-1</sub>, receive analog frontend <b>350</b>, input manager <b>352</b>, digital manager <b>354</b>, pulse operations manager <b>356</b>, pulse operations <b>358</b>, output manager <b>360</b>, transmit analog frontend <b>362</b>, data exchange <b>364</b>, synchronization manager <b>366</b>, and input/output (&#x201c;I/O&#x201d;) manager <b>368</b>. Circuitry depicted in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> other than pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>corresponds to an example implementation of the shared circuitry <b>310</b> of <figref idref="DRAWINGS">FIG. <b>3</b>A</figref>.</p><p id="p-0047" num="0042">The receive analog frontend <b>350</b> comprises circuitry operable to concurrently process up to M (an integer &#x2265;1) analog inbound signals (RP&#x2032;<sub>0</sub>-RP&#x2032;<sub>M-1</sub>) received via signal paths <b>315</b><sub>0</sub>-<b>315</b><sub>M-1 </sub>to generate up to M concurrent inbound signals (RP<sub>0</sub>-RP<sub>M-1</sub>) to be output to input manager <b>352</b> via one or more signal paths. Although there is shown to be M signals RP and M signals RP&#x2032;, this need not be the case. Such processing may comprise, for example, analog-to-digital conversion, filtering, upconversion, downconversion, amplification, attenuation, time division multiplexing/demultiplexing, frequency division multiplexing/demultiplexing, and/or the like. In various implementations, M may be less than, equal to, or greater than L and M may be less than, equal to, or greater than K.</p><p id="p-0048" num="0043">The input manager <b>352</b> comprises circuitry operable to route any one or more of signals (RP<sub>0</sub>-RP<sub>M-1</sub>) to any one or more of pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>(as signal(s) AI<sub>0</sub>-AI<sub>L-1</sub>) and/or to other circuits (e.g. as signal io_mgr to I/O manager <b>368</b>). In an example implementation, the input manager <b>352</b> comprises one or more switch networks, multiplexers, and/or the like for dynamically reconfiguring which signals RP<sub>0</sub>-RP<sub>M-1 </sub>are routed to which pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>. This may enable time division multiplexing multiple of the signals RP<sub>0</sub>-RP<sub>M-1 </sub>onto a single signal AI<sub>l </sub>and/or time division demultiplexing components (e.g., time slices) of a signal RP<sub>m </sub>onto multiple of the signals AI<sub>0</sub>-AI<sub>L-1</sub>. In an example implementation, the input manager <b>352</b> comprises one or more mixers and/or filters for frequency division multiplexing multiple of the signals RP<sub>0</sub>-RP<sub>M-1 </sub>onto a single signal AI<sub>l </sub>and/or frequency division demultiplexing components (e.g., frequency bands) of a signal RP<sub>m </sub>onto multiple of the signals AI<sub>0</sub>-AI<sub>L-1</sub>. The signal routing and multiplexing/demultiplexing functions performed by the input manager <b>352</b> enables: a particular pulser <b>302</b><sub>l </sub>to process different inbound pulses from different quantum elements at different times; a particular pulser <b>302</b><sub>l </sub>to process different inbound pulses from different quantum elements at the same time; and multiple of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>to processes the same inbound pulse at the same time. In the example implementation shown, routing of the signals RP<sub>0</sub>-RP<sub>M-1 </sub>among the inputs of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>is controlled by digital control signals in_slct<sub>0</sub>-in_slct<sub>L-1 </sub>from the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>. In another implementation, the input manager may be operable to autonomously determine the appropriate routing (e.g., where the quantum algorithm description includes instructions to be loaded into memory of, and executed by, the input manager <b>352</b>). In the example implementation, the input manager <b>352</b> is operable to rout input signals RP<sub>0</sub>-RP<sub>M-1 </sub>to the I/O manager <b>368</b> (as signal(s) io_mgr), to be sent to the quantum programing subsystem <b>202</b>. This routing may, for example, be controlled by signals from the digital manager <b>354</b>. In an example implementation, for each input signal RP<sub>m </sub>there is a digital signal, stream<sub>m</sub>, from the digital manager <b>354</b> to the input manager <b>352</b> that controls whether RP<sub>m </sub>will be sent from the input manager <b>352</b> to the I/O manager <b>368</b> and from there to the quantum programing subsystem <b>202</b>.</p><p id="p-0049" num="0044">Each of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>is as described above with reference to <figref idref="DRAWINGS">FIG. <b>3</b>A</figref>. In the example implementation shown, each pulser <b>302</b><sub>l </sub>is operable to generate raw outbound pulses CP&#x2032;<sub>l </sub>(&#x201c;raw&#x201d; is used simply to denote that the pulse has not yet been processed by pulse operations circuitry <b>358</b>) and digital control signals in_slct<sub>l</sub>, D_port<sub>l</sub>, D<sub>l</sub>, out_slct<sub>l</sub>, ops_ctrl<sub>l</sub>, ops_slct<sub>l</sub>, IF<sub>l</sub>, F<sub>l</sub>, and dmod_sclt<sub>l </sub>for carrying out quantum algorithms on the quantum processor <b>218</b>, and results<sub>l </sub>for carrying intermediate and/or final results generated by the pulser <b>302</b><sub>l </sub>to the quantum programming subsystem <b>202</b>. One or more of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>may receive and/or generate additional signals which are not shown in <figref idref="DRAWINGS">FIG. <b>3</b>A</figref> for clarity of illustration. The raw outbound pulses CP&#x2032;<sub>0</sub>-CP&#x2032;<sub>L-1 </sub>are conveyed via signal paths <b>308</b><sub>0</sub>-<b>308</b><sub>L-1 </sub>and the digital control signals are conveyed via signal paths <b>304</b><sub>0</sub>-<b>304</b><sub>L-1</sub>. Each of the pulsers <b>302</b><sub>l </sub>is operable to receive inbound pulse signal AI<sub>l </sub>and signal f_dmod<sub>l</sub>. Pulser <b>302</b><sub>l </sub>may process the inbound signal AI<sub>l </sub>to determine the state of certain quantum element(s) in the quantum processor <b>218</b> and use this state information for making decisions such as, for example, which raw outbound pulse CP&#x2032;<sub>l </sub>to generate next, when to generate it, and what control signals to generate to affect the characteristics of that raw outbound pulse appropriately. Pulser <b>302</b><sub>l </sub>may use the signal f_dmod<sub>l </sub>for determining how to process inbound pulse signal AI<sub>l</sub>. As an example, when pulser <b>302</b><sub>1 </sub>needs to process an inbound signal AI<sub>1 </sub>from quantum element <b>122</b><sub>3</sub>, it can send a dmod_sclt<sub>l </sub>signal that directs pulse operations manager <b>356</b> to send, on f_dmod<sub>1</sub>, settings to be used for demodulation of an inbound signal AI<sub>1 </sub>from quantum element <b>122</b><sub>3 </sub>(e.g., the pulse operations manager <b>356</b> may send the value cos(&#x3c9;<sub>3</sub>*TS*T<sub>clk1</sub>+&#x3d5;<sub>3</sub>), where &#x3c9;<sub>3 </sub>is the frequency of quantum element <b>122</b><sub>3</sub>, TS is amount of time passed since the reference point, for instance the time at which quantum algorithm started running, and &#x3d5;<sub>3 </sub>is the phase of the total frame rotation of quantum element <b>122</b><sub>3</sub>, i.e. the accumulated phase of all frame rotations since the reference point).</p><p id="p-0050" num="0045">The pulse operations circuitry <b>358</b> is operable to process the raw outbound pulses CP&#x2032;<sub>0</sub>-CP&#x2032;<sub>L-1 </sub>to generate corresponding output outbound pulses CP<sub>0</sub>-CP<sub>L-1</sub>. This may comprise, for example, manipulating the amplitude, phase, and/or frequency of the raw pulse CP&#x2032;<sub>l</sub>. The pulse operations circuitry <b>358</b> receives raw outbound pulses CP&#x2032;<sub>0</sub>-CP&#x2032;<sub>L-1 </sub>from pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>, control signals ops_cnfg<sub>0</sub>-ops_cnfg<sub>L-1 </sub>from pulse operations manager <b>356</b>, and ops_ctrl<sub>0</sub>-ops_ctrl<sub>L-1 </sub>from pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>.</p><p id="p-0051" num="0046">The control signal ops_cnfg<sub>l </sub>configures, at least in part, the pulse operations circuitry <b>358</b> such that each raw outbound pulse CP&#x2032;<sub>l </sub>that passes through the pulse operations circuitry <b>358</b> has performed on it one or more operation(s) tailored for that particular pulse. To illustrate, denoting a raw outbound pulse from pulser <b>302</b><sub>3 </sub>at time T<b>1</b> as CP&#x2032;<sub>3,T1</sub>, then, at time T<b>1</b> (or sometime before T<b>1</b> to allow for latency, circuit setup, etc.), the digital control signal ops_cnfg<sub>3 </sub>(denoted ops_cnfg<sub>3,T1 </sub>for purposes of this example) provides the information (e.g., in the form of one or more matrix, as described below) as to what specific operations are to be performed on pulse CP&#x2032;<sub>3,T1</sub>. Similarly, ops_cnfg<sub>4,T1 </sub>provides the information as to what specific operations are to be performed on pulse CP&#x2032;<sub>4,T1</sub>, and ops_cnfg<sub>3,T2 </sub>provides the information as to what specific operations are to be performed on pulse CP&#x2032;<sub>4,T1</sub>.</p><p id="p-0052" num="0047">The control signal ops_ctrl<sub>l </sub>provides another way for the pulser <b>302</b><sub>l </sub>to configure how any particular pulse is processed in the pulse operations circuitry <b>358</b>. This may enable the pulser <b>302</b><sub>l </sub>to, for example, provide information to the pulse operation circuitry <b>358</b> that does not need to pass through the pulse operation manager <b>356</b>. For example, the pulser <b>302</b><sub>l </sub>may send matrix values calculated in real-time by the pulser <b>302</b><sub>l </sub>to be used by the pulse operation circuitry <b>358</b> to modify pulse CP&#x2032;<sub>l</sub>. These matrix values arrive to the pulse operation circuitry <b>358</b> directly from the pulser <b>302</b><sub>l </sub>and do not need to be sent to the pulse operation manager first. Another example may be that the pulser <b>302</b><sub>l </sub>provides information to the pulse operation circuitry <b>358</b> to affect the operations themselves (e.g. the signal ops_ctrl<sub>l </sub>can choose among several different mathematical operations that can be performed on the pulse).</p><p id="p-0053" num="0048">The pulse operations manager <b>356</b> comprises circuitry operable to configure the pulse operations circuitry <b>358</b> such that the pulse operations applied to each raw outbound pulse CP&#x2032;<sub>l </sub>are tailored to that particular raw outbound pulse. To illustrate, denoting a first raw outbound pulse to be output during a first time interval T<b>1</b> as CP&#x2032;<sub>l,T1</sub>, and a second raw outbound pulse to be output during a second time interval T<b>2</b> as CP&#x2032;<sub>l,T2</sub>, then pulse operations circuitry <b>358</b> is operable to perform a first one or more operations on CP&#x2032;<sub>l,T1 </sub>and a second one or more operations on CP&#x2032;<sub>1,T2</sub>. The first one or more operations may be determined, at least in part, based on to which quantum element the pulse CP<sub>1,T1 </sub>is to be sent, and the second one or more operations may be determined, at least in part, based on to which quantum element the pulse CP<sub>1,T2 </sub>is to be sent. The determination of the first one or more operations and second one or more operations may be performed dynamically during runtime.</p><p id="p-0054" num="0049">The transmit analog frontend <b>362</b> comprises circuitry operable to concurrently process up to K digital signals DO<sub>k </sub>to generate up to K concurrent analog signals AO<sub>k </sub>to be output to the quantum processor <b>218</b>. Such processing may comprise, for example, digital-to-analog conversion, filtering, upconversion, downconversion, amplification, attenuation, time division multiplexing/demultiplexing, frequency division multiplexing/demultiplexing and/or the like. In an example implementation, each of the one or more of signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1 </sub>(<figref idref="DRAWINGS">FIG. <b>3</b>A</figref>) represents a respective portion of Tx analog frontend circuit <b>362</b> as well as a respective portion of interconnect <b>212</b> (<figref idref="DRAWINGS">FIG. <b>2</b></figref>) between the Tx analog frontend circuit <b>362</b> and the quantum processor <b>218</b>. Although there is one-to-one correspondence between the number of DO signals and the number of AO signals in the example implementation described here, such does not need to be the case. In another example implementation, the analog frontend <b>362</b> is operable to map more (or fewer) signals DO to fewer (or more) signals AO. In an example implementation the transmit analog frontend <b>362</b> is operable to process digital signals DO<sub>0</sub>-DO<sub>K-1 </sub>as K independent outbound pulses, as K/2 two-pulse pairs, or process some of signals DO<sub>0</sub>-DO<sub>K-1 </sub>as independent outbound pulses and some signals DO<sub>0</sub>-DO<sub>K-1 </sub>as two-pulse pairs (at different times and/or concurrently.</p><p id="p-0055" num="0050">The output manager <b>360</b> comprises circuitry operable to route any one or more of signals CP<sub>0</sub>-CP<sub>L-1 </sub>to any one or more of signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1</sub>. As just one possible example, signal path <b>313</b><sub>0 </sub>may comprise a first path through the analog frontend <b>362</b> (e.g., a first mixer and DAC) that outputs AO<sub>0 </sub>and traces/wires of interconnect <b>212</b> that carry signal AO<sub>0</sub>; signal path <b>313</b><sub>1 </sub>may comprise a second path through the analog frontend <b>362</b> (e.g., a second mixer and DAC) that outputs AO<sub>1 </sub>and traces/wires of interconnect <b>212</b> that carry signal AO<sub>1</sub>, and so on. In an example implementation, the output manager <b>360</b> comprises one or more switch networks, multiplexers, and/or the like for dynamically reconfiguring which one or more signals CP<sub>0</sub>-CP<sub>L-1 </sub>are routed to which signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1</sub>. This may enable time division multiplexing multiple of the signals CP<sub>0</sub>-CP<sub>L-1 </sub>onto a single signal path <b>313</b><sub>k </sub>and/or time division demultiplexing components (e.g., time slices) of a signal CP<sub>m </sub>onto multiple of the signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1</sub>. In an example implementation, the output manager <b>360</b> comprises one or more mixers and/or filters for frequency division multiplexing multiple of the signals CP<sub>0</sub>-CP<sub>M-1 </sub>onto a single signal path <b>313</b><sub>k </sub>and/or frequency division demultiplexing components (e.g., frequency bands) of a signal CP<sub>m </sub>onto multiple of the signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1</sub>. The signal routing and multiplexing/demultiplexing functions performed by the output manager <b>360</b> enables: routing outbound pulses from a particular pulser <b>302</b><sub>l </sub>to different ones of the signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1 </sub>at different times; routing outbound pulses from a particular pulser <b>302</b><sub>l </sub>to multiple of the signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1 </sub>at the same time; and multiple of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>generating pulses for the same signal path <b>313</b><sub>k </sub>at the same time. In the example implementation shown, routing of the signals CP<sub>0</sub>-CP<sub>L-1 </sub>among the signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1 </sub>is controlled by digital control signals out_slct<sub>0</sub>-out_slct<sub>L-1 </sub>from the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>. In another implementation, the output manager <b>360</b> may be operable to autonomously determine the appropriate routing (e.g., where the quantum algorithm description includes instructions to be loaded into memory of, and executed by, the output manager <b>360</b>). In an example implementation, at any given time, the output manager <b>360</b> is operable to concurrently route K of the digital signals CP<sub>0</sub>-CP<sub>L-1 </sub>as K independent outbound pulses, concurrently route K/2 of the digital signals CP<sub>0</sub>-CP<sub>L-1 </sub>as two-pulse pairs, or route some of signals CP<sub>0</sub>-CP<sub>L-1 </sub>as independent outbound pulses and some others of the signals CP<sub>0</sub>-CP<sub>L-1 </sub>as multi-pulse sets (at different times and/or concurrently).</p><p id="p-0056" num="0051">The digital manager <b>354</b> comprises circuitry operable to process and/or route digital control signals (DigCtrl<sub>0</sub>-DigCtrl<sub>J&#x2212;1</sub>) to various circuits of the quantum controller <b>210</b> and/or external circuits coupled to the quantum controller <b>210</b>. In the example implementation shown, the digital manager receives, from each pulser <b>302</b><sub>l</sub>, (e.g., via one or more of signal paths <b>304</b><sub>0</sub>-<b>304</b><sub>N-1</sub>) a digital signal Di that is to be processed and routed by the digital manager <b>354</b>, and a control signal D_port<sub>l </sub>that indicates to which output port(s) of the digital manager <b>354</b> the signal Di should be routed. The digital control signals may be routed to, for example, any one or more of circuits shown in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>, switches/gates which connect and disconnect the outputs AO<sub>0</sub>-AO<sub>K-1 </sub>from the quantum processor <b>218</b>, external circuits coupled to the quantum controller <b>210</b> such as microwave mixers and amplifiers, and/or any other circuitry which can benefit from on real-time information from the pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>. Each such destination of the digital signals may require different operations to be performed on the digital signal (such as delay, broadening, or digital convolution with a given digital pattern). These operations may be performed by the digital manager <b>354</b> and may be specified by control signals from the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>. This allows each pulser <b>302</b><sub>l </sub>to generate digital signals to different destinations and allows different ones of pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>to generate digital signals to the same destination while saving resources.</p><p id="p-0057" num="0052">The synchronization manager <b>366</b> comprises circuitry operable to manage synchronization of the various circuits shown in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>. Such synchronization is advantageous in a modular and dynamic system, such as quantum controller <b>210</b>, where different ones of pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>generate, receive, and process pulses to and from different quantum elements at different times. For example, while carrying out a quantum algorithm, a first pulser circuit <b>302</b><sub>1 </sub>and a second pulser circuit <b>302</b><sub>2 </sub>may sometimes need to transmit pulses at precisely the same time and at other times transmit pulses independently of one another. In the example implementation shown, the synchronization manager <b>366</b> reduces the overhead involved in performing such synchronization.</p><p id="p-0058" num="0053">The data exchange circuitry <b>364</b> is operable to manage exchange of data among the various circuits shown in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>. For example, while carrying out a quantum algorithm, a first pulser circuit <b>302</b><sub>1 </sub>and a second pulser circuit <b>302</b><sub>2 </sub>may sometimes need to exchange information. As just one example, pulser <b>302</b><sub>1 </sub>may need to share, with pulser <b>302</b><sub>2</sub>, the characteristics of an inbound signal AI<sub>1 </sub>that it just processed so that pulser <b>302</b><sub>2 </sub>can generate a raw outbound pulse CP&#x2032;<sub>2 </sub>based on the characteristics of AI<sub>1</sub>. The data exchange circuitry <b>364</b> may enable such information exchange. In an example implementation, the data exchange circuitry <b>364</b> may comprise one or more registers to and from which the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>can read and write.</p><p id="p-0059" num="0054">The I/O manager <b>368</b> is operable to route information between the quantum controller <b>210</b> and the quantum programming subsystem <b>202</b>. Machine code quantum algorithm descriptions may be received via the I/O manager <b>368</b>. Accordingly, the I/O manager <b>368</b> may comprise circuitry for loading the machine code into the necessary registers/memory (including any SRAM, DRAM, FPGA BRAM, flash memory, programmable read only memory, etc.) of the quantum controller <b>210</b> as well as for reading contents of the registers/memory of the quantum controller <b>210</b> and conveying the contents to the quantum programming subsystem <b>202</b>. The I/O manager <b>368</b> may, for example, include a PCIe controller, AXI controller/interconnect, and/or the like.</p><p id="p-0060" num="0055"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example implementation of the pulser of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>. The example pulser <b>302</b><sub>l </sub>shown comprises instruction memory <b>402</b>, pulse template memory <b>404</b>, digital pattern memory <b>406</b>, control circuitry <b>408</b>, and compute and/or signal processing circuitry (CSP) <b>410</b>.</p><p id="p-0061" num="0056">The memories <b>402</b>, <b>404</b>, <b>406</b> may comprise one or more be any type of suitable storage elements (e.g., DRAM, SRAM, Flash, etc.). The instructions stored in memory <b>402</b> are instructions to be executed out by the pulser <b>302</b><sub>l </sub>for carrying out its role in a quantum algorithm. Because different pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>have different roles to play in any particular quantum algorithm (e.g., generating different pulses at different times), the instructions memory <b>402</b> for each pulser <b>302</b><sub>l </sub>may be specific to that pulser. For example, the quantum algorithm description <b>206</b> from the quantum programming subsystem <b>202</b> may comprise a first set of instructions to be loaded (via I/O manager <b>368</b>) into pulser <b>302</b><sub>0</sub>, a second set of instructions to be loaded into pulser <b>302</b><sub>1</sub>, and so on. Each pulse template stored in memory <b>404</b> comprises a sequence of one or more samples of any arbitrary shape (e.g., Gaussian, sinc, impulse, etc.) representing the pulses to be sent to pulse operation circuitry <b>358</b>. Each digital pattern stored in memory <b>406</b> comprises a sequence of one or more binary values which may represent the digital pulses to be sent to the digital manager <b>354</b> for generating digital control signals DigCtrl<sub>0</sub>-DigCtrl<sub>J&#x2212;1</sub>.</p><p id="p-0062" num="0057">The control circuitry <b>408</b> is operable to execute the instructions stored in memory <b>402</b> to process inbound signal AI<sub>l</sub>, generate raw outbound pulses CP&#x2032;<sub>l</sub>, and generate digital control signals in_slct<sub>l</sub>, out_slct<sub>l</sub>, D_port<sub>l</sub>, D<sub>l</sub>, IF<sub>l</sub>, F<sub>l</sub>, ops_slct<sub>l</sub>, ops_ctrl<sub>l</sub>, results<sub>l</sub>, dmod_slct<sub>l </sub>and pair<sub>l</sub>. In the example implementation shown, the processing of the inbound signal AI<sub>l </sub>is performed by the CSP circuitry <b>410</b> and based (at least in part) on the signal f_dmod<sub>l</sub>.</p><p id="p-0063" num="0058">The compute and/or signal processing circuitry (CSP) <b>410</b> is operable to perform computational and/or signal processing functions, which may comprise, for example Boolean-algebra based logic and arithmetic functions and demodulation (e.g., of inbound signals AI<sub>l</sub>). The CSP <b>410</b> may comprise memory in which are stored instructions for performing the functions and demodulation. The instructions may be specific to a quantum algorithm to be performed and be generated during compilation of a quantum machine specification and QUA program.</p><p id="p-0064" num="0059">In operation of an example implementation, generation of a raw outbound pulse CP&#x2032;<sub>l </sub>comprises the control circuitry <b>408</b>: (1) determining a pulse template to retrieve from memory <b>404</b> (e.g., based on a result of computations and/or signal processing performed by the CSP <b>410</b>); (2) retrieving the pulse template; (3) performing some preliminary processing on the pulse template; (4) determining the values of F, IF, pair<sub>l</sub>, ops_slct<sub>l</sub>, and dmod_slct<sub>l </sub>to be sent to the pulse operation manager <b>356</b> (as predetermined in the quantum algorithm description and/or determined dynamically based on results of computations and/or signal processing performed by the CSP <b>410</b>); (5) determining the value of ops_ctrl<sub>l </sub>to be sent to the pulse operation circuitry <b>358</b>; (6) determining the value of in_slct<sub>l </sub>to be sent to the input manager <b>352</b>; (7) determining a digital pattern to retrieve from memory <b>406</b> (as predetermined in the quantum algorithm description and/or determined dynamically based on results of computations and/or signal processing performed by the CSP <b>410</b>); (8) outputting the digital pattern as Di to the digital manager along with control signal D_port<sub>l </sub>(as predetermined in the quantum algorithm description and/or determined dynamically based on results of computations and/or signal processing performed by the CSP <b>410</b>); (9) outputting the raw outbound pulse CP&#x2032;<sub>l </sub>to the pulse operations circuitry <b>358</b>; (10) outputting results<sub>l </sub>to the I/O manager.</p><p id="p-0065" num="0060"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows an example implementation of the pulse operations manager and pulse operations circuitry of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>. The pulse operations circuitry <b>358</b> comprises a plurality of pulse modification circuits <b>508</b><sub>0</sub>-<b>508</b><sub>R-1 </sub>(R is an integer &#x2265;1 in general, and R=L/2 in the example shown). The pulse operations manager <b>356</b> comprises control circuitry <b>502</b>, routing circuitry <b>506</b>, and a plurality of modification settings circuits <b>504</b><sub>0</sub>-<b>504</b><sub>K-1</sub>.</p><p id="p-0066" num="0061">Although the example implementation has a 1-to-2 correspondence between pulse modification circuits <b>508</b><sub>0</sub>-<b>508</b><sub>R-1 </sub>and pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>, such does not need to be the case. In other implementations there may be fewer pulse modification circuits <b>508</b> than pulser circuits <b>302</b>. Similarly, other implementations may comprise more pulse modification circuits <b>508</b> than pulser circuits <b>302</b>.</p><p id="p-0067" num="0062">As an example, in some instances, two of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>may generate two raw outbound pulses which are a phase-quadrature pulse pair. For example, assuming CP<sub>1 </sub>and CP<sub>2 </sub>are a phase-quadrature pulse pair to be output on path <b>313</b><sub>3</sub>. In this example, pulse operations circuitry <b>358</b> may process CP<sub>1 </sub>and CP<sub>2 </sub>by multiplying a vector representation of CP&#x2032;<sub>1 </sub>and CP&#x2032;<sub>2 </sub>by one or more 2 by 2 matrices to: (1) perform single-sideband-modulation, as given by</p><p id="p-0068" num="0000"><maths id="MATH-US-00003" num="00003"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mrow>       <mo>(</mo>       <mtable>        <mtr>         <mtd>          <mrow>           <mi>C</mi>           <mo>&#x2062;</mo>           <msub>            <mi>P</mi>            <mn>1</mn>           </msub>          </mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>C</mi>           <mo>&#x2062;</mo>           <msub>            <mi>P</mi>            <mn>2</mn>           </msub>          </mrow>         </mtd>        </mtr>       </mtable>       <mo>)</mo>      </mrow>      <mo>=</mo>      <mrow>       <mrow>        <mo>(</mo>        <mtable>         <mtr>          <mtd>           <mrow>            <mi>cos</mi>            <mo>&#x2062;</mo>            <mrow>             <mo>(</mo>             <mrow>              <mi>&#x3c9;</mi>              <mo>*</mo>              <mi>TS</mi>              <mo>*</mo>              <msub>               <mi>T</mi>               <mrow>                <mi>clck</mi>                <mo>&#x2062;</mo>                <mn>1</mn>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>           </mrow>          </mtd>          <mtd>           <mrow>            <mrow>             <mo>-</mo>             <mi>sin</mi>            </mrow>            <mo>&#x2062;</mo>            <mrow>             <mo>(</mo>             <mrow>              <mi>&#x3c9;</mi>              <mo>*</mo>              <mi>TS</mi>              <mo>*</mo>              <msub>               <mi>T</mi>               <mrow>                <mi>c</mi>                <mo>&#x2062;</mo>                <mi>l</mi>                <mo>&#x2062;</mo>                <mi>c</mi>                <mo>&#x2062;</mo>                <mi>k</mi>                <mo>&#x2062;</mo>                <mn>1</mn>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>           </mrow>          </mtd>         </mtr>         <mtr>          <mtd>           <mrow>            <mi>sin</mi>            <mo>&#x2062;</mo>            <mrow>             <mo>(</mo>             <mrow>              <mi>&#x3c9;</mi>              <mo>*</mo>              <mi>TS</mi>              <mo>*</mo>              <msub>               <mi>T</mi>               <mrow>                <mi>c</mi>                <mo>&#x2062;</mo>                <mi>l</mi>                <mo>&#x2062;</mo>                <mi>c</mi>                <mo>&#x2062;</mo>                <mi>k</mi>                <mo>&#x2062;</mo>                <mn>1</mn>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>           </mrow>          </mtd>          <mtd>           <mrow>            <mi>cos</mi>            <mo>&#x2062;</mo>            <mrow>             <mo>(</mo>             <mrow>              <mi>&#x3c9;</mi>              <mo>*</mo>              <mi>TS</mi>              <mo>*</mo>              <msub>               <mi>T</mi>               <mrow>                <mi>c</mi>                <mo>&#x2062;</mo>                <mi>l</mi>                <mo>&#x2062;</mo>                <mi>c</mi>                <mo>&#x2062;</mo>                <mi>k</mi>                <mo>&#x2062;</mo>                <mn>1</mn>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>           </mrow>          </mtd>         </mtr>        </mtable>        <mo>)</mo>       </mrow>       <mo>&#x2062;</mo>       <mrow>        <mo>(</mo>        <mtable>         <mtr>          <mtd>           <msubsup>            <mi>CP</mi>            <mn>1</mn>            <mo>&#x2032;</mo>           </msubsup>          </mtd>         </mtr>         <mtr>          <mtd>           <msubsup>            <mi>CP</mi>            <mn>2</mn>            <mo>&#x2032;</mo>           </msubsup>          </mtd>         </mtr>        </mtable>        <mo>)</mo>       </mrow>      </mrow>     </mrow>     <mo>,</mo>    </mrow>   </mtd>   <mtd>    <mtext> </mtext>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0069" num="0000">where &#x3c9; is the frequency of the single side band modulation and TS is the time passed since the reference time (e.g. the beginning of a certain control protocol); (2) keep track of frame-of-reference rotations, as given by</p><p id="p-0070" num="0000"><maths id="MATH-US-00004" num="00004"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mo>(</mo>    <mtable>     <mtr>      <mtd>       <mrow>        <mi>C</mi>        <mo>&#x2062;</mo>        <msub>         <mi>P</mi>         <mn>1</mn>        </msub>       </mrow>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <mi>C</mi>        <mo>&#x2062;</mo>        <msub>         <mi>P</mi>         <mn>2</mn>        </msub>       </mrow>      </mtd>     </mtr>    </mtable>    <mo>)</mo>   </mrow>   <mo>=</mo>   <mrow>    <mrow>     <mo>(</mo>     <mtable>      <mtr>       <mtd>        <mrow>         <mi>cos</mi>         <mo>&#x2062;</mo>         <mrow>          <mo>(</mo>          <mi>&#x3d5;</mi>          <mo>)</mo>         </mrow>        </mrow>       </mtd>       <mtd>        <mrow>         <mrow>          <mo>-</mo>          <mi>sin</mi>         </mrow>         <mo>&#x2062;</mo>         <mrow>          <mo>(</mo>          <mi>&#x3b2;</mi>          <mo>)</mo>         </mrow>        </mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mrow>         <mi>sin</mi>         <mo>&#x2062;</mo>         <mrow>          <mo>(</mo>          <mi>&#x3d5;</mi>          <mo>)</mo>         </mrow>        </mrow>       </mtd>       <mtd>        <mrow>         <mi>cos</mi>         <mo>&#x2062;</mo>         <mrow>          <mo>(</mo>          <mi>&#x3d5;</mi>          <mo>)</mo>         </mrow>        </mrow>       </mtd>      </mtr>     </mtable>     <mo>)</mo>    </mrow>    <mo>&#x2062;</mo>    <mrow>     <mo>(</mo>     <mtable>      <mtr>       <mtd>        <msubsup>         <mi>CP</mi>         <mn>1</mn>         <mo>&#x2032;</mo>        </msubsup>       </mtd>      </mtr>      <mtr>       <mtd>        <msubsup>         <mi>CP</mi>         <mn>2</mn>         <mo>&#x2032;</mo>        </msubsup>       </mtd>      </mtr>     </mtable>     <mo>)</mo>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0071" num="0000">where &#x3d5; is the total phase that the frame of reference accumulated since the reference time; and/or (3) perform an IQ-mixer correction</p><p id="p-0072" num="0000"><maths id="MATH-US-00005" num="00005"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mrow>       <mo>(</mo>       <mtable>        <mtr>         <mtd>          <mrow>           <mi>C</mi>           <mo>&#x2062;</mo>           <msub>            <mi>P</mi>            <mn>1</mn>           </msub>          </mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>C</mi>           <mo>&#x2062;</mo>           <msub>            <mi>P</mi>            <mn>2</mn>           </msub>          </mrow>         </mtd>        </mtr>       </mtable>       <mo>)</mo>      </mrow>      <mo>=</mo>      <mrow>       <mrow>        <mo>(</mo>        <mtable>         <mtr>          <mtd>           <msub>            <mi>C</mi>            <mrow>             <mn>0</mn>             <mo>&#x2062;</mo>             <mn>0</mn>            </mrow>           </msub>          </mtd>          <mtd>           <msub>            <mi>C</mi>            <mrow>             <mn>0</mn>             <mo>&#x2062;</mo>             <mn>1</mn>            </mrow>           </msub>          </mtd>         </mtr>         <mtr>          <mtd>           <msub>            <mi>C</mi>            <mrow>             <mn>1</mn>             <mo>&#x2062;</mo>             <mn>0</mn>            </mrow>           </msub>          </mtd>          <mtd>           <msub>            <mi>C</mi>            <mrow>             <mn>1</mn>             <mo>&#x2062;</mo>             <mn>1</mn>            </mrow>           </msub>          </mtd>         </mtr>        </mtable>        <mo>)</mo>       </mrow>       <mo>&#x2062;</mo>       <mrow>        <mo>(</mo>        <mtable>         <mtr>          <mtd>           <msubsup>            <mi>CP</mi>            <mn>1</mn>            <mo>&#x2032;</mo>           </msubsup>          </mtd>         </mtr>         <mtr>          <mtd>           <msubsup>            <mi>CP</mi>            <mn>2</mn>            <mo>&#x2032;</mo>           </msubsup>          </mtd>         </mtr>        </mtable>        <mo>)</mo>       </mrow>      </mrow>     </mrow>     <mo>,</mo>    </mrow>   </mtd>   <mtd>    <mtext> </mtext>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0073" num="0000">where C<sub>00</sub>, C<sub>01</sub>, C<sub>10</sub>, and C<sub>11 </sub>are the elements of a matrix that corrects for IQ-mixer imperfections. In an example implementation, each modification settings circuit, <b>504</b><sub>k</sub>, contains registers that contain the matrix elements of three matrices:</p><p id="p-0074" num="0000"><maths id="MATH-US-00006" num="00006"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>C</mi>    <mi>k</mi>   </msub>   <mo>=</mo>   <mrow>    <mo>(</mo>    <mtable>     <mtr>      <mtd>       <msub>        <mi>C</mi>        <mrow>         <mi>k</mi>         <mo>&#x2062;</mo>         <mn>0</mn>         <mo>&#x2062;</mo>         <mn>0</mn>        </mrow>       </msub>      </mtd>      <mtd>       <msub>        <mi>C</mi>        <mrow>         <mi>k</mi>         <mo>&#x2062;</mo>         <mn>01</mn>        </mrow>       </msub>      </mtd>     </mtr>     <mtr>      <mtd>       <msub>        <mi>C</mi>        <mrow>         <mi>k</mi>         <mo>&#x2062;</mo>         <mn>1</mn>         <mo>&#x2062;</mo>         <mn>0</mn>        </mrow>       </msub>      </mtd>      <mtd>       <msub>        <mi>C</mi>        <mrow>         <mi>k</mi>         <mo>&#x2062;</mo>         <mn>1</mn>         <mo>&#x2062;</mo>         <mn>1</mn>        </mrow>       </msub>      </mtd>     </mtr>    </mtable>    <mo>)</mo>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0075" num="0000">an IQ-mixer correction matrix;</p><p id="p-0076" num="0000"><maths id="MATH-US-00007" num="00007"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>S</mi>    <mi>k</mi>   </msub>   <mo>=</mo>   <mrow>    <mo>(</mo>    <mtable>     <mtr>      <mtd>       <mrow>        <mi>cos</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <msub>           <mi>&#x3c9;</mi>           <mi>k</mi>          </msub>          <mo>*</mo>          <mi>T</mi>          <mo>&#x2062;</mo>          <mi>S</mi>          <mo>*</mo>          <msub>           <mi>T</mi>           <mrow>            <mi>c</mi>            <mo>&#x2062;</mo>            <mi>l</mi>            <mo>&#x2062;</mo>            <mi>c</mi>            <mo>&#x2062;</mo>            <mi>k</mi>            <mo>&#x2062;</mo>            <mn>1</mn>           </mrow>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mtd>      <mtd>       <mrow>        <mrow>         <mo>-</mo>         <mi>sin</mi>        </mrow>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <msub>           <mi>&#x3c9;</mi>           <mi>k</mi>          </msub>          <mo>*</mo>          <mi>T</mi>          <mo>&#x2062;</mo>          <mi>S</mi>         </mrow>         <mo>)</mo>        </mrow>        <mo>*</mo>        <msub>         <mi>T</mi>         <mrow>          <mi>c</mi>          <mo>&#x2062;</mo>          <mi>l</mi>          <mo>&#x2062;</mo>          <mi>c</mi>          <mo>&#x2062;</mo>          <mi>k</mi>          <mo>&#x2062;</mo>          <mn>1</mn>         </mrow>        </msub>       </mrow>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <mi>sin</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <msub>           <mi>&#x3c9;</mi>           <mi>k</mi>          </msub>          <mo>*</mo>          <mi>T</mi>          <mo>&#x2062;</mo>          <mi>S</mi>          <mo>*</mo>          <msub>           <mi>T</mi>           <mrow>            <mi>c</mi>            <mo>&#x2062;</mo>            <mi>l</mi>            <mo>&#x2062;</mo>            <mi>c</mi>            <mo>&#x2062;</mo>            <mi>k</mi>            <mo>&#x2062;</mo>            <mn>1</mn>           </mrow>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mtd>      <mtd>       <mrow>        <mi>cos</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <msub>           <mi>&#x3c9;</mi>           <mi>k</mi>          </msub>          <mo>*</mo>          <mi>T</mi>          <mo>&#x2062;</mo>          <mi>S</mi>          <mo>*</mo>          <msub>           <mi>T</mi>           <mrow>            <mi>c</mi>            <mo>&#x2062;</mo>            <mi>l</mi>            <mo>&#x2062;</mo>            <mi>c</mi>            <mo>&#x2062;</mo>            <mi>k</mi>            <mo>&#x2062;</mo>            <mi>l</mi>           </mrow>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mtd>     </mtr>    </mtable>    <mo>)</mo>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0077" num="0000">a single side band frequency modulation matrix; and</p><p id="p-0078" num="0000"><maths id="MATH-US-00008" num="00008"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>F</mi>    <mi>k</mi>   </msub>   <mo>=</mo>   <mrow>    <mo>(</mo>    <mtable>     <mtr>      <mtd>       <mrow>        <mi>cos</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <msub>          <mi>&#x3d5;</mi>          <mi>k</mi>         </msub>         <mo>)</mo>        </mrow>       </mrow>      </mtd>      <mtd>       <mrow>        <mrow>         <mo>-</mo>         <mi>sin</mi>        </mrow>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <msub>          <mi>&#x3d5;</mi>          <mi>k</mi>         </msub>         <mo>)</mo>        </mrow>       </mrow>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <mi>sin</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <msub>          <mi>&#x3d5;</mi>          <mi>k</mi>         </msub>         <mo>)</mo>        </mrow>       </mrow>      </mtd>      <mtd>       <mrow>        <mi>cos</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <msub>          <mi>&#x3d5;</mi>          <mi>k</mi>         </msub>         <mo>)</mo>        </mrow>       </mrow>      </mtd>     </mtr>    </mtable>    <mo>)</mo>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0079" num="0000">a frame rotation matrix, which rotates the IQ axes around the axis perpendicular to the IQ plane (i.e. the z-axis if I and Q are the x-axis and y-axis). In an example implementation, each modification settings circuit <b>504</b><sub>k </sub>also contains registers that contain the elements of the matrix products C<sub>k</sub>S<sub>k</sub>F<sub>k </sub>and S<sub>k</sub>F<sub>k</sub>.</p><p id="p-0080" num="0063">In the example shown, each pulse modification circuit <b>508</b><sub>r </sub>is operable to process two raw outbound pulses CP&#x2032;<sub>2r </sub>and CP&#x2032;<sub>2r+1 </sub>according to: the modification settings ops_cnfg<sub>2r </sub>and ops_cnfg<sub>2r+1</sub>; the signals ops_ctrl<sub>2r </sub>and ops_ctrl<sub>2r+1</sub>; and the signals pair<sub>2r </sub>and pair<sub>2r+1</sub>. In an example implementation pair<sub>2r </sub>and pair<sub>2r+1 </sub>may be communicated as ops_ctrl<sub>2r </sub>and ops_ctrl<sub>2r+1</sub>. The result of the processing is outbound pulses CP<sub>2r </sub>and CP<sub>2r+1</sub>. Such processing may comprise adjusting a phase, frequency, and/or amplitude of the raw outbound pulses CP&#x2032;<sub>2r </sub>and CP&#x2032;<sub>2r+1</sub>. In an example implementation, ops_cnfg<sub>2r </sub>and ops_cnfg<sub>2r+1 </sub>are in the form of a matrix comprising real and/or complex numbers and the processing comprises matrix multiplication involving a matrix representation of the raw outbound pulses CP<sub>2r </sub>and CP<sub>2r+1 </sub>and the ops_cnfg<sub>2r </sub>and ops_cnfg<sub>2r+1 </sub>matrix.</p><p id="p-0081" num="0064">The control circuitry <b>502</b> is operable to exchange information with the pulser circuits <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>to generate values of ops_confg<sub>0</sub>-ops_confg<sub>L-1 </sub>and f_demod<sub>0</sub>-f_demod<sub>L-1</sub>, to control routing circuitry <b>506</b> based on signals ops_slct<sub>0</sub>-ops_slct<sub>L-1 </sub>and dmod_slct<sub>0</sub>-dmod_slct<sub>L-1</sub>, and to update pulse modification settings <b>504</b><sub>0</sub>-<b>504</b><sub>K-1 </sub>based on IF<sub>0</sub>-IF<sub>L-1 </sub>and F<sub>0</sub>-F<sub>L-1 </sub>such that pulse modification settings output to pulse operations circuitry <b>358</b> are specifically tailored to each raw outbound pulse (e.g., to which quantum element <b>222</b> the pulse is destined, to which signal path <b>313</b> the pulse is destined, etc.) to be processed by pulse operations circuitry <b>358</b>.</p><p id="p-0082" num="0065">Each modification settings circuit <b>504</b><sub>k </sub>comprises circuitry operable to store modification settings for later retrieval and communication to the pulse operations circuitry <b>358</b>. The modification settings stored in each modification settings circuit <b>504</b><sub>k </sub>may be in the form of one or more two-dimensional complex-valued matrices. Each signal path <b>313</b><sub>0</sub>-<b>313</b><sub>K-1 </sub>may have particular characteristics (e.g., non-idealities of interconnect, mixers, switches, attenuators, amplifiers, and/or circuits along the paths) to be accounted for by the pulse modification operations. Similarly, each quantum element <b>122</b><sub>0</sub>-<b>122</b><sub>k </sub>may have a particular characteristics (e.g. resonance frequency, frame of reference, etc.). In an example implementation, the number of pulse modification settings, K, stored in the circuits <b>504</b> corresponds to the number of quantum element <b>122</b><sub>0</sub>-<b>122</b><sub>K-1 </sub>and of signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1 </sub>such that each of the modification settings circuits <b>504</b><sub>0</sub>-<b>504</b><sub>K-1 </sub>stores modification settings for a respective one of the quantum elements <b>122</b><sub>0</sub>-<b>122</b><sub>K-1 </sub>and/or paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1</sub>. In other implementations, there may be more or fewer pulse modification circuits <b>504</b> than signal paths <b>313</b> and more or fewer pulse modification circuits <b>504</b> than quantum elements <b>122</b> and more or fewer signal paths <b>313</b> than quantum elements <b>122</b>. The control circuitry <b>502</b> may load values into the modification settings circuit <b>504</b><sub>0</sub>-<b>504</b><sub>K-1 </sub>via signal <b>503</b>.</p><p id="p-0083" num="0066">The routing circuitry <b>506</b> is operable to route modification settings from the modification settings circuits <b>504</b><sub>0</sub>-<b>504</b><sub>L-1 </sub>to the pulse operations circuit <b>358</b> (as ops_confg<sub>0</sub>-ops_confg<sub>L-1</sub>) and to the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>(as f_dmod<sub>0</sub>-f_dmod<sub>L-1</sub>). In the example implementation shown, which of the modification settings circuits <b>504</b><sub>0</sub>-<b>504</b><sub>K-1 </sub>has its/their contents sent to which of the pulse modification circuits <b>508</b><sub>0</sub>-<b>508</b><sub>R-1 </sub>and to which of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>is controlled by the signal <b>505</b> from the control circuitry <b>502</b>.</p><p id="p-0084" num="0067">The signal ops_slct<sub>l </sub>informs the pulse operations manager <b>356</b> as to which modification settings <b>504</b><sub>k </sub>to send to the pulse modification circuit <b>5081</b>. The pulser <b>302</b><sub>l </sub>may determine ops_slct<sub>l </sub>based on the particular quantum element <b>122</b><sub>k </sub>and/or signal path <b>313</b><sub>k </sub>to which the pulse is to be transmitted (e.g., the resonant frequency of the quantum element, frame of reference, and/or mixer correction). The determination of which quantum element and/or signal path to which a particular pulser <b>302</b><sub>l </sub>is to send an outbound pulse at a particular time may be predetermined in the quantum algorithm description or may be determined based on calculations performed by the pulser <b>302</b><sub>l </sub>and/or others of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>during runtime. The control circuitry <b>502</b> may then use this information to configure the routing block <b>506</b> such that the correct modification settings are routed to the correct one or more of the pulse modification circuits <b>508</b><sub>0</sub>-<b>508</b><sub>L-1</sub>.</p><p id="p-0085" num="0068">In an example implementation, the digital signal IF<sub>l </sub>instructs the pulse operations manager <b>356</b> to update a frequency setting of the modification settings circuit <b>504</b><sub>k </sub>indicated by ops_slct<sub>l</sub>. In an example implementation, the frequency setting is the matrix S<sub>k </sub>(described above) and the signal IF<sub>l </sub>carries new values indicating the new &#x3c9;<sub>k </sub>to be used in the elements of the matrix S<sub>k</sub>. The new values may, for example, be determined during a calibration routine (e.g., performed as an initial portion of the quantum algorithm) in which one or more of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>sends a series of outbound pulses CP, each at a different carrier frequency, and then measures the corresponding inbound signals AI.</p><p id="p-0086" num="0069">In an example implementation, the signal F<sub>1 </sub>instructs the pulse operations manager <b>356</b> to update a frame setting of the modification settings circuit <b>504</b><sub>k </sub>indicated by ops_slct<sub>l</sub>. In an example implementation, the frame setting is the matrix F<sub>k </sub>(described above) and the signal F<sub>l </sub>carries a rotation matrix F<sub>l </sub>which multiplies with F<sub>k </sub>to rotate F<sub>k</sub>. This can be written as</p><p id="p-0087" num="0000"><maths id="MATH-US-00009" num="00009"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>F</mi>    <mi>k</mi>   </msub>   <mo>=</mo>   <mrow>    <mrow>     <msub>      <mi>F</mi>      <mn>1</mn>     </msub>     <mo>&#x2062;</mo>     <msub>      <mi>F</mi>      <mi>k</mi>     </msub>    </mrow>    <mo>=</mo>    <mrow>     <mrow>      <mrow>       <mo>(</mo>       <mtable>        <mtr>         <mtd>          <mrow>           <mi>cos</mi>           <mo>&#x2062;</mo>           <mrow>            <mo>(</mo>            <mi>&#x394;&#x3d5;</mi>            <mo>)</mo>           </mrow>          </mrow>         </mtd>         <mtd>          <mrow>           <mrow>            <mo>-</mo>            <mi>sin</mi>           </mrow>           <mo>&#x2062;</mo>           <mrow>            <mo>(</mo>            <mi>&#x394;&#x3d5;</mi>            <mo>)</mo>           </mrow>          </mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>sin</mi>           <mo>&#x2062;</mo>           <mrow>            <mo>(</mo>            <mi>&#x394;&#x3d5;</mi>            <mo>)</mo>           </mrow>          </mrow>         </mtd>         <mtd>          <mrow>           <mi>cos</mi>           <mo>&#x2062;</mo>           <mrow>            <mo>(</mo>            <mi>&#x394;&#x3d5;</mi>            <mo>)</mo>           </mrow>          </mrow>         </mtd>        </mtr>       </mtable>       <mo>)</mo>      </mrow>      <mo>&#x2062;</mo>      <mrow>       <mo>(</mo>       <mtable>        <mtr>         <mtd>          <mrow>           <mi>cos</mi>           <mo>&#x2062;</mo>           <mrow>            <mo>(</mo>            <msub>             <mi>&#x3d5;</mi>             <mi>k</mi>            </msub>            <mo>)</mo>           </mrow>          </mrow>         </mtd>         <mtd>          <mrow>           <mrow>            <mo>-</mo>            <mi>sin</mi>           </mrow>           <mo>&#x2062;</mo>           <mrow>            <mo>(</mo>            <msub>             <mi>&#x3d5;</mi>             <mi>k</mi>            </msub>            <mo>)</mo>           </mrow>          </mrow>         </mtd>        </mtr>        <mtr>         <mtd>          <mrow>           <mi>sin</mi>           <mo>&#x2062;</mo>           <mrow>            <mo>(</mo>            <msub>             <mi>&#x3d5;</mi>             <mi>k</mi>            </msub>            <mo>)</mo>           </mrow>          </mrow>         </mtd>         <mtd>          <mrow>           <mi>cos</mi>           <mo>&#x2062;</mo>           <mrow>            <mo>(</mo>            <msub>             <mi>&#x3d5;</mi>             <mi>k</mi>            </msub>            <mo>)</mo>           </mrow>          </mrow>         </mtd>        </mtr>       </mtable>       <mo>)</mo>      </mrow>     </mrow>     <mo>=</mo>     <mrow>      <mo>(</mo>      <mtable>       <mtr>        <mtd>         <mrow>          <mi>cos</mi>          <mo>&#x2062;</mo>          <mrow>           <mo>(</mo>           <mrow>            <msub>             <mi>&#x3d5;</mi>             <mi>k</mi>            </msub>            <mo>+</mo>            <mrow>             <mi>&#x394;</mi>             <mo>&#x2062;</mo>             <mi>t</mi>             <mo>&#x2062;</mo>             <mi>&#x3b2;</mi>            </mrow>           </mrow>           <mo>)</mo>          </mrow>         </mrow>        </mtd>        <mtd>         <mrow>          <mrow>           <mo>-</mo>           <mi>sin</mi>          </mrow>          <mo>&#x2062;</mo>          <mrow>           <mo>(</mo>           <mrow>            <msub>             <mi>&#x3d5;</mi>             <mi>k</mi>            </msub>            <mo>+</mo>            <mrow>             <mi>&#x394;</mi>             <mo>&#x2062;</mo>             <mi>&#x3d5;</mi>            </mrow>           </mrow>           <mo>)</mo>          </mrow>         </mrow>        </mtd>       </mtr>       <mtr>        <mtd>         <mrow>          <mi>sin</mi>          <mo>&#x2062;</mo>          <mrow>           <mo>(</mo>           <mrow>            <msub>             <mi>&#x3d5;</mi>             <mi>k</mi>            </msub>            <mo>+</mo>            <mrow>             <mi>&#x394;</mi>             <mo>&#x2062;</mo>             <mi>&#x3d5;</mi>            </mrow>           </mrow>           <mo>)</mo>          </mrow>         </mrow>        </mtd>        <mtd>         <mrow>          <mi>cos</mi>          <mo>&#x2062;</mo>          <mrow>           <mo>(</mo>           <mrow>            <msub>             <mi>&#x3d5;</mi>             <mi>k</mi>            </msub>            <mo>+</mo>            <mrow>             <mi>&#x394;</mi>             <mo>&#x2062;</mo>             <mi>&#x3d5;</mi>            </mrow>           </mrow>           <mo>)</mo>          </mrow>         </mrow>        </mtd>       </mtr>      </mtable>      <mo>)</mo>     </mrow>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0088" num="0000">where &#x3d5;<sub>k </sub>is the frame of reference before the rotation and &#x394;&#x3d5; is the amount by which to rotate the frame of reference. The pulser <b>302</b><sub>l </sub>may determine &#x394;&#x3d5; based on a predetermined algorithm or based on calculations performed by the pulsers <b>302</b><sub>l </sub>and/or others of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>during runtime.</p><p id="p-0089" num="0070">In an example implementation, the signal dmod_sclt<sub>l </sub>informs the pulse operations manager <b>356</b> from which of the modification settings circuits <b>504</b><sub>k </sub>to retrieve values to be sent to pulser <b>302</b><sub>l </sub>as f_dmod<sub>l</sub>. The pulser <b>302</b><sub>l </sub>may determine dmod_slct<sub>l </sub>based on the particular quantum element <b>122</b><sub>k </sub>and/or signal path <b>315</b><sub>k </sub>from which the pulse to be processed arrived. The determination of from which quantum element and/or signal path a particular pulser <b>302</b><sub>l </sub>is to process an inbound pulse at a particular time may be predetermined in the quantum algorithm description or may be determined based on calculations performed by the pulser <b>302</b><sub>l </sub>and/or others of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>during runtime. The control circuitry <b>502</b> may then use this information to configure the routing block <b>506</b> such that the correct modification settings are routed to the correct one of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>. For example, when pulse generation circuit <b>302</b><sub>l </sub>needs to demodulate a pulse signal AI<sub>l </sub>from quantum element <b>122</b><sub>k</sub>, it will send a dmod_sclt<sub>l </sub>signal instructing the pulse operation manager <b>356</b> to rout the element SF<sub>k00</sub>=cos(&#x3c9;<sub>k</sub>*time_stamp+&#x3d5;<sub>k</sub>) from modification settings circuit <b>504</b><sub>k </sub>to pulser <b>302</b><sub>l </sub>(as f_dmod<sub>l</sub>).</p><p id="p-0090" num="0071">In the example implementation shown, the digital signals C<sub>0</sub>-C<sub>K-1 </sub>provide information about signal-path-specific modification settings to be used for each of the signal paths <b>313</b><sub>0</sub>-<b>313</b><sub>K-1</sub>. For example, each signal C<sub>k </sub>may comprise a matrix to be multiplied by a matrix representation of a raw outbound pulse CP&#x2032;<sub>l </sub>such that the resulting output outbound pulse is pre-compensated for errors (e.g., resulting from imperfections in mixers, amplifiers, wiring, etc.) introduced as the outbound pulse propagates along signal path <b>313</b><sub>k</sub>. The result of the pre-compensation is that output outbound pulse CP<sub>l </sub>will have the proper characteristics upon arriving at the quantum processor <b>218</b>. The signals C<sub>0</sub>-C<sub>K-1 </sub>may, for example, be calculated by the quantum controller <b>210</b> itself, by the programming subsystem <b>202</b>, and/or by external calibration equipment and provided via I/O manager <b>368</b>. The calculation of signals may be done as part of a calibration routine which may be performed before a quantum algorithm and/or may be determined/adapted in real-time as part of a quantum algorithm (e.g., to compensate for temperature changes during the quantum algorithm).</p><p id="p-0091" num="0072"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> shows frequency generation circuitry of the quantum controller of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>. In the example implementation shown, the frequency generation circuitry is part of control circuitry <b>502</b> of pulse operations manager circuitry <b>356</b>. The frequency generation circuitry comprises K coordinate rotation digital computer (CORDIC) circuits <b>602</b><sub>0</sub>-<b>602</b><sub>K-1</sub>, phase generation circuitry <b>604</b>, timestamp register <b>606</b>, and S-Matrix generation circuitry <b>608</b>.</p><p id="p-0092" num="0073">Each CORDIC circuit <b>602</b><sub>k </sub>is operable to compute cosine and sine of its input, &#x3b8;<sub>k</sub>, thus generating two signals cos(&#x3b8;<sub>k</sub>) and sin(&#x3b8;<sub>k</sub>).</p><p id="p-0093" num="0074">The phase generation circuitry <b>604</b> is operable to generate the CORDIC input parameters &#x3b8;<sub>0</sub>-&#x3b8;<sub>k-1 </sub>based on: (1) the frequency setting signals IF<sub>0</sub>-IF<sub>L-1 </sub>from the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1</sub>; and (2) the contents, TS, of the timestamp register <b>606</b>.</p><p id="p-0094" num="0075">The timestamp register <b>606</b> comprises circuitry (e.g., a counter incremented on each cycle of the clock signal clk1) operable to track the number of cycles of clk1 since a reference point in time (e.g., power up of the quantum controller <b>210</b>, start of execution of set of instructions of a quantum algorithm by the quantum controller <b>210</b>, etc.).</p><p id="p-0095" num="0076">In the example shown, the phase generation circuitry <b>604</b> sets &#x3b8;<sub>0</sub>=2&#x3c0;f<sub>0</sub>(TS)(dt<sub>clk1</sub>), where f<sub>0 </sub>is a frequency determined from the signal IF<sub>0</sub>, TS is the number of clock cycles counted from the reference point and dt<sub>clk1 </sub>is the duration of a single clock cycle of clk1. This leads to the CORDIC outputs being a pair of phase-quadrature reference signals, cos(2&#x3c0;f<sub>0</sub>(TS)(dt<sub>clk1</sub>)) and sin(2&#x3c0;f<sub>0</sub>(TS)(dt<sub>clk1</sub>)), as in the example shown, which are used to generate the S<sub>0 </sub>rotation matrix that rotates at a frequency f<sub>0</sub>.</p><p id="p-0096" num="0077">As shown in <figref idref="DRAWINGS">FIG. <b>6</b>B</figref>, the signal IF<sub>l </sub>may comprise an update component and an f<sub>l </sub>component. In an example implementation, when update, is asserted then the phase generation circuitry updates one of more of f<sub>0</sub>-f<sub>K-1 </sub>to be the value of f<sub>l</sub>.</p><p id="p-0097" num="0078">The S-matrix generation circuitry <b>608</b> is operable to build the matrices S<sub>0</sub>-S<sub>K-1 </sub>from the outputs of the CORDIC circuits <b>602</b><sub>0</sub>-<b>602</b><sub>K-1</sub>. In an example implementation, the S-matrix generation circuit <b>606</b> is operable to synchronize changes to the S matrices such that any matrix update occurs on a desired cycle of clock clk1 (which may be determined by the control information IF<sub>0</sub>-IF<sub>L-1</sub>).</p><p id="p-0098" num="0079">With K CORDIC circuits <b>602</b><sub>k</sub>, the frequency generation circuitry is operable to concurrently generate K S-matrices. In instances that more than K frequencies are needed over the course of a set of instructions, the phase generation circuit <b>604</b> is operable to change the input parameter &#x3b8;<sub>k </sub>of one or more of the CORDIC circuits <b>602</b><sub>0</sub>-<b>602</b><sub>K-1 </sub>to stop generating one frequency and start generating the K+1th frequency. In some instances, it may be necessary for the new frequency to start at a phase &#x3b8; that would have been the phase if the new frequency was being generated from the initial reference time (e.g., because the new frequency would be used to address a quantum element that has a resonance at the new frequency and that was coherent since the reference point). In some other instances, it might be necessary to start the new frequency from the phase that the old frequency ended in. The phase generation circuit <b>604</b> and timestamp register <b>606</b> enable both of these possibilities.</p><p id="p-0099" num="0080"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows an example implementation of the digital manager of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>. Shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref> are the digital manager <b>376</b>, controlled circuits <b>710</b><sub>0</sub>-<b>710</b><sub>J&#x2212;1</sub>, and input manager <b>372</b>.</p><p id="p-0100" num="0081">The example implementation of the digital manager <b>376</b> comprises input routing circuit <b>702</b>, configuration circuit <b>704</b>, output routing circuit <b>706</b>, processing paths <b>708</b><sub>0</sub>-<b>708</b><sub>Z-1 </sub>(where Z is an integer), and routing control circuit <b>712</b>.</p><p id="p-0101" num="0082">The configuration circuit <b>704</b> is operable to store configuration settings and use those settings to configure the processing paths <b>708</b><sub>0</sub>-<b>708</b><sub>Z-1 </sub>and/or the routing control circuit <b>712</b>. The settings may, for example, be loaded via the signal DM_config as part of the quantum algorithm description provided by quantum programming subsystem <b>202</b>. The settings may comprise, for example, one or more of: a bitmap on which may be based a determination of which of signals D<sub>0</sub>-D<sub>L-1 </sub>to route to which of signals P&#x2032;<sub>0</sub>-P&#x2032;<sub>Z-1 </sub>for one or more instructions of a quantum algorithm; a bitmap on which may be based a determination of which processing path outputs P<sub>0</sub>-P<sub>Z-1 </sub>to route to which of DigOut<sub>0</sub>-DigOut<sub>J+M-1 </sub>for one or more instructions of a quantum algorithm; and one or more bit patterns which processing paths <b>708</b><sub>0</sub>-<b>708</b><sub>Z-1 </sub>may convolve with one or more of the signals P&#x2032;<sub>0</sub>-P&#x2032;<sub>Z-1 </sub>for one or more instructions of a quantum algorithm.</p><p id="p-0102" num="0083">The input routing circuit <b>702</b> is operable to route each of the digital signals D<sub>0</sub>-D<sub>L-1 </sub>to one or more of the processing paths <b>708</b><sub>0</sub>-<b>708</b><sub>Z-1</sub>. At any given time (e.g., for any particular instruction of every pulser <b>302</b><sub>l </sub>of pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L</sub>), the input routing circuit <b>702</b> may determine to which of the processing paths <b>708</b><sub>0</sub>-<b>708</b><sub>Z-1 </sub>to rout the signal Di of signals D<sub>0</sub>-D<sub>Ll </sub>based on the signal fanin<sub>l </sub>of signals fanin<sub>0</sub>-fanin<sub>L-1</sub>. That is, for a particular instruction, the digital signal Di may be routed to any one or more of paths <b>708</b><sub>0</sub>-<b>708</b><sub>Z-1 </sub>based on the value of fanin<sub>l </sub>for that instruction. For example, fanin<sub>l </sub>may be a Z-bit signal and a state of each bit of fanin<sub>l </sub>during a particular instruction may indicate whether D<sub>l </sub>is to be routed to a corresponding one of the Z processing paths <b>708</b><sub>0</sub>-<b>708</b><sub>Z-1 </sub>during that instruction. An example implementation of the input routing circuit <b>702</b> is described below with reference to <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0103" num="0084">The output routing circuit <b>706</b> is operable to route each of the digital signals P<sub>0</sub>-P<sub>Z-1 </sub>to one or more of DigOut<sub>0</sub>-DigOut<sub>J+M-1 </sub>(In the example shown DigOut<sub>0</sub>-DigOut<sub>J+M-1 </sub>connect to stream<sub>0</sub>-stream<sub>M-1</sub>, respectively, and DigOut<sub>M</sub>-DigOut<sub>J+M-1 </sub>connect to DigCtrl0-DigCtrlJ&#x2212;1, respectively). At any given time (e.g., for any particular instruction of every pulser <b>302</b><sub>l </sub>of pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L</sub>), the output routing circuit <b>706</b> may determine to which of DigOut<sub>0</sub>-DigOut<sub>J+M-1 </sub>to rout the signal P<sub>l </sub>of the signals P<sub>0</sub>-P<sub>L-1 </sub>based on the signal fanout<sub>l </sub>of signals fanout<sub>0</sub>-fanout<sub>Z-1</sub>. That is, for a particular instruction, the digital signal P<sub>z </sub>(z an integer between 0 and Z) may be routed to any one or more of DigOut<sub>0</sub>-DigOut<sub>J+M-1 </sub>based on the value of fanout<sub>z </sub>for that instruction. For example, values of fanout<sub>z </sub>may be (J+M&#x2212;1) bits and a state of each bit of fanout<sub>z </sub>during a particular instruction may indicate whether P<sub>z </sub>is to be routed to a corresponding one of the J+M&#x2212;1 signals DigOut during that instruction. An example implementation of the output routing circuit <b>704</b> is described below with reference to <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0104" num="0085">Each of the processing path circuits <b>708</b><sub>0</sub>-<b>708</b><sub>Z-1 </sub>is operable to manipulate a respective one of signals P&#x2032;<sub>0</sub>-P&#x2032;<sub>Z-1 </sub>to generate a corresponding manipulated signal P<sub>0</sub>-P<sub>Z-1</sub>. The manipulation may comprise, for example, introducing a delay to the signal such that the resulting one or more of DigOut<sub>0</sub>-DigOut<sub>J+M-1 </sub>reach(es) its/their destination (a controlled circuit <b>710</b> and/or input manager <b>372</b>) at the proper time with respect to the time of arrival of a corresponding quantum control pulse at the corresponding destination.</p><p id="p-0105" num="0086">Each of the controlled circuits <b>710</b><sub>0</sub>-<b>710</b><sub>J&#x2212;1 </sub>and input manager <b>372</b> is a circuit which, at least some of the time, needs to operate synchronously with quantum control pulses generated by one or more of pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L-1 </sub>(possibly a reflection/return pulse from a quantum processor in the case of input manager <b>372</b>). Accordingly, each of the control circuits <b>710</b><sub>0</sub>-<b>710</b><sub>J&#x2212;1 </sub>receives a respective one of control signals DigOut<sub>0</sub>-DigCtrl<sub>J&#x2212;1 </sub>that is synchronized with a respective quantum control pulse. Similarly, input manager <b>372</b> receives a plurality of the DigOut signals (one for each stream input).</p><p id="p-0106" num="0087">The routing controller <b>712</b> comprises circuitry operable to generate signals fanin<sub>0</sub>-fanin<sub>L-1 </sub>and fanout<sub>0</sub>-fanout<sub>Z-1 </sub>based on D_path<sub>0</sub>-D_path<sub>L-1</sub>, D_port<sub>0</sub>-D_port<sub>L-1</sub>, and/or information stored in configuration circuit <b>704</b>.</p><p id="p-0107" num="0088"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows an example implementation of the digital manager of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>. The example input routing circuit <b>502</b> comprises routing circuits <b>802</b><sub>0</sub>-<b>802</b><sub>L-1 </sub>and combining circuits <b>804</b><sub>0</sub>-<b>804</b><sub>L-1</sub>. The example output routing circuitry <b>506</b> comprises circuits routing circuits <b>808</b><sub>0</sub>-<b>808</b><sub>Z-1 </sub>and combining circuits <b>810</b><sub>0</sub>-<b>810</b><sub>J&#x2212;1</sub>. The example processing path circuits are convolution circuits <b>806</b><sub>0</sub>-<b>806</b><sub>Z-1</sub>.</p><p id="p-0108" num="0089">Each of the routing circuits <b>802</b><sub>0</sub>-<b>802</b><sub>L </sub>is operable to route a respective one of signals D<sub>0</sub>-D<sub>L-1 </sub>to one or more of the combining circuits <b>804</b><sub>0</sub>-<b>804</b><sub>Z-1</sub>. To which of combining circuit(s) <b>804</b><sub>0</sub>-<b>804</b><sub>Z-1 </sub>the signal D<sub>l </sub>is routed is determined based on the signal fanin<sub>l</sub>. In an example implementation, each signal fanin<sub>l </sub>is a Z-bits signal and, for a pulser<sub>l </sub>instruction, the value of bit z of the signal fanin<sub>l </sub>determines whether the signal Di is to be routed to combining circuit <b>804</b><sub>z </sub>for that instruction. The value of fanin<sub>l </sub>may be updated on a per-instruction basis.</p><p id="p-0109" num="0090">Each of combining circuits <b>804</b><sub>0</sub>-<b>804</b><sub>L-1 </sub>is operable to combine up to L of the signals D0-DL&#x2212;1 to generate a corresponding one of signals P<sub>0</sub>-P<sub>Z-1</sub>. In an example implementation, the combining comprises OR-ing together the values of the up to L signals.</p><p id="p-0110" num="0091">Each of the routing circuits <b>808</b><sub>0</sub>-<b>808</b><sub>Z-1 </sub>is operable to route a respective one of signals P&#x2032;<sub>0</sub>-P&#x2032;<sub>Z-1 </sub>to one or more of the combining circuits <b>810</b><sub>0</sub>-<b>810</b><sub>L-1</sub>. To which of combining circuit(s) <b>810</b><sub>0</sub>-<b>810</b><sub>J&#x2212;1 </sub>the signal P&#x2032;<sub>z </sub>is routed is determined based on the signal fanout<sub>z</sub>. In an example implementation, each signal fanout<sub>z </sub>is a (J+M&#x2212;1)-bit signal and the value of bit j+m&#x2212;1 of the signal fanout<sub>z </sub>determines whether the signal P&#x2032;<sub>z </sub>is to be routed to combining circuit <b>804</b><sub>j+m-1</sub>. In an example implementation the value of fanout<sub>z </sub>is preconfigured before the runtime of the quantum algorithm, however, in another implementation it may be updated dynamically (e.g., on a per-instruction basis).</p><p id="p-0111" num="0092">Each combining circuit of combining circuits <b>810</b><sub>0</sub>-<b>810</b><sub>J&#x2212;1 </sub>is operable to combine up to Z of the signals P&#x2032;<sub>0</sub>-P&#x2032;<sub>Z-1 </sub>(received via inputs <b>803</b><sub>0 </sub>to <b>803</b><sub>Z-1</sub>) to generate a corresponding one of signals DigOut<sub>0</sub>-DigOut<sub>J+M-1</sub>. In an example implementation, the combining comprises OR-ing together the values of the up to Z signals.</p><p id="p-0112" num="0093">Each convolution circuit <b>806</b><sub>z </sub>is operable to convolve signal P<sub>z </sub>with pattern<sub>z </sub>to generate signal P&#x2032;<sub>z</sub>. In an example implementation, pattern<sub>z </sub>is preconfigured before runtime of the quantum algorithm, however, in another implementation it may be updated dynamically. pattern<sub>z </sub>may be determined based on: the destination(s) of signal P<sub>z </sub>(e.g., to which of controlled circuits <b>510</b> and/or input of input manager <b>352</b> P<sub>z </sub>is intended); characteristics of the corresponding quantum control pulse (e.g., any one or more of its frequency, phase, amplitude, and/or duration); and/or process, temperature, and/or voltage variations.</p><p id="p-0113" num="0094"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates configuration and control of the quantum controller via the quantum programming subsystem. In <figref idref="DRAWINGS">FIG. <b>9</b></figref>, the quantum controller <b>210</b> comprises one or more instances of various circuits (such as the pulser, input manager, output manager, digital manager, pulse operations manager, and analog front end circuits described above). Connected to the inputs and outputs of the quantum controller <b>210</b> may be a plurality of external devices (e.g., oscilloscopes, waveform generators, spectrum analyzers, mixers, amplifiers, etc.) and a plurality of quantum elements. As described in further detail below, these physical circuits can be allocated and deallocated independently of one another such that the physical resources of the quantum controller <b>210</b>, and the quantum elements and external devices connected to the quantum controller <b>210</b> via the analog and digital inputs and outputs, can be organized into one or more &#x201c;quantum machines.&#x201d;</p><p id="p-0114" num="0095">Also shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref> are a compiler <b>906</b> and quantum machines manager <b>908</b> of the quantum programming subsystem <b>202</b>.</p><p id="p-0115" num="0096">The compiler <b>906</b> comprises circuitry operable to generate a machine code quantum algorithm description based on: (1) a specification <b>902</b>; (2) a pulse generation program <b>904</b>; and (3) a resources management data structure from the quantum machines manager <b>908</b>.</p><p id="p-0116" num="0097">The specification <b>902</b> identifies resources of a quantum machine some of which are mapped to physical circuits during an instantiation of a quantum machines (e.g. input and output ports of the quantum controller <b>2</b>|<b>0</b>), and some of which the compiler attaches to physical circuits of the quantum controller <b>210</b> during compilation of a Pulse generation Program <b>904</b>. The compiler <b>906</b> may allocate resources for executing the program <b>904</b> based on the specification <b>902</b>, the program <b>904</b>, and/or the available resources indicated by the quantum machines manager <b>908</b>. As an example, assume a scenario in which there are five quantum elements in the specification <b>902</b> and the program <b>904</b> uses only two of the quantum elements; the number of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L </sub>allocated may depend on the available resources and the specifics of the program <b>904</b>. In one case the compiler <b>906</b> may allocate a first number (e.g., two) of the pulsers <b>302</b><sub>0</sub>-<b>302</b><sub>L </sub>for interfacing with the two quantum elements and in another case the compiler may allocate a second number (e.g., four) for sending pulses to the two quantum elements. Examples of resource definitions which may be present in specification <b>902</b> are described below with reference to <figref idref="DRAWINGS">FIGS. <b>10</b>A-C</figref>. In an example implementation, Python is used as a &#x201c;host&#x201d; language for the specification and the specification is a Python dictionary. In this example implementation the Python syntax/constructs can thus be leveraged to create the specification (Python variables, functions, etc.).</p><p id="p-0117" num="0098">The pulse generation program <b>904</b> comprises statements that define a sequence of operations to be performed by the quantum machine defined in the specification <b>902</b>. Such operations typically include the generation of one or more analog pulses to be sent to a controlled element, such as a quantum element. Such operations typically include measuring one or more return pulses from an element. The pulse generation program is also referred to herein as a QUA program. Functions, syntax, etc. of the QUA programming language are described below. In an example implementation, Python is used as a &#x201c;host&#x201d; language for the QUA program. This allows leveraging Python syntax/constructs (Python variables, functions, etc.) to generate the QUA program, but it is still a QUA&#x2014;not Python&#x2014;program to be compiled by the compiler <b>906</b> to generate QOP machine code, and to be executed on the quantum controller/s <b>210</b>.</p><p id="p-0118" num="0099">In an example implementation, a QUA program defines the sequence of statements for: (1) Generating, shaping and sending pulses to the quantum device; (2) Measuring of pulses returning from the quantum device; (3) Performing real-time classical calculations on the measured data and storing results in classical variables; (4) Performing real-time classical calculations on classical variables; (5) Controlling the flow of the program, including branching statements; and (6) Streaming of data from the quantum controller <b>210</b> to the quantum programing system <b>202</b> and processing and saving it in the quantum programing system <b>202</b>.</p><p id="p-0119" num="0100">In addition to the specification of which pulses are played, a QUA program can also specify when they should be played through both explicit and implicit statements and dependency constructs. Thus, a QUA program can define exactly the timing in which pulses are played, down to the single sample level and single clock cycles of the quantum controller <b>210</b>.</p><p id="p-0120" num="0101">In an example implementation, the pulses syntax defines an implicit pulse dependency, which determines the order of pulse execution. The dependency can be summarized as follows: (1) Each pulse is played immediately, unless dependent on a previous pulse yet to be played; (2) Pulses applied to the same quantum element are dependent on each other according to the order in which they are written in the program In another implementation, timing and ordering or pulses may be set forth explicitly in the QUA program.</p><p id="p-0121" num="0102">Example QUA programming constructs are described below in Table 1.</p><p id="p-0122" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>QUA programming constructs</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>play(pulse * amp(g<sub>00</sub>, g<sub>01</sub>, g<sub>10</sub>, g<sub>11</sub>), qe, duration=None, condition=None, break_condition=None )</entry></row><row><entry>Play a pulse to an element.</entry></row><row><entry>The pulse will be modified according to the properties of the element defined in the specification, and</entry></row><row><entry>then played to the analog output(s) defined in the specification.</entry></row><row><entry>Parameters:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>pulse - name of the pulse, as defined in the quantum machine specification.</entry></row><row><entry/><entry>qe - name of the quantum element, as defined in the quantum machine specification.</entry></row><row><entry/><entry>duration - duration of the pulse (&#x2033;=None&#x2033; means default is no explicit duration)</entry></row><row><entry/><entry>g<sub>ij </sub>- an expression;</entry></row><row><entry/><entry>amp( ) - matrix definition;</entry></row><row><entry/><entry>condition - if present, the pulse will be played with the condition evaluates to true (&#x2033;=None&#x2033;</entry></row><row><entry/><entry>means default is no condition);</entry></row><row><entry/><entry>break_condition - if present, the pulser will be stopped when the condition evaluates to true</entry></row><row><entry/><entry>(&#x2033;=None&#x2033; means default is no break_condition);</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>It is possible to scale the pulse&#x2032;s amplitude dynamically by using the following syntax:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>play(&#x2032;pulse_name&#x2032; * amp(v), &#x2032;element&#x2032;), where amp(v) = mat(v, 0, 0, v)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>where v is a variable.</entry></row><row><entry>Moreover, if the pulse is intended for an element that receives a pulse pair and thus is defined with</entry></row><row><entry>two waveforms, the two waveforms, described as a column vector, can be multiplied by a matrix:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>play(&#x2032;pulse_name&#x2032; * amp([v_00, v_01, v_10, v_11]), &#x2032;element&#x2032;),</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>where v_ij, i,j={0,1}, are variables.</entry></row><row><entry>Example:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x3e;&#x3e;&#x3e; with program( ) as prog:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;v1 = declare(fixed)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;assign(v1, 0.3)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse1&#x2032;, &#x2032;qe1&#x2032;)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse1&#x2032; * amp(0.5), &#x2032;qe1&#x2032;)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse1&#x2032; * amp(v1), &#x2032;qe1&#x2032;)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse1&#x2032; * amp([0.9, v1, &#x2212;v1, 0.9]), &#x2032;qe_iq_pair&#x2032;)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>wait(duration, *qes)</entry></row><row><entry>Wait for the given duration on all provided elements.</entry></row><row><entry>During the wait command the quantum controller 210 will output 0.0 to the elements.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="70pt" align="left"/><colspec colname="2" colwidth="245pt" align="left"/><tbody valign="top"><row><entry>&#x2002;Parameters:</entry><entry>duration (int | QUA variable of type int) - time to wait (e.g., in multiples of 4nsec</entry></row><row><entry/><entry>with Range: [4, 2<sup>24</sup>] in steps of 1).</entry></row><row><entry/><entry>*qes (str | sequence of str) - elements to wait on (the Asterix denotes there can be</entry></row><row><entry/><entry>0 or more)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>measure(pulse, qe, Rvar, *outputs)</entry></row><row><entry>The measure statement allows operating on a quantum element (which has outputs), by</entry></row><row><entry>sending a pulse to it, after some time acquiring the returning signal and processing it in</entry></row><row><entry>various ways</entry></row><row><entry>An element for which a measurement is applied must have outputs defined in the quatum machine</entry></row><row><entry>specification.</entry></row><row><entry>A measurement may comprise:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="280pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2022;</entry><entry>playing a pulse to the element (identical to a play statement)</entry></row><row><entry>&#x2003;&#x2022;</entry><entry>waiting for a duration of time defined as the time_of_flight in the definition of the element,</entry></row><row><entry/><entry>and then sampling the returning pulse. The analog input to be sampled is defined in the</entry></row><row><entry/><entry>definition of the element.</entry></row><row><entry>&#x2003;&#x2022;</entry><entry>processing the returned samples using the listed process(es) (if any). The processing could be,</entry></row><row><entry/><entry>for example, demodulation and integration with specified integration weights, which</entry></row><row><entry/><entry>produces a scalar, accumulated demodulation and integration that produces a vector,</entry></row><row><entry/><entry>a sequence of demodulation and integrations that produces a vector, FIR filter, neural</entry></row><row><entry/><entry>network.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>Parameters</entry></row><row><entry>&#x2003;pulse - name of the pulse, as defined in the quantum machine specification. Pulse must have</entry></row><row><entry>&#x2003;a measurement operation.</entry></row><row><entry>&#x2003;qe - name of the element, as defined in the quantum machine specification. The element must</entry></row><row><entry>&#x2003;have outputs.</entry></row><row><entry>&#x2003;Rvar - a result variable reference, a string, or &#x2018;None&#x2019;. If Rvar is a result variable reference, the</entry></row><row><entry>&#x2003;raw ADC data will be sent to the quantum programing subsystem 202 and processed there</entry></row><row><entry>&#x2003;according to the result processing section of the QUA program. If Rvar is a string, the raw ADC</entry></row><row><entry>&#x2003;data will be sent to the quantum programming subsystem 202 and saved as it is with the default</entry></row><row><entry>&#x2003;minimal processing. If Rvar is set to None, raw results will not be sent to quantum programming</entry></row><row><entry>&#x2003;subsystem 202 and will not be saved. In one implementation, the raw results will be saved as long</entry></row><row><entry>&#x2003;as the digital pulse that is played with pulse is high.</entry></row><row><entry>&#x2003;outputs - a tuple with the form (processing identifier, params, variable name), where:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>processing identifier</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;defined in the top-level specification and/or in reserved words of the QUA language</entry></row><row><entry/><entry>&#x2003;and referred to in the pulse definition. A processing identifier may, for example, refer</entry></row><row><entry/><entry>&#x2003;to a set of integration weights, or neural network parameters, or the like.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Params</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;parameters passed to the processing reference</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>variable name</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;the name of a QUA variable to which the processing result is assigned.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>&#x2003;zero or more output tuples may be defined.</entry></row><row><entry>Example:</entry></row><row><entry>&#x3e;&#x3e;&#x3e; with program( ) as prog:</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;I = declare(fixed)</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;Q = declare(fixed)</entry></row><row><entry>&#x3e;&#x3e;&#x3e;</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;# measure by playing &#x2032;meas_pulse1&#x2032; to QE &#x2032;rr1&#x2032;, do not save raw results.</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;# demodulate and integrate using &#x2032;cos_weights&#x2032; and store result in I, and also</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;# demodulate and integrate using &#x2032;sin_weights&#x2032; and store result in Q</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;measure(&#x2032;meas_pulse1&#x2032;, &#x2032;rr1&#x2032;, None, (&#x2018;int&#x2019;, &#x2032;cos_weights&#x2032;, I), (&#x2018;int&#x2019; &#x2032;sin_weights&#x2032;, Q))</entry></row><row><entry>&#x3e;&#x3e;&#x3e;</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;# measure by playing &#x2032;meas_pulse2&#x2032; to QE &#x2032;rr1&#x2032;, save raw results to tag &#x2032;samples&#x2032;.</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;# demodulate and integrate data from &#x2032;out1&#x2032; port of &#x2032;rr1&#x2032; using &#x2032;optimized_weights&#x2032; as</entry></row><row><entry>integration weights</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;# store result in I</entry></row><row><entry>&#x3e;&#x3e;&#x3e;&#x2003;measure(&#x2032;meas_pulse2&#x2032;, &#x2032;rr1&#x2032;, &#x2032;samples&#x2032;, (&#x2018;int&#x2019;, &#x2032;optimized_weights&#x2032;, &#x2032;out1&#x2032;, I))</entry></row><row><entry>align(*qes)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Align several quantum elements together.</entry></row><row><entry/><entry>All of the quantum elements referenced in *qes will wait for all the others to finish their</entry></row><row><entry/><entry>currently running statement.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>*qes (str | sequence of str) - a single quantum element, or list of quantum elements</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>pause( )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Pause the execution of the job until QmJob.resume( ) is called.</entry></row><row><entry/><entry>The quantum machines freezes on its current output state.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>declare(t)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Declare a QUA variable to be used in subsequent expressions and assignments.</entry></row><row><entry/><entry>Declaration is performed by declaring a python variable with the return value of this function.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>t - The type of QUA variable. Possible values: int, fixed, bool, where:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;int</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="70pt" align="left"/><colspec colname="1" colwidth="245pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;a signed 32-bit number</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;fixed</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="70pt" align="left"/><colspec colname="1" colwidth="245pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;a signed 4.28 fixed point number</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;bool</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="70pt" align="left"/><colspec colname="1" colwidth="245pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;either True or False</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Returns</entry></row><row><entry/><entry>The variable</entry></row><row><entry/><entry>Example:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; a = declare(fixed)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; play(&#x2032;pulse&#x2032; * amp(a), &#x2032;qe&#x2032;)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>assign(var,_exp)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Set the value of a given QUA variable.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>var (QUA variable) - The variable to set (defined by the declare function)</entry></row><row><entry/><entry>&#x2022;</entry><entry>_exp (QUA expression) - An expression to set the variable to</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Example:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; with program( ) as prog:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;v1 = declare(fixed)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;assign(v1, 1.3)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse1&#x2032; * amp(v1), &#x2032;qe1&#x2032;)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>save(var, tag)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Save a QUA variable with a given tag.</entry></row><row><entry/><entry>The tag will appear later as a field in the saved results object returned by QmJob.get_results( ).</entry></row><row><entry/><entry>The type of the variable determines the python type, according to the following rule:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2002;&#x2022;</entry><entry>&#x2002;int &#x2212;&#x3e; int</entry></row><row><entry/><entry>&#x2002;&#x2022;</entry><entry>&#x2002;fixed &#x2212;&#x3e; float</entry></row><row><entry/><entry>&#x2002;&#x2022;</entry><entry>&#x2002;bool &#x2212;&#x3e; bool</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>var (QUA variable) - A QUA variable to save</entry></row><row><entry/><entry>&#x2022;</entry><entry>tag (str) - A name to save the value under</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>update_frequency(qe, new_frequency)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Dynamically update the frequency of the NCO associated with a given quantum element.</entry></row><row><entry/><entry>This changes the frequency from the value defined in the quantum machine specification.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe (str) - The quantum element associated with the NCO whose frequency will be</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>changed</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>new_frequency (int) - The new frequency value to set in units of Hz. Range: (0 to</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>5000000) in steps of 1.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Example:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; with program( ) as prog:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;update_frequency(&#x2033;q1&#x2033;, 4000000)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>z_rotation(angle, *qes)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Shift the phase of the NCO associated with a quantum element by the given angle.</entry></row><row><entry/><entry>This is typically used for virtual z-rotations. Equivalent to z_rot( )</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>angle (float) - The angle to add to the current phase (in radians)</entry></row><row><entry/><entry>&#x2022;</entry><entry>*qes (str | sequence of str) - A quantum element, or sequence of quantum elements,</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>associated with the NCO whose phase will be shifted</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>z_rot(angle, *qes)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Shift the phase of the NCO associated with a quantum element by the given angle.</entry></row><row><entry/><entry>This is typically used for virtual z-rotations. Equivalent to z_rotation( )</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>angle (float) - The angle to add to the current phase (in radians)</entry></row><row><entry/><entry>&#x2022;</entry><entry>*qes (str | sequence of str) - A quantum element, or sequence of quantum elements,</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>associated with the NCO whose phase will be shifted</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>set_frame(qes, angle)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Set the phase of the frame matrix associated with a quantum element to the given angle.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>reset_phase(qes, angle)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Set the total phase of the frequency modulation of a quantum element to zero (both the</entry></row><row><entry/><entry>frequency modulation matrix and the frame matrix).</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>infinite_loop_( )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Infinite loop flow control statement in QUA.</entry></row><row><entry/><entry>To be used with a context manager.</entry></row><row><entry/><entry>Optimized for zero latency between iterations, provided that no more than a single quantum</entry></row><row><entry/><entry>element appears in the loop.</entry></row><row><entry/><entry>Note</entry></row><row><entry/><entry>In case multiple quantum elements need to be used in an infinite loop, it is possible to add</entry></row><row><entry/><entry>several loops in parallel (see example).</entry></row><row><entry/><entry>Example:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; with infinite_loop_( ):</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse1&#x2032;, &#x2032;qe1&#x2032;)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; with infinite_loop_( ):</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse2&#x2032;, &#x2032;qe2&#x2032;)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>for(var=None, init=None, cond=None, update=None)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>For loop flow control statement in QUA.</entry></row><row><entry/><entry>To be used with a context manager.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>var (QUA variable) - QUA variable used as iteration variable</entry></row><row><entry/><entry>&#x2022;</entry><entry>init (QUA expression) - an expression which sets the initial value of the iteration variable</entry></row><row><entry/><entry>&#x2022;</entry><entry>cond (QUA expression) - an expression which evaluates to a boolean variable, determines</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>if to continue to next loop iteration</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>update (QUA expression) - an expression to add to var with each loop iteration</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Example:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; x = declare(fixed)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; with for(var=x, init=0, cond=x&#x3c;=1, update=x+0.1):</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse&#x2032;, &#x2032;qe&#x2032;)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>if(condition)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>If flow control statement in QUA.</entry></row><row><entry/><entry>To be used with a context manager.</entry></row><row><entry/><entry>The QUA code block following the statement will be executed only if condition evaluates to</entry></row><row><entry/><entry>true.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="259pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>condition - A boolean expression to evaluate</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Example:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; x=declare(int)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; with if_(x&#x3e;0):</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse&#x2032;, &#x2032;qe&#x2032;)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>else</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>Else flow control statement in QUA.</entry></row><row><entry/><entry>To be used with a context manager.</entry></row><row><entry/><entry>Must appear after an if( ) statement.</entry></row><row><entry/><entry>The QUA code block following the statement will be executed only if expression in</entry></row><row><entry/><entry>preceding if( ) statement evaluates to false.</entry></row><row><entry/><entry>Example:</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; x=declare(int)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; with if(x&#x3e;0):</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;pulse&#x2032;, &#x2032;qe&#x2032;)</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e; with else( ):</entry></row><row><entry/><entry>&#x3e;&#x3e;&#x3e;&#x2003;play(&#x2032;other_pulse&#x2032;, &#x2032;qe&#x2032;)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0123" num="0103">The Play statement in QUA instructs the quantum controller <b>210</b> to send the indicated pulse to the indicated element. The quantum controller <b>210</b> will modify or manipulate the pulse according to the element's properties defined in the quantum machine specification (i.e., the compiler will generate the required pulse modification settings which will then be stored to the appropriate one or more of pulse modification settings circuit(s) <b>504</b><sub>0</sub>-<b>504</b><sub>K-1</sub>, so the user is relieved of the burden of having to specify the modifications/manipulations in each individual Play statement.</p><p id="p-0124" num="0104">If the element has a single input, the pulse sent to it may be defined with a single waveform. For example:</p><p id="p-0125" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2018;elements&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;qubit&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;SingleInput&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;port&#x2019;: (&#x2018;con1&#x2019;, 1),</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;intermediate_frequency&#x2019;: 70e6,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;operations&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;pulse1&#x2019;: &#x2018;pulse1&#x2019;</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>&#x2018;pulses&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;gauss_pulse_in&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;operation&#x2019;: &#x2018;control&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;length&#x2019;: 12,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;waveforms&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;single&#x2019;: &#x2018;wf1&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>&#x2002;},</entry></row><row><entry/><entry>&#x2018;waveforms&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;wf1&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;type&#x2019;: &#x2018;arbitrary&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2018;samples&#x2019;:[0.49, 0.47, 0.44, 0.41, 0.37, 0.32, 0.32, 0.37,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;0.41, 0.44, 0.47, 0.49]</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0126" num="0105">Denoting the samples of the waveform as s<sub>i</sub>, the play statement instructs the quantum controller <b>210</b> to modulate the waveform samples with the intermediate frequency of the element:</p><p id="p-0127" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>{tilde over (s)}</i><sub>i</sub><i>=s</i><sub>i </sub>cos(&#x3c9;<sub>IF</sub><i>t+&#x3d5;</i><sub>F</sub>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0128" num="0000">&#x3c9;<sub>IF</sub>, is the intermediate frequency defined in the quantum machine specification of the element and &#x3d5;<sub>F </sub>is the frame phase, initially set to zero (see z_rot statement specifications for information on &#x3d5;<sub>F</sub>). The quantum controller <b>210</b> then plays s<sub>i </sub>to the analog output port defined in the definition of the element (in the above example, port 1).</p><p id="p-0129" num="0106">If the element has two mixed inputs (i.e. two output ports of the quantum controller <b>210</b> are connected to the element via an IQ mixer), in addition to the intermediate frequency, a mixer and a lo_frequency may be defined in the quantum machine specification. For example:</p><p id="p-0130" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="168pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2018;elements&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;qubit&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;mixedInputs&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;I&#x2019;: (&#x2018;con1&#x2019;, 1),</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;Q&#x2019;: (&#x2018;con1&#x2019;, 2),</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;mixer&#x2019;: &#x2018;mixer1&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;lo_frequency&#x2019;: 5.1e9,</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;intermediate_frequency&#x2019;: 70e6,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;operations&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;pulse1&#x2019;: &#x2018;pulse1&#x2019;</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>},</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0131" num="0107">A pulse that is sent to such element may be defined with two waveforms. For example:</p><p id="p-0132" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2018;pulses&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;pulse1&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;operation&#x2019;: &#x2018;control&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;length&#x2019;: 12,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;waveforms&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;I&#x2019;: &#x2018;wf_I&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;Q&#x2019;: &#x2018;wf_Q&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>&#x2002;},</entry></row><row><entry/><entry>&#x2018;waveforms&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;wf_I&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;type&#x2019;: &#x2018;arbitrary&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;samples&#x2019;:[0.49, 0.47, 0.44, 0.41, 0.37, 0.32, 0.32, 0.37, 0.41,</entry></row><row><entry/><entry>&#x2003;&#x2002;0.44, 0.47, 0.49]</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>&#x2003;&#x2018;wf_Q&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;type&#x2019;: &#x2018;arbitrary&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;samples&#x2019;: [0.02, 0.03, 0.03, 0.04, 0.05, 0.00, 0.05, 0.04,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;0.03, 0.03, 0.02, 0.02]</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0133" num="0108">In addition, a mixer can be defined with a mixer correction matrix that corresponds to the intermediate_frequency and the lo_frequency. For example:</p><p id="p-0134" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="175pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2018;mixers&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;mixer1&#x2019;: [</entry></row><row><entry/><entry>&#x2003;&#x2002;{</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2018;intermediate_frequency&#x2019;: 70e6,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2018;lo_frequency&#x2019;: 5.1e9,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2018;correction&#x2019;: [0.9, 0.003, 0.0, 1.05]</entry></row><row><entry/><entry>&#x2003;&#x2003;}</entry></row><row><entry/><entry>],</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0135" num="0109">Denoting the samples of the waveforms by I<sub>i </sub>and Q<sub>i</sub>, the play statement instructs the quantum controller <b>210</b> to modulate the waveform samples with the intermediate frequency of the element and to apply the mixer correction matrix in the following way:</p><p id="p-0136" num="0000"><maths id="MATH-US-00010" num="00010"><math overflow="scroll"> <mrow>  <mrow>   <mo>(</mo>   <mtable>    <mtr>     <mtd>      <mover accent="true">       <msub>        <mi>I</mi>        <mi>&#x3b9;</mi>       </msub>       <mi>&#x2dc;</mi>      </mover>     </mtd>    </mtr>    <mtr>     <mtd>      <mover accent="true">       <msub>        <mi>Q</mi>        <mi>&#x3b9;</mi>       </msub>       <mi>&#x2dc;</mi>      </mover>     </mtd>    </mtr>   </mtable>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <mrow>    <mo>(</mo>    <mtable>     <mtr>      <mtd>       <msub>        <mi>C</mi>        <mn>00</mn>       </msub>      </mtd>      <mtd>       <msub>        <mi>C</mi>        <mrow>         <mn>0</mn>         <mo>&#x2062;</mo>         <mn>1</mn>        </mrow>       </msub>      </mtd>     </mtr>     <mtr>      <mtd>       <msub>        <mi>C</mi>        <mrow>         <mn>1</mn>         <mo>&#x2062;</mo>         <mn>0</mn>        </mrow>       </msub>      </mtd>      <mtd>       <msub>        <mi>C</mi>        <mrow>         <mn>1</mn>         <mo>&#x2062;</mo>         <mn>1</mn>        </mrow>       </msub>      </mtd>     </mtr>    </mtable>    <mo>)</mo>   </mrow>   <mo>&#x2062;</mo>   <mrow>    <mo>(</mo>    <mtable>     <mtr>      <mtd>       <mrow>        <mi>cos</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mrow>           <msub>            <mi>&#x3c9;</mi>            <mi>IF</mi>           </msub>           <mo>&#x2062;</mo>           <mi>t</mi>          </mrow>          <mo>+</mo>          <msub>           <mi>&#x3d5;</mi>           <mi>F</mi>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mtd>      <mtd>       <mrow>        <mrow>         <mo>-</mo>         <mi>sin</mi>        </mrow>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mrow>           <msub>            <mi>&#x3c9;</mi>            <mi>IF</mi>           </msub>           <mo>&#x2062;</mo>           <mi>t</mi>          </mrow>          <mo>+</mo>          <msub>           <mi>&#x3d5;</mi>           <mi>F</mi>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mtd>     </mtr>     <mtr>      <mtd>       <mrow>        <mi>sin</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mrow>           <msub>            <mi>&#x3c9;</mi>            <mi>IF</mi>           </msub>           <mo>&#x2062;</mo>           <mi>t</mi>          </mrow>          <mo>+</mo>          <msub>           <mi>&#x3d5;</mi>           <mi>F</mi>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mtd>      <mtd>       <mrow>        <mi>cos</mi>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mrow>           <msub>            <mi>&#x3c9;</mi>            <mi>IF</mi>           </msub>           <mo>&#x2062;</mo>           <mi>t</mi>          </mrow>          <mo>+</mo>          <msub>           <mi>&#x3d5;</mi>           <mi>F</mi>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mtd>     </mtr>    </mtable>    <mo>)</mo>   </mrow>   <mo>&#x2062;</mo>   <mrow>    <mo>(</mo>    <mtable>     <mtr>      <mtd>       <msub>        <mi>I</mi>        <mi>i</mi>       </msub>      </mtd>     </mtr>     <mtr>      <mtd>       <msub>        <mi>Q</mi>        <mi>i</mi>       </msub>      </mtd>     </mtr>    </mtable>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0137" num="0000">&#x3c9;<sub>IF </sub>&#x3c9;<sub>IF</sub>, is the intermediate and the C<sub>ij</sub>'s are the matrix elements of the correction matrix defined in the mixer for the relevant intermediate_frequency and lo_frequency. As mentioned above, &#x3d5;<sub>F </sub>is the frame phase, initially set to zero (see z_rot statement specifications for information on &#x3d5;<sub>F</sub>). The quantum controller <b>210</b> then plays I<sub>i </sub>and Q<sub>i </sub>to the analog output ports defined in the definition of the element (in the above example, port 1 and port 2, respectively).</p><p id="p-0138" num="0110">An element could have digital inputs as well as analog inputs. Each digital input of an element may be defined with three properties: port, delay, and buffer. For example:</p><p id="p-0139" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="168pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2018;elements&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;qubit&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;mixedInputs&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;I&#x2019;: (&#x2018;con1&#x2019;, 1),</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;Q&#x2019;: (&#x2018;con1&#x2019;, 2),</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;mixer&#x2019;: &#x2018;mixer1&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;lo_frequency&#x2019;: 5.1e9,</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;intermediate_frequency&#x2019;: 70e6,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;digital_inputs&#x2019;:</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;digital_input1&#x2019;:</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2002;&#x2018;port&#x2019;: (cont1, 1)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2002;&#x2018;delay&#x2019;: 144</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2002;&#x2018;buffer&#x2019;: 8</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;digital_input2&#x2019;:</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2002;&#x2018;port&#x2019;: (cont1, 2)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2002;&#x2018;delay&#x2019;: 88</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2002;&#x2018;buffer&#x2019;: 20</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;operations&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;pulse1&#x2019;: &#x2018;pulse1&#x2019;</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>},</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0140" num="0111">For a simple example, a pulse that is played to such quantum element could include a single digital marker which points to a single digital waveform. For example:</p><p id="p-0141" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="182pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2018;pulses&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;pulse1&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;operation&#x2019;: &#x2018;control&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;length&#x2019;: 40,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;waveforms&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;I&#x2019;: &#x2018;wf_I&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;Q&#x2019;: &#x2018;wf_Q&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;digital_marker&#x2019;: &#x2018;digital_waveform_high&#x2019;</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>&#x2002;},</entry></row><row><entry/><entry>&#x2018;digital_waveforms&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;digital_waveform_high&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;samples&#x2019;: [(1, 0)]</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0142" num="0112">The coding of the digital waveform may be a list of the form: [(value, length), (value, length), . . . , (value, length)], where each value is either 0 or 1 indicating the digital value to be played (digital high or low). Each length may be an integer (e.g., divisible by 4 in one example implementation) indicating for how many nanoseconds the value should be played. A length 0 indicates that the corresponding value is to be played for the remaining duration of the pulse. In the example above, the digital waveform is a digital high.</p><p id="p-0143" num="0113">When such pulse is played to the element, via the play or the measurement command, the digital waveform may be sent to all the digital inputs of the element. For each digital input, however, the quantum controller <b>210</b> may: (1) Delay the digital waveform by the delay that is defined in the definition of the digital input (e.g., given in ns); (2) Convolve the digital waveform with a digital pattern that is high for a duration which is, for example, twice the buffer that is defined in the definition of the digital input (e.g., given in ns in a &#x201c;buffer&#x201d;); and (3) Play the digital waveform to the digital output of the quantum controller <b>210</b> that is indicated in the quantum machine specification to be connected to the digital input. In other implementations, the digital pattern with which the digital waveform to be convolved may be more complex than a simple high value. In one such example, the &#x201c;buffer&#x201d; object may comprise &#x201c;duration&#x201d; and &#x201c;pattern&#x201d; properties.</p><p id="p-0144" num="0114">In the example above a play(pulse1, qubit) command would play: (1) A digital waveform to digital output 1, which starts 144 ns after the analog waveforms and which is high for 56 ns (the length of the pulse plus 2&#xd7;8 ns); and (2) A digital waveform to digital output 2, which starts 88 ns after the analog waveforms and which is high for 80 ns (the length of the pulse plus 2&#xd7;20 ns).</p><p id="p-0145" num="0115">A measurement can be done for an element that has outputs defined in the quantum machine specification. For example:</p><p id="p-0146" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="168pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2018;elements&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;resonator&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;mixedInputs&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;I&#x2019;: (&#x2018;con1&#x2019;, 3),</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;Q&#x2019;: (&#x2018;con1&#x2019;, 4),</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;mixer&#x2019;: &#x2018;mixer1&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;lo_frequency&#x2019;: 7.3e9,</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;intermediate_frequency&#x2019;: 50e6,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;outputs&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;out1&#x2019;: : (&#x2018;con1&#x2019;, 1),</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;time_of_flight&#x2019;: 196,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;smearing&#x2019;: 20,</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>},</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0147" num="0116">As seen in the above example, when a quantum element has outputs, two additional properties may be defined: time_of_flight and smearing. The pulse used in a measurement statement may also be defined as a measurement pulse and may have integration_weights defined. For example:</p><p id="p-0148" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="182pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2018;pulses&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;pulse1&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;operation&#x2019;: &#x2018;measurement&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;length&#x2019;: 400,</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;waveforms&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;I&#x2019;: &#x2018;meas_wf_I&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;Q&#x2019;: &#x2018;meas_wf_Q&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;},</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;integration_weights&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;integ1&#x2019;: &#x2018;integW1&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2018;integ2&#x2019;: &#x2018;integW2&#x2019;,</entry></row><row><entry/><entry>&#x2003;&#x2002;}</entry></row><row><entry/><entry>&#x2018;integration_weights&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2018;integW1&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;cosine&#x2019;: [0.0, 0.5, 1.0, 1.0, ..., 1.0, 0.5, 0.0]</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;sine&#x2019;: [0.0, 0.0, ..., 0.0]</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>&#x2003;&#x2018;integW2&#x2019;: {</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;cosine&#x2019;: [0.0, 0.0, ..., 0.0]</entry></row><row><entry/><entry>&#x2003;&#x2002;&#x2018;sine&#x2019;: [0.0, 0.5, 1.0, 1.0, ..., 1.0, 0.5, 0.0]</entry></row><row><entry/><entry>&#x2003;},</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0149" num="0117">A measurement statement, such as the one shown above, instructs the quantum controller <b>210</b> to: (1) Send the indicated pulse to the indicated element, manipulating the waveforms in the same manner that is described in the play statement section above; (2) After a time period time_of_flight (e.g., given in ns), samples the returning pulse at the quantum controller <b>210</b> input port/s that is/are connected to the output/s of the element. It saves the sampled data under stream_name (unless stream_name=None, in which case the sampled data will not be saved). The sampling time window will be of a duration that is the duration of the pulse plus twice the smearing (e.g., given in ns). This accounts for the returning pulse that is longer than the sent pulse due to the response of the quantum device, as well as for the cables and other elements in the pulse's path; and (3) Demodulate the sampled data with a frequency intermediate_frequency, defined in the definition of the element, perform weighted integration on the demodulated data with integration_weights that are defined in the quantum machine specification, and put the result in the indicated variable. The quantum controller <b>210</b> can perform multiple (e.g., 10 or more) demodulations and integrations at any given point in time, which may or may not be a part of the same measurement statement. The precise mathematical operation on the sampled data is:</p><p id="p-0150" num="0000"><maths id="MATH-US-00011" num="00011"><math overflow="scroll"> <mrow>  <mi>variable</mi>  <mo>=</mo>  <mrow>   <munder>    <mo>&#x2211;</mo>    <mi>i</mi>   </munder>   <mrow>    <msub>     <mi>s</mi>     <mi>i</mi>    </msub>    <mo>[</mo>    <mrow>     <mrow>      <msubsup>       <mi>w</mi>       <mi>c</mi>       <mi>i</mi>      </msubsup>      <mo>&#x2062;</mo>      <mi>cos</mi>      <mo>&#x2062;</mo>      <mrow>       <mo>(</mo>       <mrow>        <mrow>         <msub>          <mi>&#x3c9;</mi>          <mi>IF</mi>         </msub>         <mo>&#x2062;</mo>         <msub>          <mi>t</mi>          <mi>i</mi>         </msub>        </mrow>        <mo>+</mo>        <msub>         <mi>&#x3d5;</mi>         <mi>F</mi>        </msub>       </mrow>       <mo>)</mo>      </mrow>     </mrow>     <mo>+</mo>     <mrow>      <msubsup>       <mi>w</mi>       <mi>s</mi>       <mi>i</mi>      </msubsup>      <mo>&#x2062;</mo>      <mi>sin</mi>      <mo>&#x2062;</mo>      <mrow>       <mo>(</mo>       <mrow>        <mrow>         <msub>          <mi>&#x3c9;</mi>          <mi>IF</mi>         </msub>         <mo>&#x2062;</mo>         <msub>          <mi>t</mi>          <mi>i</mi>         </msub>        </mrow>        <mo>+</mo>        <msub>         <mi>&#x3d5;</mi>         <mi>F</mi>        </msub>       </mrow>       <mo>)</mo>      </mrow>     </mrow>    </mrow>    <mo>]</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0151" num="0000">where s<sub>i </sub>is the sampled data, &#x3c9;<sub>IF </sub>is the intermediate_frequency, &#x3d5;<sub>F </sub>is the frame phase discussed in the z_rot statement below, and w<sub>c</sub><sup>i </sup>and w<sub>s</sub><sup>i </sup>are the cosine and sine integration_weights. In an example implementation, the integration_weights are defined in a time resolution of 4 ns, while the sampling is done with time resolution of 1 ns (1 GSa/Sec sampling rate):</p><p id="p-0152" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>w</i><sub>c/s</sub><sup>4i</sup><i>+w</i><sub>c/s</sub><sup>4i+1</sup><i>+w</i><sub>c/s</sub><sup>4i+2</sup><i>+w</i><sub>c/s</sub><sup>4i+3 </sup><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0153" num="0118">Compilation may include allocating specific resources of the quantum controller <b>210</b> to that quantum machine and then generating machine code that, when executed by quantum controller <b>210</b>, will use those allocated resources.</p><p id="p-0154" num="0119">The quantum machines manager <b>908</b> comprises circuitry operable to determine resources present in the quantum controller <b>210</b> and the availability of those resources at any given time. To determine the resources, the quantum machines manager <b>908</b> may be operable to read one or more configuration registers of the quantum controller <b>210</b>, inspect a netlist of one or more circuits of the quantum controller <b>210</b>, and/or parse hardware description language (HDL) source code used to define circuits of the quantum controller <b>210</b> and/or other files used to describe various configurations of the hardware and software components. Once the resources are determined, the quantum machines manager <b>908</b> may keep track of which resources are in use and which are available based on which quantum machines are &#x201c;open&#x201d; (i.e., in a state where some resources are reserved for that machine regardless of which, if any, quantum algorithm description that quantum machine is executing at that time), and/or which quantum algorithm descriptions are loaded into and/or being executed by the quantum controller <b>210</b> at that time. For example, referring briefly to <figref idref="DRAWINGS">FIG. <b>13</b>A</figref>, during a time period where two quantum machines are open, each executing one of a first two quantum algorithms descriptions (QAD) (&#x201c;Program 1&#x201d; and &#x201c;Program 2&#x201d;), the system may be configured as shown in <figref idref="DRAWINGS">FIG. <b>13</b>A</figref> and a data structure managed by the quantum machines manager <b>908</b> may reflect the situation as shown in Table 2.</p><p id="p-0155" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Example data structure maintained by </entry></row><row><entry>quantum machines manager</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="147pt" align="center"/><tbody valign="top"><row><entry/><entry>Resource</entry><entry>Status</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Pulser 1</entry><entry>Allocated to program 2</entry></row><row><entry/><entry>Pulser 2</entry><entry>Allocated to program 2</entry></row><row><entry/><entry>Pulser 3</entry><entry>Allocated to program 1</entry></row><row><entry/><entry>Pulser 4</entry><entry>Available</entry></row><row><entry/><entry>Port 1</entry><entry>Allocated to QM2</entry></row><row><entry/><entry>Port 2</entry><entry>Available</entry></row><row><entry/><entry>Port 3</entry><entry>Allocated to QM2</entry></row><row><entry/><entry>Port 4</entry><entry>Allocated to QM1</entry></row><row><entry/><entry>Port 5</entry><entry>Allocated to QM1</entry></row><row><entry/><entry>Port 6</entry><entry>Allocated to QM2</entry></row><row><entry/><entry>Port 7</entry><entry>Allocated to QM1</entry></row><row><entry/><entry>Port 8</entry><entry>Allocated to QM1</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>During another time period where a single quantum machine is open and executing a third algorithm description (&#x201c;Program 3&#x201d;), the system may be configured as shown in <figref idref="DRAWINGS">FIG. <b>13</b>B</figref>. The data structure managed by the quantum machines manager <b>908</b> may reflect the situation as shown in Table 3.</p><p id="p-0156" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 3</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Example data structure maintained by </entry></row><row><entry>quantum machines manager</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="42pt" align="center"/><colspec colname="2" colwidth="140pt" align="center"/><tbody valign="top"><row><entry/><entry>Resource</entry><entry>Status</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Pulser 1</entry><entry>Allocated to</entry></row><row><entry/><entry/><entry>program 3</entry></row><row><entry/><entry>Pulser 2</entry><entry>Allocated to</entry></row><row><entry/><entry/><entry>program 3</entry></row><row><entry/><entry>Pulser 3</entry><entry>Allocated to</entry></row><row><entry/><entry/><entry>program 3</entry></row><row><entry/><entry>Pulser 4</entry><entry>Allocated to</entry></row><row><entry/><entry/><entry>program 3</entry></row><row><entry/><entry>Port 1</entry><entry>Allocated to QM3</entry></row><row><entry/><entry>Port 2</entry><entry>Allocated to QM3</entry></row><row><entry/><entry>Port 3</entry><entry>Allocated to QM3</entry></row><row><entry/><entry>Port 4</entry><entry>Allocated to QM3</entry></row><row><entry/><entry>Port 5</entry><entry>Allocated to QM3</entry></row><row><entry/><entry>Port 6</entry><entry>Allocated to QM3</entry></row><row><entry/><entry>Port 7</entry><entry>Allocated to QM3</entry></row><row><entry/><entry>Port 8</entry><entry>Allocated to QM3</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0157" num="0120">Table 4 below shows an example schema which uses Python as a host language the quantum machine specification is one or more Python dictionaries.</p><p id="p-0158" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="357pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 4</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Example quantum machine specification schema</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="329pt" align="left"/><tbody valign="top"><row><entry>version</entry><entry>integer &#x3c;int32&#x3e;</entry></row><row><entry/><entry>schema version.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="119pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry>controllers</entry><entry>object</entry></row><row><entry/><entry>A collection of controllers. Each controller represents a control</entry></row><row><entry/><entry>and computation resource on the quantum controller 210</entry></row><row><entry/><entry>hardware.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>property name*</entry><entry>object (controller)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="119pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>specification of a single quantum control module. Here we</entry></row><row><entry/><entry>define its static properties.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>analog_outputs</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry>a collection of analog output ports and the properties</entry></row><row><entry/><entry/><entry/><entry/><entry>associated with them</entry></row><row><entry/><entry/><entry/><entry>property name*</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of the properties of a physical analog output port</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>of the quantum control module.</entry></row><row><entry/><entry/><entry/><entry/><entry>offset</entry><entry>number</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>DC offset to output, range: (&#x2212;0.5, 0.5). Will be applied only</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>when program runs.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>digital_outputs</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>property name*</entry><entry>object (quantum control module digital port)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of the properties of a physical digital output port</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>of the quantum control module.</entry></row><row><entry/><entry/><entry/><entry/><entry>offset</entry><entry>number</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>analog</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>a collection of analog output ports and the properties</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>associated with them.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>Property name*</entry><entry>object (quantum control module analog output port)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of the properties of a physical analog output port</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>of the quantum control module.</entry></row><row><entry/><entry/><entry/><entry/><entry>offset</entry><entry>number</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>DC offset to output, range: (&#x2212;0.5, 0.5). Will be applied only</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>when program runs.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>type</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>Default: &#x201c;opx1&#x201d;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>analog_inputs</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>Property name*</entry><entry>object (quantum control module analog input port)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of the properties of a physical digital input port of</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>the quantum control module.</entry></row><row><entry/><entry/><entry/><entry/><entry>offset</entry><entry>number</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="119pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry>elements</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>A collection of quantum elements and/or external devices.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>Each quantum element represents and describes a controlled</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>entity which is connected to the ports (analog input, analog</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>output and digital outputs) of the quantum control module.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>property_name*</entry><entry>object (quantum element (QE))</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of a single element. Here we define to which port</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>of the quantum control module the element is connected,</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>what is the RF frequency of the pulses sent and/or received</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>from this element</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>frequency</entry><entry>integer &#x3c;int32&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>resonance frequency [Hz]. Actual carrier frequency output by</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>the quantum control module to the input of this QE is</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>frequency-lo_frequency.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>mixInputs</entry><entry>object (mixer input)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of the input of a QE which is driven by an IQ mixer</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>I</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>(tuple) of the form ((string) controller name, (int) controller</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>output/input port)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>Q</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>(tuple) of the form ((string) controller name, (int) controller</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>output/input port)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>mixer</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>the mixer used to drive the input of the QE, taken from the</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>names in mixers entry in the main quantum machine</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>specification</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>lo_frequency</entry><entry>integer &#x3c;int32&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>the frequency of the local oscillator which drives the mixer</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>outputs</entry><entry>collection of up to two output ports of QE. Keys: &#x201c;outl&#x201d; and</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>&#x201c;out2&#x201d;.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>property_name*</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>(tuple) of the form ((string) controller name, (int) controller</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>output/input port)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>intermediate_frequency</entry><entry>integer &#x3c;int32&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>intermediate frequency [Hz]. The actual frequency to be</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>output by the quantum control module to the input of this</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>element</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>measurement_qe</entry><entry>String</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>A reference to an element that has outputs (and thus can be</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>measured using the measurement command). This can be</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>specified for any element that does not have outputs so that</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>whenever a measurement command is used to measure this</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>elements, the actual measurement will be of the referenced</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>element.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>smearing</entry><entry>integer &#x3c;int32&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>padding time, in nsec, to add to both the start and end of the</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>raw data streaming window during a measure command.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>time_of_flight</entry><entry>integer &#x3c;int32&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>delay time [nsec] from start of pulse until output of QE reaches</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>quantum control module. Minimal value: 180. Used in measure</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>command, to determine the delay between the start of a</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>measurement pulse and the beginning of the demodulation</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>and/or raw data streaming window.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>singleInput</entry><entry>object (single input)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of the input of a QE which has a single input port</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>port</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>(tuple) of the form ((string) controller name, (int) controller</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>output/input port)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>operations</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>A collection of all pulse names to be used in play and measure</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>commands</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>property_name*</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>the name of the pulse as it appears under the &#x201c;pulses&#x201d; entry in</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>the quantum machine specification</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>digitalInputs</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>property_name*</entry><entry>object (digital input)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of the digital input of a QE</entry></row><row><entry/><entry/><entry/><entry/><entry>port</entry><entry>string</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>(tuple) of the form ((string) controller name, (int) controller</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>output/input port)</entry></row><row><entry/><entry/><entry/><entry/><entry>delay</entry><entry>integer &#x3c;int32&#x3e;</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>the digital pulses played to this QE will be delayed by this</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>amount [nsec] relative to the analog pulses.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>An intinsic negative delay of 143 + &#x2212;2nsec exists by default</entry></row><row><entry/><entry/><entry/><entry/><entry>output</entry><entry>string</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>(tuple) of the form ((string) controller name, (int) controller</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>output/input port)</entry></row><row><entry/><entry/><entry/><entry/><entry>buffer</entry><entry>integer &#x3c;int32&#x3e;</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>all digital pulses played to this QE will be convolved with a</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>digital pulse of value 1 with this length [nsec]</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="119pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry>pulses</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>A collection of pulses to be played to the quantum elements.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>In the case of a measurement pulse, the properties related to</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>the measurement are specified as well.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>property_name*</entry><entry>object (pulse)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of a single pulse. Here we define its analog and</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>digital components, as well as properties related to</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>measurement associated with it.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>integration_weights</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>if measurement pulse, a collection of integration weights</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>associated with this pulse,</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>to be applied to the data output from the QE and sent to the</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>controller.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>Keys: name of integration weights to be used in the</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>measurement command.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>property_name*</entry><entry>the name of the integration weights as it appears under the</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>&#x201c;integration_weigths&#x201d; entry in the quantum machine</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>specification</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>waveforms</entry><entry>a specification of the analog waveform to be played with this</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>pulse.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>If associated element has singleInput, key is &#x201c;single&#x201d;.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>If associated element has &#x201c;mixinputs&#x201d;, keys are &#x201c;1&#x201d; and &#x201c;Q&#x201d;.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><colspec colname="5" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry>property_name*</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>name of waveform to be played at the input port given in</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>associated keys</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>digital_marker</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>name of the digital marker to be played with this pulse</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>operation</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>type of operation. Possible values: control, measurement</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>length</entry><entry>integer &#x3c;int32&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>length of pulse [nsec]. Possible values: 16 to 4194304 in steps</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>of 4</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="119pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry>waveforms</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>A collection of analog waveforms to be output when a pulse is</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>played. Here we specify their defining type (constant, arbitrary</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>or compressed) and their actual datapoints.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>property_name*</entry><entry>arbitrary waveform (object) or constant waveform (object) or</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>compressed waveform (object)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>type</entry><entry>&#x2018;arbitrary&#x2019; | &#x2018;constant&#x2019; | &#x2018;compressed&#x2019;</entry></row><row><entry/><entry/><entry>samples</entry><entry>If type = &#x2018;arbitrary&#x2019;:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>Array of numbers &#x3c;float&#x3e;</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>list of values of arbitrary waveforms, range: (&#x2212;0.5, 0.5)</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>If type = &#x2018;constant&#x2019;:</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>number &#x3c;float&#x3e;</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>value of constant, range: (&#x2212;0.5, 0.5)</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>If type = &#x2018;compressed&#x2019;:</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>Array of numbers &#x3c;float&#x3e;</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>integer &#x3c;int32&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="119pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry>digital_waveforms</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>A collection of digital waveforms to be output when a pulse is</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>played. Here we specify their actual datapoints.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>property_name*</entry><entry>object (digital waveform)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>raw data samples of a digital waveform</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>samples</entry><entry>Array of strings</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>(list of tuples) specifying the analog data according to following</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>code:</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>The first entry of each tuple is 0 or 1 and corresponds to the</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>digital value, and the second entry is the length in nsec to play</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>the value, in steps of 1. If value is 0, the value will be played to</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="119pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry>integration_weights</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>A collection of integration weight vectors used in the</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>demodulation of pulses returned from a quantum element.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>property_name*</entry><entry>object (integration weights)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>specification of a set of measurement integration weights.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>Result of integration will be:</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>sum over i of (W_cosine[i]cos[wt[i]] +</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>W_sine[i]sin[wt[i]])analog[i].</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>Here:</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>w is the angular frequency of the quantum element, and</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>analog[i] is the analog data acquired by the controller.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>W_cosine, W_sine are the vectors associated with the &#x2018;cosine&#x2019;</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>and &#x2018;sine&#x2019; keys, respectively.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>Note: the entries in the vector are specified in 4nsec intervals,</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>and each entry is repeated four times during the</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>demodulation.</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>Example:</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>W_cosine = [2.0], W_sine = [0.0] will lead to the following</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>demodulation operation:</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>2.0(cos[wt[0]]analog[0] + cos[wt[l]]analog[1] +</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>cos[wt[2]]analog[2] + cos[wt[3]]analog[3])</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>sine</entry><entry>Array of numbers &#x3c;float&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>W_sine, a fixed-point vector of integration weights,</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>range: [&#x2212;2048, 2048] in steps of 2**&#x2212;15</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>cosine</entry><entry>Array of numbers &#x3c;float&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>W_cosine, a fixed-point vector of integration weights,</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>range: [&#x2212;2048, 2048] in steps of 2**&#x2212;15</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="119pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry>mixers</entry><entry>object</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>A collection of IQ mixer calibration properties, used to post-</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>shape the pulse to compensate for imperfections in the mixers</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>used for upconverting the analog waveforms.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>property_name*</entry><entry>Array of objects (mixer)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>intermediate_frequency</entry><entry>integer &#x3c;int32&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>intermediate frequency associated with correction matrix</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>lo_freq</entry><entry>integer &#x3c;int32&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>local oscillator (LO) frequency associated with correction</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>matrix</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><colspec colname="4" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>correction</entry><entry>string</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="7pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><colspec colname="6" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry/><entry>(tuple) a 2x2 matrix entered as a four-element tuple specifying</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>the correction matrix</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0159" num="0121">Elements of the quantum processor, (e.g. qubits, resonators, flux lines, gates, etc.), external devices (e.g., oscilloscopes, spectrum analyzers, waveform generators, etc.), and/or any other element which is a part of a quantum machine and is connected to output and/or input ports of the controller <b>210</b>, are defined using one or more of the other properties described in Table 4 and/or other similar properties which may be used in other implementations.</p><p id="p-0160" num="0122">An example of other properties which may be used to specify an element are properties of a neural network that processes pulses sent to the element. For example, an element specification may specify that pulses sent to it are to be generates and/or processed by a neural network and the element definition may include one or more parameters specifying the number of layers of the neural network, the number of neurons of the neural network, the weights and biases for each neuron of the neural network, and/or other parameters familiar to those working with neural networks. The neural network having the specified parameters may then be trained during a calibration routine (e.g., at the beginning of execution of a QUA program).</p><p id="p-0161" num="0123">For each element defined in a specification <b>902</b>, the controller output and/or input ports to which it is connected are defined. During compilation, pulse modification settings for manipulating pulses intended for an element may be generated (for loading into pulse modification settings circuits <b>504</b>) and the pulse modification setting circuit(s) <b>504</b> to which they will be loaded before execution may be chosen and may be allocated to the quantum machine on which the program is to be executed. Similarly, parameters and configurations of operations that will be performed on input signals related to an element (e.g. readout/measurement pulses) may be generated during compilation (for loading into compute and signal processing circuits <b>410</b>). Likewise, the compute and signal processing circuit <b>410</b> in which they will be used may be chosen during compilation and may be allocated to the quantum machine on which the program is to be executed during compilation.</p><p id="p-0162" num="0124">One example of an element that a quantum machine may contain is an IQ mixer that is connected to two output ports of the controller <b>210</b>. To correct for mixer imbalances, the in-phase/quadrature (IQ) waveforms of the pulse can be multiplied by a 2&#xd7;2 mixer correction matrix before being sent to the output ports. This mixer correction matrix, determined via a calibration routine, may be frequency dependent. Thus, a mixer definition may include the mixer's name and a list of one or more frequencies and the correction matrix to be used at each frequency. In one example implementation, the correction matrix is loaded into corresponding pulse modification circuit during compilation. Similarly, an element definition may include an intermediate frequency with which every pulse sent to the element is to be modulated.</p><p id="p-0163" num="0125">An example quantum machine specification file is described below with reference to <figref idref="DRAWINGS">FIGS. <b>10</b>A-<b>10</b>C</figref>. While the example implementations we show here (including the one Table 4 refers to) show some possible properties that can be defined and specified in the quantum machine specification, it is not limited to these examples. For example, various filters and their parameters may be defined (e.g. FIR filter) to be performed on pulses to be played to certain elements and/or on input signals to the controller.</p><p id="p-0164" num="0126">Pulses available for transmission by a quantum machine may be defined using one or more of the properties described in Table 4 and/or other similar properties which may be used in other implementations. Each pulse has a length. Each pulse is made of one or more waveforms. In one implementation there are two types of pulses: control pulses that are pulses that are only sent to the quantum system and will not be measured, and measurement pulses that are sent to the quantum system and will be measured upon return. The definition of a measurement pulse may specify parameters to be used for processing the measurement pulse upon its return from the element to which it was sent. Such parameters may include, for example, integration weights, parameters (e.g., number of layers, number of neurons, weights and biases, and/or the like) of a neural network, parameters (e.g., number of taps and tap coefficients) of a FIR filter, and/or the like. During compilation, pulse definitions may be used to, for example: generate pulse templates to load into pulse template memory <b>404</b>; generate instructions to be loaded into instruction memory <b>402</b> and/or compute and signal processing circuit <b>410</b> for retrieving and manipulating the contents of pulse template memory <b>404</b> to achieve the defined pulses; and/or generate one or more classical processor programs to be executed by compute and signal processing circuit <b>410</b> for processing readout/measurement pulses.</p><p id="p-0165" num="0127"><figref idref="DRAWINGS">FIGS. <b>10</b>A-<b>10</b>C</figref> show an example quantum machine specification. The example shown uses Python as a host language. The example quantum machine specification is a Python dictionary with a key of &#x201c;config&#x201d; and a value that comprises a plurality of nested objects, some of which are key-value pairs and some of which are nested dictionaries.</p><p id="p-0166" num="0128">The &#x201c;version&#x201d; key-value pair which indicates the version of the quantum machine specification schema being used.</p><p id="p-0167" num="0129">The &#x201c;controllers&#x201d; object is used to specify the number of modules/units that make up the quantum controller <b>210</b> of the quantum machine. The example shown specifies just a single quantum control module named &#x201c;con1&#x201d;, which is of type &#x201c;opx1&#x201d; (different opx types may, for example, indicated different hardware and/or configuration of the hardware). For each controller <b>210</b>, the output and input ports that are used in the quantum machine are specified. For analog outputs and inputs, DC offset voltage is specified as well.</p><p id="p-0168" num="0130">The &#x201c;elements&#x201d; object is used to specify elements that are connected to output and input ports of the controller <b>210</b>. Such elements may include quantum elements (e.g., qubits, readout resonators, flux lines, etc.), external devices (e.g., test equipment such as oscilloscopes, spectrum analyzers, signal generators, etc.), and/or any other element connected to the output and/or input ports of the controller. The example shown in <figref idref="DRAWINGS">FIG. <b>10</b>A</figref> specifies a qubit named &#x201c;qubit&#x201d; and a readout resonator named &#x201c;RR&#x201d;. The &#x201c;qubit&#x201d; element comprises &#x201c;mixinputs&#x201d;, &#x201c;operations&#x201d;, and &#x201c;frequency&#x201d; objects. The &#x201c;mixinputs&#x201d; object comprises &#x201c;I&#x201d;, &#x201c;Q&#x201d;, &#x201c;lo_frequency&#x201d;, and &#x201c;mixer&#x201d; objects. The &#x201c;I&#x201d; and &#x201c;Q&#x201d; objects specify the corresponding output ports of &#x201c;con1&#x201d; to which the inputs of the element are connected. The &#x201c;intermediate_frequency&#x201d; object specifies the intermediate frequency with which pulses sent to the qubit are to be modulated (e.g., determined from a qubit calibration routine). The &#x201c;mixer&#x201d; object refers to mixer object &#x201c;mixer_quibit,&#x201d; which is defined later in the quantum machine specification. The &#x201c;operations&#x201d; object specifies a &#x201c;gauss-pulse&#x201d; which refers to the &#x201c;gauss_pulse_in&#x201d; object is defined later in the quantum machine specification. The &#x201c;RR&#x201d; element comprises &#x201c;mixinputs&#x201d;, &#x201c;operations&#x201d;, &#x201c;outputs&#x201d;, &#x201c;frequency&#x201d;, &#x201c;time_of_flight&#x201d;, and &#x201c;smearing&#x201d; objects. The &#x201c;mixinputs&#x201d; object comprises &#x201c;I&#x201d;, &#x201c;Q&#x201d;, &#x201c;lo_frequency&#x201d;, and &#x201c;mixer&#x201d; objects. The &#x201c;I&#x201d; and &#x201c;Q&#x201d; objects specify the corresponding ports of &#x201c;con1&#x201d;. The &#x201c;frequency&#x201d; object specifies the frequency of the readout_resonator (e.g., determined from a qubit calibration routine). The &#x201c;mixer&#x201d; object refers to mixer object &#x201c;mixer_res,&#x201d; which is defined later in the quantum machine specification. The &#x201c;operations&#x201d; object specifies a &#x201c;meas_pulse&#x201d; which refers to the &#x201c;meas_pulse_in&#x201d; object is defined later in the quantum machine specification. The &#x201c;time_of_flight&#x201d; and &#x201c;smearing&#x201d; objects specify those values for the readout resonator. The &#x201c;outputs&#x201d; object specifies an output on the element &#x201c;out1&#x201d; and the corresponding input port of &#x201c;con1&#x201d; to which it is connected.</p><p id="p-0169" num="0131">The &#x201c;Pulses&#x201d; object is used to specify pulses available for transmission by the quantum machine. The example shown specifies two pulses: &#x201c;means_pulse_in&#x201d; and &#x201c;gauss_pulse_in.&#x201d; The &#x201c;means_pulse_in&#x201d; object in turn comprises &#x201c;operation&#x201d;, &#x201c;length&#x201d;, &#x201c;waveforms&#x201d;, &#x201c;integration_weights&#x201d;, and &#x201c;digital_marker&#x201d; objects. The &#x201c;operation&#x201d; object specifies it as a &#x201c;measurement&#x201d; pulse. The &#x201c;I&#x201d; and &#x201c;Q&#x201d; objects of the &#x201c;waveforms&#x201d; object refer to the &#x201c;exc_wf&#x201d; and &#x201c;zero_wf&#x201d; objects which are defined later in the quantum machine specification. The &#x201c;integration_weights&#x201d; object refers to the integration weights objects &#x201c;integW1&#x201d; and &#x201c;integW2&#x201d; which are defined later in the specification. The &#x201c;digital_marker&#x201d; object refers to the &#x201c;marker1&#x201d; object defined later in the specification.</p><p id="p-0170" num="0132">The &#x201c;gauss_pulse_in&#x201d; object comprises &#x201c;operation&#x201d;, &#x201c;length&#x201d;, and &#x201c;waveforms&#x201d; objects. The &#x201c;operation&#x201d; object specifies it is a &#x201c;control&#x201d; pulse. The &#x201c;I&#x201d; and &#x201c;Q&#x201d; objects of the &#x201c;waveforms&#x201d; object refer to the &#x201c;gauss_wf&#x201d; and &#x201c;zero_wf&#x201d; objects which are defined later in the quantum machine specification.</p><p id="p-0171" num="0133">The &#x201c;waveforms&#x201d; object defines the &#x201c;zero_wf&#x201d;, &#x201c;gauss_wf&#x201d;, and &#x201c;exc_wf&#x201d; objects (&#x201c;exc_wf&#x201d; not shown) using &#x201c;type&#x201d; and &#x201c;samples&#x201d; objects.</p><p id="p-0172" num="0134">The &#x201c;digital_waveforms&#x201d; defines the &#x201c;marker1&#x201d; object using a &#x201c;samples&#x201d; object.</p><p id="p-0173" num="0135">The &#x201c;integration_weights&#x201d; object defines the objects &#x201c;integW1&#x201d; and &#x201c;integW2&#x201d; using &#x201c;cosine&#x201d; and &#x201c;sine&#x201d; objects.</p><p id="p-0174" num="0136">The &#x201c;mixers&#x201d; object defines the &#x201c;mixer_res&#x201d; and &#x201c;mixer_qubit&#x201d; objects using &#x201c;freq&#x201d;, &#x201c;lo_freq&#x201d;, and &#x201c;correction&#x201d; objects.</p><p id="p-0175" num="0137"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow chart showing an example process for operation of the quantum orchestration platform. The process begins in block <b>1102</b> in which one or more quantum control modules are connected together to form quantum controller <b>210</b> and the quantum controller <b>210</b> is connected to a quantum system. In this regard, the quantum controller <b>210</b> is modular and extendable enabling use of as many units as desired/necessary for the quantum algorithm to be performed. Each of the modules may, for example, comprise one or more of each of the circuits shown in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>.</p><p id="p-0176" num="0138">In block <b>1103</b>, a quantum machine with a certain specification is instantiated by a user. This may be done via a Quantum Machines Manager API. In an example of such an API, shown in Table 5, this may include a call to the open_qm( ) function or the open_qm_from_file( ) function.</p><p id="p-0177" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 5</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Quantum Machines Manager API</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>Class QuantumMachinesManager (host=None, port=None, **kargs)</entry></row><row><entry>&#x2003;close_all_quantum_machines( )</entry></row><row><entry>&#x2003;&#x2003;Closes ALL open quantum machines</entry></row><row><entry>&#x2003;get_controllers( )</entry></row><row><entry>&#x2003;&#x2003;Returns a list of all the quantum control modules that are available</entry></row><row><entry>&#x2003;get_qm(machine_id)</entry></row><row><entry>&#x2003;&#x2003;Gets an open quantum machine object with the given machine id</entry></row><row><entry>&#x2003;&#x2003;Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="231pt" align="left"/><tbody valign="top"><row><entry/><entry>machine_id - The id of the open quantum machine to get</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;Returns</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="231pt" align="left"/><tbody valign="top"><row><entry/><entry>A quantum machine obj that can be used to execute programs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>&#x2003;list_open_quantum_machines( )</entry></row><row><entry>&#x2003;&#x2003;Return a list of open quantum machines. (Returns only the ids, use get_qm(...) to get</entry></row><row><entry>&#x2003;&#x2003;the machine object)</entry></row><row><entry>&#x2003;&#x2003;Returns</entry></row><row><entry>&#x2003;&#x2003;The ids list</entry></row><row><entry>&#x2003;open_qm(config, close_other_machines=True) &#x2192;</entry></row><row><entry>&#x2003;qm.QuantumMachine.QuantumMachine</entry></row><row><entry>&#x2003;&#x2003;Opens a new quantum machine</entry></row><row><entry>&#x2003;&#x2003;Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="231pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2022;</entry><entry>config - The config that will be used by the name machine</entry></row><row><entry>&#x2003;&#x2003;&#x2022;</entry><entry>close_other_machines - Flag whether to close all other running machines</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;Returns</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="231pt" align="left"/><tbody valign="top"><row><entry/><entry>A quantum machine obj that can be used to execute programs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>&#x2003;open_qm_from_file(filename, close_other_machines=True)</entry></row><row><entry>&#x2003;&#x2003;Opens a new quantum machine with config taken from a file on the local file system</entry></row><row><entry>&#x2003;&#x2003;Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="231pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2022;</entry><entry>filename - The path to the file that contains the config</entry></row><row><entry>&#x2003;&#x2003;&#x2022;</entry><entry>close_other_machines - Flag whether to close all other running machines</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;Returns</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="231pt" align="left"/><tbody valign="top"><row><entry/><entry>A quantum machine obj that can be used to execute programs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>&#x2003;perform_healthcheck(strict=True)</entry></row><row><entry>&#x2003;&#x2003;Perform a health check against the QM programming subsystem.</entry></row><row><entry>&#x2003;&#x2003;Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="231pt" align="left"/><tbody valign="top"><row><entry/><entry>strict - Will raise an exception if health check failed</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><tbody valign="top"><row><entry>&#x2003;version( )</entry></row><row><entry>&#x2003;&#x2003;Returns</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="231pt" align="left"/><tbody valign="top"><row><entry/><entry>The QM programming subsystem version</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0178" num="0139">In block <b>1104</b>, the quantum machines manager <b>908</b> attempts to allocate machine resources (i.e., resources allocated to a particular quantum machine regardless of whether a quantum algorithm description is currently executing on that quantum machine) of the quantum controller <b>210</b> to the new quantum machine according to the specification.</p><p id="p-0179" num="0140">In block <b>1105</b>, the quantum machines manager <b>908</b> determines whether the allocation and instantiation is successful. If not, then in block <b>1122</b> an alert is generated for the user (e.g., to inform the user that there are currently insufficient resources available to instantiate the required quantum machine). If allocation is successful, then in block <b>1106</b> the allocated resources are stored in quantum machines manager <b>908</b>, which updates its data structure of available resources to reflect the allocation of resources to the quantum machine, the new quantum machine is instantiated, and the process advances to block <b>1107</b>.</p><p id="p-0180" num="0141">In block <b>1107</b>, a user requests to execute a QUA program on the quantum machine. This may be done via a Quantum Machine API. In an example of such an API, shown in Table 6, this may include a call to the execute( ) function. Prior to the request to execute the QUA program, and/or during the execution of the QUA program, the user can use a Quantum Machine API, such as the one shown below in table 6, to alter any parameter that was set in the specification <b>902</b>. This is advantageous where, for example, something (e.g., temperature, voltage, equipment in use, and/or any other factor that may impact a quantum experiment), has changed since the time the specification <b>902</b> was generated.</p><p id="p-0181" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 6</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Quantum Machine API</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>Class QuantumMachine (machine_id, pb_config, config, manager)</entry></row><row><entry>&#x2003;close( )</entry></row><row><entry>&#x2003;Closes the quantum machine.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Returns</entry></row><row><entry/><entry>True if the close request succeeded, Raises an exception otherwise.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;execute(pragram, duration_limit=1000, data_limit=20000, force_execution=False, dry_run=</entry></row><row><entry>&#x2003;False, **kwargs) &#x2192; qm.QmJob.QmJob</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="329pt" align="left"/><tbody valign="top"><row><entry/><entry>Executes a program and returns a job object to keep track of execution and get results.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>program - A program( ) object generated in QUA to execute</entry></row><row><entry/><entry>&#x2022;</entry><entry>duration_limit (int) - Maximal time (in msec) for which results will be collected.</entry></row><row><entry/><entry>&#x2022;</entry><entry>data_limit (int) -</entry></row><row><entry/><entry/><entry>Maximal amount of data sends for which results will be collected.</entry></row><row><entry/><entry/><entry>Here data sends is either:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="147pt" align="left"/><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="182pt" align="left"/><tbody valign="top"><row><entry/><entry>1.</entry><entry>4 ADC samples, in case raw data is transferred</entry></row><row><entry/><entry>2.</entry><entry>a single save operation</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>force_execution (bool) - Execute program even if warnings occur (verify this)</entry></row><row><entry/><entry>&#x2022;</entry><entry>dry_run (bool) - compile program but do not run it (verify this)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="329pt" align="left"/><tbody valign="top"><row><entry/><entry>No new results will be available to the returned job object When duration_limit is reached,</entry></row><row><entry/><entry>or when data_limit is reached, whichever occurs sooner.</entry></row><row><entry/><entry>Returns</entry></row><row><entry/><entry>A QmJob object that can be used to keep track of the execution and get results</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;get_config( )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Gives the current config of the qm</entry></row><row><entry/><entry>Returns</entry></row><row><entry/><entry>A dictionary with the qm's config</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;get_dc_offset_by_qe(qe, input)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>get the current DC offset of the quantum control module analog output channel</entry></row><row><entry/><entry>associated with a quantum element. ** remove ** note: not currently implemented.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe - the name of the element to get the correction for</entry></row><row><entry/><entry>&#x2022;</entry><entry>input - the input name as appears in the element's config be more specific here</entry></row><row><entry/><entry/><entry>Returns</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>the offset, in normalized output units</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;get_digital_buffer(qe, digital_input)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>get the buffer for digital waveforms of the quantum element</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe (str) - the name of the element to get the buffer for</entry></row><row><entry/><entry>&#x2022;</entry><entry>digital_input (str) - the digital input name as appears in the element's config</entry></row><row><entry/><entry/><entry>Returns</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>the buffer</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;get_digital_delay(qe, digital_input)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="329pt" align="left"/><tbody valign="top"><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe - the name of the element to get the delay for</entry></row><row><entry/><entry>&#x2022;</entry><entry>digital_input - the digital input name as appears in the element's config</entry></row><row><entry/><entry/><entry>Returns</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="329pt" align="left"/><tbody valign="top"><row><entry/><entry>the delay</entry></row><row><entry/><entry>get_io1_value( )</entry></row><row><entry/><entry>Gives the data stored in OI1</entry></row><row><entry/><entry>No inference is made on type.</entry></row><row><entry/><entry>Returns</entry></row><row><entry/><entry>A dictionary with data stored in IO1. (Data is in all three format: int, float, bool)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;get_io2_value( )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Gives the data stored in IO2</entry></row><row><entry/><entry>No inference is made on type.</entry></row><row><entry/><entry>Returns</entry></row><row><entry/><entry>A dictionary with data from the second IO register. (Data is in all three format: int, float,</entry></row><row><entry/><entry>and bool)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;get_io_values( )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Gives the data stored In both IO1 and IO2</entry></row><row><entry/><entry>No inference is made on type.</entry></row><row><entry/><entry>Returns</entry></row><row><entry/><entry>A list that contains dictionaries with data from the IO registers. (Data is in all three</entry></row><row><entry/><entry>format: int, float, and bool)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;get_smearing(qe)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>get the smearing associated with a measurement quantum element.</entry></row><row><entry/><entry>This is a broadening of the raw results acquisition window, to account for dispersive</entry></row><row><entry/><entry>broadening in the measurement elements (readout resonators etc.) The acquisition</entry></row><row><entry/><entry>window will be broadened by this amount on both sides.</entry></row><row><entry/><entry>Parameters</entry></row><row><entry/><entry>qe (str) - the name of the element to get smearing for</entry></row><row><entry/><entry>Returns</entry></row><row><entry/><entry>the smearing, in nsec.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;get_time_of_flight(qe)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>get the time of flight, associated with a measurement quantum element.</entry></row><row><entry/><entry>This is the amount of time between the beginning of a measurement pulse applied to</entry></row><row><entry/><entry>quantum element and the time that the data is available to the controller for</entry></row><row><entry/><entry>demodulation or streaming.</entry></row><row><entry/><entry>Parameters</entry></row><row><entry/><entry>qe (str) - the name of the element to get time of flight for</entry></row><row><entry/><entry>Returns</entry></row><row><entry/><entry>the time of flight, in nsec</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;list_controllers( )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Gives a list with the defined controllers in this qm</entry></row><row><entry/><entry>Returns</entry></row><row><entry/><entry>The names of the controllers configured in this qm</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;save_config_to_file(filename)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Saves the qm current config to a file</entry></row><row><entry/><entry>Parameters</entry></row><row><entry/><entry>filename: The name of the file where the config will be saved</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_correction(qe, values)</entry></row><row><entry>&#x2003;Sets the correction matrix for correcting gain and phase imbalances of an IQ mixer associated</entry></row><row><entry>&#x2003;with a quantum element.</entry></row><row><entry>&#x2003;Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="329pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2022;</entry><entry>qe (str) - the name of the element to update the correction for</entry></row><row><entry>&#x2003;&#x2022;</entry><entry>values (tuple) - 4 value tuple which represents the correction matrix</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_dc_offset_by_qe(qe, input, offset)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>set the current DC offset of the quantum control module analog output channel</entry></row><row><entry/><entry>associated with a quantum element.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe (str) - the name of the element to update the correction for</entry></row><row><entry/><entry>&#x2022;</entry><entry>input (str) - the input name as appears in the element config. Options:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="203pt" align="left"/><colspec colname="1" colwidth="182pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2019;single&#x2019;</entry></row><row><entry/><entry>&#x2003;for an element with single input</entry></row><row><entry/><entry>&#x2019;I&#x2019; or &#x2018;Q&#x2019;</entry></row><row><entry/><entry>&#x2003;for an element with mixer inputs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>offset (float) - the dc value to set to, in normalized output units. Ranges from &#x2212;0.5</entry></row><row><entry/><entry/><entry>to 0.5 - 2{circumflex over (&#x2009;)}&#x2212;16 in steps of 2{circumflex over (&#x2009;)}&#x2212;16.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_digital_buffer(qe, digital_input, buffer)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>set the buffer for digital waveforms of the quantum element</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe (str) - the name of the element to update buffer for</entry></row><row><entry/><entry>&#x2022;</entry><entry>digital_input (str) - the digital input name as appears in the element's config</entry></row><row><entry/><entry>&#x2022;</entry><entry>buffer (int) - the buffer value to set to, in nsec. Range: 0 to (255 &#x2212; delay) / 2, in</entry></row><row><entry/><entry/><entry>steps of 1</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_digital_delay(qe, digital_input, delay)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Sets the delay of the digital waveform of the quantum element</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe (str) - the name of the element to update delay for</entry></row><row><entry/><entry>&#x2022;</entry><entry>digital_input (str) - the digital input name as appears in the element's config</entry></row><row><entry/><entry>&#x2022;</entry><entry>delay (int) - the delay value to set to, in nsec. Range: 0 to 255 &#x2212; 2 * buffer, in</entry></row><row><entry/><entry/><entry>steps of 1</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_frequency(qe, freq)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Sets the frequency of an element, at the output of the mixer, taking LO frequency into</entry></row><row><entry/><entry>account.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe (str) - the name of the element to update the correction for</entry></row><row><entry/><entry>&#x2022;</entry><entry>freq (float) - the frequency to set to the given element</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_intermediate_frequency(qe, freq)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Sets the intermediate frequency of the quantum element:</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe (str) - the name of the element to update the intermediate frequency for</entry></row><row><entry/><entry>&#x2022;</entry><entry>freq (float) - the intermediate frequency to set to the given element</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_io1_value(value_1)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Sets the value of IO1.</entry></row><row><entry/><entry>This can be used later inside a QUA program as a QUA variable IO1 without declaration.</entry></row><row><entry/><entry>The type of QUA variable is inferred from the python type passed to value_1, according</entry></row><row><entry/><entry>to the following rule:</entry></row><row><entry/><entry>int &#x2212;&#x3e; int float &#x2212;&#x3e; fixed bool &#x2212;&#x3e; bool</entry></row><row><entry/><entry>Parameters</entry></row><row><entry/><entry>value_1 (float | bool | int) - the value to be placed in IO1</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_io2_value(value_2)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Sets the value of IO1</entry></row><row><entry/><entry>This can be used later inside a QUA program as a QUA variable IO2 without declaration.</entry></row><row><entry/><entry>The type of QUA variable is inferred from the python type passed to value_2, according</entry></row><row><entry/><entry>to the following rule:</entry></row><row><entry/><entry>int &#x2212;&#x3e; int float &#x2212;&#x3e; fixed bool &#x2212;&#x3e; bool</entry></row><row><entry/><entry>Parameters</entry></row><row><entry/><entry>value_1 (float | bool | int) - the value to be placed in IO1</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_io_values(value_1, value_2)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>Sets the value of IO1 and IO2</entry></row><row><entry/><entry>This can be used later inside a QUA program as a QUA variable IO1, IO2 without</entry></row><row><entry/><entry>declaration. The type of QUA variable is inferred from the python type passed to</entry></row><row><entry/><entry>value_1, value_2 according to the following rule:</entry></row><row><entry/><entry>int &#x2212;&#x3e; int float &#x2212;&#x3e; fixed bool &#x2212;&#x3e; bool</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>value_1 (float | bool | int) - the value to be placed in IO1</entry></row><row><entry/><entry>&#x2022;</entry><entry>value_2 (float | bool | int) - the value to be placed in IO2</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_smearing(ge, smearing)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>set the smearing associated with a measurement quantum element.</entry></row><row><entry/><entry>This is a broadening of the raw results acquisition window, to account for dispersive</entry></row><row><entry/><entry>broadening in the measurement elements (readout resonators etc.) The acquisition</entry></row><row><entry/><entry>window will be broadened by this amount on both sides.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe (str) - the name of the element to set smearing for</entry></row><row><entry/><entry>&#x2022;</entry><entry>smearing (int) - the time, in nsec, to broaden the acquisition window. Range: 0 to</entry></row><row><entry/><entry/><entry>(255 &#x2212; time of flight)/2, in steps of 1.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="385pt" align="left"/><tbody valign="top"><row><entry>&#x2003;set_time_of_flight(qe, time_of_flight)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry/><entry>set the time of flight, associated with a measurement quantum element.</entry></row><row><entry/><entry>This is the amount of time between the beginning of a measurement pulse applied to</entry></row><row><entry/><entry>quantum element and the time that the data is available to the controller for</entry></row><row><entry/><entry>demodulation or streaming.</entry></row><row><entry/><entry>This time also accounts for processing delays, which are typically 176nsec.</entry></row><row><entry/><entry>Parameters</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="98pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="238pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2022;</entry><entry>qe (str) - the name of the element to set time of flight for</entry></row><row><entry/><entry>&#x2022;</entry><entry>time_of_flight (int) - the time of flight to set, in nsec. Range: 0 to 255 &#x2212; 2 *</entry></row><row><entry/><entry/><entry>smearing, in steps of 4.</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0182" num="0142">In block <b>1108</b>, compiler <b>906</b> receives the quantum machine specification and the QUA program (e.g., in the form of two plain text files).</p><p id="p-0183" num="0143">In block <b>1109</b>, compiler <b>906</b> attempts to compile the program using the quantum machine specification and the resources of the quantum controller <b>210</b> that the quantum machines manager <b>908</b> indicates are available for program execution. During compilation, the compiler determines and allocates the program resources of the quantum controller <b>210</b> that will be used in the program.</p><p id="p-0184" num="0144">In block <b>1110</b>, the compiler <b>906</b> determines whether compilation is successful. If not, then in block <b>1122</b> an alert is generated for the user (e.g., to inform the user that there are currently insufficient resources available to execute the program). If compilation is successful, then the process advances to block <b>1112</b>. If compilation is successful the compiler outputs the machine code to be loaded to the quantum controller for program execution.</p><p id="p-0185" num="0145">In block <b>1112</b>, the programming system <b>202</b> loads machine code generated by the compiler <b>906</b> based on the program, the quantum machine specification, and the available resources into quantum controller <b>210</b> (e.g., via I/O Manager <b>368</b>).</p><p id="p-0186" num="0146">In block <b>1114</b>, the programming subsystem <b>202</b> determines whether the machine code has been successfully loaded into the quantum controller <b>210</b>. If not, then in block <b>1122</b> an alert is generated for the user. If the machine code is successfully loaded, then the process advances to block <b>1116</b>.</p><p id="p-0187" num="0147">In block <b>1116</b>, the program is executed on the quantum controller and the quantum machines manager <b>908</b> updates its data structure of available resources to reflect the allocation of resources to the program.</p><p id="p-0188" num="0148">Either while the program is executing and/or after the program execution is over, the user may change the configuration/specification of the quantum machine. This may be done via a Quantum Machine API, an example implementation of which is shown in Table 6. An example of changing the configuration/specification of the quantum machine may be that the user uses the call to the set_frequency(qe, freq) function, which changes the frequency of the specified element to the specified frequency. In another example implementation such quantum machines API may include commands for changing any parameter defined in the specification (e.g. an API command may allow to change the definition of the samples of a specified waveform, change the parameters of a neural network associated with an element or a pulse, etc.) If the specification is changed while a program is running on the quantum machine, this may include writing to registers and/or memory of the quantum controller <b>210</b> while the program is executing as well as changing the specification in the quantum machines manager. If the specification is changed while no program is running on the quantum machine, this may include only changing the specification in the quantum machines manager. The ability to alter characteristics of the quantum machine without closing the quantum machine and even during execution of a QUA program on the quantum machine enables, for example, altering the quantum machine based on calculations performed on the quantum programming subsystem <b>202</b>. As an example, during execution of a QUA program, results may be streamed from the quantum controller <b>210</b> to the quantum programming subsystem <b>202</b>, the quantum programming subsystem <b>202</b> may perform some calculations using the results (e.g., resource-intensive calculations not possible or desirable to perform on the quantum controller <b>210</b>) and then update the quantum machine based on the calculations. The update may impact the currently running QUA program or a successive run of the same QUA program or a different QUA program without having to close the quantum machine for reconfiguration (which may be desirable to, for example, avoid having to repeat a calibration).</p><p id="p-0189" num="0149">In block <b>1118</b>, upon completing execution of the instructions, the program ends and the quantum machines manager <b>908</b> updates its data structure to deallocate the program resources that were allocated to that program and updates the available resources.</p><p id="p-0190" num="0150">In block <b>1120</b>, the process can advance either back to block <b>1107</b> again in which a user a user requests to execute a QUA program on the quantum machine, or to block <b>1124</b> in which a user closes the quantum machine. If the user closes the quantum machine the process advances to block <b>1126</b>.</p><p id="p-0191" num="0151">In block <b>1126</b> the quantum machines manager <b>908</b> deallocate the machine resources that were allocated to that quantum machine and updates the available resources.</p><p id="p-0192" num="0152">In an example implementation, the pulse generation program <b>904</b> is written using the QUA programming language.</p><p id="p-0193" num="0153">To aid understanding of the QOP's unique approach to quantum control, a use case example of Power Rabi Calibration will now be described, end-to-end. The use case begins by discussing the theoretical background of the experiment and its goals and showing a typical setup on which it is implemented. It is then shown, step by step, how to program the QOP to perform this experiment, how to execute it, and how to retrieve the results.</p><p id="p-0194" num="0154">The purpose of Power Rabi Calibration is to measure Rabi oscillations&#x2014;oscillations of the qubit state that are driven by a control signal. Assume that the qubit is initially in the ground state (state 0), a drive pulse is applied to rotate the qubit on the Bloch sphere around a rotation axis in the x-y plane. The qubit is then measured by calculating the effect of the resonator (that is coupled to the qubit) on a measurement pulse. The rotation angle, and consequently the probability to find the qubit in the excited state (1), depends on the amplitude of the drive pulse. The protocol is repeated with varying amplitudes (a). For each amplitude, the protocol is repeated many times for averaging, which allows extracting the probability of the qubit to be in the excited state after the drive pulse is applied. This probability is then plotted as a function of the drive amplitude, from which the rotation angle, as a function of the amplitude, can be extracted. This experiment provides an important tool for calibrating quantum gates. For example, the amplitude at which the qubit reaches a rotation of 180 degrees gives us the required amplitude for performing an X-gate (the quantum NOT gate). Similarly, this program can be run to identify the amplitude required to perform a &#x3c0;/2-rotation.</p><p id="p-0195" num="0155">The example experiment setup is shown in <figref idref="DRAWINGS">FIG. <b>12</b>A</figref>. The quantum device is a superconducting circuit composed of a single, fixed frequency qubit and a readout resonator, with the following Hamiltonian:</p><p id="p-0196" num="0000"><maths id="MATH-US-00012" num="00012"><math overflow="scroll"> <mrow>  <mi>H</mi>  <mo>=</mo>  <mrow>   <mrow>    <mfrac>     <mi>&#x210f;</mi>     <mn>2</mn>    </mfrac>    <mo>&#x2062;</mo>    <msub>     <mi>&#x3c9;</mi>     <mi>Q</mi>    </msub>    <mo>&#x2062;</mo>    <msub>     <mi>&#x3c3;</mi>     <mi>Z</mi>    </msub>   </mrow>   <mo>+</mo>   <mrow>    <msub>     <mi>&#x210f;&#x3c9;</mi>     <mi>R</mi>    </msub>    <mo>&#x2062;</mo>    <msup>     <mi>a</mi>     <mo>&#x2020;</mo>    </msup>    <mo>&#x2062;</mo>    <mi>a</mi>   </mrow>   <mo>+</mo>   <mrow>    <mi>&#x210f;</mi>    <mo>&#x2062;</mo>    <mrow>     <mrow>      <mi>g</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <mrow>        <msup>         <mi>a</mi>         <mo>&#x2020;</mo>        </msup>        <mo>&#x2062;</mo>        <msup>         <mi>&#x3c3;</mi>         <mo>-</mo>        </msup>       </mrow>       <mo>+</mo>       <mrow>        <mi>a</mi>        <mo>&#x2062;</mo>        <msup>         <mi>&#x3c3;</mi>         <mo>+</mo>        </msup>       </mrow>      </mrow>      <mo>)</mo>     </mrow>     <mo>.</mo>    </mrow>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0197" num="0156">Since the interaction between the qubit and resonator is dispersive (|&#x3c9;<sub>R</sub>&#x2212;&#x3c9;<sub>Q</sub>|), an approximation can be made that leads to the following form of the Hamiltonian:</p><p id="p-0198" num="0000"><maths id="MATH-US-00013" num="00013"><math overflow="scroll"> <mrow>  <mi>H</mi>  <mo>=</mo>  <mrow>   <mrow>    <mfrac>     <mi>&#x210f;</mi>     <mn>2</mn>    </mfrac>    <mo>&#x2062;</mo>    <mrow>     <mo>(</mo>     <mrow>      <msub>       <mi>&#x3c9;</mi>       <mi>Q</mi>      </msub>      <mo>+</mo>      <mfrac>       <msup>        <mi>g</mi>        <mn>2</mn>       </msup>       <mi>&#x394;</mi>      </mfrac>     </mrow>     <mo>)</mo>    </mrow>    <mo>&#x2062;</mo>    <msub>     <mi>&#x3c3;</mi>     <mi>Z</mi>    </msub>   </mrow>   <mo>+</mo>   <mrow>    <mrow>     <mi>&#x210f;</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msub>       <mi>&#x3c9;</mi>       <mi>R</mi>      </msub>      <mo>+</mo>      <mrow>       <mfrac>        <msup>         <mi>g</mi>         <mn>2</mn>        </msup>        <mi>&#x394;</mi>       </mfrac>       <mo>&#x2062;</mo>       <msub>        <mi>&#x3c3;</mi>        <mi>Z</mi>       </msub>      </mrow>     </mrow>     <mo>)</mo>    </mrow>    <mo>&#x2062;</mo>    <msup>     <mi>a</mi>     <mo>&#x2020;</mo>    </msup>    <mo>&#x2062;</mo>    <mi>a</mi>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0199" num="0000">Where &#x394;=&#x3c9;<sub>Q</sub>&#x2212;&#x3c9;<sub>R</sub>. Finally, the qubit driving term can be explicitly included, which leads to the Hamiltonian:</p><p id="p-0200" num="0000"><maths id="MATH-US-00014" num="00014"><math overflow="scroll"> <mrow>  <mi>H</mi>  <mo>=</mo>  <mrow>   <msub>    <mi>H</mi>    <mn>0</mn>   </msub>   <mo>+</mo>   <mrow>    <mi>&#x210f;</mi>    <mo>&#x2062;</mo>    <mrow>     <mi>s</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mi>t</mi>     <mo>)</mo>    </mrow>    <mo>&#x2062;</mo>    <msub>     <mi>&#x3c3;</mi>     <msup>      <mi>x</mi>      <mo>.</mo>     </msup>    </msub>   </mrow>   <mo>+</mo>   <mrow>    <mfrac>     <mrow>      <mi>m</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mi>t</mi>      <mo>)</mo>     </mrow>     <mn>2</mn>    </mfrac>    <mo>[</mo>    <mrow>     <mrow>      <msup>       <mi>a</mi>       <mo>&#x2020;</mo>      </msup>      <mo>&#x2062;</mo>      <msup>       <mi>e</mi>       <mrow>        <mrow>         <mo>-</mo>         <mi>i</mi>        </mrow>        <mo>&#x2062;</mo>        <mi>&#x3c9;</mi>        <mo>&#x2062;</mo>        <mi>t</mi>       </mrow>      </msup>     </mrow>     <mo>+</mo>     <mrow>      <mi>a</mi>      <mo>&#x2062;</mo>      <msup>       <mi>e</mi>       <mrow>        <mi>i</mi>        <mo>&#x2062;</mo>        <mi>&#x3c9;</mi>        <mo>&#x2062;</mo>        <mi>t</mi>       </mrow>      </msup>     </mrow>    </mrow>    <mo>]</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0201" num="0157">Here it is assumed that the frequencies of both the qubit and the resonator were calibrated in advance.</p><p id="p-0202" num="0158">A signal, at the resonance frequency of the qubit, of the form</p><p id="p-0203" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>s</i>(<i>t</i>)=<i>A </i>cos(&#x3c9;<sub>Q</sub><i>t</i>+&#x3d5;)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0204" num="0000">rotates the Bloch vector of the qubit at a rate A around the axis which is on the x-y plane and is rotated by an angle &#x3c6; from the x-axis.</p><p id="p-0205" num="0159">If the parameters A(t) and &#x3c6;(t) are varied slowly compared to &#x3c9;<sub>Q</sub>, then this still holds at each point in time. Thus, if a pulse is sent (i.e. a signal that is finite in time) to the qubit of the form</p><p id="p-0206" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>s</i>(<i>t</i>)=<i>A</i>(<i>t</i>)cos(&#x3c9;<sub>Q</sub><i>t</i>+&#x3d5;)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0207" num="0000">where A(t) varies slowly compared to &#x3c9;<sub>Q</sub>, the Bloch vector will be rotated around the above axis by a total angle which is given by the integral of A(t):</p><p id="p-0208" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>&#x3b8;=&#x222b;<sub>t</sub><sub><sub2>0</sub2></sub><sup>t</sup><sup><sub2>0</sub2></sup><sup>+&#x3c4;</sup><i>+TA</i>(<i>t</i>)<i>dt. </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0209" num="0000">Here t<sub>0 </sub>is the time at which the pulse starts and t is the duration of the pulse.</p><p id="p-0210" num="0160">In a typical Power Rabi Oscillations experiment, the shape and duration of the pulse A(t) are fixed (e.g. a 20-nanosecond gaussian pulse) and only its amplitude is varied in order to get different rotation angles &#x3b8;. The experiment performed by repeating the following basic sequence:</p><p id="p-0211" num="0000">(1) Initialize the qubit to the ground state, 0.<br/>(2) Apply a pulse with amplitude a (e.g. A(t) is a Gaussian shaped pulse with peak amplitude a, which rotates the qubit by &#x3b8; so that the qubit is in the state</p><p id="p-0212" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>cos(&#x3b8;<sub>a</sub>)|<img id="CUSTOM-CHARACTER-00011" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00003.TIF" alt="custom-character" img-content="character" img-format="tif"/>+<i>e</i><sup>i&#x3d5;</sup> sin(&#x3b8;<sub>a</sub>)|1<img id="CUSTOM-CHARACTER-00012" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/>.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0213" num="0000">(3) Apply a resonant pulse to the readout resonator, and from the phase of the reflected pulse, deduce the state of the qubit.</p><p id="p-0214" num="0161">This basic sequence is repeated in the program for a series of amplitudes (i.e., many values of a), where for each amplitude, a, it is repeated N times (i.e. N identical basic sequences with the same a). N identical measurements are required because of state collapse. The measurement at the end of each basic sequence gives a binary result (0 or 1) for the state of the qubit, even if before the measurement the qubit was in a superposition state. However, when the results of the N identical basic sequences are averaged, the average will be &#x2dc;sin<sup>2</sup>(&#x3b8;). Denote this average as <img id="CUSTOM-CHARACTER-00013" he="2.79mm" wi="3.89mm" file="US20230006661A1-20230105-P00004.TIF" alt="custom-character" img-content="character" img-format="tif"/>(a) since it reflects the probability of measuring the qubit in the |1<img id="CUSTOM-CHARACTER-00014" he="2.46mm" wi="1.44mm" file="US20230006661A1-20230105-P00005.TIF" alt="custom-character" img-content="character" img-format="tif"/> state for a given amplitude, a. The results of the whole experiment can be summarized by plotting <img id="CUSTOM-CHARACTER-00015" he="2.79mm" wi="3.89mm" file="US20230006661A1-20230105-P00006.TIF" alt="custom-character" img-content="character" img-format="tif"/>(a) as a function of a (see <figref idref="DRAWINGS">FIG. <b>12</b>B</figref>).</p><p id="p-0215" num="0162">This can be used to calibrate any single qubit rotation gate that rotates the qubit by an angle &#x3b8;, around a rotation axis that is on the x-y plane and is rotated &#x3c6; from the x-axis. Such a gate is denoted by R<sub>&#x3d5;(&#x3b8;)</sub>. In fact, one of the typical goals of the Power Rabi Oscillations experiment is to calibrate the amplitude of a given pulse so that it performs &#x3c0;-rotation (X-gate) or &#x3c0;/2-rotation. &#x3c6;, however, cannot be determined from the Rabi oscillations and must be determined by other means (e.g. tomography).</p><p id="p-0216" num="0163">An example implementation of the Power Rabi experiment in the QOP will now be described.</p><p id="p-0217" num="0164">The experiment is implemented on the QOP as follows: (1) Defining a quantum machine specification; (2) Opening an interface to the quantum machine; (3) Writing the program; (4) Running the program; (5) Saving the results</p><p id="p-0218" num="0165">As discussed above, the quantum machine specification is a description of the physical elements present in the experimental setup and their properties, as well as the connectivity between the elements and the quantum control module(s). The physical elements that are connected to the quantum control module(s) are denoted in the quantum machine specification as elements, which are discrete entities such as qubits, readout resonators, flux lines, gate electrodes, etc. Each of these has inputs and in some cases outputs, connected to the quantum control module(s). The properties of the elements and their connectivity to the quantum control module(s) are used by the QOP to interpret and execute QUA programs correctly (e.g. a pulse played to a certain qubit is modulated by the quantum control module with the intermediate frequency defined for this element). The quantum machine specification in <figref idref="DRAWINGS">FIGS. <b>10</b>A-<b>10</b>C</figref> is used for this particular example.</p><p id="p-0219" num="0166">The pulses applied to the elements are also specified in the quantum machine specification, where each pulse is defined as a collection of temporal waveforms. For example, a pulse to an element with two analog inputs and one digital input will specify the two waveforms applied to the analog inputs of the element and the digital pulse applied to its digital input.</p><p id="p-0220" num="0167">Also defined in the quantum machine specification are the properties of any auxiliary components that affect the actual output of the controller, such as IQ mixers and local oscillators.</p><p id="p-0221" num="0168">After defining the quantum machine specification, an interface to a new quantum machine can be opened with the following command:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0169">my_qm=qmManager.open_qm(my_config)</li>    </ul>    </li></ul></p><p id="p-0222" num="0170">After having defined the quantum machine specification, write the QUA program. Below is the power Rabi program.</p><p id="p-0223" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>with program( ) as powerRabiProg :</entry></row><row><entry/><entry>&#x2003;I = declare(fixed)</entry></row><row><entry/><entry>&#x2003;Q = declare(fixed)</entry></row><row><entry/><entry>&#x2003;a = declare(fixed)</entry></row><row><entry/><entry>&#x2003;Nrep = declare(int)</entry></row><row><entry/><entry>&#x2003;with for_(Nrep, 0, Nrep &#x3c; 100, Nrep + 1):</entry></row><row><entry/><entry>&#x2003;&#x2003;with for_(a, 0.00, a &#x3c;= 1.0, a + 0.01):</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;play(&#x2018;gauss_pulse&#x2019;*amp(a), &#x2018;qubit&#x2019;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;align(&#x201c;qubit&#x201d;, &#x201c;RR&#x201d;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;measure(&#x2018;meas_pulse&#x2019;, &#x2018;RR&#x2019;, &#x2018;samples&#x2019;,(&#x2018;integW1&#x2019;,I),</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;(&#x2018;integW2&#x2019;,Q))</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;save(I, &#x2018;I&#x2019;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;save(Q, &#x2018;Q&#x2019;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;save(a, &#x2018;a&#x2019;)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0224" num="0171">The program is very intuitive to someone who knows the theory of the Power Rabi calibration, which illustrates one of the benefits of the QOP: the ability for people (e.g., quantum physicists) to rapidly design and run quantum experiments without first having to become expert programmers or computer systems designers. This is in stark contrast to current systems which, for example, require quantum physicists to learn a hardware description language such as VHDL or Verilog to be able to run their quantum experiments/algorithms.</p><p id="p-0225" num="0172">This program: (1) Defines the variables a (amplitude) and Nrep (number of repetitions), as well as the variables I and Q, which store the demodulation result; and (2) Performs 100 repetitions (the loop over Nrep), where in each scan loops over 100 values of a, from 0-1 in increments of 0.01 and for each value of a performs the Rabi sequence: playing a pulse with amplitude a to the qubit, then measuring the resonator response and extracting from it the state of the qubit. This is done by sending a measurement pulse to the resonator and demodulating and integrating the returning pulse using the indicated integration weights.</p><p id="p-0226" num="0173">The raw data sampled at the quantum control module's input is also streamed and saved with the label &#x2018;samples.&#x2019; Finally, the demodulation and integration results, I and Q, are saved as well as the corresponding amplitude.</p><p id="p-0227" num="0174">This Python code block creates an object named powerRabiProg, which is a QUA program that can be executed on an open quantum machine.</p><p id="p-0228" num="0175">The program is run on a quantum machine &#x201c;my_qm&#x201d; defined in the quantum machine specification using the following command which saves the results in the job object &#x201c;my_job.&#x201d;<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0176">myjob=my_qm.execute(powerRabiProg)</li>    </ul>    </li></ul></p><p id="p-0229" num="0177">After the program is executed, the results can be pulled:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0178">my_powerRabi_results=job.get_results( )</li>    </ul>    </li></ul></p><p id="p-0230" num="0179">This command pulls the results from &#x201c;myjob&#x201d; to the results object &#x201c;my_powerRabi_results&#x201d;.</p><p id="p-0231" num="0180">The data in &#x201c;my_powerRabi_results&#x201d; is a Python object which contains the variables saved during the program, as well as all the raw data sampled at the input of the quantum control module. Here, &#x201c;my_powerRabi_results&#x201d; will have: (1) my_powerRabi_results.variable_results, which will be a dictionary containing three keys: &#x2018;I&#x2019;, &#x2018;Q&#x2019; and &#x2018;a&#x2019;. The value for each key will be a dictionary containing the saved data and the time stamp for each saved data point; (2) my_powerRabi_results.raw_results, which will be a dictionary containing a single key and its value will be a dictionary containing the sampled input data and the timestamp of each data point.</p><p id="p-0232" num="0181">In accordance with an example implementation of this disclosure, a system comprises pulse generation and measurement circuitry (e.g., <b>210</b>) comprising a plurality of pulse generator circuits (e.g., <b>302</b>) and a plurality of ports (e.g., ports of signal path(s) <b>304</b>, <b>306</b>, and/or <b>308</b>), and management circuitry (e.g., <b>202</b> and part of <b>210</b>). The management circuitry is operable to analyze a specification of a control system and controlled elements (e.g., specification <b>902</b>) that comprises a definition of a controlled element of the control system, and a definition of one or more pulses available for transmission by the control system. The management circuitry is operable to configure, based on the specification, the pulse generation and measurement circuitry to: generate the one or more pulses via one or more of the plurality of pulse generator circuits; and output the one or more pulses to the controlled element via one or more of the plurality of ports. The configuration of the pulse generation and measurement circuitry may comprise generation of one or more pulse modification settings and storage of the one or more pulse modification settings to pulse modification circuitry (e.g., <b>504</b><sub>0</sub>-<b>504</b><sub>K-1</sub>) of the pulse generation and measurement circuitry. The configuration of the pulse generation and measurement circuitry may comprise generation of pulse templates and storage of the pulse templates to pulse memory (<b>404</b>) of the pulse generation and measurement circuitry. The configuration of the pulse generation and measurement circuitry may comprise generation of instructions for a processor (e.g., <b>410</b>) of the pulse generation and modification circuitry to perform classical computations and storage of the instructions to the processor. The configuration of the pulse generation and measurement circuitry may comprise generation of digital signal processing path configuration settings and storage of the digital signal processing path configuration settings to digital signal generation circuitry (e.g., <b>376</b>) of the pulse generation and measurement circuitry. The definition of the controlled element may specify whether the controlled element is to be controlled with independent pulses or with two-pair pulses (e.g., via &#x201c;singleInput&#x201d; and &#x201c;mixInputs&#x201d; properties). The definition of the controlled element may specify a frequency with which pulses sent to the controlled element are to be modulated (e.g., via an &#x201c;intermediate_frequency&#x201d; property). The definition of the controlled element may specify which of the one or more pulses are to be available for transmission to the controlled element (e.g., via an &#x201c;operations&#x201d; property). The definition of the controlled element may specify which of the plurality of ports are connected to which of one or more inputs of the controlled element of the first control system (e.g., via &#x201c;mixinputs&#x201d; or &#x201c;singleInput&#x201d; properties). The definition of the controlled element may specify whether the controlled element has an output (e.g., via an &#x201c;outputs&#x201d; property), and, if the controlled element has an output, one or more timing parameters to be used for receiving signals from the controlled element (e.g., via &#x201c;smearing&#x201d; and/or &#x201c;time-of-flight&#x201d; property). The one or more timing parameters determine, at least in part, one or both of: a duration of an acquisition window; and a delay between when a pulse is transmitted to the controlled element and when measurement of a signal from the controlled element should begin. The definition of the controlled element may specify one or more digital inputs of the controlled element (e.g., via a &#x201c;digital inputs&#x201d; property). The definition of the controlled element may specify a delay between a send time of a pulse destined for the controlled element and a send time of a digital signal accompanying the pulse destined for the controlled element (e.g., via a &#x201c;delay&#x201d; property). The definition of the controlled element may specify convolution parameters and/or delay parameters for use with digital signals sent to the controlled element (e.g., via a &#x201c;buffer&#x201d;. The definition of the controlled element may specify a circuit element associated with the controlled element (e.g., in the signal path to the controlled element), The circuit element may be a of particular type (e.g., a mixer) specified by a property named after the type of circuit (e.g., &#x201c;mixer&#x201d;)). The control system specification comprises a definition of the circuit element, and the definition of the circuit element may comprise a parameter for compensating for nonidealities of the circuit element (e.g., a mixer correction matrix). The definition of the one or more pulses may specify one or more parameters to be used for processing signals from the controlled element (e.g., integration weights, a filter transfer function, etc.). The specification may comprise a definition of the one or more parameters, which may take the form of a plurality of vectors. The definition of the one or more pulses may specify one or more waveforms to be used for generation of the one or more pulses (e.g., via a &#x201c;waveforms&#x201d; property). The specification may comprise a definition of the one or more waveforms. The definition of the one or more waveforms which may take the form of a collection (e.g., list, string, array, etc.) of samples of the one or more waveforms. The definition of the one or more pulses may specify one or more digital signals that are to be output along with the one or more pulses. The specification may comprise a definition of the one or more digital signals. The definition of the one or more digital signals may specify the digital values of the one or more digital signals and how long each of the digital values is to be output. The management circuitry may be operable to receive commands via an application programming interface (e.g., a quantum machine API, an example of which is shown in Table 6), and the configuration may be based on the commands such that the commands supplement the specification and/or override one or more definitions in the specification.</p><p id="p-0233" num="0182">The present method and/or system may be realized in hardware, software, or a combination of hardware and software. The present methods and/or systems may be realized in a centralized fashion in at least one computing system, or in a distributed fashion where different elements are spread across several interconnected computing systems. Any kind of computing system or other apparatus adapted for carrying out the methods described herein is suited. A typical implementation may comprise one or more application specific integrated circuit (ASIC), one or more field programmable gate array (FPGA), and/or one or more processor (e.g., x86, x64, ARM, PIC, and/or any other suitable processor architecture) and associated supporting circuitry (e.g., storage, DRAM, FLASH, bus interface circuits, etc.). Each discrete ASIC, FPGA, Processor, or other circuit may be referred to as &#x201c;chip,&#x201d; and multiple such circuits may be referred to as a &#x201c;chipset.&#x201d; Another implementation may comprise a non-transitory machine-readable (e.g., computer readable) medium (e.g., FLASH drive, optical disk, magnetic storage disk, or the like) having stored thereon one or more lines of code that, when executed by a machine, cause the machine to perform processes as described in this disclosure. Another implementation may comprise a non-transitory machine-readable (e.g., computer readable) medium (e.g., FLASH drive, optical disk, magnetic storage disk, or the like) having stored thereon one or more lines of code that, when executed by a machine, cause the machine to be configured (e.g., to load software and/or firmware into its circuits) to operate as a system described in this disclosure.</p><p id="p-0234" num="0183">As used herein the terms &#x201c;circuits&#x201d; and &#x201c;circuitry&#x201d; refer to physical electronic components (i.e. hardware) and any software and/or firmware (&#x201c;code&#x201d;) which may configure the hardware, be executed by the hardware, and or otherwise be associated with the hardware. As used herein, for example, a particular processor and memory may comprise a first &#x201c;circuit&#x201d; when executing a first one or more lines of code and may comprise a second &#x201c;circuit&#x201d; when executing a second one or more lines of code. As used herein, &#x201c;and/or&#x201d; means any one or more of the items in the list joined by &#x201c;and/or&#x201d;. As an example, &#x201c;x and/or y&#x201d; means any element of the three-element set {(x), (y), (x, y)}. As another example, &#x201c;x, y, and/or z&#x201d; means any element of the seven-element set {(x), (y), (z), (x, y), (x, z), (y, z), (x, y, z)}. As used herein, the term &#x201c;exemplary&#x201d; means serving as a non-limiting example, instance, or illustration. As used herein, the terms &#x201c;e.g.,&#x201d; and &#x201c;for example&#x201d; set off lists of one or more non-limiting examples, instances, or illustrations. As used herein, circuitry is &#x201c;operable&#x201d; to perform a function whenever the circuitry comprises the necessary hardware and code (if any is necessary) to perform the function, regardless of whether performance of the function is disabled or not enabled (e.g., by a user-configurable setting, factory trim, etc.). As used herein, the term &#x201c;based on&#x201d; means &#x201c;based at least in part on.&#x201d; For example, &#x201c;x based on y&#x201d; means that &#x201c;x&#x201d; is based at least in part on &#x201c;y&#x201d; (and may also be based on z, for example).</p><p id="p-0235" num="0184">While the present method and/or system has been described with reference to certain implementations, it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted without departing from the scope of the present method and/or system. In addition, many modifications may be made to adapt a particular situation or material to the teachings of the present disclosure without departing from its scope. Therefore, it is intended that the present method and/or system not be limited to the particular implementations disclosed, but that the present method and/or system will include all implementations falling within the scope of the appended claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230006661A1-20230105-M00001.NB"><img id="EMI-M00001" he="5.67mm" wi="76.20mm" file="US20230006661A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230006661A1-20230105-M00002.NB"><img id="EMI-M00002" he="5.67mm" wi="76.20mm" file="US20230006661A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00003" nb-file="US20230006661A1-20230105-M00003.NB"><img id="EMI-M00003" he="6.01mm" wi="76.20mm" file="US20230006661A1-20230105-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00004" nb-file="US20230006661A1-20230105-M00004.NB"><img id="EMI-M00004" he="6.01mm" wi="76.20mm" file="US20230006661A1-20230105-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00005" nb-file="US20230006661A1-20230105-M00005.NB"><img id="EMI-M00005" he="6.01mm" wi="76.20mm" file="US20230006661A1-20230105-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00006" nb-file="US20230006661A1-20230105-M00006.NB"><img id="EMI-M00006" he="5.67mm" wi="76.20mm" file="US20230006661A1-20230105-M00006.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00007" nb-file="US20230006661A1-20230105-M00007.NB"><img id="EMI-M00007" he="5.67mm" wi="76.20mm" file="US20230006661A1-20230105-M00007.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00008" nb-file="US20230006661A1-20230105-M00008.NB"><img id="EMI-M00008" he="5.67mm" wi="76.20mm" file="US20230006661A1-20230105-M00008.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00009" nb-file="US20230006661A1-20230105-M00009.NB"><img id="EMI-M00009" he="12.70mm" wi="76.20mm" file="US20230006661A1-20230105-M00009.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00010" nb-file="US20230006661A1-20230105-M00010.NB"><img id="EMI-M00010" he="7.03mm" wi="76.20mm" file="US20230006661A1-20230105-M00010.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00011" nb-file="US20230006661A1-20230105-M00011.NB"><img id="EMI-M00011" he="6.01mm" wi="76.20mm" file="US20230006661A1-20230105-M00011.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00012" nb-file="US20230006661A1-20230105-M00012.NB"><img id="EMI-M00012" he="5.67mm" wi="76.20mm" file="US20230006661A1-20230105-M00012.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00013" nb-file="US20230006661A1-20230105-M00013.NB"><img id="EMI-M00013" he="7.03mm" wi="76.20mm" file="US20230006661A1-20230105-M00013.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00014" nb-file="US20230006661A1-20230105-M00014.NB"><img id="EMI-M00014" he="5.25mm" wi="76.20mm" file="US20230006661A1-20230105-M00014.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-01-24" num="01-24"><claim-text><b>1</b>-<b>24</b>. (canceled)</claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. A system comprising:<claim-text>a plurality of pulse generator circuits, wherein the plurality of pulse generator circuits comprises a plurality of output ports; and</claim-text><claim-text>a pulse management circuit operable to receive a definition of one or more pulses and a selection of one or more output ports of the plurality of output ports, wherein:<claim-text>the pulse management circuit is operable to configure the plurality of pulse generator circuits to output the one or more pulses from the one or more output ports,</claim-text><claim-text>an RF signal is generated according to the one or more pulses, and</claim-text><claim-text>the RF signal is configured to interact with a quantum element.</claim-text></claim-text></claim-text></claim><claim id="CLM-00026" num="00026"><claim-text><b>26</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the system comprises a pulse modification circuit operably coupled between the plurality of pulse generator circuits and the quantum element, wherein the pulse modification circuit is configurable according to one or more pulse modification settings.</claim-text></claim><claim id="CLM-00027" num="00027"><claim-text><b>27</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the system comprises a pulse memory operable to store a pulse template, and wherein the pulse template is used to configure the plurality of pulse generator circuits.</claim-text></claim><claim id="CLM-00028" num="00028"><claim-text><b>28</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the system comprises a processor that is operable to perform classical computations, and wherein the configuration of the plurality of pulse generator circuits comprises generation of instructions for the processor.</claim-text></claim><claim id="CLM-00029" num="00029"><claim-text><b>29</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the configuration of the plurality of pulse generator circuits comprises a generation of instructions to be executed by the plurality of pulse generator circuits.</claim-text></claim><claim id="CLM-00030" num="00030"><claim-text><b>30</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the system comprises a digital signal generator, and wherein the configuration of the plurality of pulse generator circuits comprises a generation of digital signal processing settings for the digital signal generator.</claim-text></claim><claim id="CLM-00031" num="00031"><claim-text><b>31</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein:<claim-text>the configuration of the plurality of pulse generator circuits is based on whether the quantum element is to be controlled with independent pulses or with two-pair pulses.</claim-text></claim-text></claim><claim id="CLM-00032" num="00032"><claim-text><b>32</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the one or more pulses are modulated on a selectable frequency.</claim-text></claim><claim id="CLM-00033" num="00033"><claim-text><b>33</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the configuration of the plurality of pulse generator circuits operates according to one or more timing parameters, and wherein the one or more timing parameters are used for receiving signals from the quantum element.</claim-text></claim><claim id="CLM-00034" num="00034"><claim-text><b>34</b>. The system of <claim-ref idref="CLM-00033">claim 33</claim-ref>, wherein the one or more timing parameters determine, at least in part, one or both of a duration of an acquisition window and a delay between when a pulse is transmitted to the quantum element and when measurement of a signal from the quantum element should begin.</claim-text></claim><claim id="CLM-00035" num="00035"><claim-text><b>35</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the configuration of the plurality of pulse generator circuits uses the one or more digital inputs.</claim-text></claim><claim id="CLM-00036" num="00036"><claim-text><b>36</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the configuration of the plurality of pulse generator circuits uses a convolution parameter and/or a delay parameter.</claim-text></claim><claim id="CLM-00037" num="00037"><claim-text><b>37</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the system comprises a mixer operably coupled between the plurality of pulse generator circuits and the quantum element.</claim-text></claim><claim id="CLM-00038" num="00038"><claim-text><b>38</b>. The system of <claim-ref idref="CLM-00037">claim 37</claim-ref>, wherein the mixer is configurable according to a mixer correction matrix.</claim-text></claim><claim id="CLM-00039" num="00039"><claim-text><b>39</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the plurality of pulse generator circuits are configured according to a plurality of vectors.</claim-text></claim><claim id="CLM-00040" num="00040"><claim-text><b>40</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the plurality of pulse generator circuits are configured according to one or more parameters of a neural network.</claim-text></claim><claim id="CLM-00041" num="00041"><claim-text><b>41</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the one or more pulses are defined by a collection of samples of one or more waveforms.</claim-text></claim><claim id="CLM-00042" num="00042"><claim-text><b>42</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the plurality of pulse generator circuits are operable to generate one or more digital signals.</claim-text></claim><claim id="CLM-00043" num="00043"><claim-text><b>43</b>. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the configuration is based on commands received via an application programming interface.</claim-text></claim></claims></us-patent-application>