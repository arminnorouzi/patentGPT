<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004524A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004524</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17901480</doc-number><date>20220901</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>82</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>4401</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>82</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>4406</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">METHOD OF NOTIFYING A PROCESS OR PROGRAMMABLE ATOMIC OPERATION TRAPS</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17074779</doc-number><date>20201020</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11436187</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17901480</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Micron Technology, Inc.</orgname><address><city>Boise</city><state>ID</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Brewer</last-name><first-name>Tony</first-name><address><city>Plano</city><state>TX</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Disclosed in some examples, are methods, systems, programmable atomic units, and machine-readable mediums that provide an exception as a response to the calling processor. That is, the programmable atomic unit will send a response to the calling processor. The calling processor will recognize that the exception has been raised and will handle the exception. Because the calling processor knows which process triggered the exception, the calling processor (e.g., the Operating System) can take appropriate action, such as terminating the calling process. The calling processor may be a same processor as that executing the programmable atomic transaction, or a different processor (e.g., on a different chiplet).</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="116.25mm" wi="158.75mm" file="US20230004524A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="230.38mm" wi="150.96mm" file="US20230004524A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="200.66mm" wi="155.36mm" orientation="landscape" file="US20230004524A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="189.48mm" wi="153.75mm" file="US20230004524A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="231.14mm" wi="168.49mm" orientation="landscape" file="US20230004524A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="230.80mm" wi="168.49mm" orientation="landscape" file="US20230004524A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="230.80mm" wi="154.60mm" orientation="landscape" file="US20230004524A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="233.43mm" wi="128.02mm" file="US20230004524A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="233.43mm" wi="129.20mm" file="US20230004524A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="242.57mm" wi="155.19mm" orientation="landscape" file="US20230004524A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="235.63mm" wi="147.07mm" file="US20230004524A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">PRIORITY APPLICATION</heading><p id="p-0002" num="0001">This application is a continuation of U.S. application Ser. No. 17/074,779, filed Oct. 20, 2020, which is incorporated herein by reference in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?federal-research-statement description="Federal Research Statement" end="lead"?><heading id="h-0002" level="1">STATEMENT REGARDING GOVERNMENT SUPPORT</heading><p id="p-0003" num="0002">This invention was made with U.S. Government support under Agreement No. HR00111890003, awarded by DARPA. The U.S. Government has certain rights in the invention.</p><?federal-research-statement description="Federal Research Statement" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Chiplets are an emerging technique for integrating various processing functionalities. Generally, a chiplet system is made up of discreet modules (each a &#x201c;chiplet&#x201d;) that are integrated on an interposer, and in many examples interconnected as desired through one or more established networks, to provide a system with the desired functionality. The interposer and included chiplets may be packaged together to facilitate interconnection with other components of a larger system. Each chiplet may include one or more individual integrated circuits, or &#x201c;chips&#x201d; (ICs), potentially in combination with discrete circuit components, and commonly coupled to a respective substrate to facilitate attachment to the interposer. Most or all chiplets in a system will be individually configured for communication through the one or more established networks.</p><p id="p-0005" num="0004">The configuration of chiplets as individual modules of a system is distinct from such a system being implemented on single chips that contain distinct device blocks (e.g., intellectual property (IP) blocks) on one substrate (e.g., single die), such as a system-on-a-chip (SoC), or multiple discrete packaged devices integrated on a printed circuit board (PCB). In general, chiplets provide better performance (e.g., lower power consumption, reduced latency, etc.) than discrete packaged devices, and chiplets provide greater production benefits than single die chips. These production benefits can include higher yields or reduced development costs and time.</p><p id="p-0006" num="0005">Chiplet systems may include, for example, one or more application (or processor) chiplets and one or more support chiplets. Here, the distinction between application and support chiplets is simply a reference to the likely design scenarios for the chiplet system. Thus, for example, a synthetic vision chiplet system can include, by way of example only, an application chiplet to produce the synthetic vision output along with support chiplets, such as a memory controller chiplet, a sensor interface chiplet, or a communication chiplet. In a typical use case, the synthetic vision designer can design the application chiplet and source the support chiplets from other parties. Thus, the design expenditure (e.g., in terms of time or complexity) is reduced because by avoiding the design and production of functionality embodied in the support chiplets. Chiplets also support the tight integration of IP blocks that can otherwise be difficult, such as those manufactured using different processing technologies or using different feature sizes (or utilizing different contact technologies or spacings). Thus, multiple IC's or IC assemblies, with different physical, electrical, or communication characteristics may be assembled in a modular manner to provide an assembly providing desired functionalities. Chiplet systems can also facilitate adaptation to suit needs of different larger systems into which the chiplet system will be incorporated. In an example, IC's or other assemblies can be optimized for the power, speed, or heat generation for a specific function&#x2014;as can happen with sensors&#x2014;can be integrated with other devices more easily than attempting to do so on a single die. Additionally, by reducing the overall size of the die, the yield for chiplets tends to be higher than that of more complex, single die devices.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0007" num="0006">The disclosure will be understood more fully from the detailed description given below and from the accompanying drawings of various embodiments of the disclosure. The drawings, however, should not be taken to limit the disclosure to the specific embodiments, but are for explanation and understanding only.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIGS. <b>1</b>A and <b>1</b>B</figref> illustrate an example of a chiplet system, according to an embodiment.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates components of an example of a memory controller chiplet, according to an embodiment.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates components in an example of a programmable atomic unit (PAU), according to an embodiment.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates a request packet for requesting execution of a particular programmable atomic according to some examples of the present disclosure.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a programmable atomic response message according to some examples of the present disclosure.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a programmable atomic trap response according to some examples of the present disclosure.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a flowchart of a method of a programmable atomic unit providing a notification to a calling processor that the programmable atomic ended with an exception according to some examples of the present disclosure.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a flowchart of a method of a calling processor notifying an operating system according to some examples of the present disclosure.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates a block diagram of a memory controller according to some examples of the present disclosure.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram of an example of a machine with which, in which, or by which embodiments of the present disclosure can operate.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>1</b></figref>, described below, offers an example of a chiplet system and the components operating therein. As explained below, such chiplet systems may include a memory controller that has programmable atomic units that execute programmable atomic transactions that comprise one or more instructions. A programmable atomic may be requested by a different processor (e.g., such as by a process on a different chiplet) via a request packet sent to the memory controller through a chiplet communication mechanism. The programmable atomic transaction is executed at a programmable atomic unit of a memory controller as a memory operation. If the programmable atomic transaction successfully completes, the programmable atomic unit may send a response to the calling processor.</p><p id="p-0019" num="0018">A programmable atomic transaction may also terminate due to an exception condition such as a memory request address bound check failure, instruction execution limit, and the like. For personal computers, such as for an x86 architecture, when an instruction triggers an exception the processor triggers an interrupt which is handled by an operating system that then may terminate the process that caused the exception. The operating system knows which process caused the exception as it manages which process runs at any given time.</p><p id="p-0020" num="0019">In other systems, for example those using programmable atomic transactions, the programmable atomic unit is called by a process by issuing a RISC instruction. The RISC instruction is executed by a local processor which sends a request over the chiplet network to the memory controller that then executes the transaction in the physical memory space of the programmable atomic unit. As a result, the programmable atomic unit does not know which process it is executing for. When an exception is encountered the offending process should be terminated to avoid memory faults that may cause undesired operation. However, without knowledge of which process was at fault, the memory controller is not in a position to do this. One solution would be to raise a flag in the memory controller and an operating system would periodically poll the flag and figure out which process caused the flag. This is undesirable and creates a lot of overhead for the O/S as it would have to constantly check the flag. Moreover, if the O/S were on a different processor, this would create overhead for the communications interface to the memory controller.</p><p id="p-0021" num="0020">Disclosed in some examples, are methods, systems, programmable atomic units, and machine-readable mediums that provide an exception as a response to the calling processor. That is, the programmable atomic unit will send a response to the calling processor. The calling processor will recognize that the exception has been raised and will handle the exception. Because the calling processor knows which process triggered the exception, the calling processor (e.g., the Operating System) can take appropriate action, such as terminating the calling process. The calling processor may be a same processor as that executing the programmable atomic transaction, or a different processor (e.g., on a different chiplet). The ability to send an exception back to the issuing processor allows the system to trap at the point in the executing application where the PAU operation was issued. This allows a programming using a debugger to determine which PAU operation trapped, why it trapped and what the input parameters that caused the exception.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIGS. <b>1</b>A and <b>1</b>B</figref> illustrate an example of a chiplet system <b>110</b>, according to an embodiment. <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> is a representation of the chiplet system <b>110</b> mounted on a peripheral board <b>105</b>, that can be connected to a broader computer system by a peripheral component interconnect express (PCIe), for example. The chiplet system <b>110</b> includes a package substrate <b>115</b>, an interposer <b>120</b>, and four chiplets, an application chiplet <b>125</b>, a host interface chiplet <b>135</b>, a memory controller chiplet <b>140</b>, and a memory device chiplet <b>150</b>. Other systems may include many additional chiplets to provide additional functionalities as will be apparent from the following discussion. The package of the chiplet system <b>110</b> is illustrated with a lid or cover <b>165</b>, though other packaging techniques and structures for the chiplet system can be used. <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> is a block diagram labeling the components in the chiplet system for clarity.</p><p id="p-0023" num="0022">The application chiplet <b>125</b> is illustrated as including a network-on-chip (NOC) <b>130</b> to support a chiplet network <b>155</b> for inter-chiplet communications. In example embodiments NOC <b>130</b> may be included on the application chiplet <b>125</b>. In an example, NOC <b>130</b> may be defined in response to selected support chiplets (e.g., chiplets <b>135</b>, <b>140</b>, and <b>150</b>) thus enabling a designer to select an appropriate number or chiplet network connections or switches for the NOC <b>130</b>. In an example, the NOC <b>130</b> can be located on a separate chiplet, or even within the interposer <b>120</b>. In examples as discussed herein, the NOC <b>130</b> implements a chiplet protocol interface (CPI) network.</p><p id="p-0024" num="0023">The CPI is a packet-based network that supports virtual channels to enable a flexible and high-speed interaction between chiplets. CPI enables bridging from intra-chiplet networks to the chiplet network <b>155</b>. For example, the Advanced eXtensible Interface (AXI) is a widely used specification to design intra-chip communications. AXI specifications, however, cover a great variety of physical design options, such as the number of physical channels, signal timing, power, etc. Within a single chip, these options are generally selected to meet design goals, such as power consumption, speed, etc. However, to achieve the flexibility of the chiplet system, an adapter, such as CPI, is used to interface between the various AXI design options that can be implemented in the various chiplets. By enabling a physical channel to virtual channel mapping and encapsulating time-based signaling with a packetized protocol, CPI bridges intra-chiplet networks across the chiplet network <b>155</b>.</p><p id="p-0025" num="0024">CPI can use a variety of different physical layers to transmit packets. The physical layer can include simple conductive connections, or can include drivers to increase the voltage, or otherwise facilitate transmitting the signals over longer distances. An example of one such physical layer can include the Advanced Interface Bus (AIB), which in various examples, can be implemented in the interposer <b>120</b>. AIB transmits and receives data using source synchronous data transfers with a forwarded clock. Packets are transferred across the AIB at single data rate (SDR) or dual data rate (DDR) with respect to the transmitted clock. Various channel widths are supported by AIB. AIB channel widths are in multiples of 20 bits when operated in SDR mode (20, 40, 60, . . . ), and multiples of 40 bits for DDR mode: (40, 80, 120, . . . ). The AIB channel width includes both transmit and receive signals. The channel can be configured to have a symmetrical number of transmit (TX) and receive (RX) input/outputs (I/Os), or have a non-symmetrical number of transmitters and receivers (e.g., either all transmitters or all receivers). The channel can act as an AIB primary or secondary depending on which chiplet provides the master clock. AIB I/O cells support three clocking modes: asynchronous (i.e. non-clocked), SDR, and DDR. In various examples, the non-clocked mode is used for clocks and some control signals. The SDR mode can use dedicated SDR only I/O cells, or dual use SDR/DDR I/O cells.</p><p id="p-0026" num="0025">In an example, CPI packet protocols (e.g., point-to-point or routable) can use symmetrical receive and transmit I/O cells within an AIB channel. The CPI streaming protocol allows more flexible use of the AIB I/O cells. In an example, an AIB channel for streaming mode can configure the I/O cells as all TX, all RX, or half RX and half RX. CPI packet protocols can use an AIB channel in either SDR or DDR operation modes. In an example, the AIB channel is configured in increments of 80 I/O cells (i.e. 40 TX and 40 RX) for SDR mode and 40 I/O cells for DDR mode. The CPI streaming protocol can use an AIB channel in either SDR or DDR operation modes. Here, in an example, the AIB channel is in increments of 40 I/O cells for both SDR and DDR modes. In an example, each AIB channel is assigned a unique interface identifier. The identifier is used during CPI reset and initialization to determine paired AIB channels across adjacent chiplets. In an example, the interface identifier is a 20-bit value comprising a seven-bit chiplet identifier, a seven-bit column identifier, and a six-bit link identifier. The AIB physical layer transmits the interface identifier using an AIB out-of-band shift register. The 20-bit interface identifier is transferred in both directions across an AIB interface using bits <b>32</b>-<b>51</b> of the shift registers.</p><p id="p-0027" num="0026">AIB defines a stacked set of AIB channels as an AIB channel column. An AIB channel column has some number of AIB channels, plus an auxiliary channel. The auxiliary channel contains signals used for AIB initialization. All AIB channels (other than the auxiliary channel) within a column are of the same configuration (e.g., all TX, all RX, or half TX and half RX, as well as having the same number of data I/O signals). In an example, AIB channels are numbered in continuous increasing order starting with the AIB channel adjacent to the AUX channel. The AIB channel adjacent to the AUX is defined to be AIB channel zero.</p><p id="p-0028" num="0027">Generally, CPI interfaces on individual chiplets can include serialization-deserialization (SERDES) hardware. SERDES interconnects work well for scenarios in which high-speed signaling with low signal count are desirable. SERDES, however, can result in additional power consumption and longer latencies for multiplexing and demultiplexing, error detection or correction (e.g., using block level cyclic redundancy checking (CRC)), link-level retry, or forward error correction. However, when low latency or energy consumption is a primary concern for ultra-short reach, chiplet-to-chiplet interconnects, a parallel interface with clock rates that allow data transfer with minimal latency may be utilized. CPI includes elements to minimize both latency and energy consumption in these ultra-short reach chiplet interconnects.</p><p id="p-0029" num="0028">For flow control, CPI employs a credit-based technique. A recipient, such as the application chiplet <b>125</b>, provides a sender, such as the memory controller chiplet <b>140</b>, with credits that represent available buffers. In an example, a CPI recipient includes a buffer for each virtual channel for a given time-unit of transmission. Thus, if the CPI recipient supports five messages in time and a single virtual channel, the recipient has five buffers arranged in five rows (e.g., one row for each unit time). If four virtual channels are supported, then the recipient has twenty buffers arranged in five rows. Each buffer holds the payload of one CPI packet.</p><p id="p-0030" num="0029">When the sender transmits to the recipient, the sender decrements the available credits based on the transmission. Once all credits for the recipient are consumed, the sender stops sending packets to the recipient. This ensures that the recipient always has an available buffer to store the transmission.</p><p id="p-0031" num="0030">As the recipient processes received packets and frees buffers, the recipient communicates the available buffer space back to the sender. This credit return can then be used by the sender allow transmitting of additional information.</p><p id="p-0032" num="0031">Also illustrated is a chiplet mesh network <b>160</b> that uses a direct, chiplet-to-chiplet technique without the need for the NOC <b>130</b>. The chiplet mesh network <b>160</b> can be implemented in CPI, or another chiplet-to-chiplet protocol. The chiplet mesh network <b>160</b> generally enables a pipeline of chiplets where one chiplet serves as the interface to the pipeline while other chiplets in the pipeline interface only with themselves.</p><p id="p-0033" num="0032">Additionally, dedicated device interfaces, such as one or more industry standard memory interfaces <b>145</b> (such as, for example, synchronous memory interfaces, such as DDR5, DDR 6), can also be used to interconnect chiplets. Connection of a chiplet system or individual chiplets to external devices (such as a larger system can be through a desired interface (for example, a PCIE interface). Such as external interface may be implemented, in an example, through a host interface chiplet <b>135</b>, which in the depicted example, provides a PCIE interface external to chiplet system <b>110</b>. Such dedicated interfaces <b>145</b> are generally employed when a convention or standard in the industry has converged on such an interface. The illustrated example of a Double Data Rate (DDR) interface <b>145</b> connecting the memory controller chiplet <b>140</b> to a dynamic random access memory (DRAM) memory device <b>150</b> is just such an industry convention.</p><p id="p-0034" num="0033">Of the variety of possible support chiplets, the memory controller chiplet <b>140</b> is likely present in the chiplet system <b>110</b> due to the near omnipresent use of storage for computer processing as well as sophisticated state-of-the-art for memory devices. Thus, using memory device chiplets <b>150</b> and memory controller chiplets <b>140</b> produced by others gives chiplet system designers access to robust products by sophisticated producers. Generally, the memory controller chiplet <b>140</b> provides a memory device specific interface to read, write, or erase data. Often, the memory controller chiplet <b>140</b> can provide additional features, such as error detection, error correction, maintenance operations, or atomic operation execution. For some types of memory, maintenance operations tend to be specific to the memory device <b>150</b>, such as garbage collection in NAND flash or storage class memories, temperature adjustments (e.g., cross temperature management) in NAND flash memories. In an example, the maintenance operations can include logical-to-physical (L2P) mapping or management to provide a level of indirection between the physical and logical representation of data. In other types of memory, for example DRAM, some memory operations, such as refresh may be controlled by a host processor or of a memory controller at some times, and at other times controlled by the DRAM memory device, or by logic associated with one or more DRAM devices, such as an interface chip (in an example, a buffer).</p><p id="p-0035" num="0034">Atomic transactions are one or more data manipulation operations that, for example, may be performed by the memory controller chiplet <b>140</b>. In other chiplet systems, the atomic transactions may be performed by other chiplets. For example, an atomic transaction of &#x201c;increment&#x201d; can be specified in a command by the application chiplet <b>125</b>, the command including a memory address and possibly an increment value. Upon receiving the command, the memory controller chiplet <b>140</b> retrieves a number from the specified memory address, increments the number by the amount specified in the command, and stores the result. Upon a successful completion, the memory controller chiplet <b>140</b> provides an indication of the commands success to the application chiplet <b>125</b>. Atomic transactions avoid transmitting the data across the chiplet mesh network <b>160</b>, resulting in lower latency execution of such commands.</p><p id="p-0036" num="0035">Atomic transactions can be classified as built-in atomics or programmable (e.g., custom) atomic transactions. Built-in atomic transactions are a finite set of operations that are immutably implemented in hardware. Programmable atomic transactions are small programs with one or more instructions (e.g., an instruction set) that may execute on a programmable atomic unit (PAU) (e.g., a custom atomic unit (CAU)) of the memory controller chiplet <b>140</b>. <figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an example of a memory controller chiplet that discusses a PAU.</p><p id="p-0037" num="0036">The memory device chiplet <b>150</b> can be, or include any combination of, volatile memory devices or non-volatile memories. Examples of volatile memory devices include, but are not limited to, random access memory (RAM)&#x2014;such as DRAM) synchronous DRAM (SDRAM), graphics double data rate type 6 SDRAM (GDDR6 SDRAM), among others. Examples of non-volatile memory devices include, but are not limited to, negative-and-(NAND)-type flash memory, storage class memory (e.g., phase-change memory or memristor based technologies), ferroelectric RAM (FeRAM), among others. The illustrated example includes the memory device <b>150</b> as a chiplet, however, the memory device <b>150</b> can reside elsewhere, such as in a different package on the peripheral board <b>105</b>. For many applications, multiple memory device chiplets may be provided. In an example, these memory device chiplets may each implement one or multiple storage technologies. In an example, a memory chiplet may include, multiple stacked memory die of different technologies, for example one or more SRAM devices stacked or otherwise in communication with one or more DRAM devices. Memory controller <b>140</b> may also serve to coordinate operations between multiple memory chiplets in chiplet system <b>110</b>; for example, to utilize one or more memory chiplets in one or more levels of cache storage, and to use one or more additional memory chiplets as main memory. Chiplet system <b>110</b> may also include multiple memory controllers <b>140</b>, as may be used to provide memory control functionality for separate processors, sensors, networks, etc. A chiplet architecture, such as chiplet system <b>110</b> offers advantages in allowing adaptation to different memory storage technologies; and different memory interfaces, through updated chiplet configurations, without requiring redesign of the remainder of the system structure.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates components of an example of a memory controller chiplet <b>205</b>, according to an embodiment. The memory controller chiplet <b>205</b> includes a cache <b>210</b>, a cache controller <b>215</b>, an off-die memory controller <b>220</b> (e.g., to communicate with off-die memory <b>275</b>), a network communication interface <b>225</b> (e.g., to interface with a chiplet network <b>285</b> and communicate with other chiplets), and a set of atomic and merge unit <b>250</b>. Members of this set can include, for example, a write merge unit <b>255</b>, a memory hazard unit <b>260</b>, built-in atomic unit <b>265</b> (for performing built in atomic transactions), or a programmable atomic unit (PAU) <b>270</b> (for performing programmable atomic transactions). The various components are illustrated logically, and not as they necessarily would be implemented. For example, the built-in atomic unit <b>265</b> likely comprises different devices along a path to the off-die memory. For example, the built-in atomic unit <b>265</b> could be in an interface device/buffer on a memory chiplet, as discussed above. In contrast, the programmable atomic unit <b>270</b> could be implemented in a separate processor on the memory controller chiplet <b>205</b> (but in various examples may be implemented in other locations, for example on a memory chiplet).</p><p id="p-0039" num="0038">The off-die memory controller <b>220</b> is directly coupled to the off-die memory <b>275</b> (e.g., via a bus or other communication connection) to provide write operations and read operations to and from the one or more off-die memory, such as off-die memory <b>275</b> and off-die memory <b>280</b>. In the depicted example, the off-die memory controller <b>220</b> is also coupled for output to the atomic and merge unit <b>250</b>, and for input to the cache controller <b>215</b> (e.g., a memory side cache controller).</p><p id="p-0040" num="0039">In the example configuration, cache controller <b>215</b> is directly coupled to the cache <b>210</b>, and may be coupled to the network communication interface <b>225</b> for input (such as incoming read or write requests), and coupled for output to the off-die memory controller <b>220</b>.</p><p id="p-0041" num="0040">The network communication interface <b>225</b> includes a packet decoder <b>230</b>, network input queues <b>235</b>, a packet encoder <b>240</b>, and network output queues <b>245</b> to support a packet-based chiplet network <b>285</b>, such as CPI. The chiplet network <b>285</b> can provide packet routing between and among processors, memory controllers, hybrid threading processors, configurable processing circuits, or communication interfaces. In such a packet-based communication system, each packet typically includes destination and source addressing, along with any data payload or instruction. In an example, the chiplet network <b>285</b> can be implemented as a collection of crossbar switches having a folded Clos configuration, or a mesh network providing for additional connections, depending upon the configuration.</p><p id="p-0042" num="0041">In various examples, the chiplet network <b>285</b> can be part of an asynchronous switching fabric. Here, a data packet can be routed along any of various paths, such that the arrival of any selected data packet at an addressed destination can occur at any of multiple different times, depending upon the routing. Additionally, chiplet network <b>285</b> can be implemented at least in part as a synchronous communication network, such as a synchronous mesh communication network. Both configurations of communication networks are contemplated for use for examples in accordance with the present disclosure.</p><p id="p-0043" num="0042">The memory controller chiplet <b>205</b> can receive a packet having, for example, a source address, a read request, and a physical address. In response, the off-die memory controller <b>220</b> or the cache controller <b>215</b> will read the data from the specified physical address (which can be in the off-die memory <b>275</b> or in the cache <b>210</b>), and assemble a response packet to the source address containing the requested data. Similarly, the memory controller chiplet <b>205</b> can receive a packet having a source address, a write request, and a physical address. In response, the memory controller chiplet <b>205</b> will write the data to the specified physical address (which can be in the cache <b>210</b> or in the off-die memories <b>275</b> or <b>280</b>), and assemble a response packet to the source address containing an acknowledgement that the data was stored to a memory.</p><p id="p-0044" num="0043">Thus, the memory controller chiplet <b>205</b> can receive read and write requests via the chiplet network <b>285</b> and process the requests using the cache controller <b>215</b> interfacing with the cache <b>210</b>, if possible. If the request cannot be handled by the cache controller <b>215</b>, the off-die memory controller <b>220</b> handles the request by communication with the off-die memories <b>275</b> or <b>280</b>, the atomic and merge unit <b>250</b>, or both. As noted above, one or more levels of cache may also be implemented in off-die memories <b>275</b> or <b>280</b>; and in some such examples may be accessed directly by cache controller <b>215</b>. Data read by the off-die memory controller <b>220</b> can be cached in the cache <b>210</b> by the cache controller <b>215</b> for later use.</p><p id="p-0045" num="0044">The atomic and merge unit <b>250</b> are coupled to receive (as input) the output of the off-die memory controller <b>220</b>, and to provide output to the cache <b>210</b>, the network communication interface <b>225</b>, or directly to the chiplet network <b>285</b>. The memory hazard unit <b>260</b>, write merge unit <b>255</b> and the built-in (e.g., predetermined) atomic unit <b>265</b> can each be implemented as state machines with other combinational logic circuitry (such as adders, shifters, comparators, AND gates, OR gates, XOR gates, or any suitable combination thereof) or other logic circuitry. These components can also include one or more registers or buffers to store operand or other data. The PAU <b>270</b> can be implemented as one or more processor cores or control circuitry, and various state machines with other combinational logic circuitry or other logic circuitry, and can also include one or more registers, buffers, or memories to store addresses, executable instructions, operand and other data, or can be implemented as a processor. An example PAU <b>270</b> is shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0046" num="0045">The write merge unit <b>255</b> receives read data and request data, and merges the request data and read data to create a single unit having the read data and the source address to be used in the response or return data packet). The write merge unit <b>255</b> provides the merged data to the write port of the cache <b>210</b> (or, equivalently, to the cache controller <b>215</b> to write to the cache <b>210</b>). Optionally, the write merge unit <b>255</b> provides the merged data to the network communication interface <b>225</b> to encode and prepare a response or return data packet for transmission on the chiplet network <b>285</b>.</p><p id="p-0047" num="0046">When the request data is for a built-in atomic operation, the built-in atomic unit <b>265</b> receives the request and reads data, either from the write merge unit <b>255</b> or directly from the off-die memory controller <b>220</b>. The atomic transaction is performed, and using the write merge unit <b>255</b>, the resulting data is written to the cache <b>210</b>, or provided to the network communication interface <b>225</b> to encode and prepare a response or return data packet for transmission on the chiplet network <b>285</b>.</p><p id="p-0048" num="0047">The built-in atomic unit <b>265</b> handles predefined atomic transactions such as fetch-and-increment or compare-and-swap. In an example, these transactions perform a simple read-modify-write operation to a single memory location of 32-bytes or less in size. Atomic memory transactions are initiated from a request packet transmitted over the chiplet network <b>285</b>. The request packet has a physical address, atomic operator type, operand size, and optionally up to 32-bytes of data. The atomic transaction performs the read-modify-write to a cache memory line of the cache <b>210</b>, filling the cache memory if necessary. The atomic transaction response can be a simple completion response, or a response with up to 32-bytes of data. Example atomic memory transactions include fetch-and-AND, fetch-and-OR, fetch-and-XOR, fetch-and-add, fetch-and-subtract, fetch-and-increment, fetch-and-decrement, fetch-and-minimum, fetch-and-maximum, fetch-and-swap, and compare-and-swap. In various example embodiments, 32-bit and 64-bit operations are supported, along with operations on 16 or 32 bytes of data. Methods disclosed herein are also compatible with hardware supporting larger or smaller operations and more or less data.</p><p id="p-0049" num="0048">Built-in atomic transactions can also involve requests for a &#x201c;standard&#x201d; atomic standard on the requested data, such as comparatively simple, single cycle, integer atomics&#x2014;such as fetch-and-increment or compare-and-swap&#x2014;which will occur with the same throughput as a regular memory read or write operation not involving an atomic operation. For these operations, the cache controller <b>215</b> may generally reserve a cache line in the cache <b>210</b> by setting a hazard bit (in hardware), so that the cache line cannot be read by another process while it is in transition. The data is obtained from either the off-die memory <b>275</b> or the cache <b>210</b>, and is provided to the built-in atomic unit <b>265</b> to perform the requested atomic transaction. Following the atomic transaction, in addition to providing the resulting data to the packet encoder <b>240</b> to encode outgoing data packets for transmission on the chiplet network <b>285</b>, the built-in atomic unit <b>265</b> provides the resulting data to the write merge unit <b>255</b>, which will also write the resulting data to the cache <b>210</b>. Following the writing of the resulting data to the cache <b>210</b>, any corresponding hazard bit which was set will be cleared by the memory hazard unit <b>260</b>.</p><p id="p-0050" num="0049">The PAU <b>270</b> enables high performance (high throughput and low latency) for programmable atomic transactions (also referred to as &#x201c;custom atomic transactions&#x201d; or &#x201c;custom atomic operations&#x201d;), comparable to the performance of built-in atomic transactions. Rather than executing multiple memory accesses, in response to an atomic transaction request designating a programmable atomic transaction and a memory address, circuitry in the memory controller chiplet <b>205</b> transfers the atomic transaction request to PAU <b>270</b> and sets a hazard bit stored in a memory hazard register corresponding to the memory address of the memory line used in the atomic operation, to ensure that no other operation (read, write, or atomic transaction) is performed on that memory line, which hazard bit is then cleared upon completion of the atomic transaction. Additional, direct data paths provided for the PAU <b>270</b> executing the programmable atomic transactions allow for additional write operations without any limitations imposed by the bandwidth of the communication networks and without increasing any congestion of the communication networks.</p><p id="p-0051" num="0050">The PAU <b>270</b> includes a multi-threaded processor <b>320</b>, for example, such as a RISC-V ISA based multi-threaded processor, having one or more processor cores, and further having an extended instruction set for executing programmable atomic transactions. When provided with the extended instruction set for executing programmable atomic transactions, the processor <b>320</b> of PAU <b>270</b> can be embodied as one or more hybrid threading processors. In some example embodiments, the processor <b>320</b> of PAU <b>270</b> provides barrel-style, round-robin instantaneous thread switching to maintain a high instruction-per-clock rate.</p><p id="p-0052" num="0051">PAU <b>270</b> may include a local memory <b>305</b>, such as Static Random-Access Memory (SRAM), NAND, phase change memory, or the like. The local memory <b>305</b> may include registers <b>335</b>, instruction memory <b>325</b>, and cache <b>330</b>. The local memory <b>305</b> may be accessible to the processor <b>320</b> through a memory controller <b>310</b>.</p><p id="p-0053" num="0052">Programmable atomic transactions can be performed by the PAU <b>270</b> involving requests for programmable atomic transactions on the requested data. A user can prepare programming code in the form of one or more instructions to provide such programmable atomic transactions. For example, the programmable atomic transactions can be comparatively simple, multi-cycle operations such as floating-point addition, or comparatively complex, multi-instruction operations such as a Bloom filter insert. The programmable atomic transactions can be the same as or different than the predetermined atomic transactions, insofar as they are defined by the user rather than a system vendor. For these operations, the cache controller <b>215</b> can reserve a cache line in the cache <b>210</b>, by setting a hazard bit (in hardware), so that cache line cannot be read by another process while it is in transition. The data is obtained from either the cache <b>210</b> or the off-die memories <b>275</b> or <b>280</b>, and is provided to the PAU <b>270</b> to perform the requested programmable atomic transaction. Following the atomic operation, the PAU <b>270</b> will provide the resulting data to the network communication interface <b>225</b> to directly encode outgoing data packets having the resulting data for transmission on the chiplet network <b>285</b>. In addition, the PAU <b>270</b> will provide the resulting data to the cache controller <b>215</b>, which will also write the resulting data to the cache <b>210</b>. Following the writing of the resulting data to the cache <b>210</b>, any corresponding hazard bit which was set will be cleared by the cache controller <b>215</b>.</p><p id="p-0054" num="0053">In selected examples, the approach taken for programmable atomic transactions is to provide multiple, generic, programmable atomic request types that can be sent through the chiplet network <b>285</b> to the memory controller chiplet <b>205</b> from an originating source such as a processor or other system component. The cache controllers <b>215</b> or off-die memory controller <b>220</b> identify the request as a programmable atomic transaction and forward the request to the PAU <b>270</b>. In a representative embodiment, the PAU <b>270</b>: (1) is a programmable processing element capable of efficiently performing a user defined atomic transaction; (2) can perform load and stores to memory, arithmetic and logical operations and control flow decisions; and (3) leverages the RISC-V ISA with a set of new, specialized instructions to facilitate interacting with such controllers <b>215</b>, <b>220</b> to atomically perform the user-defined transaction. In desirable examples, the RISC-V ISA contains a full set of instructions that support high level language operators and data types. The PAU <b>270</b> can leverage the RISC-V ISA, but will commonly support a more limited set of instructions and limited register file size to reduce the die size of the unit when included within the memory controller chiplet <b>205</b>.</p><p id="p-0055" num="0054">As mentioned above, prior to the writing of the read data to the cache <b>210</b>, the set hazard bit for the reserved cache line is to be cleared, by the memory hazard unit <b>260</b>. Accordingly, when the request and read data is received by the write merge unit <b>255</b>, a reset or clear signal can be transmitted by the memory hazard unit <b>260</b> to the cache <b>210</b> to reset the set memory hazard bit for the reserved cache line. Also, resetting this hazard bit will also release a pending read or write request involving the designated (or reserved) cache line, providing the pending read or write request to an inbound request multiplexer for selection and processing.</p><p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a block diagram of a programmable atomic unit <b>270</b> according to some examples of the present disclosure. As previously described, programmable atomic units may include one or more programmable atomic transactions that are specified by sets of one or more atomic instructions stored in instruction memory <b>325</b> that are custom defined and perform operations on memory managed by the memory controller. The instructions of atomic transactions may be specified by applications and/or processes outside the programmable atomic unit <b>270</b> that may reside on the memory controller chiplet <b>205</b>, other chiplets (such as application chiplet <b>125</b>), or an off chiplet-device. In some examples, the instructions of the programmable atomic transaction are loaded by the operating system when registered by a process. To execute the programmable atomic transaction, the initiating process sends a CPI message including an instruction to execute the requested programmable atomic transaction on the local memory <b>305</b> of the programmable atomic unit <b>270</b> by providing an index into the local memory of the programmable atomic unit <b>270</b>. The programmable atomic transactions may utilize cache <b>330</b>, registers <b>335</b>, and other memory of local memory <b>305</b> during execution. Local memory controller <b>310</b> may manage the local memory <b>305</b>. In some examples, programmable atomic unit <b>270</b> may not need the local memory controller as the local memory <b>305</b> may be SRAM.</p><p id="p-0057" num="0056">When requesting execution of a particular programmable atomic transaction, a requesting processor may send a CPI request packet indicating the particular memory location (e.g., partition(s) within local memory <b>305</b>) within the programmable atomic unit which contain the previously loaded programmable atomic instructions to execute, a location of the memory managed by the memory controller chiplet <b>205</b> (e.g., off-die memory <b>275</b>, <b>280</b>) that is to be operated upon, and one or more arguments. The processor of the programmable atomic unit (e.g., processor <b>320</b>) then begins executing the instructions at the indicated partition. <figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates a request packet for requesting execution of a particular programmable atomic transaction. The fields are described as:</p><p id="p-0058" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="70pt" align="left"/><colspec colname="2" colwidth="28pt" align="center"/><colspec colname="3" colwidth="21pt" align="center"/><colspec colname="4" colwidth="98pt" align="left"/><thead><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry/><entry>Field</entry><entry/><entry/></row><row><entry>Field Name</entry><entry>Width</entry><entry>Value</entry><entry>Description</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="70pt" align="left"/><colspec colname="2" colwidth="28pt" align="char" char="."/><colspec colname="3" colwidth="21pt" align="char" char="."/><colspec colname="4" colwidth="98pt" align="left"/><tbody valign="top"><row><entry>CMD</entry><entry>8</entry><entry>126</entry><entry>Extended VC1</entry></row><row><entry>LEN</entry><entry>5</entry><entry/><entry>Packet Length</entry></row><row><entry>SC</entry><entry>1</entry><entry>0</entry><entry>Sequence Continue</entry></row><row><entry/><entry/><entry/><entry>(ignored for EMD)</entry></row><row><entry>DID</entry><entry>12</entry><entry/><entry>Destination NOC endpoint</entry></row><row><entry>PATH</entry><entry>8</entry><entry/><entry>Endpoint Offset &#x3c;14:7&#x3e;</entry></row><row><entry>CP</entry><entry>2</entry><entry>1</entry><entry>Credit/Path Order -</entry></row><row><entry/><entry/><entry/><entry>Credit Return</entry></row><row><entry/><entry/><entry/><entry>enabled in flits 3-N and Path</entry></row><row><entry/><entry/><entry/><entry>field based path ordering</entry></row><row><entry>TU</entry><entry>2</entry><entry/><entry>Transaction ID &#x3c;9:8&#x3e;</entry></row><row><entry>EpOFF&#x3c;6:0&#x3e;</entry><entry>7</entry><entry/><entry>Endpoint Offset &#x3c;6:0&#x3e;</entry></row><row><entry>TA</entry><entry>8</entry><entry/><entry>Transaction ID &#x3c;7:0&#x3e;</entry></row><row><entry>EPOffset&#x3c;33:15&#x3e;</entry><entry>19</entry><entry/><entry>Endpoint Offset &#x3c;33:15&#x3e;</entry></row><row><entry>EXCMD</entry><entry>8</entry><entry/><entry>Extended Command</entry></row><row><entry>BTYPE</entry><entry>4</entry><entry>8</entry><entry>BTYPE of 8 is EMD</entry></row><row><entry/><entry/><entry/><entry>vendor defined</entry></row><row><entry>SID</entry><entry>12</entry><entry/><entry>Source NOC endpoint</entry></row><row><entry>EPOFFSET &#x3c;37:34&#x3e;</entry><entry>4</entry><entry/><entry>Endpoint Offset &#x3c;37:34&#x3e;</entry></row><row><entry>RSV</entry><entry>4</entry><entry>0</entry><entry>Reserved</entry></row><row><entry>CR/RSV</entry><entry>4</entry><entry/><entry>Credit Return</entry></row><row><entry>CrPKnd</entry><entry>4</entry><entry/><entry>Credit pool kind</entry></row><row><entry>CrPIdx</entry><entry>8</entry><entry/><entry>Credit Pool Index</entry></row><row><entry>RSV</entry><entry>4</entry><entry>0</entry><entry>Reserved</entry></row><row><entry>CaPIdx</entry><entry>8</entry><entry/><entry>Custom Atomic Partition Index</entry></row><row><entry>CaIntv</entry><entry>8</entry><entry/><entry>Interleave Size</entry></row><row><entry>CR/RSV</entry><entry>4</entry><entry/><entry>Credit Return</entry></row><row><entry>DATA</entry><entry>32</entry><entry/><entry>Argument Data: 0, 1, 2,</entry></row><row><entry/><entry/><entry/><entry>or 4 64 Bit Values</entry></row><row><entry>CR/RSV</entry><entry>4</entry><entry/><entry>Credit Return</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0059" num="0057">A programmable atomic transaction begins by executing the first instruction located at the partition in the instruction RAM (e.g., local memory <b>305</b> of programmable atomic unit <b>270</b>) of the programmable atomic transaction specified by the Custom Atomic Partition Index (CaPIdx). The operation starts at the first instruction within the partition. The CaPIdx may also be used to index into a control structure that contains additional information for the operation. The additional information includes a flag to indicate whether the transaction is valid, the number of partitions for the transaction and the instruction execution limit.</p><p id="p-0060" num="0058">The programmable atomic unit continues executing instructions until a termination instruction is reached or an exception occurs. On reaching a termination instruction where no exception occurred a normal response is sent to the requestor processor. A normal response to the programmable atomic transaction is provided as a memory response. For example, <figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates the response message. The fields of the response message are as follows:</p><p id="p-0061" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="133pt" align="left"/><thead><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Field Name</entry><entry>Field Width</entry><entry>Description</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="42pt" align="char" char="."/><colspec colname="3" colwidth="133pt" align="left"/><tbody valign="top"><row><entry>CMD</entry><entry>8</entry><entry>Packet command</entry></row><row><entry>LEN</entry><entry>5</entry><entry>Encoded Packet Length</entry></row><row><entry>SC</entry><entry>1</entry><entry>Sequence Continue. When set, this packet</entry></row><row><entry/><entry/><entry>is part of a multi-packet transfer and this</entry></row><row><entry/><entry/><entry>packet is not the last packet in the</entry></row><row><entry/><entry/><entry>sequence. This bit is present in the first flit</entry></row><row><entry/><entry/><entry>of all packet types</entry></row><row><entry>DID</entry><entry>8</entry><entry>Destination Endpoint ID bits 7:0 -</entry></row><row><entry/><entry/><entry>destination fabric endpoint</entry></row><row><entry>STAT</entry><entry>4</entry><entry>Response Status</entry></row><row><entry>Path</entry><entry>8</entry><entry>The Path field is used to specify a path</entry></row><row><entry/><entry/><entry>through a CPI fabric to force ordering</entry></row><row><entry/><entry/><entry>between packets. For both CPI native and</entry></row><row><entry/><entry/><entry>AXI over CPI the read response packet's</entry></row><row><entry/><entry/><entry>PATH field contains the TID value</entry></row><row><entry>CP</entry><entry>2</entry><entry>Credit Present/Path Ordering. The CP field</entry></row><row><entry/><entry/><entry>contains an encoded value that specifies</entry></row><row><entry/><entry/><entry>both if field CR of flits 3-N of the packet</entry></row><row><entry/><entry/><entry>contains credit return information as well as</entry></row><row><entry/><entry/><entry>whether path ordering is enabled.</entry></row><row><entry>Data</entry><entry>32</entry><entry>Read response data - bits N*8-1:0</entry></row><row><entry>CR/RSV</entry><entry>4</entry><entry>Credit Return Information</entry></row><row><entry>RSV</entry><entry>4</entry><entry>Reserved</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0062" num="0059">An exception occurs if either the specified number of instructions (the instruction execution limit) is reached or an operation in the transaction is executing which lies outside the appropriate partitions, as determined by the number of partitions and the starting partition. That is, if the next instruction lies within a partition with a partition index that is after the sum of the starting partition index and the number of partitions (provided in the control structure indexed by the CaPIdx), an exception is thrown. An exception causes the executing programmable atomic transaction to cease, and a termination instruction to be executed automatically by the programmable atomic unit that releases any locks, cleans up the transaction, and provides a response to the caller.</p><p id="p-0063" num="0060">As noted above, the programmable atomic unit is unaware of the process it is executing for and so the exception may be handled by sending a response to the calling processor indicating that the programmable atomic transaction terminated due to an exception. The calling processor is indicated in the source field in the request packet of the programmable atomic transaction. The requesting processor that called the programmable atomic may receive this response, and then perform the appropriate error handling, such as calling an operating system to handle the error.</p><p id="p-0064" num="0061">Disclosed in some examples, are methods, systems, devices, and machine-readable mediums that provide notification of an exception condition of a programmable atomic transaction by first having the programmable atomic unit send a completion response to the requesting processor, and then having the requesting processor handle the fault (e.g., by informing the operating system through an exception or trap). This allows the request for the programmable atomic operation to have the minimal information needed to initiate the programmable atomic transaction while still providing proper exception handling. This also simplifies the programmable atomic unit in the memory controller as it does not directly interact with the system's operating system. The ability to send an exception back to the issuing processor allows the system to trap at the point in the executing application where the PAU operation was issued. This allows a programming using a debugger to determine which PAU operation trapped, why it trapped and what the input parameters that caused the exception.</p><p id="p-0065" num="0062">When a programmable atomic unit detects an exception condition in an executing programmable atomic transaction, it terminates the offending operation and forces the execution of an atomic return instruction (EAR). The EAR instruction responds back to the processor that made the original programmable atomic request with a memory response that has a status field indicating the cause of the exception and up to 16 bytes of programmable atomic state used for debugging the cause of the exception.</p><p id="p-0066" num="0063"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a programmable atomic trap response according to some examples of the present disclosure. The trap response is sent in VC1 using a vendor defined extended header CPI packet. The fields are defined as:</p><p id="p-0067" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="63pt" align="left"/><colspec colname="2" colwidth="28pt" align="center"/><colspec colname="3" colwidth="21pt" align="center"/><colspec colname="4" colwidth="105pt" align="left"/><thead><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry/><entry>Field</entry><entry/><entry/></row><row><entry>Name</entry><entry>Width</entry><entry>Value</entry><entry>Field Description</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="63pt" align="left"/><colspec colname="2" colwidth="28pt" align="char" char="."/><colspec colname="3" colwidth="21pt" align="char" char="."/><colspec colname="4" colwidth="105pt" align="left"/><tbody valign="top"><row><entry>CMD</entry><entry>8</entry><entry>126</entry><entry>Extended VC1</entry></row><row><entry>LEN</entry><entry>5</entry><entry>3</entry><entry>Packet Length</entry></row><row><entry>SC</entry><entry>1</entry><entry>0</entry><entry>Sequential Continue</entry></row><row><entry/><entry/><entry/><entry>(Ignored by EMD)</entry></row><row><entry>DID</entry><entry>12</entry><entry/><entry>Destination NOC Endpoint</entry></row><row><entry>Path</entry><entry>8</entry><entry/><entry>Transaction ID &#x3c;7:0&#x3e;</entry></row><row><entry>CP</entry><entry>2</entry><entry>0</entry><entry>Credit/Path Order -</entry></row><row><entry/><entry/><entry/><entry>Credit Return enabled</entry></row><row><entry/><entry/><entry/><entry>in flits 3-N and Path Field Ignored</entry></row><row><entry>EXCMD</entry><entry>8</entry><entry>224</entry></row><row><entry>BTYPE</entry><entry>4</entry><entry>8</entry><entry>BTYPE of 8 is</entry></row><row><entry/><entry/><entry/><entry>EMD vendor defined</entry></row><row><entry>CaPC</entry><entry>16</entry><entry/><entry>Custom Atomic Program</entry></row><row><entry/><entry/><entry/><entry>Counter at Point of Trap</entry></row><row><entry>CaTrap</entry><entry>6</entry><entry/><entry>Custom Atomic Trap Type</entry></row><row><entry>TU</entry><entry>2</entry><entry/><entry>Transaction ID &#x3c;9:8&#x3e;</entry></row><row><entry>CauState &#x3c;31:0&#x3e;</entry><entry>32</entry><entry/><entry>Custom Atomic State</entry></row><row><entry/><entry/><entry/><entry>for debugging</entry></row><row><entry>CR/RSV</entry><entry>4</entry><entry/><entry>Credit Return</entry></row><row><entry>CauState &#x3c;62:32&#x3e;</entry><entry>32</entry><entry/><entry>Custom Atomic state</entry></row><row><entry/><entry/><entry/><entry>for debugging</entry></row><row><entry>CR/RSV</entry><entry>4</entry><entry/><entry>Credit Return</entry></row><row><entry>CauState&#x3c;127:96&#x3e;</entry><entry>32</entry><entry/><entry>Custom Atomic State</entry></row><row><entry/><entry/><entry/><entry>for Debugging</entry></row><row><entry>Cr/RSV</entry><entry>4</entry><entry/><entry>Credit Return</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0068" num="0064"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a flowchart of a method <b>700</b> of a programmable atomic unit providing a notification to a calling processor that the programmable atomic transaction ended with an exception according to some examples of the present disclosure. At operation <b>705</b>, the programmable atomic unit may receive an instruction to execute a programmable atomic transaction. As previously described the instruction may specify one of a plurality of programmable atomic instruction sets that are stored within the memory of the programmable atomic unit. The instruction may specify the particular programmable atomic transaction based upon a memory partition identifier as previously described. The request may be received from a process running on the memory controller (e.g., memory controller <b>205</b>; <b>140</b>) or from a process running on another chiplet, such as application chiplet <b>125</b>.</p><p id="p-0069" num="0065">At operation <b>710</b>, the programmable atomic unit may perform the instructions of the programmable atomic transaction. Such instructions may include reading values from memory cells (e.g., off-die memory <b>275</b>, <b>280</b>) controlled by the memory controller of which the programmable atomic unit <b>270</b> is a part of. Such instructions may perform operations to the value read from the memory and may store modified values back to the memory (e.g., off-die memory <b>275</b>, <b>280</b>). Such operations provide reduced latency to processes that call the PAU.</p><p id="p-0070" num="0066">Operations continue to be executed until the programmable atomic completes, unless an exception is detected at operation <b>715</b>. If an exception is detected, at operation <b>720</b>, the execution of the programmable atomic is terminated. At operation <b>725</b>, the programmable atomic unit generate a response message including the type of exception, the program counter (PC) (the instruction pointer), and state information, such as memory dump information. The response may be formatted such as shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. At operation <b>730</b>, the response may be sent to the calling processor using the return address of the processor that called the programmable atomic at operation <b>705</b>.</p><p id="p-0071" num="0067"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a flowchart of a method <b>800</b> of a calling processor notifying an operating system according to some examples of the present disclosure. Method <b>800</b> may be performed by a processor executing on the memory controller <b>140</b>, a host interface <b>135</b>, an application chiplet <b>125</b>, or the like. At operation <b>805</b> the processor sends the instruction to execute a programmable atomic transaction to the programmable atomic unit of the memory controller (e.g., memory controller <b>140</b>). For example, a message such as shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>. At operation <b>810</b>, the processor receives a response from the programmable atomic unit. The response is checked at operation <b>815</b> to determine if the programmable atomic transaction ended successfully or with an exception. If the programmable atomic transaction ended with an exception at operation <b>815</b>, then at operation <b>820</b>, the processor may notify an operating system of the exception. For example, by triggering an exception, fault, or otherwise passing a message to an operating system executing on the application chiplet <b>125</b>, an operating system executing on a computer system in which a peripheral board <b>105</b> is inserted, or the like. At operation <b>830</b>, the processor may continue with its operations&#x2014;for example, by applying one or more error handling conditions.</p><p id="p-0072" num="0068"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates a block diagram of a memory controller <b>900</b> according to some examples of the present disclosure. <figref idref="DRAWINGS">FIG. <b>9</b></figref> is another example of a memory controller <b>205</b> and shows many of the same components as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. For example, the cache <b>902</b> and <b>985</b> are examples of cache <b>210</b>; DRAM(s) <b>945</b> are examples of off-die memory <b>275</b>-<b>280</b>; atomic/write merge <b>980</b> and the programmable atomic unit <b>995</b> may be an example of atomics and merge unit <b>250</b>; other components of <figref idref="DRAWINGS">FIG. <b>8</b></figref> may be examples of other components of <figref idref="DRAWINGS">FIG. <b>2</b></figref> such as off-die memory controller <b>220</b> and cache controller <b>215</b>.</p><p id="p-0073" num="0069">NOC Request Queue <b>905</b> receives requests from the network-on-chip and provides a small amount of queuing. Atomic Request Queue <b>910</b> receives requests from the programmable atomic unit and provides a small amount of queuing. Inbound Request Multiplexer (IRM) <b>915</b> selects between inbound memory request sources. The three sources, in order of priority are: Memory Hazard Requests, Atomic Requests, and Inbound NOC Requests. Cache (Read) <b>902</b> and Cache (Write) <b>985</b> is an SRAM data cache. The diagram shows the cache as two separate blocks (<b>902</b> and <b>985</b>), one providing read access, the other providing write access. Delay Block <b>925</b> provides one or more pipeline stages to mimic the delay for an SRAM cache read operation. A cache miss requires access to memory to bring the desired data into the cache. During this DRAM access time, the memory line is not available for other requests. The Memory Hazard block (Set block <b>930</b> and Clear block <b>990</b>) maintains a table of hazard bits indicating which memory lines are unavailable for access. An inbound request that tries to access a line with a hazard is held by the Memory Hazard block until the hazard is cleared. Once the hazard is cleared then the request is resent through the Inbound Request Multiplexer. The memory line tag address is hashed to a hazard bit index. The number of hazard bits may be chosen to set the hazard collision probability to a sufficiently low level. Inbound DRAM Control Multiplexer (IDCM) <b>935</b> selects from an inbound NOC request and a cache eviction request. Bank Request Queues <b>940</b>&#x2014;each separately managed DRAM bank has a dedicated bank request queue to hold requests until they can be scheduled on the associated DRAM bank.</p><p id="p-0074" num="0070">Scheduler <b>942</b> selects across the bank request queues <b>940</b> to choose a request for an available DRAM bank. The DRAM(s) <b>945</b> represents the external DRAM device or devices. Request Hit Data Queue <b>950</b> holds request data from cache hits until selected. Request Miss Data Queue <b>955</b> holds data read from the DRAM(s) until selected. Miss Request Queue <b>960</b> is used to hold request packet information for cache misses until the request is selected. Hit Request Queue <b>965</b> holds request packet information for cache hits until selected. Data Selection Multiplexer (DSM) <b>970</b> selects between DRAM read data and cache hit read data. The selected data is written to the SRAM cache. Request Selection Multiplexer (RSM) <b>975</b> selects between hit and miss request queues <b>960</b> and <b>965</b>.</p><p id="p-0075" num="0071">Atomic/Write Merge <b>980</b> either merges the request data and DRAM read data, or, if the request is a built-in atomic, the memory data and request data are used as inputs for an atomic operation. Cache (Write) block <b>985</b> represents the write port for the SRAM cache. Data from a NOC write request and data from DRAM read operations are written to the SRAM cache. Memory Hazard (Clear) block <b>990</b> represents the hazard clear operation for the memory hazard structure. Clearing a hazard may release a pending NOC request and send it to the Inbound Request Multiplexer. Programmable Atomic Unit <b>995</b> processes programmable atomic transactions. NOC Outbound Response Multiplexer (ORM) <b>997</b> selects between memory controller responses and custom atomic unit responses and sends the selection to the NOC.</p><p id="p-0076" num="0072"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a block diagram of an example machine <b>1000</b> with which, in which, or by which any one or more of the techniques (e.g., methodologies) discussed herein can be implemented. Examples, as described herein, can include, or can operate by, logic or a number of components, or mechanisms in the machine <b>1000</b>. Circuitry (e.g., processing circuitry) is a collection of circuits implemented in tangible entities of the machine <b>1000</b> that include hardware (e.g., simple circuits, gates, logic, etc.). Circuitry membership can be flexible over time. Circuitries include members that can, alone or in combination, perform specified operations when operating. In an example, hardware of the circuitry can be immutably designed to carry out a specific operation (e.g., hardwired). In an example, the hardware of the circuitry can include variably connected physical components (e.g., execution units, transistors, simple circuits, etc.) including a machine readable medium physically modified (e.g., magnetically, electrically, moveable placement of invariant massed particles, etc.) to encode instructions of the specific operation. In connecting the physical components, the underlying electrical properties of a hardware constituent are changed, for example, from an insulator to a conductor or vice versa. The instructions enable embedded hardware (e.g., the execution units or a loading mechanism) to create members of the circuitry in hardware via the variable connections to carry out portions of the specific operation when in operation. Accordingly, in an example, the machine-readable medium elements are part of the circuitry or are communicatively coupled to the other components of the circuitry when the device is operating. In an example, any of the physical components can be used in more than one member of more than one circuitry. For example, under operation, execution units can be used in a first circuit of a first circuitry at one point in time and reused by a second circuit in the first circuitry, or by a third circuit in a second circuitry at a different time. Additional examples of these components with respect to the machine <b>1000</b> follow.</p><p id="p-0077" num="0073">In alternative embodiments, the machine <b>1000</b> can operate as a standalone device or can be connected (e.g., networked) to other machines. In a networked deployment, the machine <b>1000</b> can operate in the capacity of a server machine, a client machine, or both in server-client network environments. In an example, the machine <b>1000</b> can act as a peer machine in peer-to-peer (P2P) (or other distributed) network environment. The machine <b>1000</b> can be a personal computer (PC), a tablet PC, a set-top box (STB), a personal digital assistant (PDA), a mobile telephone, a web appliance, a network router, switch or bridge, or any machine capable of executing instructions (sequential or otherwise) that specify actions to be taken by that machine. Further, while only a single machine is illustrated, the term &#x201c;machine&#x201d; shall also be taken to include any collection of machines that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein, such as cloud computing, software as a service (SaaS), other computer cluster configurations.</p><p id="p-0078" num="0074">The machine (e.g., computer system) <b>1000</b> can include a hardware processor <b>1002</b> (e.g., a central processing unit (CPU), a graphics processing unit (GPU), a hardware processor core, or any combination thereof), a main memory <b>1004</b>, a static memory (e.g., memory or storage for firmware, microcode, a basic-input-output (BIOS), unified extensible firmware interface (UEFI), etc.) <b>1006</b>, and mass storage <b>1008</b> (e.g., hard drives, tape drives, flash storage, or other block devices) some or all of which can communicate with each other via an interlink (e.g., bus) <b>1030</b>. The machine <b>1000</b> can further include a display unit <b>1010</b>, an alphanumeric input device <b>1012</b> (e.g., a keyboard), and a user interface (UI) navigation device <b>1014</b> (e.g., a mouse). In an example, the display unit <b>1010</b>, input device <b>1012</b> and UI navigation device <b>1014</b> can be a touch screen display. The machine <b>1000</b> can additionally include a mass storage (e.g., drive unit) <b>1008</b>, a signal generation device <b>1018</b> (e.g., a speaker), a network interface device <b>1020</b>, and one or more sensors <b>1016</b>, such as a global positioning system (GPS) sensor, compass, accelerometer, or other sensor. The machine <b>1000</b> can include an output controller <b>1028</b>, such as a serial (e.g., universal serial bus (USB), parallel, or other wired or wireless (e.g., infrared (IR), near field communication (NFC), etc.) connection to communicate or control one or more peripheral devices (e.g., a printer, card reader, etc.).</p><p id="p-0079" num="0075">Registers of the processor <b>1002</b>, the main memory <b>1004</b>, the static memory <b>1006</b>, or the mass storage <b>1008</b> can be, or include, a machine readable medium <b>1022</b> on which is stored one or more sets of data structures or instructions <b>1024</b> (e.g., software) embodying or utilized by any one or more of the techniques or functions described herein. The instructions <b>1024</b> can also reside, completely or at least partially, within any of registers of the processor <b>1002</b>, the main memory <b>1004</b>, the static memory <b>1006</b>, or the mass storage <b>1008</b> during execution thereof by the machine <b>1000</b>. In an example, one or any combination of the hardware processor <b>1002</b>, the main memory <b>1004</b>, the static memory <b>1006</b>, or the mass storage <b>1008</b> can constitute the machine readable media <b>1022</b>. While the machine readable medium <b>1022</b> is illustrated as a single medium, the term &#x201c;machine readable medium&#x201d; can include a single medium or multiple media (e.g., a centralized or distributed database, or associated caches and servers) configured to store the one or more instructions <b>1024</b>.</p><p id="p-0080" num="0076">The term &#x201c;machine readable medium&#x201d; can include any medium that is capable of storing, encoding, or carrying instructions for execution by the machine <b>1000</b> and that cause the machine <b>1000</b> to perform any one or more of the techniques of the present disclosure, or that is capable of storing, encoding or carrying data structures used by or associated with such instructions. Non-limiting machine-readable medium examples can include solid-state memories, optical media, magnetic media, and signals (e.g., radio frequency signals, other photon-based signals, sound signals, etc.). In an example, a non-transitory machine-readable medium comprises a machine-readable medium with a plurality of particles having invariant (e.g., rest) mass, and thus are compositions of matter. Accordingly, non-transitory machine-readable media are machine readable media that do not include transitory propagating signals. Specific examples of non-transitory machine readable media can include: non-volatile memory, such as semiconductor memory devices (e.g., electrically programmable read-only memory (EPROM), electrically erasable programmable read-only memory (EEPROM)) and flash memory devices; magnetic disks, such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.</p><p id="p-0081" num="0077">In an example, information stored or otherwise provided on the machine readable medium <b>1022</b> can be representative of the instructions <b>1024</b>, such as instructions <b>1024</b> themselves or a format from which the instructions <b>1024</b> can be derived. This format from which the instructions <b>1024</b> can be derived can include source code, encoded instructions (e.g., in compressed or encrypted form), packaged instructions (e.g., split into multiple packages), or the like. The information representative of the instructions <b>1024</b> in the machine readable medium <b>1022</b> can be processed by processing circuitry into the instructions to implement any of the operations discussed herein. For example, deriving the instructions <b>1024</b> from the information (e.g., processing by the processing circuitry) can include: compiling (e.g., from source code, object code, etc.), interpreting, loading, organizing (e.g., dynamically or statically linking), encoding, decoding, encrypting, unencrypting, packaging, unpackaging, or otherwise manipulating the information into the instructions <b>1024</b>.</p><p id="p-0082" num="0078">In an example, the derivation of the instructions <b>1024</b> can include assembly, compilation, or interpretation of the information (e.g., by the processing circuitry) to create the instructions <b>1024</b> from some intermediate or preprocessed format provided by the machine readable medium <b>1022</b>. The information, when provided in multiple parts, can be combined, unpacked, and modified to create the instructions <b>1024</b>. For example, the information can be in multiple compressed source code packages (or object code, or binary executable code, etc.) on one or several remote servers. The source code packages can be encrypted when in transit over a network and decrypted, uncompressed, assembled (e.g., linked) if necessary, and compiled or interpreted (e.g., into a library, stand-alone executable etc.) at a local machine, and executed by the local machine.</p><p id="p-0083" num="0079">The instructions <b>1024</b> can be further transmitted or received over a communications network <b>1026</b> using a transmission medium via the network interface device <b>1020</b> utilizing any one of a number of transfer protocols (e.g., frame relay, internet protocol (IP), transmission control protocol (TCP), user datagram protocol (UDP), hypertext transfer protocol (HTTP), etc.). Example communication networks can include a local area network (LAN), a wide area network (WAN), a packet data network (e.g., the Internet), mobile telephone networks (e.g., cellular networks), plain old telephone (POTS) networks, and wireless data networks (e.g., Institute of Electrical and Electronics Engineers (IEEE) 802.11 family of standards known as Wi-Fi&#xae;, IEEE 802.16 family of standards known as WiMax&#xae;), IEEE 802.15.4 family of standards, peer-to-peer (P2P) networks, among others. In an example, the network interface device <b>1020</b> can include one or more physical jacks (e.g., Ethernet, coaxial, or phone jacks) or one or more antennas to connect to the communications network <b>1026</b>. In an example, the network interface device <b>1020</b> can include a plurality of antennas to wirelessly communicate using at least one of single-input multiple-output (SIMO), multiple-input multiple-output (MIMO), or multiple-input single-output (MISO) techniques. The term &#x201c;transmission medium&#x201d; shall be taken to include any intangible medium that is capable of storing, encoding or carrying instructions for execution by the machine <b>1000</b>, and includes digital or analog communications signals or other intangible medium to facilitate communication of such software. A transmission medium is a machine readable medium. To better illustrate the methods and apparatuses described herein, a non-limiting set of Example embodiments are set forth below as numerically identified Examples.</p><heading id="h-0006" level="1">OTHER NOTES AND EXAMPLES</heading><p id="p-0084" num="0080">Example 1 is an apparatus comprising: a memory controller; a programmable atomic unit coupled to the memory controller, the programmable atomic unit comprising: a memory storing a programmable atomic transaction; a processor, the processor configured to: receive, from a second processor communicatively coupled to the programmable atomic unit, a command to execute the programmable atomic transaction; execute the programmable atomic transaction, the programmable atomic transaction comprising a set of one or more instructions to perform operations; determine, during execution of the programmable atomic transaction, an exception condition corresponding to the programmable atomic transaction; terminate execution of the instruction set; generate a response indicating the exception; and sending the response to the processor.</p><p id="p-0085" num="0081">In Example 2, the subject matter of Example 1 includes, wherein the processor notifies an operating system of the exception.</p><p id="p-0086" num="0082">In Example 3, the subject matter of Examples 1-2 includes, wherein the response includes a program counter.</p><p id="p-0087" num="0083">In Example 4, the subject matter of Examples 1-3 includes, wherein the response includes memory state information of the state of the memory of the programmable atomic unit.</p><p id="p-0088" num="0084">In Example 5, the subject matter of Examples 1-4 includes, wherein the response comprises one or more values stored in a register of the programmable atomic unit.</p><p id="p-0089" num="0085">In Example 6, the subject matter of Examples 1-5 includes, wherein the programmable atomic unit is on a same chiplet as the memory controller, the memory controller controlling a Random Access Memory (RAM) bank.</p><p id="p-0090" num="0086">In Example 7, the subject matter of Examples 1-6 includes, wherein the memory controller is on a chiplet that is coupled to a second chiplet, the second chiplet comprising the second processor.</p><p id="p-0091" num="0087">In Example 8, the subject matter of Examples 1-7 includes, wherein the exception condition is exceeding an instruction execution limit.</p><p id="p-0092" num="0088">In Example 9, the subject matter of Examples 1-8 includes, wherein the exception condition is an execution of an instruction that is in a memory partition of the programmable atomic unit with an index that is greater than a sum of a first index of the programmable atomic transaction and a partition count of the programmable atomic transaction.</p><p id="p-0093" num="0089">Example 10 is a method comprising: receiving, by a programmable atomic unit of a memory controller, from a processor, a command to execute a programmable atomic transaction stored in a memory of the programmable atomic unit corresponding to a programmable atomic transaction; executing, by a processor of the programmable atomic unit, the programmable atomic transaction, the programmable atomic transaction comprising a set of one or more instructions to perform operations; determining, during execution of the programmable atomic transaction, an exception condition corresponding to the programmable atomic transaction; terminate execution of the instruction set; generate a response indicating the exception; and sending the response to the processor.</p><p id="p-0094" num="0090">In Example 11, the subject matter of Example 10 includes, wherein the processor notifies an operating system of the exception.</p><p id="p-0095" num="0091">In Example 12, the subject matter of Examples 10-11 includes, wherein the response includes a program counter.</p><p id="p-0096" num="0092">In Example 13, the subject matter of Examples 10-12 includes, wherein the response includes memory state information of the state of the memory of the programmable atomic unit.</p><p id="p-0097" num="0093">In Example 14, the subject matter of Examples 10-13 includes, wherein the response comprises one or more values stored in a register of the programmable atomic unit.</p><p id="p-0098" num="0094">In Example 15, the subject matter of Examples 10-14 includes, wherein the programmable atomic unit is coupled to a memory controller, the memory controller controlling one or more Random Access Memory (RAM) banks.</p><p id="p-0099" num="0095">In Example 16, the subject matter of Examples 10-15 includes, wherein the memory controller is on a chiplet that is coupled to a second chiplet, the second chiplet comprising the processor.</p><p id="p-0100" num="0096">In Example 17, the subject matter of Examples 10-16 includes, wherein the exception condition is exceeding an instruction execution limit.</p><p id="p-0101" num="0097">In Example 18, the subject matter of Examples 10-17 includes, wherein the exception condition is an execution of an instruction that is in a memory partition of the programmable atomic unit with an index that is greater than a sum of a first index of the programmable atomic transaction and a partition count of the programmable atomic transaction.</p><p id="p-0102" num="0098">Example 19 is a non-transitory machine-readable medium, storing instructions, which when executed, causes a machine to perform operations comprising: receiving, by a programmable atomic unit of a memory controller, from a processor, a command to execute a programmable atomic transaction stored in a memory of the programmable atomic unit corresponding to a programmable atomic transaction; executing, by a processor of the programmable atomic unit, the programmable atomic transaction, the programmable atomic transaction comprising a set of one or more instructions to perform operations; determining, during execution of the programmable atomic transaction, an exception condition corresponding to the programmable atomic transaction; terminating execution of the instruction set; generating a response indicating the exception; and sending the response to the processor.</p><p id="p-0103" num="0099">In Example 20, the subject matter of Example 19 includes, wherein the processor notifies an operating system of the exception.</p><p id="p-0104" num="0100">In Example 21, the subject matter of Examples 19-20 includes, wherein the response includes a program counter.</p><p id="p-0105" num="0101">In Example 22, the subject matter of Examples 19-21 includes, wherein the response includes memory state information of the state of the memory of the programmable atomic unit.</p><p id="p-0106" num="0102">In Example 23, the subject matter of Examples 19-22 includes, wherein the response comprises one or more values stored in a register of the programmable atomic unit.</p><p id="p-0107" num="0103">In Example 24, the subject matter of Examples 19-23 includes, wherein the programmable atomic unit is coupled to a memory controller, the memory controller controlling one or more Random Access Memory (RAM) banks.</p><p id="p-0108" num="0104">In Example 25, the subject matter of Examples 19-24 includes, wherein the memory controller is on a chiplet that is coupled to a second chiplet, the second chiplet comprising the processor.</p><p id="p-0109" num="0105">In Example 26, the subject matter of Examples 19-25 includes, wherein the exception condition is exceeding an instruction execution limit.</p><p id="p-0110" num="0106">In Example 27, the subject matter of Examples 19-26 includes, wherein the exception condition is an execution of an instruction that is in a memory partition of the programmable atomic unit with an index that is greater than a sum of a first index of the programmable atomic transaction and a partition count of the programmable atomic transaction.</p><p id="p-0111" num="0107">Example 28 is an apparatus comprising: means for receiving, by a programmable atomic unit of a memory controller, from a processor, a command to execute a programmable atomic transaction stored in a memory of the programmable atomic unit corresponding to a programmable atomic transaction; means for executing, by a processor of the programmable atomic unit, the programmable atomic transaction, the programmable atomic transaction comprising a set of one or more instructions to perform operations; means for determining, during execution of the programmable atomic transaction, an exception condition corresponding to the programmable atomic transaction; means for terminating execution of the instruction set; means for generating a response indicating the exception; and means for sending the response to the processor.</p><p id="p-0112" num="0108">In Example 29, the subject matter of Example 28 includes, wherein the processor notifies an operating system of the exception.</p><p id="p-0113" num="0109">In Example 30, the subject matter of Examples 28-29 includes, wherein the response includes a program counter.</p><p id="p-0114" num="0110">In Example 31, the subject matter of Examples 28-30 includes, wherein the response includes memory state information of the state of the memory of the programmable atomic unit.</p><p id="p-0115" num="0111">In Example 32, the subject matter of Examples 28-31 includes, wherein the response comprises one or more values stored in a register of the programmable atomic unit.</p><p id="p-0116" num="0112">In Example 33, the subject matter of Examples 28-32 includes, wherein the programmable atomic unit is coupled to a memory controller, the memory controller controlling one or more Random Access Memory (RAM) banks.</p><p id="p-0117" num="0113">In Example 34, the subject matter of Examples 28-33 includes, wherein the memory controller is on a chiplet that is coupled to a second chiplet, the second chiplet comprising the processor.</p><p id="p-0118" num="0114">In Example 35, the subject matter of Examples 28-34 includes, wherein the exception condition is exceeding an instruction execution limit.</p><p id="p-0119" num="0115">In Example 36, the subject matter of Examples 28-35 includes, wherein the exception condition is an execution of an instruction that is in a memory partition of the programmable atomic unit with an index that is greater than a sum of a first index of the programmable atomic transaction and a partition count of the programmable atomic transaction.</p><p id="p-0120" num="0116">Example 37 is at least one machine-readable medium including instructions that, when executed by processing circuitry, cause the processing circuitry to perform operations to implement of any of Examples 1-36.</p><p id="p-0121" num="0117">Example 38 is an apparatus comprising means to implement of any of Examples 1-36.</p><p id="p-0122" num="0118">Example 39 is a system to implement of any of Examples 1-36.</p><p id="p-0123" num="0119">Example 40 is a method to implement of any of Examples 1-36.</p><p id="p-0124" num="0120">The above detailed description includes references to the accompanying drawings, which form a part of the detailed description. The drawings show, by way of illustration, specific embodiments in which the invention can be practiced. These embodiments are also referred to herein as &#x201c;examples&#x201d;. Such examples can include elements in addition to those shown or described. However, the present inventors also contemplate examples in which only those elements shown or described are provided. Moreover, the present inventors also contemplate examples using any combination or permutation of those elements shown or described (or one or more aspects thereof), either with respect to a particular example (or one or more aspects thereof), or with respect to other examples (or one or more aspects thereof) shown or described herein.</p><p id="p-0125" num="0121">In this document, the terms &#x201c;a&#x201d; or &#x201c;an&#x201d; are used, as is common in patent documents, to include one or more than one, independent of any other instances or usages of &#x201c;at least one&#x201d; or &#x201c;one or more.&#x201d; In this document, the term &#x201c;or&#x201d; is used to refer to a nonexclusive or, such that &#x201c;A or B&#x201d; can include &#x201c;A but not B,&#x201d; &#x201c;B but not A,&#x201d; and &#x201c;A and B,&#x201d; unless otherwise indicated. In the appended claims, the terms &#x201c;including&#x201d; and &#x201c;in which&#x201d; are used as the plain-English equivalents of the respective terms &#x201c;comprising&#x201d; and &#x201c;wherein&#x201d;. Also, in the following claims, the terms &#x201c;including&#x201d; and &#x201c;comprising&#x201d; are open-ended, that is, a system, device, article, or process that includes elements in addition to those listed after such a term in a claim are still deemed to fall within the scope of that claim. Moreover, in the following claims, the terms &#x201c;first,&#x201d; &#x201c;second,&#x201d; and &#x201c;third,&#x201d; etc. are used merely as labels, and are not intended to impose numerical requirements on their objects.</p><p id="p-0126" num="0122">The above description is intended to be illustrative, and not restrictive. For example, the above-described examples (or one or more aspects thereof) can be used in combination with each other. Other embodiments can be used, such as by one of ordinary skill in the art upon reviewing the above description. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. Also, in the above Detailed Description, various features can be grouped together to streamline the disclosure. This should not be interpreted as intending that an unclaimed disclosed feature is essential to any claim. Rather, inventive subject matter can lie in less than all features of a particular disclosed embodiment. Thus, the following claims are hereby incorporated into the Detailed Description, with each claim standing on its own as a separate embodiment, and it is contemplated that such embodiments can be combined with each other in various combinations or permutations. The scope of the invention should be determined with reference to the appended claims, along with the full scope of equivalents to which such claims are entitled.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. An apparatus comprising:<claim-text>a memory controller;</claim-text><claim-text>a programmable atomic unit coupled to the memory controller, the programmable atomic unit comprising:<claim-text>a memory partitioned into a plurality of partitions, instructions of a programmable atomic transaction stored in one or more of the plurality of partitions;</claim-text><claim-text>a processor, the processor configured to:<claim-text>receive, from a second processor communicatively coupled to the programmable atomic unit, a command to execute the programmable atomic transaction, the command specifying the programmable atomic transaction using a partition index;</claim-text><claim-text>responsive to receiving the command:<claim-text>identify a control structure corresponding to the programmable atomic transaction, the control structure including a number of partitions used by the programmable atomic transaction and an instruction execution limit;</claim-text><claim-text>causing execution of the programmable atomic transaction by causing execution of a first instruction stored in a first partition of the plurality of partitions indicated by the partition index and subsequent instructions;</claim-text><claim-text>determine, during execution of the programmable atomic transaction, that an exception condition corresponding to the programmable atomic transaction has occurred, the exception condition comprising reaching the instruction execution limit or reaching an instruction in a partition of the plurality of partitions beyond the number of partitions;</claim-text><claim-text>responsive to determining the exception condition:</claim-text><claim-text>&#x2003;cause termination of execution of the instruction set;</claim-text><claim-text>&#x2003;generate a response indicating the exception condition; and</claim-text></claim-text></claim-text></claim-text><claim-text>send the response to the second processor.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is configured to notify an operating system of the exception.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the response includes a program counter.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the response includes memory state information of the state of the memory of the programmable atomic unit.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the response comprises one or more values stored in a register of the programmable atomic unit.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the programmable atomic unit is on a same chiplet as the memory controller, the memory controller controlling a Random Access Memory (RAM) bank.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the memory controller is on a chiplet that is coupled to a second chiplet, the second chiplet comprising the second processor.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A method comprising:<claim-text>using a processor:</claim-text><claim-text>receiving, from a second processor communicatively coupled to a programmable atomic unit, a command to execute a programmable atomic transaction stored in one or more of a plurality of partitions of a memory, the command specifying the programmable atomic transaction using a partition index;</claim-text><claim-text>responsive to receiving the command:<claim-text>identifying a control structure corresponding to the programmable atomic transaction, the control structure including a number of partitions used by the programmable atomic transaction and an instruction execution limit;</claim-text><claim-text>causing execution of the programmable atomic transaction by causing execution of a first instruction stored in a first partition of the plurality of partitions indicated by the partition index and subsequent instructions;</claim-text><claim-text>determining, during execution of the programmable atomic transaction, that an exception condition corresponding to the programmable atomic transaction has occurred, the exception condition comprising reaching the instruction execution limit or reaching an instruction in a partition of the plurality of partitions beyond the number of partitions;</claim-text><claim-text>responsive to determining the exception condition:<claim-text>causing termination of execution of the instruction set;</claim-text><claim-text>generating a response indicating the exception condition; and</claim-text><claim-text>sending the response to the second processor.</claim-text></claim-text></claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising notifying an operating system of the exception.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the response includes a program counter.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the response includes memory state information of the state of the memory of the programmable atomic unit.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the response comprises one or more values stored in a register of the programmable atomic unit.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the programmable atomic unit is on a same chiplet as the memory controller, the memory controller controlling a Random Access Memory (RAM) bank.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the memory controller is on a chiplet that is coupled to a second chiplet, the second chiplet comprising the second processor.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A non-transitory, machine-readable medium, storing instructions, which when executed by a processor, causes the processor to perform operations comprising:<claim-text>receiving, from a second processor communicatively coupled to a programmable atomic unit, a command to execute a programmable atomic transaction stored in one or more of a plurality of partitions of a memory, the command specifying the programmable atomic transaction using a partition index;</claim-text><claim-text>responsive to receiving the command:<claim-text>identifying a control structure corresponding to the programmable atomic transaction, the control structure including a number of partitions used by the programmable atomic transaction and an instruction execution limit;</claim-text><claim-text>causing execution of the programmable atomic transaction by causing execution of a first instruction stored in a first partition of the plurality of partitions indicated by the partition index and subsequent instructions;</claim-text><claim-text>determining, during execution of the programmable atomic transaction, that an exception condition corresponding to the programmable atomic transaction has occurred, the exception condition comprising reaching the instruction execution limit or reaching an instruction in a partition of the plurality of partitions beyond the number of partitions;</claim-text></claim-text><claim-text>responsive to determining the exception condition:<claim-text>causing termination of execution of the instruction set;</claim-text><claim-text>generating a response indicating the exception condition; and</claim-text><claim-text>sending the response to the second processor.</claim-text></claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The non-transitory, machine-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the operations further comprise notifying an operating system of the exception.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The non-transitory, machine-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the response includes a program counter.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The non-transitory, machine-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the response includes memory state information of the state of the memory of the programmable atomic unit.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The non-transitory, machine-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the response comprises one or more values stored in a register of the programmable atomic unit.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The non-transitory, machine-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the programmable atomic unit is on a same chiplet as the memory controller, the memory controller controlling a Random Access Memory (RAM) bank.</claim-text></claim></claims></us-patent-application>